var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import fs from 'node:fs/promises';
import path from 'node:path';
import pMap from 'p-map';
import { logger } from '../shared/logger.js';
import { getProcessConcurrency } from '../shared/processConcurrency.js';
import { sleep } from '../shared/sleep.js';
import { collectFiles as defaultCollectFiles } from './file/fileCollector.js';
import { processFiles as defaultProcessFiles } from './file/fileProcessor.js';
import { searchFiles as defaultSearchFiles } from './file/fileSearcher.js';
import { generateOutput as defaultGenerateOutput } from './output/outputGenerator.js';
import { runSecurityCheck as defaultRunSecurityCheck, } from './security/securityCheckRunner.js';
import { TokenCounter } from './tokenCounter/tokenCounter.js';
export const pack = (rootDir_1, config_1, ...args_1) => __awaiter(void 0, [rootDir_1, config_1, ...args_1], void 0, function* (rootDir, config, progressCallback = () => { }, deps = {
    searchFiles: defaultSearchFiles,
    collectFiles: defaultCollectFiles,
    processFiles: defaultProcessFiles,
    runSecurityCheck: defaultRunSecurityCheck,
    generateOutput: defaultGenerateOutput,
}) {
    // Get all file paths considering the config
    progressCallback('Searching for files...');
    const filePaths = yield deps.searchFiles(rootDir, config);
    // Collect raw files
    progressCallback('Collecting files...');
    const rawFiles = yield deps.collectFiles(filePaths, rootDir);
    let safeRawFiles = rawFiles;
    let suspiciousFilesResults = [];
    if (config.security.enableSecurityCheck) {
        // Perform security check and filter out suspicious files
        progressCallback('Running security check...');
        suspiciousFilesResults = yield deps.runSecurityCheck(rawFiles, progressCallback);
        safeRawFiles = rawFiles.filter((rawFile) => !suspiciousFilesResults.some((result) => result.filePath === rawFile.path));
    }
    const safeFilePaths = safeRawFiles.map((file) => file.path);
    logger.trace('Safe files count:', safeRawFiles.length);
    // Process files (remove comments, etc.)
    progressCallback('Processing files...');
    const processedFiles = yield deps.processFiles(safeRawFiles, config);
    // Generate output
    progressCallback('Generating output...');
    const output = yield deps.generateOutput(rootDir, config, processedFiles, safeFilePaths);
    // Write output to file. path is relative to the cwd
    progressCallback('Writing output file...');
    const outputPath = path.resolve(config.cwd, config.output.filePath);
    logger.trace(`Writing output to: ${outputPath}`);
    yield fs.writeFile(outputPath, output);
    // Setup token counter
    const tokenCounter = new TokenCounter();
    // Metrics
    progressCallback('Calculating metrics...');
    const fileMetrics = yield pMap(processedFiles, (file, index) => __awaiter(void 0, void 0, void 0, function* () {
        const charCount = file.content.length;
        const tokenCount = tokenCounter.countTokens(file.content);
        progressCallback(`Calculating metrics... (${index + 1}/${processedFiles.length})`);
        // Sleep for a short time to prevent blocking the event loop
        yield sleep(1);
        return { path: file.path, charCount, tokenCount };
    }), {
        concurrency: getProcessConcurrency(),
    });
    tokenCounter.free();
    const totalFiles = processedFiles.length;
    const totalCharacters = fileMetrics.reduce((sum, fileMetric) => sum + fileMetric.charCount, 0);
    const totalTokens = fileMetrics.reduce((sum, fileMetric) => sum + fileMetric.tokenCount, 0);
    const fileCharCounts = {};
    const fileTokenCounts = {};
    for (const file of fileMetrics) {
        fileCharCounts[file.path] = file.charCount;
        fileTokenCounts[file.path] = file.tokenCount;
    }
    return {
        totalFiles,
        totalCharacters,
        totalTokens,
        fileCharCounts,
        fileTokenCounts,
        suspiciousFilesResults,
    };
});
//# sourceMappingURL=packager.js.map