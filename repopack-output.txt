This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-01T15:27:02.833Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
runelite-client/
  src/
    main/
      java/
        net/
          runelite/
            client/
              plugins/
                microbot/
                  example/
                    ExampleConfig.java
                    ExampleOverlay.java
                    ExamplePlugin.java
                    ExampleScript.java
                  mining/
                    amethyst/
                      enums/
                        AmethystCraftingOption.java
                        MiningSpot.java
                        Status.java
                      AmethystMiningConfig.java
                      AmethystMiningOverlay.java
                      AmethystMiningPlugin.java
                      AmethystMiningScript.java
                    enums/
                      Rocks.java
                    motherloadmine/
                      enums/
                        MLMMiningSpot.java
                        MLMStatus.java
                      MotherloadMineConfig.java
                      MotherloadMineOverlay.java
                      MotherloadMinePlugin.java
                      MotherloadMineScript.java
                    shootingstar/
                      enums/
                        Pickaxe.java
                        ShootingStarLocation.java
                        ShootingStarState.java
                      model/
                        ShootingStarTableHeader.java
                        ShootingStarTableRow.java
                        Star.java
                      ShootingStarConfig.java
                      ShootingStarOverlay.java
                      ShootingStarPanel.java
                      ShootingStarPlugin.java
                      ShootingStarScript.java
                    AutoMiningConfig.java
                    AutoMiningOverlay.java
                    AutoMiningPlugin.java
                    AutoMiningScript.java
                  wintertodt/
                    enums/
                      Brazier.java
                      State.java
                    MWintertodtConfig.java
                    MWintertodtOverlay.java
                    MWintertodtPlugin.java
                    MWintertodtScript.java
                VoxSylvaePlugins/
                  data/
                    teleportationData/
                      FairyRingTeleportLoader.java
                      SpellbookTeleportLoader.java
                      TeleportItemLoader.java
                  scraper/
                    api/
                      WikipediaApi.java
                    model/
                      ImageType.java
                      ScraperResult.java
                      WikipediaPage.java
                    util/
                      ImageUtil.java
                      StringUtil.java
                    VSItemScraper.java
                    VSNPCScraper.java
                    VSWikiScraper.java
                  skilling/
                    hunter/
                      VoxSylvaeAIOHunter/
                        AIOHunterConfig.java
                        AIOHunterOverlay.java
                        AIOHunterPlugin.java
                        AIOHunterTaskManager.java
                        CreatureLocation.java
                        HunterAreaUtils.java
                        HunterCreatureTarget.java
                        HunterMaster.java
                        HuntersRumoursScript.java
                  util/
                    navigation/
                      VoxSylvaeNavigationConfig.java
                      VoxSylvaeNavigationOverlay.java
                      VoxSylvaeNavigationPlugin.java
                      VoxSylvaeNavigationScript.java
                    teleport/
                      AbstractTeleport.java
                      FairyRingTeleport.java
                      ItemQuantity.java
                      POHTeleport.java
                      ShortestPathResult.java
                      SpellbookTeleport.java
                      Teleport.java
                      TeleportationManager.java
                      TeleportItem.java
                      TeleportType.java
                    VoxSylvaeInventoryAndBankManagementScript.java
                    VoxSylvaeUitl.java

================================================================
Repository Files
================================================================

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/example/ExampleConfig.java
================
package net.runelite.client.plugins.microbot.example;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
@ConfigGroup("example")
public interface ExampleConfig extends Config {
/*    @ConfigItem(
            keyName = "Ore",
            name = "Ore",
            description = "Choose the ore",
            position = 0
    )
    default List<String> ORE()
    {
        return Rocks.TIN;
    }*/
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/example/ExampleOverlay.java
================
package net.runelite.client.plugins.microbot.example;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import javax.inject.Inject;
import javax.inject.Named;
import java.awt.*;
public class ExampleOverlay extends OverlayPanel {
    @Inject
    ExampleOverlay(ExamplePlugin plugin)
    {
        super(plugin);
        setPosition(OverlayPosition.TOP_LEFT);
        setNaughty();
    }
    @Override
    public Dimension render(Graphics2D graphics) {
        try {
            panelComponent.setPreferredSize(new Dimension(200, 300));
            panelComponent.getChildren().add(TitleComponent.builder()
                    .text("Micro Example V1.0.0")
                    .color(Color.GREEN)
                    .build());
            panelComponent.getChildren().add(LineComponent.builder().build());
            panelComponent.getChildren().add(LineComponent.builder()
                    .left(Microbot.status)
                    .build());
        } catch(Exception ex) {
            System.out.println(ex.getMessage());
        }
        return super.render(graphics);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/example/ExamplePlugin.java
================
package net.runelite.client.plugins.microbot.example;
import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.GameTick;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import javax.inject.Inject;
import java.awt.*;
@PluginDescriptor(
        name = PluginDescriptor.Default + "Example",
        description = "Microbot example plugin",
        tags = {"example", "microbot"},
        enabledByDefault = false
)
@Slf4j
public class ExamplePlugin extends Plugin {
    @Inject
    private ExampleConfig config;
    @Provides
    ExampleConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(ExampleConfig.class);
    }
    @Inject
    private OverlayManager overlayManager;
    @Inject
    private ExampleOverlay exampleOverlay;
    @Inject
    ExampleScript exampleScript;
    @Override
    protected void startUp() throws AWTException {
        if (overlayManager != null) {
            overlayManager.add(exampleOverlay);
        }
        exampleScript.run(config);
    }
    protected void shutDown() {
        exampleScript.shutdown();
        overlayManager.remove(exampleOverlay);
    }
    int ticks = 10;
    @Subscribe
    public void onGameTick(GameTick tick)
    {
        //System.out.println(getName().chars().mapToObj(i -> (char)(i + 3)).map(String::valueOf).collect(Collectors.joining()));
        if (ticks > 0) {
            ticks--;
        } else {
            ticks = 10;
        }
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/example/ExampleScript.java
================
package net.runelite.client.plugins.microbot.example;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.Script;
import net.runelite.client.plugins.microbot.util.grounditem.LootingParameters;
import net.runelite.client.plugins.microbot.util.grounditem.Rs2GroundItem;
import java.util.concurrent.TimeUnit;
public class ExampleScript extends Script {
    public static boolean test = false;
    public boolean run(ExampleConfig config) {
        Microbot.enableAutoRunOn = false;
        mainScheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(() -> {
            try {
                if (!Microbot.isLoggedIn()) return;
                if (!super.run()) return;
                long startTime = System.currentTimeMillis();
                test = false;
                LootingParameters valueParams = new LootingParameters(
                        5000,
                        Integer.MAX_VALUE,
                        20,
                        1,
                        0,
                        false,
                        false
                );
                Rs2GroundItem.loot("Vorkath's head", 20);
                if (Rs2GroundItem.lootItemBasedOnValue(valueParams)) {
                    System.out.println("Looing succesfull!");
                }
                /*for (int i = 0; i < 2; i++) {
                    System.out.println("loop:= " + i);
                    Rs2Inventory.waitForInventoryChanges();
                }*/
                long endTime = System.currentTimeMillis();
                long totalTime = endTime - startTime;
                System.out.println("Total time for loop " + totalTime);
            } catch (Exception ex) {
                System.out.println(ex.getMessage());
            }
        }, 0, 1000, TimeUnit.MILLISECONDS);
        return true;
    }
    @Override
    public void shutdown() {
        super.shutdown();
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/amethyst/enums/AmethystCraftingOption.java
================
package net.runelite.client.plugins.microbot.mining.amethyst.enums;
import lombok.Getter;
public enum AmethystCraftingOption {
    BOLT_TIPS(83, "Bolt tips", '1'),
    ARROW_TIPS(85, "Arrow tips", '2'),
    JAVELIN_HEADS(87, "Javelin heads", '3'),
    DART_TIPS(89, "Dart tips", '4');
    @Getter
    private final int requiredLevel;
    @Getter
    private final String displayName;
    private final char dialogOption;
    AmethystCraftingOption(int requiredLevel, String displayName, char dialogOption) {
        this.requiredLevel = requiredLevel;
        this.displayName = displayName;
        this.dialogOption = dialogOption;
    }
    public char getDialogOption() {
        return dialogOption;
    }
    @Override
    public String toString() {
        return displayName + " (Level " + requiredLevel + ")";
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/amethyst/enums/MiningSpot.java
================
package net.runelite.client.plugins.microbot.mining.amethyst.enums;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.coords.WorldPoint;
import java.util.Random;
@Getter
@RequiredArgsConstructor
public enum MiningSpot {
    RANDOM_POINT_1(new WorldPoint(3019, 9706, 0)),
    RANDOM_POINT_2(new WorldPoint(3020, 9706, 0)),
    RANDOM_POINT_3(new WorldPoint(3018, 9703, 0)),
    RANDOM_POINT_4(new WorldPoint(3019, 9703, 0)),
    RANDOM_POINT_5(new WorldPoint(3020, 9700, 0)),
    NULL(null);
    private static final Random RANDOM = new Random();
    private final WorldPoint worldPoint;
    public static MiningSpot getRandomMiningSpot() {
        MiningSpot[] spots = values();
        return spots[RANDOM.nextInt(spots.length)];
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/amethyst/enums/Status.java
================
package net.runelite.client.plugins.microbot.mining.amethyst.enums;
public enum Status {
    IDLE,
    MINING,
    BANKING,
    CHISELING
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/amethyst/AmethystMiningConfig.java
================
package net.runelite.client.plugins.microbot.mining.amethyst;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.plugins.microbot.mining.amethyst.enums.AmethystCraftingOption;
@ConfigGroup("AmethystMining")
public interface AmethystMiningConfig extends Config {
    @ConfigSection(
            name = "Chiseling Options",
            description = "Options related to chiseling amethysts",
            position = 2
    )
    String chiselingOptionsSection = "chiselingOptionsSection";
    @ConfigItem(
            keyName = "guide",
            name = "How to use",
            description = "How to use this plugin",
            position = 0
    )
    default String GUIDE() {
        return "Start near the bank chest in the amethyst mine at the mining guild.";
    }
    @ConfigItem(
            keyName = "PickAxeInInventory",
            name = "Pick Axe In Inventory?",
            description = "Pick Axe in inventory?",
            position = 1
    )
    default boolean pickAxeInInventory() {
        return false;
    }
    @ConfigItem(
            keyName = "chiselAmethysts",
            name = "Chisel Amethysts",
            description = "If enabled, the player will chisel the amethysts after mining.",
            position = 0,
            section = chiselingOptionsSection
    )
    default boolean chiselAmethysts() {
        return false;
    }
    @ConfigItem(
            keyName = "amethystCraftingOption",
            name = "Item",
            description = "Choose what to craft from amethysts.",
            position = 1,
            section = chiselingOptionsSection
    )
    default AmethystCraftingOption amethystCraftingOption() {
        return AmethystCraftingOption.BOLT_TIPS;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/amethyst/AmethystMiningOverlay.java
================
package net.runelite.client.plugins.microbot.mining.amethyst;
import net.runelite.client.plugins.microbot.util.antiban.Rs2Antiban;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import javax.inject.Inject;
import java.awt.*;
import static net.runelite.client.plugins.microbot.mining.amethyst.AmethystMiningScript.status;
public class AmethystMiningOverlay extends OverlayPanel {
    @Inject
    AmethystMiningOverlay(AmethystMiningPlugin plugin) {
        super(plugin);
        setPosition(OverlayPosition.TOP_LEFT);
    }
    @Override
    public Dimension render(Graphics2D graphics) {
        try {
            panelComponent.setPreferredLocation(new Point(80, 8));
            panelComponent.setPreferredSize(new Dimension(275, 700));
            panelComponent.getChildren().add(TitleComponent.builder()
                    .text("\uD83E\uDD86 Amethyst Miner \uD83E\uDD86")
                    .color(Color.ORANGE)
                    .build());
            addEmptyLine();
            Rs2Antiban.renderAntibanOverlayComponents(panelComponent);
            addEmptyLine();
            panelComponent.getChildren().add(LineComponent.builder()
                    .left(status.toString())
                    .right("Version: " + AmethystMiningScript.version)
                    .build());
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
        return super.render(graphics);
    }
    private void addEmptyLine() {
        panelComponent.getChildren().add(LineComponent.builder().build());
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/amethyst/AmethystMiningPlugin.java
================
package net.runelite.client.plugins.microbot.mining.amethyst;
import com.google.inject.Provides;
import net.runelite.api.ObjectID;
import net.runelite.api.WallObject;
import net.runelite.api.events.WallObjectSpawned;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.microbot.mining.amethyst.enums.Status;
import net.runelite.client.ui.overlay.OverlayManager;
import javax.inject.Inject;
import java.awt.*;
@PluginDescriptor(
        name = PluginDescriptor.See1Duck + " Amethyst Miner",
        description = "Automates mining amethyst in the mining guild",
        enabledByDefault = false,
        tags = {"mining", "amethyst", "mining guild"}
)
public class AmethystMiningPlugin extends Plugin {
    @Inject
    private OverlayManager overlayManager;
    @Inject
    private AmethystMiningOverlay amethystMiningOverlay;
    @Inject
    private AmethystMiningScript amethystMiningScript;
    @Inject
    private AmethystMiningConfig amethystMiningConfig;
    @Provides
    AmethystMiningConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(AmethystMiningConfig.class);
    }
    @Override
    protected void startUp() throws AWTException {
        overlayManager.add(amethystMiningOverlay);
        amethystMiningScript.run(amethystMiningConfig);
    }
    @Subscribe
    public void onWallObjectSpawned(WallObjectSpawned event) {
        WallObject wallObject = event.getWallObject();
        if (wallObject == null)
            return;
        if (AmethystMiningScript.status == Status.MINING && wallObject.getId() == ObjectID.EMPTY_WALL) {
            if (wallObject.getWorldLocation().equals(AmethystMiningScript.oreVein.getWorldLocation())) {
                AmethystMiningScript.oreVein = null;
            }
        }
    }
    protected void shutDown() {
        amethystMiningScript.shutdown();
        overlayManager.remove(amethystMiningOverlay);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/amethyst/AmethystMiningScript.java
================
package net.runelite.client.plugins.microbot.mining.amethyst;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;
import net.runelite.api.TileObject;
import net.runelite.api.WallObject;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.widgets.Widget;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.Script;
import net.runelite.client.plugins.microbot.mining.amethyst.enums.AmethystCraftingOption;
import net.runelite.client.plugins.microbot.mining.amethyst.enums.MiningSpot;
import net.runelite.client.plugins.microbot.mining.amethyst.enums.Status;
import net.runelite.client.plugins.microbot.util.antiban.Rs2Antiban;
import net.runelite.client.plugins.microbot.util.antiban.Rs2AntibanSettings;
import net.runelite.client.plugins.microbot.util.bank.Rs2Bank;
import net.runelite.client.plugins.microbot.util.bank.enums.BankLocation;
import net.runelite.client.plugins.microbot.util.combat.Rs2Combat;
import net.runelite.client.plugins.microbot.util.equipment.Rs2Equipment;
import net.runelite.client.plugins.microbot.util.gameobject.Rs2GameObject;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Item;
import net.runelite.client.plugins.microbot.util.keyboard.Rs2Keyboard;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.microbot.util.tile.Rs2Tile;
import net.runelite.client.plugins.microbot.util.walker.Rs2Walker;
import net.runelite.client.plugins.microbot.util.widget.Rs2Widget;
import java.util.concurrent.TimeUnit;
public class AmethystMiningScript extends Script {
    public static String version = "1.1.2";
    public static Status status = Status.IDLE;
    public static WallObject oreVein;
    private static AmethystMiningConfig config;
    private static MiningSpot miningSpot = MiningSpot.NULL;
    private String pickAxeInInventory = "";
    public boolean run(AmethystMiningConfig config) {
        AmethystMiningScript.config = config;
        initialize();
        mainScheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(this::executeTask, 0, 600, TimeUnit.MILLISECONDS);
        return true;
    }
    private boolean isClickHereToPlayButtonVisible() {
        Widget clickHereToPlayButton = Rs2Widget.getWidget(24772680);
        return (clickHereToPlayButton != null && !Microbot.getClientThread().runOnClientThread(clickHereToPlayButton::isHidden));
    }
    private void executeTask() {
        if (!super.run() || !Microbot.isLoggedIn() || isClickHereToPlayButtonVisible() || Rs2Antiban.isIdleTooLong(50)) {
            miningSpot = MiningSpot.NULL;
            oreVein = null;
            return;
        }
        if (config.pickAxeInInventory() && pickAxeInInventory.isEmpty()) {
            pickAxeInInventory = Rs2Inventory.get("pickaxe").name;
        }
        if (pickAxeInInventory.isEmpty() && config.pickAxeInInventory()) {
            Microbot.showMessage("Pickaxe was not found in your inventory");
            sleep(5000);
            return;
        }
        if (Rs2AntibanSettings.actionCooldownActive) return;
        if (Rs2Player.isAnimating() || Microbot.getClient().getLocalPlayer().isInteracting()) return;
        handleDragonPickaxeSpec();
        handleInventory();
        switch (status) {
            case IDLE:
                return;
            case MINING:
                handleMining();
                break;
            case BANKING:
                bankItems();
                break;
            case CHISELING:
                chiselAmethysts();
                break;
        }
    }
    private void handleDragonPickaxeSpec() {
        if (Rs2Equipment.isWearing("dragon pickaxe")) {
            Rs2Combat.setSpecState(true, 1000);
        }
    }
    private void handleInventory() {
        if (!Rs2Inventory.isFull()) {
            status = Status.MINING;
        } else {
            oreVein = null;
            miningSpot = MiningSpot.NULL;
            if (config.chiselAmethysts())
                status = Status.CHISELING;
            else
                status = Status.BANKING;
        }
    }
    private void bankItems() {
        if (Rs2Walker.walkTo(BankLocation.MINING_GUILD.getWorldPoint()))
            bank();
    }
    private void bank() {
        TileObject bank = Rs2GameObject.findObjectById(4483);
        if (Rs2Bank.openBank(bank)) {
            sleepUntil(Rs2Bank::isOpen);
            Rs2Bank.depositAllExcept(pickAxeInInventory);
            sleep(100, 300);
            if (config.pickAxeInInventory() && !Rs2Inventory.hasItem(pickAxeInInventory)) {
                Rs2Bank.withdrawOne(pickAxeInInventory);
            }
            sleep(600);
        }
    }
    private void chiselAmethysts() {
        AmethystCraftingOption craftingOption = config.amethystCraftingOption();
        int requiredLevel = craftingOption.getRequiredLevel();
        Rs2Item chisel = Rs2Inventory.get("chisel");
        Rs2Inventory.moveItemToSlot(chisel, 27);
        sleepUntil(() -> Rs2Inventory.slotContains(27, "chisel"), 5000);
        if (Microbot.getClient().getRealSkillLevel(Skill.CRAFTING) >= requiredLevel) {
            Rs2Inventory.combineClosest(ItemID.CHISEL, ItemID.AMETHYST);
            sleepUntil(() -> Rs2Widget.getWidget(17694733) != null);
            Rs2Keyboard.keyPress(craftingOption.getDialogOption());
            sleepUntil(() -> !Rs2Inventory.hasItem(ItemID.AMETHYST), 40000);
            Rs2Antiban.takeMicroBreakByChance();
        } else {
            Microbot.showMessage("You do not have the required crafting level to make " + craftingOption.getDisplayName());
            status = Status.BANKING;
        }
    }
    private void handleMining() {
        if (oreVein != null) return;
        if (miningSpot == MiningSpot.NULL)
            miningSpot = MiningSpot.getRandomMiningSpot();
        else {
            if (walkToMiningSpot()) {
                if (Rs2Player.isMoving()) return;
                mineVein();
                Rs2Antiban.actionCooldown();
                Rs2Antiban.takeMicroBreakByChance();
            }
        }
    }
    private boolean mineVein() {
        if (Rs2Player.isMoving()) return false;
        WallObject closestVein = findClosestVein();
        if (closestVein == null) {
            moveToMiningSpot();
            return false;
        }
        interactWithVein(closestVein);
        return true;
    }
    private WallObject findClosestVein() {
        return Rs2GameObject.getWallObjects().stream()
                .filter(this::isVein).min((a, b) -> Integer.compare(distanceToPlayer(a), distanceToPlayer(b))).orElse(null);
    }
    private boolean isVein(WallObject wallObject) {
        int id = wallObject.getId();
        return id == 11388 || id == 11389;
    }
    private int distanceToPlayer(WallObject wallObject) {
        WorldPoint closestWalkableNeighbour = Rs2Tile.getNearestWalkableTile(wallObject.getWorldLocation());
        if (closestWalkableNeighbour == null) return 999;
        return Microbot.getClient().getLocalPlayer().getWorldLocation().distanceTo2D(closestWalkableNeighbour);
    }
    private void interactWithVein(WallObject vein) {
        if (Rs2GameObject.interact(vein))
            oreVein = vein;
        sleepUntil(Rs2Player::isAnimating, 10000);
        if (!Rs2Player.isAnimating()) {
            oreVein = null;
        }
    }
    private boolean walkToMiningSpot() {
        WorldPoint miningWorldPoint = miningSpot.getWorldPoint();
        return Rs2Walker.walkTo(miningWorldPoint, 8);
    }
    private void moveToMiningSpot() {
        Rs2Walker.walkFastCanvas(miningSpot.getWorldPoint());
    }
    private void initialize() {
        Rs2Antiban.antibanSetupTemplates.applyMiningSetup();
        status = Status.IDLE;
        miningSpot = MiningSpot.NULL;
        oreVein = null;
    }
    @Override
    public void shutdown() {
        Rs2Antiban.resetAntibanSettings();
        super.shutdown();
        status = Status.IDLE;
        miningSpot = MiningSpot.NULL;
        oreVein = null;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/enums/Rocks.java
================
package net.runelite.client.plugins.microbot.mining.enums;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Skill;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
@Getter
@RequiredArgsConstructor
public enum Rocks {
    TIN("tin rocks", 1),
    COPPER("copper rocks", 1),
    CLAY("clay rocks", 1),
    IRON("iron rocks", 15),
    SILVER("silver rocks", 20),
    COAL("coal rocks", 30),
    GOLD("gold rocks", 40),
    GEM("gem rocks", 40),
    MITHRIL("mithril rocks", 55),
    ADAMANTITE("adamantite rocks", 70),
    RUNITE("runite rocks", 85);
    private final String name;
    private final int miningLevel;
    @Override
    public String toString() {
        return name;
    }
    public boolean hasRequiredLevel() {
        return Rs2Player.getSkillRequirement(Skill.MINING, this.miningLevel);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/motherloadmine/enums/MLMMiningSpot.java
================
package net.runelite.client.plugins.microbot.mining.motherloadmine.enums;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.coords.WorldPoint;
import java.util.Arrays;
import java.util.List;
@Getter
@RequiredArgsConstructor
public enum MLMMiningSpot {
    IDLE(null),
    WEST_LOWER(Arrays.asList(new WorldPoint(3731, 5661, 0), new WorldPoint(3730, 5668, 0))),
    WEST_MID(null),
    WEST_UPPER(Arrays.asList(new WorldPoint(3752, 5683, 0), new WorldPoint(3752, 5680, 0))),
    SOUTH(Arrays.asList(new WorldPoint(3745, 5647, 0), new WorldPoint(3756, 5653, 0))),
    NORTH(null),
    EAST_UPPER(Arrays.asList(new WorldPoint(3760, 5673, 0), new WorldPoint(3759, 5673, 0)));
    private final List<WorldPoint> worldPoint;
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/motherloadmine/enums/MLMStatus.java
================
package net.runelite.client.plugins.microbot.mining.motherloadmine.enums;
public enum MLMStatus {
    IDLE,
    MINING,
    DEPOSIT_HOPPER,
    BANKING,
    EMPTY_SACK,
    FIXING_WATERWHEEL
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/motherloadmine/MotherloadMineConfig.java
================
package net.runelite.client.plugins.microbot.mining.motherloadmine;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
@ConfigGroup("MotherloadMine")
public interface MotherloadMineConfig extends Config {
    @ConfigItem(
            keyName = "guide",
            name = "How to use",
            description = "How to use this plugin",
            position = 0
    )
    default String GUIDE() {
        return "1. Have a hammer in your inventory \n2. Start near the bank chest in motherload mine";
    }
    @ConfigItem(
            keyName = "PickAxeInInventory",
            name = "Pick Axe In Inventory?",
            description = "Pick Axe in inventory?",
            position = 1
    )
    default boolean pickAxeInInventory() {
        return false;
    }
    // Mine upstairs
    @ConfigItem(
            keyName = "MineUpstairs",
            name = "Mine Upstairs?",
            description = "Mine upstairs?",
            position = 2
    )
    default boolean mineUpstairs() {
        return false;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/motherloadmine/MotherloadMineOverlay.java
================
package net.runelite.client.plugins.microbot.mining.motherloadmine;
import net.runelite.client.plugins.microbot.util.antiban.Rs2Antiban;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import javax.inject.Inject;
import java.awt.*;
import static net.runelite.client.plugins.microbot.mining.motherloadmine.MotherloadMineScript.status;
public class MotherloadMineOverlay extends OverlayPanel {
    @Inject
    MotherloadMineOverlay(MotherloadMinePlugin plugin)
    {
        super(plugin);
        setPosition(OverlayPosition.TOP_LEFT);
        setSnappable(true);
    }
    @Override
    public Dimension render(Graphics2D graphics) {
        try {
            panelComponent.setPreferredSize(new Dimension(275, 900));
            panelComponent.getChildren().add(TitleComponent.builder()
                    .text("\uD83E\uDD86 Motherlode Mine \uD83E\uDD86")
                    .color(Color.ORANGE)
                    .build());
            Rs2Antiban.renderAntibanOverlayComponents(panelComponent);
            addEmptyLine();
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Mining Location: " + MotherloadMineScript.miningSpot.name())
                    .build());
            addEmptyLine();
            panelComponent.getChildren().add(LineComponent.builder()
                    .left(status.toString())
                    .right("Version: " + MotherloadMineScript.version)
                    .build());
        } catch(Exception ex) {
            System.out.println(ex.getMessage());
        }
        return super.render(graphics);
    }
    private void addEmptyLine() {
        panelComponent.getChildren().add(LineComponent.builder().build());
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/motherloadmine/MotherloadMinePlugin.java
================
package net.runelite.client.plugins.microbot.mining.motherloadmine;
import com.google.inject.Provides;
import net.runelite.api.ObjectID;
import net.runelite.api.WallObject;
import net.runelite.api.events.WallObjectSpawned;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.microbot.mining.motherloadmine.enums.MLMStatus;
import net.runelite.client.ui.overlay.OverlayManager;
import javax.inject.Inject;
import java.awt.*;
@PluginDescriptor(
        name = PluginDescriptor.Mocrosoft + "MotherlodeMine",
        description = "A bot that mines paydirt in the motherlode mine",
        tags = {"paydirt", "mine", "motherlode"},
        enabledByDefault = false
)
public class MotherloadMinePlugin extends Plugin {
    @Inject
    private MotherloadMineConfig config;
    @Inject
    private OverlayManager overlayManager;
    @Inject
    private MotherloadMineOverlay motherloadMineOverlay;
    @Inject
    private MotherloadMineScript motherloadMineScript;
    @Provides
    MotherloadMineConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(MotherloadMineConfig.class);
    }
    @Override
    protected void startUp() throws AWTException {
        overlayManager.add(motherloadMineOverlay);
        motherloadMineScript.run(config);
    }
    @Subscribe
    public void onWallObjectSpawned(WallObjectSpawned event) {
        WallObject wallObject = event.getWallObject();
        try {
            if (wallObject == null || MotherloadMineScript.oreVein == null)
                return;
            if (MotherloadMineScript.status == MLMStatus.MINING && (wallObject.getId() == ObjectID.DEPLETED_VEIN_26665 || wallObject.getId() == ObjectID.DEPLETED_VEIN_26666 || wallObject.getId() == ObjectID.DEPLETED_VEIN_26667 || wallObject.getId() == ObjectID.DEPLETED_VEIN_26668)) {
                if (wallObject.getWorldLocation().equals(MotherloadMineScript.oreVein.getWorldLocation())) {
                    MotherloadMineScript.oreVein = null;
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    protected void shutDown() {
        motherloadMineScript.shutdown();
        overlayManager.remove(motherloadMineOverlay);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/motherloadmine/MotherloadMineScript.java
================
package net.runelite.client.plugins.microbot.mining.motherloadmine;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.Script;
import net.runelite.client.plugins.microbot.mining.motherloadmine.enums.MLMMiningSpot;
import net.runelite.client.plugins.microbot.mining.motherloadmine.enums.MLMStatus;
import net.runelite.client.plugins.microbot.util.antiban.Rs2Antiban;
import net.runelite.client.plugins.microbot.util.antiban.Rs2AntibanSettings;
import net.runelite.client.plugins.microbot.util.antiban.enums.ActivityIntensity;
import net.runelite.client.plugins.microbot.util.bank.Rs2Bank;
import net.runelite.client.plugins.microbot.util.combat.Rs2Combat;
import net.runelite.client.plugins.microbot.util.equipment.Rs2Equipment;
import net.runelite.client.plugins.microbot.util.gameobject.Rs2GameObject;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.microbot.util.tile.Rs2Tile;
import net.runelite.client.plugins.microbot.util.walker.Rs2Walker;
import java.util.Collections;
import java.util.concurrent.TimeUnit;
import static net.runelite.client.plugins.microbot.util.math.Random.random;
@Slf4j
public class MotherloadMineScript extends Script {
    public static final String version = "1.6.5";
    private static final WorldArea WEST_UPPER_AREA = new WorldArea(3748, 5676, 7, 9, 0);
    private static final WorldArea EAST_UPPER_AREA = new WorldArea(3755, 5668, 8, 8, 0);
    private static final WorldPoint HOPPER = new WorldPoint(3748, 5674, 0);
    private static final int UPPER_FLOOR_HEIGHT = -490;
    private static final int SACK_LARGE_SIZE = 162;
    private static final int SACK_SIZE = 81;
    private static final int SACKID = 26688;
    public static MLMStatus status = MLMStatus.IDLE;
    public static WallObject oreVein;
    public static MLMMiningSpot miningSpot = MLMMiningSpot.IDLE;
    private static int maxSackSize;
    private static MotherloadMineConfig config;
    private String pickAxeInInventory = "";
    private boolean emptySack = false;
    public boolean run(MotherloadMineConfig config) {
        MotherloadMineScript.config = config;
        initialize();
        mainScheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(this::executeTask, 0, 600, TimeUnit.MILLISECONDS);
        return true;
    }
    private void initialize() {
        Rs2Antiban.antibanSetupTemplates.applyMiningSetup();
        miningSpot = MLMMiningSpot.IDLE;
        status = MLMStatus.IDLE;
        emptySack = false;
        if (config.pickAxeInInventory()) {
            pickAxeInInventory = Rs2Inventory.get("pickaxe").name;
        }
    }
    private void executeTask() {
        if (!super.run() || !Microbot.isLoggedIn() || Rs2Antiban.isIdleTooLong(50)) {
            oreVein = null;
            miningSpot = MLMMiningSpot.IDLE;
            return;
        }
        if (pickAxeInInventory.isEmpty() && config.pickAxeInInventory()) {
            Microbot.showMessage("Pickaxe was not found in your inventory");
            sleep(5000);
            return;
        }
        if (Rs2AntibanSettings.actionCooldownActive) return;
        if (Rs2Player.isAnimating() || Microbot.getClient().getLocalPlayer().isInteracting()) return;
        handleDragonPickaxeSpec();
        handleInventory();
        switch (status) {
            case IDLE:
                return;
            case MINING:
                Rs2Antiban.setActivityIntensity(Rs2Antiban.getActivity().getActivityIntensity());
                handleMining();
                break;
            case EMPTY_SACK:
                Rs2Antiban.setActivityIntensity(ActivityIntensity.EXTREME);
                emptySack();
                break;
            case FIXING_WATERWHEEL:
                fixWaterwheel();
                break;
            case DEPOSIT_HOPPER:
                depositHopper();
                break;
            case BANKING:
                bankItems();
                break;
        }
    }
    private void handleDragonPickaxeSpec() {
        if (Rs2Equipment.isWearing("dragon pickaxe")) {
            Rs2Combat.setSpecState(true, 1000);
        }
    }
    private void handleInventory() {
        boolean sackUpgraded = Microbot.getVarbitValue(Varbits.SACK_UPGRADED) == 1;
        maxSackSize = sackUpgraded ? SACK_LARGE_SIZE : SACK_SIZE;
        if (!Rs2Inventory.hasItem("hammer") || !Rs2Inventory.hasItem(pickAxeInInventory) && config.pickAxeInInventory()) {
            bank();
            return;
        }
        if (Microbot.getVarbitValue(Varbits.SACK_NUMBER) > maxSackSize || (emptySack && !Rs2Inventory.contains("pay-dirt"))) {
            oreVein = null;
            miningSpot = MLMMiningSpot.IDLE;
            status = MLMStatus.EMPTY_SACK;
        } else if (!Rs2Inventory.isFull()) {
            status = MLMStatus.MINING;
        } else if (Rs2Inventory.isFull()) {
            oreVein = null;
            miningSpot = MLMMiningSpot.IDLE;
            if (Rs2Inventory.hasItem(ItemID.PAYDIRT)) {
                status = Rs2GameObject.getGameObjects(ObjectID.BROKEN_STRUT).size() > 1 && Rs2Inventory.hasItem("hammer")
                        ? MLMStatus.FIXING_WATERWHEEL
                        : MLMStatus.DEPOSIT_HOPPER;
            } else {
                status = MLMStatus.BANKING;
            }
        }
        if (Rs2Inventory.hasItem("coal") && Rs2Inventory.isFull()) {
            status = MLMStatus.BANKING;
        }
    }
    private void handleMining() {
        if (oreVein != null) return;
        if (miningSpot == MLMMiningSpot.IDLE) {
            findRandomMiningSpot();
        } else {
            if (walkToMiningSpot()) {
                if (Rs2Player.isMoving()) return;
                mineVein();
                Rs2Antiban.actionCooldown();
                Rs2Antiban.takeMicroBreakByChance();
            }
        }
    }
    private void emptySack() {
        if (isUpperFloor()) goDown();
        while (Microbot.getVarbitValue(Varbits.SACK_NUMBER) > 0) {
            if (Rs2Inventory.size() <= 2) {
                Rs2GameObject.interact(SACKID);
                sleepUntil(() -> Rs2Inventory.contains(
                        ItemID.RUNITE_ORE, ItemID.ADAMANTITE_ORE, ItemID.MITHRIL_ORE,
                        ItemID.GOLD_ORE, ItemID.COAL, ItemID.UNCUT_SAPPHIRE,
                        ItemID.UNCUT_EMERALD, ItemID.UNCUT_RUBY, ItemID.UNCUT_DIAMOND,
                        ItemID.UNCUT_DRAGONSTONE));
            }
            if (Rs2Inventory.contains(
                    ItemID.RUNITE_ORE, ItemID.ADAMANTITE_ORE, ItemID.MITHRIL_ORE,
                    ItemID.GOLD_ORE, ItemID.COAL, ItemID.UNCUT_SAPPHIRE,
                    ItemID.UNCUT_EMERALD, ItemID.UNCUT_RUBY, ItemID.UNCUT_DIAMOND,
                    ItemID.UNCUT_DRAGONSTONE))
                bank();
        }
        emptySack = false;
        Rs2Antiban.takeMicroBreakByChance();
        status = MLMStatus.IDLE;
    }
    private void fixWaterwheel() {
        if (isUpperFloor()) goDown();
        if (Rs2Walker.walkTo(new WorldPoint(3741, 5666, 0), 15)) {
            Microbot.isGainingExp = false;
            if (Rs2GameObject.interact(ObjectID.BROKEN_STRUT))
                sleepUntil(() -> Microbot.isGainingExp);
        }
    }
    private void depositHopper() {
        if (!isUpperFloor() || isUpperFloor()) {
            if (Rs2GameObject.interact(ObjectID.HOPPER_26674)) {
                sleepUntil(() -> !Rs2Inventory.isFull());
                if (Microbot.getVarbitValue(Varbits.SACK_NUMBER) > maxSackSize - 28) {
                    emptySack = true;
                }
            } else {
                Rs2Walker.walkTo(HOPPER, 15);
            }
        }
    }
    private void bankItems() {
        //Rs2Walker.walkTo(new WorldPoint(3759, 5666, 0));
        bank();
    }
    private void bank() {
        if (Rs2Bank.useBank()) {
            sleepUntil(Rs2Bank::isOpen);
            Rs2Bank.depositAllExcept("hammer", pickAxeInInventory);
            sleep(100, 300);
            if (!Rs2Bank.hasItem("hammer") && !Rs2Inventory.hasItem("hammer")) {
                Microbot.showMessage("No hammer found in the bank.");
                sleep(5000);
                return;
            }
            if (!Rs2Inventory.hasItem("hammer")) Rs2Bank.withdrawOne("hammer", true);
            if (config.pickAxeInInventory() && !Rs2Inventory.hasItem(pickAxeInInventory)) {
                Rs2Bank.withdrawOne(pickAxeInInventory);
            }
            sleep(600);
        }
    }
    private void findRandomMiningSpot() {
        miningSpot = random(1, 5) == 2
                ? (config.mineUpstairs() ? MLMMiningSpot.WEST_UPPER : MLMMiningSpot.SOUTH)
                : (config.mineUpstairs() ? MLMMiningSpot.EAST_UPPER : MLMMiningSpot.WEST_LOWER);
        Collections.shuffle(miningSpot.getWorldPoint());
    }
    private boolean walkToMiningSpot() {
        WorldPoint miningWorldPoint = miningSpot.getWorldPoint().get(0);
        if (!isUpperFloor() && config.mineUpstairs()) goUp();
        return Rs2Walker.walkTo(miningWorldPoint, 10);
    }
    private boolean mineVein() {
        if (Rs2Player.isMoving()) return false;
        WallObject closestVein = findClosestVein();
        if (closestVein == null) {
            moveToMiningSpot();
            return false;
        }
        interactWithVein(closestVein);
        return true;
    }
    private WallObject findClosestVein() {
        return Rs2GameObject.getWallObjects().stream()
                .filter(this::isVein).filter(this::isWithinMiningArea).min((a, b) -> Integer.compare(distanceToPlayer(a), distanceToPlayer(b))).orElse(null);
    }
    private boolean isVein(WallObject wallObject) {
        int id = wallObject.getId();
        return id == 26661 || id == 26662 || id == 26663 || id == 26664;
    }
    private boolean isWithinMiningArea(WallObject wallObject) {
        if (!config.mineUpstairs())
            return true;
        WorldPoint walkableTile = wallObject.getWorldLocation();
        return WEST_UPPER_AREA.contains(walkableTile) || EAST_UPPER_AREA.contains(walkableTile);
    }
    private int distanceToPlayer(WallObject wallObject) {
        WorldPoint closestWalkableNeighbour = Rs2Tile.getNearestWalkableTile(wallObject.getWorldLocation());
        if (closestWalkableNeighbour == null) return 999;
        return Microbot.getClient().getLocalPlayer().getWorldLocation().distanceTo2D(closestWalkableNeighbour);
    }
    private void moveToMiningSpot() {
        Rs2Walker.walkFastCanvas(miningSpot.getWorldPoint().get(0));
    }
    private void interactWithVein(WallObject vein) {
        if (Rs2GameObject.interact(vein))
            oreVein = vein;
        sleepUntil(Rs2Player::isAnimating, 5000);
        if (!Rs2Player.isAnimating()) {
            oreVein = null;
        }
    }
    private void goUp() {
        if (isUpperFloor()) return;
        Rs2GameObject.interact(NullObjectID.NULL_19044);
        sleepUntil(this::isUpperFloor);
    }
    private void goDown() {
        if (!isUpperFloor()) return;
        Rs2GameObject.interact(NullObjectID.NULL_19045);
        sleepUntil(() -> !isUpperFloor());
    }
    private boolean isUpperFloor() {
        return Perspective.getTileHeight(Microbot.getClient(), Microbot.getClient().getLocalPlayer().getLocalLocation(), 0) < UPPER_FLOOR_HEIGHT;
    }
    public void shutdown() {
        Rs2Antiban.resetAntibanSettings();
        oreVein = null;
        miningSpot = MLMMiningSpot.IDLE;
        Rs2Walker.setTarget(null);
        super.shutdown();
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/shootingstar/enums/Pickaxe.java
================
package net.runelite.client.plugins.microbot.mining.shootingstar.enums;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.ItemID;
import net.runelite.api.Skill;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
@Getter
@AllArgsConstructor
public enum Pickaxe {
    BRONZE_PICKAXE("bronze pickaxe", ItemID.BRONZE_PICKAXE, 1, 1),
    IRON_PICKAXE("iron pickaxe", ItemID.IRON_PICKAXE, 1, 1),
    STEEL_PICKAXE("steel pickaxe", ItemID.STEEL_PICKAXE, 6, 5),
    BLACK_PICKAXE("black pickaxe", ItemID.BLACK_PICKAXE, 11, 10),
    MITHRIL_PICKAXE("mithril pickaxe", ItemID.MITHRIL_PICKAXE, 21, 20),
    ADAMANT_PICKAXE("adamant pickaxe", ItemID.ADAMANT_PICKAXE, 31, 30),
    RUNE_PICKAXE("rune pickaxe", ItemID.RUNE_PICKAXE, 41, 40),
    DRAGON_PICKAXE("dragon pickaxe", ItemID.DRAGON_PICKAXE, 61, 60),
    CRYSTAL_PICKAXE("crystal pickaxe", ItemID.CRYSTAL_PICKAXE, 71, 70);
    private final String itemName;
    private final int itemID;
    private final int miningLevel;
    private final int attackLevel;
    public boolean hasRequirements() {
        return Rs2Player.getSkillRequirement(Skill.MINING, this.miningLevel) && Rs2Player.getSkillRequirement(Skill.ATTACK, this.attackLevel);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/shootingstar/enums/ShootingStarLocation.java
================
package net.runelite.client.plugins.microbot.mining.shootingstar.enums;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Quest;
import net.runelite.api.QuestState;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.equipment.Rs2Equipment;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
/**
 * The ShootingStarLocation consists of some static game data that is used for each location where a star can drop
 * (most are included, may need to be updated in the future to include new locations)
 */
@Getter
@RequiredArgsConstructor
public enum ShootingStarLocation {
    YANILLE_BANK(new WorldPoint(2605, 3092, 0), "Yanille bank", "Yanille", false),
    SHAYZIEN_MINE(new WorldPoint(1598, 3644, 0), "Shayzien mine south of Kourend Castle", "Shayzien Mine", false),
    MOUNT_QUIDAMORTEM__BANK(new WorldPoint(1260, 3563, 0), "Chambers of Xeric bank", "CoX bank", false),
    DRAYNOR_VILLAGE(new WorldPoint(3089, 3237, 0), "Draynor Village", "Draynor", false),
    VOLCANIC_MINE_ENTRANCE(new WorldPoint(3820, 3799, 0), "Fossil Island Volcanic Mine entrance", "Volcanic Mine", false),
    MOUNT_KARUULM__BANK(new WorldPoint(1325, 3819, 0), "Mount Karuulm bank", "Mount Karuulm bank", false),
    DWARVEN_MINE_NORTHERN_ENTRANCE(new WorldPoint(3017, 3445, 0), "North Dwarven Mine entrance", "Dwarven Mine", false),
    NARDAH(new WorldPoint(3434, 2891, 0), "Nardah bank", "Nardah", false),
    AGILITY_PYRAMID_MINE(new WorldPoint(3314, 2867, 0), "Agility Pyramid mine", "Agility Pyramid", false),
    UZER_MINE(new WorldPoint(3422, 3159, 0), "Nw of Uzer (Eagle's Eyrie)", "Uzer Mine", false),
    PORT_KHAZARD_MINE(new WorldPoint(2625, 3143, 0), "Port Khazard mine", "Port Khazard", false),
    GRAND_TREE(new WorldPoint(2446, 3491, 0), "West of Grand Tree", "Grand Tree", false),
    BANDIT_CAMP_MINE__HOBGOBLINS(new WorldPoint(3093, 3751, 0), "Hobgoblin mine (lvl 30 Wildy)", "Hobgoblin mine", true),
    FOSSIL_ISLAND_MINE(new WorldPoint(3774, 3815, 0), "Fossil Island rune rocks", "Fossil Island", false),
    TAVERLEY__WHITE_WOLF_TUNNEL_ENTRANCE(new WorldPoint(2884, 3472, 0), "Taverley house portal", "Taverley", false),
    FELDIP_HUNTER_AREA(new WorldPoint(2573, 2965, 0), "Feldip Hills (aks fairy ring)", "Feldip Hills", false),
    RELLEKKA_MINE(new WorldPoint(2680, 3701, 0), "Rellekka mine", "Rellekka mine", false),
    TRAHAEARN_MINE_ENTRANCE(new WorldPoint(2552, 3294, 0), "Prifddinas Zalcano entrance", "Prifddinas Zalcano", false),
    WEST_LUMBRIDGE_SWAMP_MINE(new WorldPoint(3156, 3154, 0), "West Lumbridge Swamp mine", "W Lumbridge Swamp", false),
    RANTZS_CAVE(new WorldPoint(2630, 2991, 0), "Rantz cave", "Rantz cave", false),
    MYNYDD_MINE(new WorldPoint(2173, 3408, 0), "Mynydd nw of Prifddinas", "Mynydd", false),
    SOUTH_EAST_VARROCK_MINE(new WorldPoint(3292, 3353, 0), "Southeast Varrock mine", "SE Varrock mine", false),
    CRAFTING_GUILD(new WorldPoint(2939, 3282, 0), "Crafting guild", "Crafting Guild", false),
    LEGENDS_GUILD_MINE(new WorldPoint(2703, 3332, 0), "South of Legends' Guild", "Legends Guild", false),
    ISAFDAR_MINE(new WorldPoint(2271, 3157, 0), "Isafdar runite rocks", "Isafdar", false),
    CATHERBY_BANK(new WorldPoint(2804, 3438, 0), "Catherby bank", "Catherby", false),
    CORSAIR_COVE(new WorldPoint(2566, 2858, 0), "Corsair Cove bank", "Corsair Cove bank", false),
    CORSAIR_COVE_RESOURCE_AREA(new WorldPoint(2482, 2881, 0), "Corsair Resource Area", "Corsair Resource Area", false),
    COAL_TRUCKS(new WorldPoint(2590, 3479, 0), "Coal Trucks west of Seers'", "Seers Village", false),
    KELDAGRIM_ENTRANCE_MINE(new WorldPoint(2725, 3683, 0), "Keldagrim entrance mine", "Keldagrim entrance", false),
    PISCATORIS_MINE(new WorldPoint(2342, 3632, 0), "Piscatoris mine", "Piscatoris mine", false),
    SOUTH_BRIMHAVEN_MINE(new WorldPoint(2743, 3145, 0), "Southwest of Brimhaven Poh", "SW Brimhaven", false),
    AL_KHARID_MINE(new WorldPoint(3300, 3299, 0), "Al Kharid mine", "Al Kharid mine", false),
    SOUTH_WILDERNESS_MINE__MAGE_OF_ZAMORAK(new WorldPoint(3110, 3570, 0), "Mage of Zamorak mine (lvl 7 Wildy)", "Mage of Zamorak mine", true),
    EMIRS_ARENA(new WorldPoint(3352, 3277, 0), "North of Al Kharid PvP Arena", "Emirs Arena", false),
    AL_KHARID__BANK(new WorldPoint(3275, 3166, 0), "Al Kharid Bank", "Al Kharid Bank", false),
    MAGE_ARENA(new WorldPoint(3093, 3961, 0), "Mage Arena bank (lvl 56 Wildy)", "Mage Arena bank", true),
    MYTHS_GUILD(new WorldPoint(2468, 2846, 0), "Myths' Guild", "Myths' Guild", false),
    VARROCK__EAST_BANK(new WorldPoint(3260, 3412, 0), "Varrock east bank", "Varrock east bank", false),
    SOUTH_EAST_ARDOUGNE_MINE__MONASTERY(new WorldPoint(2607, 3229, 0), "Ardougne Monastery", "Ardougne Monastery", false),
    DENSE_ESSENCE_MINE(new WorldPoint(1761, 3854, 0), "Arceuus dense essence mine", "Arceuus Essence mine", false),
    TREE_GNOME_STRONGHOLD_BANK(new WorldPoint(2454, 3435, 0), "Gnome Stronghold spirit tree", "Gnome Stronghold", false),
    SOUTH_WEST_VARROCK_MINE(new WorldPoint(3180, 3365, 0), "Champions' Guild mine", "Champions' Guild", false),
    EAST_LUMBRIDGE_SWAMP_MINE(new WorldPoint(3232, 3152, 0), "East Lumbridge Swamp mine", "E Lumbridge Swamp", false),
    RIMMINGTON_MINE(new WorldPoint(2974, 3243, 0), "Rimmington mine", "Rimmington", false),
    BURGH_DE_ROTT__BANK(new WorldPoint(3497, 3220, 0), "Burgh de Rott bank", "Burgh de Rott", false),
    KARAMJA_JUNGLE_MINE__NATURE_ALTAR(new WorldPoint(2843, 3033, 0), "Nature Altar mine north of Shilo", "Nature Altar", false),
    SHILO_VILLAGE_MINE(new WorldPoint(2825, 2997, 0), "Shilo Village gem mine", "Shilo Gem Mine", false),
    RESOURCE_AREA(new WorldPoint(3188, 3935, 0), "Wilderness Resource Area", "Wilderness Resource Area", true),
    JATIZSO_MINE_ENTRANCE(new WorldPoint(2392, 3811, 0), "Jatizso mine entrance", "Jatizso", false),
    CENTRAL_FREMENNIK_ISLES_MINE(new WorldPoint(2372, 3833, 0), "Neitiznot south of rune rock", "Neitiznot", false),
    MOUNT_KARUULM_MINE(new WorldPoint(1276, 3811, 0), "Mount Karuulm mine", "Mount Karuulm mine", false),
    KEBOS_LOWLANDS_MINE__KEBOS_SWAMP(new WorldPoint(1210, 3651, 0), "Kebos Swamp mine", "Kebos Swamp mine", false),
    CANIFIS__BANK(new WorldPoint(3503, 3483, 0), "Canifis bank", "Canifis bank", false),
    LLETYA(new WorldPoint(2318, 3268, 0), "Lletya", "Lletya", false),
    HOSIDIUS_MINE(new WorldPoint(1781, 3491, 0), "Hosidius mine", "Hosidius mine", false),
    PORT_PISCARILIUS_MINE(new WorldPoint(1765, 3707, 0), "Port Piscarilius mine in Kourend", "Piscarilius mine", false),
    LOVAKENGJ__BANK(new WorldPoint(1534, 3756, 0), "South Lovakengj bank", "S Lovakengj bank", false),
    ABANDONED_MINE(new WorldPoint(3452, 3240, 0), "Abandoned Mine west of Burgh", "Abandoned Mine", false),
    DESERT_QUARRY(new WorldPoint(3176, 2909, 0), "Desert Quarry mine", "Desert Quarry mine", false),
    NORTH_CRANDOR_MINE(new WorldPoint(2837, 3294, 0), "North Crandor", "North Crandor", false),
    NORTH_BRIMHAVEN_MINE(new WorldPoint(2733, 3220, 0), "Brimhaven northwest gold mine", "Brimhaven gold mine", false),
    LOVAKITE_MINE(new WorldPoint(1437, 3839, 0), "Lovakite mine", "Lovakite mine", false),
    ISLE_OF_SOULS_MINE(new WorldPoint(2201, 2791, 0), "Soul Wars south mine", "Soul Wars south mine", false),
    SOUTH_CRANDOR_MINE(new WorldPoint(2821, 3240, 0), "South Crandor", "South Crandor", false),
    WEST_FALADOR_MINE(new WorldPoint(2908, 3354, 0), "West Falador mine", "West Falador mine", false),
    DAEYALT_ESSENCE_MINE_ENTRANCE(new WorldPoint(3635, 3338, 0), "Darkmeyer ess. mine entrance", "Darkmeyer mine", false),
    VER_SINHAZA__BANK(new WorldPoint(3560, 3212, 0), "Theatre of Blood bank", "ToB bank", false),
    MISCELLANIA_MINE(new WorldPoint(2530, 3887, 0), "Miscellania mine (cip fairy ring)", "Miscellania mine", false),
    SOUTH_WEST_WILDERNESS_MINE(new WorldPoint(3019, 3593, 0), "Skeleton mine (lvl 10 Wildy)", "Skeleton mine", true),
    MOS_LEHARMLESS(new WorldPoint(3683, 2969, 0), "Mos Le'Harmless west bank", "Mos Le'Harmless", false),
    LUNAR_ISLE_MINE_ENTRANCE(new WorldPoint(2140, 3940, 0), "Lunar Isle mine entrance", "Lunar Isle", false),
    MINING_GUILD_ENTRANCE(new WorldPoint(3030, 3347, 0), "East Falador bank", "E Falador bank", false),
    VARLAMORE_SOUTH_EAST_MINE(new WorldPoint(1742, 2957, 0), "Varlamore South East mine", "SE Varlamore mine", false),
    VARLAMORE_COLOSSEUM_ENTRANCE_BANK(new WorldPoint(1771, 3107, 0), "Varlamore colosseum entrance bank", "Colosseum entrance", false),
    MINE_NORTH_WEST_OF_HUNTER_GUILD(new WorldPoint(1486, 3093, 0), "Mine northwest of hunter guild", "Hunter Guild mine", false),
    PIRATES_HIDEOUT_MINE(new WorldPoint(3049, 3945, 0), "Pirates' Hideout (lvl 53 Wildy)", "Pirates' Hideout", true),
    LAVA_MAZE_RUNITE_MINE(new WorldPoint(3057, 3890, 0), "Lava maze runite mine (lvl 46 Wildy)", "Lava maze", true);
    private final WorldPoint worldPoint;
    private final String rawLocationName;
    private final String shortLocationName;
    private final boolean isInWilderness;
    public String getLocationName() {
        return getShortLocationName();
    }
    public boolean hasRequirements() {
        boolean hasLineOfSight = Microbot.getClient().getLocalPlayer().getWorldArea().hasLineOfSightTo(Microbot.getClient().getTopLevelWorldView(), this.getWorldPoint());
        switch (this) {
            case CRAFTING_GUILD:
                // Requires Crafting Guild Items
                boolean isWearingCraftingGuild = (Rs2Equipment.isWearing("brown apron") || Rs2Equipment.isWearing("golden apron") ||
                        Rs2Equipment.isWearing("crafting cape") || Rs2Equipment.isWearing("crafting hood") ||
                        Rs2Equipment.isWearing("max cape") || Rs2Equipment.isWearing("max hood"));
                // If has line of sight (already in crafting guild)
                if (hasLineOfSight) return true;
                return isWearingCraftingGuild;
            case MYTHS_GUILD:
                // Requires Dragon Slayer II Quest
                return Rs2Player.getQuestState(Quest.DRAGON_SLAYER_II) == QuestState.FINISHED;
            case JATIZSO_MINE_ENTRANCE:
            case CENTRAL_FREMENNIK_ISLES_MINE:
                // Requires The Fremennik Trials & The Fremennik Isles
                return (Rs2Player.getQuestState(Quest.THE_FREMENNIK_TRIALS) == QuestState.FINISHED) && 
                        (Rs2Player.getQuestState(Quest.THE_FREMENNIK_ISLES) == QuestState.IN_PROGRESS || Rs2Player.getQuestState(Quest.THE_FREMENNIK_ISLES) == QuestState.FINISHED);
            case MOS_LEHARMLESS:
                // Requires Cabin Fever Quest
                return Rs2Player.getQuestState(Quest.CABIN_FEVER) == QuestState.FINISHED;
            case SOUTH_CRANDOR_MINE:
            case NORTH_CRANDOR_MINE:
                // Requires start of Dragon Slayer I
                return Rs2Player.getQuestState(Quest.DRAGON_SLAYER_I) == QuestState.IN_PROGRESS || 
                        Rs2Player.getQuestState(Quest.DRAGON_SLAYER_I) == QuestState.FINISHED;
            case FOSSIL_ISLAND_MINE:
            case VOLCANIC_MINE_ENTRANCE:
                // Requires Bone Voyage
                return Rs2Player.getQuestState(Quest.BONE_VOYAGE) == QuestState.FINISHED;
            case LLETYA:
            case ISAFDAR_MINE:
                // Requires Mournings End Part I
                return Rs2Player.getQuestState(Quest.MOURNINGS_END_PART_I) == QuestState.IN_PROGRESS || 
                        Rs2Player.getQuestState(Quest.MOURNINGS_END_PART_I) == QuestState.FINISHED;
            case BURGH_DE_ROTT__BANK:
                // Requires Priest in Peril & In Aid of the Myreque
                return Rs2Player.getQuestState(Quest.PRIEST_IN_PERIL) == QuestState.FINISHED && Rs2Player.getQuestState(Quest.IN_AID_OF_THE_MYREQUE) == QuestState.FINISHED;
            case MYNYDD_MINE:
            case TRAHAEARN_MINE_ENTRANCE:
                // Requires Song of the Elves
                return Rs2Player.getQuestState(Quest.SONG_OF_THE_ELVES) == QuestState.FINISHED;
            case SHILO_VILLAGE_MINE:
                // Requires Shilo Village
                return Rs2Player.getQuestState(Quest.SHILO_VILLAGE) == QuestState.FINISHED;
            case DAEYALT_ESSENCE_MINE_ENTRANCE:
                // Requires Sins of the Father
                return Rs2Player.getQuestState(Quest.SINS_OF_THE_FATHER) == QuestState.FINISHED;
            case VER_SINHAZA__BANK:
                // Requires Priest In Peril
                return Rs2Player.getQuestState(Quest.PRIEST_IN_PERIL) == QuestState.FINISHED;
            case MISCELLANIA_MINE:
                // Requires The Fremennik Trials
                return Rs2Player.getQuestState(Quest.THE_FREMENNIK_TRIALS) == QuestState.FINISHED;
            case LUNAR_ISLE_MINE_ENTRANCE:
                // Requires Lunar Diplomacy & The Fremennik Trials
                return Rs2Player.getQuestState(Quest.THE_FREMENNIK_TRIALS) == QuestState.FINISHED && 
                        (Rs2Player.getQuestState(Quest.LUNAR_DIPLOMACY) == QuestState.IN_PROGRESS || Rs2Player.getQuestState(Quest.LUNAR_DIPLOMACY) == QuestState.FINISHED);
            case VARLAMORE_SOUTH_EAST_MINE:
            case VARLAMORE_COLOSSEUM_ENTRANCE_BANK:
            case MINE_NORTH_WEST_OF_HUNTER_GUILD:
                // Requires Children of the Sun
                return Rs2Player.getQuestState(Quest.CHILDREN_OF_THE_SUN) == QuestState.FINISHED;
            case CORSAIR_COVE:
                // Requires The Corsair Curse if not Member
                if (!Rs2Player.isMember()) {
                    return (Rs2Player.getQuestState(Quest.THE_CORSAIR_CURSE) == QuestState.IN_PROGRESS || Rs2Player.getQuestState(Quest.THE_CORSAIR_CURSE) == QuestState.FINISHED);
                }
                return true;
            case CORSAIR_COVE_RESOURCE_AREA:
                // Requires Dragon Slayer I
                return Rs2Player.getQuestState(Quest.DRAGON_SLAYER_I) == QuestState.FINISHED;
            default:
                return true;
        }
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/shootingstar/enums/ShootingStarState.java
================
package net.runelite.client.plugins.microbot.mining.shootingstar.enums;
import lombok.Getter;
@Getter
public enum ShootingStarState {
    WALKING,
    MINING,
    BANKING,
    WAITING_FOR_STAR,
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/shootingstar/model/ShootingStarTableHeader.java
================
package net.runelite.client.plugins.microbot.mining.shootingstar.model;
import net.runelite.client.plugins.microbot.mining.shootingstar.ShootingStarPlugin;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import net.runelite.client.util.ImageUtil;
import javax.swing.*;
import javax.swing.border.CompoundBorder;
import javax.swing.border.EmptyBorder;
import java.awt.*;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.image.BufferedImage;
public class ShootingStarTableHeader extends JPanel {
    private static final ImageIcon ARROW_UP;
    private static final ImageIcon HIGHLIGHT_ARROW_UP;
    private static final ImageIcon HIGHLIGHT_ARROW_DOWN;
    static {
        final BufferedImage arrowDown = ImageUtil.loadImageResource(ShootingStarPlugin.class, "arrow.png");
        final BufferedImage arrowUp = ImageUtil.rotateImage(arrowDown, Math.PI);
        ARROW_UP = new ImageIcon(arrowUp);
        final BufferedImage highlightArrowDown = ImageUtil.fillImage(arrowDown, ColorScheme.BRAND_ORANGE);
        final BufferedImage highlightArrowUp = ImageUtil.fillImage(arrowUp, ColorScheme.BRAND_ORANGE);
        HIGHLIGHT_ARROW_DOWN = new ImageIcon(highlightArrowDown);
        HIGHLIGHT_ARROW_UP = new ImageIcon(highlightArrowUp);
    }
    private final JLabel textLabel = new JLabel();
    private final JLabel arrowLabel = new JLabel();
    private boolean ordering = false;
    public ShootingStarTableHeader(String title) {
        setLayout(new BoxLayout(this, BoxLayout.X_AXIS));
        setBorder(new CompoundBorder(
                BorderFactory.createMatteBorder(0, 0, 0, 1, ColorScheme.LIGHT_GRAY_COLOR),
                new EmptyBorder(0, 2, 0, 2)
        ));
        setBackground(ColorScheme.SCROLL_TRACK_COLOR);
        addMouseListener(new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                if (!ordering) textLabel.setForeground(ColorScheme.BRAND_ORANGE);
            }
            @Override
            public void mouseExited(MouseEvent e) {
                if (!ordering) textLabel.setForeground(Color.WHITE);
            }
        });
        textLabel.setFont(FontManager.getRunescapeSmallFont());
        textLabel.setText(title);
        textLabel.setForeground(Color.WHITE);
        add(textLabel);
        add(Box.createHorizontalStrut(1));
        add(arrowLabel);
    }
    public void highlight(boolean highlight, boolean ascending) {
        ordering = highlight;
        arrowLabel.setIcon(highlight
                ? ascending ? HIGHLIGHT_ARROW_UP : HIGHLIGHT_ARROW_DOWN
                : ascending ? ARROW_UP : null);
        textLabel.setForeground(highlight ? ColorScheme.BRAND_ORANGE : Color.WHITE);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/shootingstar/model/ShootingStarTableRow.java
================
package net.runelite.client.plugins.microbot.mining.shootingstar.model;
import java.awt.*;
import javax.swing.*;
import javax.swing.border.LineBorder;
import lombok.Getter;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.mining.shootingstar.ShootingStarPanel;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.FontManager;
import javax.swing.border.EmptyBorder;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.concurrent.TimeUnit;
import static net.runelite.client.ui.ColorScheme.*;
public class ShootingStarTableRow extends JPanel {
    private static final DateTimeFormatter dtf = DateTimeFormatter.ofPattern("HH:mm");
    private static final ZoneId utcZoneId = ZoneId.of("UTC");
    private static final Color COLOR_NEGATIVE = new Color(255, 80, 80);
    @Getter
    private final Star starData;
    private final boolean displayAsMinutes;
    private JLabel locationLabel;
    private JLabel tierLabel;
    private JLabel timeLeftLabel;
    public ShootingStarTableRow(Star starData, boolean displayAsMinutes, Color backgroundColor, int curWorld) {
        this.starData = starData;
        this.displayAsMinutes = displayAsMinutes;
        setLayout(new BoxLayout(this, BoxLayout.X_AXIS));
        updateSelectedBorder();
        setBackground(backgroundColor);
        // Create worldField & color it based off curWorld
        JPanel worldField = buildWorldField(curWorld);
        worldField.setPreferredSize(new Dimension(ShootingStarPanel.WORLD_WIDTH, 20));
        worldField.addMouseListener(createMouseOptions(starData, backgroundColor));
        worldField.setOpaque(false);
        add(worldField);
        // Create tierField & color it based off hasRequirements
        JPanel tierField = buildTierField();
        tierField.setPreferredSize(new Dimension(ShootingStarPanel.TIER_WIDTH, 20));
        tierField.addMouseListener(createMouseOptions(starData, backgroundColor));
        tierField.setOpaque(false);
        add(tierField);
        // Create locationField using ShootingStarLocation ShortName
        JPanel locationField = buildLocationField();
        locationField.setPreferredSize(new Dimension(ShootingStarPanel.LOCATION_WIDTH, 20));
        locationField.setToolTipText(starData.getShootingStarLocation().getRawLocationName());
        locationField.addMouseListener(createMouseOptions(starData, backgroundColor));
        locationField.setInheritsPopupMenu(true);
        this.setInheritsPopupMenu(true);
        locationField.setOpaque(false);
        add(locationField);
        // Create timeLeftField using time data
        JPanel timeLeftField = buildTimeField();
        timeLeftField.setPreferredSize(new Dimension(ShootingStarPanel.TIME_WIDTH, 20));
        timeLeftField.setOpaque(false);
        add(timeLeftField);
    }
    public static String convertTime(long epoch) {
        long seconds = TimeUnit.MILLISECONDS.toSeconds(epoch - Instant.now().toEpochMilli());
        boolean negative = seconds < 0;
        seconds = Math.abs(seconds);
        String time = negative ? "-" : "";
        long minutes = seconds / 60;
        seconds %= 60;
        if (minutes >= 100) {
            time += minutes + "m";
        } else {
            time += String.format("%d:%02d", minutes, seconds);
        }
        return time;
    }
    private MouseAdapter createMouseOptions(Star starData, Color backgroundColor) {
        return new MouseAdapter() {
            @Override
            public void mouseEntered(MouseEvent e) {
                setBackground(getBackground().brighter());
            }
            @Override
            public void mouseExited(MouseEvent e) {
                setBackground(backgroundColor);
            }
            @Override
            public void mouseClicked(MouseEvent e) {
                // double click row hops to world
                if (e.getClickCount() == 2 && SwingUtilities.isLeftMouseButton(e)) {
                    Microbot.hopToWorld(starData.getWorldObject().getId());
                }
            }
        };
    }
    private JPanel buildWorldField(int world) {
        JPanel panel = new JPanel(new BorderLayout(7, 0));
        panel.setBorder(new EmptyBorder(0, 5, 0, 5));
        JLabel worldLabel = new JLabel(Integer.toString(starData.getWorldObject().getId()));
        worldLabel.setFont(FontManager.getRunescapeSmallFont());
        worldLabel.setForeground(worldColor(world));
        panel.add(worldLabel);
        return panel;
    }
    private Color worldColor(int curWorld) {
        if (starData.getWorldObject().getId() == curWorld) {
            return BRAND_ORANGE;
        }
        return TEXT_COLOR;
    }
    private JPanel buildTierField() {
        JPanel panel = new JPanel(new BorderLayout(4, 0));
        panel.setBorder(new EmptyBorder(0, 5, 0, 5));
        tierLabel = new JLabel(Integer.toString(starData.getTier()));
        tierLabel.setFont(FontManager.getRunescapeSmallFont());
        updateTierColor();
        panel.add(tierLabel);
        return panel;
    }
    public void updateTierColor() {
        tierLabel.setForeground(tierColor());
    }
    private Color tierColor() {
        if (starData.hasMiningLevel()) {
            return TEXT_COLOR;
        }
        return COLOR_NEGATIVE;
    }
    private JPanel buildLocationField() {
        JPanel panel = new JPanel(new BorderLayout(7, 0));
        panel.setBorder(new EmptyBorder(0, 5, 0, 5));
        locationLabel = new JLabel(starData.getShootingStarLocation().getLocationName());
        locationLabel.setFont(FontManager.getRunescapeSmallFont());
        updateLocationColor();
        panel.add(locationLabel);
        return panel;
    }
    public void updateLocationColor() {
        locationLabel.setForeground(getLocationColor());
    }
    private Color getLocationColor() {
        long time = ZonedDateTime.now(utcZoneId).toInstant().toEpochMilli();
        boolean minimumPassed = time > starData.getCalledAt();
        boolean maximumPassed = time > starData.getEndsAt();
        if (maximumPassed && minimumPassed) {
            return ColorScheme.PROGRESS_COMPLETE_COLOR;
        }
        if (!starData.hasLocationRequirements()) {
            return COLOR_NEGATIVE;
        }
        return TEXT_COLOR;
    }
    private JPanel buildTimeField() {
        JPanel panel = new JPanel(new BorderLayout(7, 0));
        panel.setBorder(new EmptyBorder(0, 5, 0, 5));
        timeLeftLabel = new JLabel();
        timeLeftLabel.setFont(FontManager.getRunescapeSmallFont());
        panel.add(timeLeftLabel);
        updateTime();
        return panel;
    }
    public void updateTime() {
        String endTime;
        if (displayAsMinutes) {
            endTime = convertTime(starData.getEndsAt());
        } else {
            Instant endInstant = Instant.ofEpochMilli(starData.getEndsAt());
            endTime = LocalDateTime.ofInstant(endInstant, ZoneId.systemDefault()).format(dtf);
        }
        timeLeftLabel.setText(endTime);
        timeLeftLabel.setForeground(getTimeColor(starData.getEndsAt()));
    }
    private Color getTimeColor(long time) {
        if (time < ZonedDateTime.now(utcZoneId).toInstant().toEpochMilli()) {
            return COLOR_NEGATIVE;
        }
        return TEXT_COLOR;
    }
    public void updateSelectedBorder() {
        if (starData.isSelected())
            setBorder(new LineBorder(BRAND_ORANGE, 1));
        else
            setBorder(new EmptyBorder(1, 1, 1, 1));
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/shootingstar/model/Star.java
================
package net.runelite.client.plugins.microbot.mining.shootingstar.model;
import com.google.gson.annotations.SerializedName;
import lombok.AllArgsConstructor;
import lombok.Data;
import net.runelite.api.ObjectID;
import net.runelite.api.Skill;
import net.runelite.api.Varbits;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.mining.shootingstar.enums.ShootingStarLocation;
import net.runelite.client.plugins.microbot.util.equipment.Rs2Equipment;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.http.api.worlds.World;
import net.runelite.http.api.worlds.WorldType;
@Data
@AllArgsConstructor
public class Star {
    private long calledAt;
    @SerializedName("estimatedEnd")
    private long endsAt;
    private int world;
    private World worldObject;
    private Object locationKey;
    private String rawLocation;
    private ShootingStarLocation shootingStarLocation;
    private int tier;
    private transient boolean selected;
    private int objectID;
    private int miningLevel;
    public boolean hasRequirements() {
        return this.hasLocationRequirements() && this.hasMiningLevel();
    }
    public boolean hasMiningLevel() {
        return Rs2Player.getSkillRequirement(Skill.MINING, this.miningLevel, true);
    }
    public boolean hasLocationRequirements() {
        return this.shootingStarLocation.hasRequirements();
    }
    public boolean isInWilderness() {
        return this.shootingStarLocation.isInWilderness();
    }
    public int getRequiredMiningLevel() {
        switch (this.tier) {
            case 1: return 10;
            case 2: return 20;
            case 3: return 30;
            case 4: return 40;
            case 5: return 50;
            case 6: return 60;
            case 7: return 70;
            case 8: return 80;
            case 9: return 90;
            default: return -1;
        }
    }
    public int getObjectIDBasedOnTier() {
        switch (this.tier) {
            case 1: return ObjectID.CRASHED_STAR_41229;
            case 2: return ObjectID.CRASHED_STAR_41228;
            case 3: return ObjectID.CRASHED_STAR_41227;
            case 4: return ObjectID.CRASHED_STAR_41226;
            case 5: return ObjectID.CRASHED_STAR_41225;
            case 6: return ObjectID.CRASHED_STAR_41224;
            case 7: return ObjectID.CRASHED_STAR_41223;
            case 8: return ObjectID.CRASHED_STAR_41021;
            case 9: return ObjectID.CRASHED_STAR;
            default: return -1;
        }
    }
    public int getTierBasedOnObjectID() {
        switch (this.objectID) {
            case ObjectID.CRASHED_STAR_41229: return 1;
            case ObjectID.CRASHED_STAR_41228: return 2;
            case ObjectID.CRASHED_STAR_41227: return 3;
            case ObjectID.CRASHED_STAR_41226: return 4;
            case ObjectID.CRASHED_STAR_41225: return 5;
            case ObjectID.CRASHED_STAR_41224: return 6;
            case ObjectID.CRASHED_STAR_41223: return 7;
            case ObjectID.CRASHED_STAR_41021: return 8;
            case ObjectID.CRASHED_STAR: return 9;
            default: return -1;
        }
    }
    public boolean isGameModeWorld() {
        return this.getWorldObject().getTypes().contains(WorldType.PVP) ||
                this.getWorldObject().getTypes().contains(WorldType.HIGH_RISK) ||
                this.getWorldObject().getTypes().contains(WorldType.BOUNTY) ||
                this.getWorldObject().getTypes().contains(WorldType.SKILL_TOTAL) ||
                this.getWorldObject().getTypes().contains(WorldType.LAST_MAN_STANDING) ||
                this.getWorldObject().getTypes().contains(WorldType.QUEST_SPEEDRUNNING) ||
                this.getWorldObject().getTypes().contains(WorldType.BETA_WORLD) ||
                this.getWorldObject().getTypes().contains(WorldType.DEADMAN) ||
                this.getWorldObject().getTypes().contains(WorldType.PVP_ARENA) ||
                this.getWorldObject().getTypes().contains(WorldType.TOURNAMENT) ||
                this.getWorldObject().getTypes().contains(WorldType.FRESH_START_WORLD);
    }
    public boolean isMemberWorld() {
        return !this.isGameModeWorld() && this.getWorldObject().getTypes().contains(WorldType.MEMBERS);
    }
    public boolean isF2PWorld() {
        return !this.isGameModeWorld() && !this.getWorldObject().getTypes().contains(WorldType.MEMBERS);
    }
    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Star other = (Star) obj;
        return this.getWorld() == other.getWorld() && this.getShootingStarLocation().equals(other.getShootingStarLocation());
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/shootingstar/ShootingStarConfig.java
================
package net.runelite.client.plugins.microbot.mining.shootingstar;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
@ConfigGroup(ShootingStarConfig.configGroup)
public interface ShootingStarConfig extends Config {
    String configGroup = "shooting-star";
    String displayAsMinutes = "displayAsMinutes";
    String hideF2PWorlds = "hideF2PWorlds";
    String hideMembersWorlds = "hideMembersWorlds";
    String hideWildernessLocations = "hideWildernessLocations";
    String useNearestHighTierStar = "useNearestHighTierStar";
    @ConfigSection(
            name = "",
            description = "",
            position = 0
    )
    String guideSection = "guide";
    @ConfigItem(
            keyName = "guide",
            name = "Guide",
            description = "",
            position = 0,
            section = guideSection
    )
    default String guide() {
        return "This plugin will assist in finding & traveling to shooting stars.\n" +
                "Start this plugin in any state & it will setup inventory, then travel based on configuration settings";
    }
    @ConfigSection(
            name = "General Settings",
            description = "Configure general plugin configuration & preferences",
            position = 1
    )
    String generalSection = "general";
    @ConfigItem(
            keyName = "inventorySetupName",
            name = "MInventorySetup Name",
            description = "Name of mInventory Setup for mining",
            position = 0,
            section = generalSection
    )
    default String inventorySetupName() {
        return "Shooting Star";
    }
    @ConfigItem(
            keyName = useNearestHighTierStar,
            name = "Use Nearest High Tier Star",
            description = "Toggles automatic mode - when enabled script will automatically check all stars within an acceptable tier range & find the closest star that has the highest tier",
            position = 2,
            section = generalSection
    )
    default boolean useNearestHighTierStar() {
        return false;
    }
    @ConfigSection(
            name = "Panel Settings",
            description = "Configure view settings within the panel",
            position = 1
    )
    String panelSection = "panel";
    @ConfigItem(
            keyName = hideMembersWorlds,
            name = "Hide Members Worlds",
            description = "Hide Members worlds inside of the panel",
            position = 0,
            section = panelSection
    )
    default boolean isHideMembersWorlds() {
        return false;
    }
    @ConfigItem(
            keyName = hideF2PWorlds,
            name = "Hide F2P Worlds",
            description = "Hide F2P worlds inside of the panel",
            position = 1,
            section = panelSection
    )
    default boolean isHideF2PWorlds() {
        return false;
    }
    @ConfigItem(
            keyName = hideWildernessLocations,
            name = "Hide Wilderness Locations",
            description = "Hide Wilderness locations inside of the panel",
            position = 2,
            section = panelSection
    )
    default boolean isHideWildernessLocations() {
        return true;
    }
    @ConfigItem(
            keyName = displayAsMinutes,
            name = "Display as Minutes",
            description = "Shows time left as minutes",
            position = 3,
            section = panelSection
    )
    default boolean isDisplayAsMinutes() {
        return false;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/shootingstar/ShootingStarOverlay.java
================
package net.runelite.client.plugins.microbot.mining.shootingstar;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import net.runelite.client.util.ColorUtil;
import javax.inject.Inject;
import java.awt.*;
public class ShootingStarOverlay extends OverlayPanel {
    @Inject
    ShootingStarOverlay(ShootingStarPlugin plugin)
    {
        super(plugin);
        setPosition(OverlayPosition.TOP_LEFT);
        setNaughty();
    }
    @Override
    public Dimension render(Graphics2D graphics) {
        try {
            panelComponent.setPreferredSize(new Dimension(200, 300));
            panelComponent.getChildren().add(TitleComponent.builder()
                    .text("ShootingStar Miner V" + ShootingStarPlugin.version)
                    .color(ColorUtil.fromHex("0077B6"))
                    .build());
            panelComponent.getChildren().add(LineComponent.builder().build());
            panelComponent.getChildren().add(LineComponent.builder()
                    .left(Microbot.status)
                    .build());
        } catch(Exception ex) {
            System.out.println(ex.getMessage());
        }
        return super.render(graphics);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/shootingstar/ShootingStarPanel.java
================
package net.runelite.client.plugins.microbot.mining.shootingstar;
import lombok.Getter;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.mining.shootingstar.model.ShootingStarTableHeader;
import net.runelite.client.plugins.microbot.mining.shootingstar.model.ShootingStarTableRow;
import net.runelite.client.plugins.microbot.mining.shootingstar.model.Star;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.ui.PluginPanel;
import com.google.common.collect.Ordering;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.SwingUtilities;
import net.runelite.client.ui.ColorScheme;
import net.runelite.client.ui.DynamicGridLayout;
import net.runelite.client.ui.FontManager;
import javax.swing.border.EmptyBorder;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.*;
import java.util.function.Function;
public class ShootingStarPanel extends PluginPanel {
    public static final int WORLD_WIDTH = 35;
    public static final int LOCATION_WIDTH = 125;
    public static final int TIER_WIDTH = 25;
    public static final int TIME_WIDTH = 70;
    private static final String SELECT_OPTION = "Select star";
    private static final String UNSELECT_OPTION = "Unselect Star";
    private final JPanel listContainer = new JPanel();
    private final ShootingStarPlugin plugin;
    private ShootingStarTableHeader worldHeader;
    private ShootingStarTableHeader locationHeader;
    private ShootingStarTableHeader tierHeader;
    private ShootingStarTableHeader timeLeftHeader;
    private Order orderIndex = Order.TIME_LEFT;
    private boolean ascendingOrder = false;
    @Getter
    private final List<Star> hiddenStars = new ArrayList<>();
    public ShootingStarPanel(ShootingStarPlugin plugin) {
        this.plugin = plugin;
        setBorder(null);
        setLayout(new DynamicGridLayout(0, 1));
        JPanel header = buildHeader();
        add(header, BorderLayout.NORTH);
        listContainer.setLayout(new BoxLayout(listContainer, BoxLayout.Y_AXIS));
        add(listContainer, BorderLayout.CENTER);
        JPanel buttons = new JPanel();
        buttons.setBorder(new EmptyBorder(5, 5, 5, 5));
        buttons.setLayout(new BoxLayout(buttons, BoxLayout.Y_AXIS));
        buttons.add(Box.createRigidArea(new Dimension(0, 5)));
        buttons.add(removeClipboardPanel());
        add(buttons);
    }
    private JPanel buildHeader() {
        JPanel header = new JPanel();
        header.setLayout(new BoxLayout(header, BoxLayout.X_AXIS));
        worldHeader = new ShootingStarTableHeader("W");
        worldHeader.setPreferredSize(new Dimension(WORLD_WIDTH, 20));
        worldHeader.addMouseListener(createHeaderMouseOptions(Order.WORLD));
        tierHeader = new ShootingStarTableHeader("T");
        tierHeader.setPreferredSize(new Dimension(TIER_WIDTH, 20));
        tierHeader.addMouseListener(createHeaderMouseOptions(Order.TIER));
        tierHeader.highlight(true, ascendingOrder);
        locationHeader = new ShootingStarTableHeader("Location");
        locationHeader.setPreferredSize(new Dimension(LOCATION_WIDTH, 20));
        locationHeader.addMouseListener(createHeaderMouseOptions(Order.LOCATION));
        timeLeftHeader = new ShootingStarTableHeader("Time Left");
        timeLeftHeader.setPreferredSize(new Dimension(TIME_WIDTH, 20));
        timeLeftHeader.addMouseListener(createHeaderMouseOptions(Order.TIME_LEFT));
        header.add(worldHeader);
        header.add(tierHeader);
        header.add(locationHeader);
        header.add(timeLeftHeader);
        return header;
    }
    private MouseAdapter createHeaderMouseOptions(Order order) {
        return new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                if (SwingUtilities.isRightMouseButton(e)) {
                    return;
                }
                ascendingOrder = orderIndex != order || !ascendingOrder;
                orderBy(order);
            }
        };
    }
    void updateList(List<Star> starData) {
        listContainer.removeAll();
        if (starData.isEmpty()) {
            JLabel noStarsLabel = new JLabel("Please wait for data to be fetched");
            noStarsLabel.setFont(FontManager.getRunescapeSmallFont());
            noStarsLabel.setBorder(new EmptyBorder(5, 5, 5, 5));
            listContainer.add(noStarsLabel);
        } else {
            starData.sort((r1, r2) ->
            {
                switch (orderIndex) {
                    case WORLD:
                        return getCompareValue(r1, r2, star -> star.getWorldObject().getId());
                    case LOCATION:
                        return getCompareValue(r1, r2, Star::getShootingStarLocation);
                    case TIER:
                        return getCompareValue(r1, r2, Star::getTier);
                    case TIME_LEFT:
                        return getCompareValue(r1, r2, Star::getEndsAt);
                    default:
                        return 0;
                }
            });
            int i = 0;
            for (Star data : starData) {
                if (hiddenStars.contains(data)) continue;
                Color backgroundColor = i % 2 == 0 ? ColorScheme.DARK_GRAY_COLOR : ColorScheme.DARKER_GRAY_COLOR;
                ShootingStarTableRow r = new ShootingStarTableRow(data, plugin.isDisplayAsMinutes(), backgroundColor, Rs2Player.getWorld());
                r.setComponentPopupMenu(buildPopupMenu(r, data));
                listContainer.add(r);
                i++;
            }
        }
        listContainer.revalidate();
        listContainer.repaint();
    }
    void refreshList(List<Star> starData) {
        if (starData.isEmpty()) {
            return;
        }
        for (Component component : listContainer.getComponents()) {
            ShootingStarTableRow r = (ShootingStarTableRow) component;
            r.updateTime();
            r.updateSelectedBorder();
            r.updateLocationColor();
            r.updateTierColor();
        }
        listContainer.repaint();
    }
    private JPopupMenu buildPopupMenu(ShootingStarTableRow row, Star star) {
        JPopupMenu popupMenu = new JPopupMenu();
        popupMenu.setBorder(new EmptyBorder(5, 5, 5, 5));
        JMenuItem hopEntryOption = new JMenuItem();
        hopEntryOption.setText("Hop to");
        hopEntryOption.setFont(FontManager.getRunescapeSmallFont());
        hopEntryOption.addActionListener(e -> Microbot.hopToWorld(star.getWorldObject().getId()));
        popupMenu.add(hopEntryOption);
        JMenuItem selectedEntryOption = new JMenuItem();
        if (star.isSelected()) {
            selectedEntryOption.setText(UNSELECT_OPTION);
        } else {
            selectedEntryOption.setText(SELECT_OPTION);
        }
        selectedEntryOption.setFont(FontManager.getRunescapeSmallFont());
        selectedEntryOption.addActionListener(e -> {
            if (star.isSelected()) {
                selectedEntryOption.setText(UNSELECT_OPTION);
            } else {
                selectedEntryOption.setText(SELECT_OPTION);
            }
            if (plugin.getSelectedStar() != null) {
                plugin.getSelectedStar().setSelected(false);
            }
            plugin.updateSelectedStar(star);
            row.updateSelectedBorder();
            selectedEntryOption.repaint();
        });
        popupMenu.add(selectedEntryOption);
        JMenuItem removeEntryOption = new JMenuItem();
        removeEntryOption.setText("Remove");
        removeEntryOption.setFont(FontManager.getRunescapeSmallFont());
        removeEntryOption.addActionListener(e -> {
            plugin.removeStar(star);
            plugin.updatePanelList(true);
        });
        popupMenu.add(removeEntryOption);
        return popupMenu;
    }
    private int getCompareValue(Star row1, Star row2, Function<Star, Comparable> compareFn) {
        Ordering<Comparable> ordering = Ordering.natural();
        if (!ascendingOrder) {
            ordering = ordering.reverse();
        }
        ordering = ordering.reverse();
        return ordering.compare(compareFn.apply(row1), compareFn.apply(row2));
    }
    private void orderBy(Order order) {
        worldHeader.highlight(false, ascendingOrder);
        locationHeader.highlight(false, ascendingOrder);
        tierHeader.highlight(false, ascendingOrder);
        timeLeftHeader.highlight(false, ascendingOrder);
        switch (order) {
            case WORLD:
                worldHeader.highlight(true, ascendingOrder);
                break;
            case LOCATION:
                locationHeader.highlight(true, ascendingOrder);
                break;
            case TIER:
                tierHeader.highlight(true, ascendingOrder);
                break;
            case TIME_LEFT:
                timeLeftHeader.highlight(true, ascendingOrder);
                break;
        }
        orderIndex = order;
        updateList(plugin.getStarList());
    }
    private JPanel removeClipboardPanel() {
        JPanel panel = new JPanel();
        JLabel label = new JLabel("Remove clipboard worlds");
        panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
        panel.setPreferredSize(new Dimension(60, 30));
        panel.addMouseListener(new MouseAdapter() {
            @Override
            public void mousePressed(MouseEvent e) {
                if (!SwingUtilities.isRightMouseButton(e)) {
                    plugin.removeWorldsInClipboard();
                }
            }
            @Override
            public void mouseEntered(MouseEvent e) {
                panel.setBackground(ColorScheme.DARKER_GRAY_HOVER_COLOR);
            }
            @Override
            public void mouseExited(MouseEvent e) {
                panel.setBackground(ColorScheme.DARKER_GRAY_COLOR);
            }
        });
        panel.add(label);
        return panel;
    }
    public void hideStars(List<Star> starList) {
        for (Star star : starList) {
            if (plugin.isHideMembersWorlds() && star.isMemberWorld()) {
                hiddenStars.add(star);
            }
            if (plugin.isHideF2PWorlds() && star.isF2PWorld()) {
                hiddenStars.add(star);
            }
            if (plugin.isHideWildernessLocations() && star.isInWilderness()) {
                hiddenStars.add(star);
            }
        }
    }
    public void showStars() {
        List<Star> starsToRemove = new ArrayList<>();
        for (Star star : hiddenStars) {
            if (!plugin.isHideMembersWorlds() && star.isMemberWorld()) {
                if (plugin.isHideF2PWorlds() && star.isF2PWorld()) continue;
                if (plugin.isHideWildernessLocations() && star.isInWilderness()) continue;
                starsToRemove.add(star);
            }
            if (!plugin.isHideF2PWorlds() && star.isF2PWorld()) {
                if (plugin.isHideMembersWorlds() && star.isMemberWorld()) continue;
                if (plugin.isHideWildernessLocations() && star.isInWilderness()) continue;
                starsToRemove.add(star);
            }
            if (!plugin.isHideWildernessLocations() && star.isInWilderness()) {
                if (plugin.isHideMembersWorlds() && star.isMemberWorld()) continue;
                if (plugin.isHideF2PWorlds() && star.isF2PWorld()) continue;
                starsToRemove.add(star);
            }
        }
        hiddenStars.removeAll(starsToRemove);
    }
    private enum Order {
        WORLD,
        LOCATION,
        TIER,
        TIME_LEFT
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/shootingstar/ShootingStarPlugin.java
================
package net.runelite.client.plugins.microbot.mining.shootingstar;
import com.google.gson.Gson;
import com.google.gson.JsonSyntaxException;
import com.google.gson.reflect.TypeToken;
import com.google.inject.Provides;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.GameState;
import net.runelite.api.Player;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.WorldService;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.mining.shootingstar.enums.ShootingStarLocation;
import net.runelite.client.plugins.microbot.mining.shootingstar.model.Star;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import net.runelite.http.api.worlds.World;
import net.runelite.http.api.worlds.WorldResult;
import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Type;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.util.*;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
@PluginDescriptor(
        name = PluginDescriptor.GZ + "ShootingStar",
        description = "Finds & Travels to shooting stars",
        tags = {"mining", "microbot", "skilling", "star", "shooting"},
        enabledByDefault = false
)
public class ShootingStarPlugin extends Plugin {
    private static final int TICKS_PER_MINUTE = 100;
    private static final int UPDATE_INTERVAL = 3;
    private static final ZoneId utcZoneId = ZoneId.of("UTC");
    public static String version = "1.0.0";
    @Getter
    public List<Star> starList = new ArrayList<>();
    @Inject
    ShootingStarScript shootingStarScript;
    private String httpEndpoint;
    private int apiTickCounter = 0;
    private int updateListTickCounter = 0;
    private int lastWorld;
    @Getter
    private boolean displayAsMinutes;
    @Getter
    private boolean hideMembersWorlds;
    @Getter
    private boolean hideF2PWorlds;
    @Getter
    private boolean hideWildernessLocations;
    private boolean useNearestHighTierStar;
    @Inject
    private WorldService worldService;
    @Inject
    private ShootingStarConfig config;
    @Inject
    private OverlayManager overlayManager;
    @Inject
    private ShootingStarOverlay shootingStarOverlay;
    @Inject
    private ClientToolbar clientToolbar;
    private NavigationButton navButton;
    private ShootingStarPanel panel;
    public void fetchStars() {
        // Create HTTP request to pull in StarData from API
        HttpClient httpClient = HttpClient.newHttpClient();
        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(httpEndpoint))
                .build();
        String jsonResponse = httpClient.sendAsync(request, HttpResponse.BodyHandlers.ofString())
                .thenApply(HttpResponse::body)
                .join();
        Gson gson = new Gson();
        Type listType = new TypeToken<List<Star>>() {}.getType();
        List<Star> starData = gson.fromJson(jsonResponse, listType);
        ZonedDateTime now = ZonedDateTime.now(utcZoneId);
        // Format starData into Star Model
        for (Star star : starData) {
            // Filter out stars that ended longer than three mintues ago to avoid adding really old stars
            if (star.getEndsAt() < now.minusMinutes(UPDATE_INTERVAL).toInstant().toEpochMilli()) continue;
            // Set ObjectID & MiningLevel based on Shooting Star Tier
            star.setObjectID(star.getObjectIDBasedOnTier());
            star.setMiningLevel(star.getRequiredMiningLevel());
            // Populate ShootingStarLocation based on locationKey & rawLocation
            ShootingStarLocation location = findLocation(star.getLocationKey().toString(), star.getRawLocation());
            if (location == null) {
                System.out.printf("No match found for location: %s - %s%n", star.getLocationKey(), star.getRawLocation());
                continue;
            }
            star.setShootingStarLocation(location);
            star.setWorldObject(findWorld(star.getWorld()));
            if (star.isGameModeWorld()) continue;
            addToList(star);
        }
        filterPanelList(hideWildernessLocations || hideMembersWorlds || hideF2PWorlds);
        updatePanelList(true);
    }
    private ShootingStarLocation findLocation(String locationKey, String rawLocation) {
        for (ShootingStarLocation location : ShootingStarLocation.values()) {
            boolean enumName = locationKey.equalsIgnoreCase(location.name());
            boolean locationString = rawLocation.equalsIgnoreCase(location.getRawLocationName()) || locationKey.equalsIgnoreCase(location.getShortLocationName());
            if (enumName || locationString) {
                return location;
            }
        }
        return null;
    }
    private World findWorld(int worldID) {
        WorldResult worldResult = worldService.getWorlds();
        if (worldResult == null) return null;
        return worldResult.findWorld(worldID);
    }
    private void addToList(Star data) {
        // Find oldStar inside of starList
        Star oldStar = starList.stream()
                .filter(star -> data.getWorld() == star.getWorld())
                .filter(star -> data.getShootingStarLocation().equals(star.getShootingStarLocation()))
                .findFirst()
                .orElse(null);
        // If there is an oldStar in the same world & location
        if (oldStar != null) {
            updateStarInList(oldStar, data);
            return;
        }
        // If oldStar not found, add new star into the list
        starList.add(data);
    }
    private void updateStarInList(Star oldStar, Star newStar) {
        oldStar.setTier(newStar.getTier());
        oldStar.setObjectID(oldStar.getObjectIDBasedOnTier());
        oldStar.setEndsAt(newStar.getEndsAt());
        oldStar.setMiningLevel(oldStar.getRequiredMiningLevel());
    }
    private void checkDepletedStars() {
        List<Star> stars = new ArrayList<>(starList);
        ZonedDateTime now = ZonedDateTime.now(utcZoneId);
        boolean fullUpdate = false;
        for (Star star : stars) {
            if (star.getEndsAt() < now.minusMinutes(UPDATE_INTERVAL).toInstant().toEpochMilli()) {
                removeStar(star);
                fullUpdate = true;
            }
        }
        updatePanelList(fullUpdate);
    }
    public void removeWorldsInClipboard() {
        try {
            final String clipboard = Toolkit.getDefaultToolkit().getSystemClipboard().getData(DataFlavor.stringFlavor).toString().trim();
            Matcher matcher = Pattern.compile("[wW]([3-5][0-9][0-9])").matcher(clipboard);
            Set<Integer> worlds = new HashSet<>();
            while (matcher.find()) {
                try {
                    worlds.add(Integer.parseInt(matcher.group(1)));
                } catch (NumberFormatException ignored) {
                }
            }
            if (worlds.isEmpty()) {
                Microbot.log("No worlds in format w451 found in clipboard.");
                return;
            }
            long timeNow = ZonedDateTime.now(utcZoneId).toInstant().toEpochMilli();
            // don't remove stars if it's impossible for them to have landed already.
            int sizeBefore = starList.size();
            starList.removeIf(s -> timeNow >= s.getCalledAt() && worlds.contains(s.getWorld()));
            int sizeAfter = starList.size();
            Microbot.log("Removed " + (sizeBefore - sizeAfter) + " worlds.");
        } catch (NumberFormatException | IOException | UnsupportedFlavorException | JsonSyntaxException ex) {
            Microbot.log(ex.getMessage());
            return;
        }
        updatePanelList(true);
    }
    @Provides
    ShootingStarConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(ShootingStarConfig.class);
    }
    @Override
    protected void startUp() throws AWTException {
        displayAsMinutes = config.isDisplayAsMinutes();
        hideMembersWorlds = config.isHideMembersWorlds();
        hideF2PWorlds = config.isHideF2PWorlds();
        useNearestHighTierStar = config.useNearestHighTierStar();
        hideWildernessLocations = config.isHideWildernessLocations();
        try {
            loadUrlFromProperties();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        fetchStars();
        createPanel();
        SwingUtilities.invokeLater(() -> panel.hideStars(starList));
        if (overlayManager != null) {
            overlayManager.add(shootingStarOverlay);
        }
        shootingStarScript.run(config);
    }
    protected void shutDown() {
        shootingStarScript.shutdown();
        removePanel();
        starList.clear();
        overlayManager.remove(shootingStarOverlay);
    }
    @Subscribe
    public void onConfigChanged(final ConfigChanged event) {
        if (!event.getGroup().equals(ShootingStarConfig.configGroup)) {
            return;
        }
        if (event.getKey().equals(ShootingStarConfig.displayAsMinutes)) {
            displayAsMinutes = config.isDisplayAsMinutes();
            updatePanelList(true);
        }
        if (event.getKey().equals(ShootingStarConfig.hideMembersWorlds)) {
            hideMembersWorlds = config.isHideMembersWorlds();
            filterPanelList(hideMembersWorlds);
            updatePanelList(true);
        }
        if (event.getKey().equals(ShootingStarConfig.hideF2PWorlds)) {
            hideF2PWorlds = config.isHideF2PWorlds();
            filterPanelList(hideF2PWorlds);
            updatePanelList(true);
        }
        if (event.getKey().equals(ShootingStarConfig.hideWildernessLocations)) {
            hideWildernessLocations = config.isHideWildernessLocations();
            filterPanelList(hideWildernessLocations);
            updatePanelList(true);
        }
        if (event.getKey().equals(ShootingStarConfig.useNearestHighTierStar)) {
            useNearestHighTierStar = config.useNearestHighTierStar();
        }
    }
    @Subscribe
    public void onGameTick(GameTick event) {
        if (!Microbot.isLoggedIn()) return;
        if (updateListTickCounter >= TICKS_PER_MINUTE) {
            checkDepletedStars();
            updateListTickCounter = 0;
        }
        if (apiTickCounter >= (TICKS_PER_MINUTE * UPDATE_INTERVAL)) {
            fetchStars();
            apiTickCounter = 0;
        }
        updateListTickCounter++;
        apiTickCounter++;
    }
    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        if (event.getGameState() == GameState.LOGGED_IN && Microbot.getClient().getWorld() != lastWorld) {
            lastWorld = Microbot.getClient().getWorld();
            updatePanelList(true);
        }
    }
    private void createPanel() {
        if (panel == null) {
            panel = new ShootingStarPanel(this);
            final BufferedImage icon = ImageUtil.loadImageResource(ShootingStarPlugin.class, "icon.png");
            navButton = NavigationButton.builder()
                    .tooltip("Shooting Stars")
                    .icon(icon)
                    .priority(7)
                    .panel(panel)
                    .build();
            clientToolbar.addNavigation(navButton);
        }
    }
    private void removePanel() {
        clientToolbar.removeNavigation(navButton);
        navButton = null;
        panel = null;
    }
    public Star getClosestHighestTierStar() {
        // Get the highest tier available
        int highestTier = starList.stream()
                .filter(Star::hasRequirements)
                .filter(s -> panel.getHiddenStars().stream().noneMatch(h -> h.equals(s)))
                .mapToInt(Star::getTier)
                .max()
                .orElse(-1);  // Return -1 if no star meets the requirements
        // If no star meets the requirements, return null
        if (highestTier == -1) {
            return null;
        }
        int minTier = Math.max(1, highestTier - 2); // The lowest tier to consider (at least 1)
        int maxTier = Math.min(9, highestTier + 1); // The highest tier to consider (up to 9)
        Map<Integer, List<Star>> distanceMap = new HashMap<>();
        // Iterate through all stars and categorize them by distance
        for (Star star : starList) {
            if (panel.getHiddenStars().stream().anyMatch(h -> h.equals(star))) continue;
            if (!star.hasRequirements()) continue;
            int starTier = star.getTier();
            if (starTier >= minTier && starTier <= maxTier) {
                WorldPoint starLocation = ShootingStarLocation.valueOf(star.getShootingStarLocation().name()).getWorldPoint();
                // Check if the star's location is already in the distanceMap
                Integer existingDistance = distanceMap.entrySet().stream()
                        .filter(entry -> entry.getValue().stream()
                                .anyMatch(s -> ShootingStarLocation.valueOf(s.getShootingStarLocation().name()).getWorldPoint().equals(starLocation)))
                        .map(Map.Entry::getKey)
                        .findFirst()
                        .orElse(null);
                // Set distance to the distance that is found in the map for the duplicate location or calculate shortest distance if not found
                int distance;
                distance = Objects.requireNonNullElseGet(existingDistance, () -> Rs2Player.distanceTo(starLocation));
                distanceMap.computeIfAbsent(distance, k -> new ArrayList<>()).add(star);
            }
        }
        // Find the closest stars
        Optional<Integer> closestDistanceOpt = distanceMap.keySet().stream().min(Integer::compare);
        if (closestDistanceOpt.isPresent()) {
            List<Star> closestStars = distanceMap.get(closestDistanceOpt.get());
            // Return the highest-tiered star among the closest ones
            return closestStars.stream()
                    .max(Comparator.comparingInt(Star::getTier))
                    .orElse(null);
        }
        // If no star is found
        return null;
    }
    public boolean useNearestHighTierStar() {
        return useNearestHighTierStar;
    }
    public void removeStar(Star star) {
        if (star.equals(getSelectedStar()))
            star.setSelected(false);
        starList.remove(star);
        panel.getHiddenStars().remove(star);
    }
    public void updateSelectedStar(Star star) {
        if (getSelectedStar() != null) {
            Star oldStar = getSelectedStar();
            oldStar.setSelected(false);
        }
        star.setSelected(!star.isSelected());
    }
    private void filterPanelList(boolean toggle) {
        List<Star> stars = new ArrayList<>(starList);
        if (toggle) {
            SwingUtilities.invokeLater(() -> panel.hideStars(stars));
        } else {
            SwingUtilities.invokeLater(() -> panel.showStars());
        }
    }
    public void updatePanelList(boolean fullUpdate) {
        List<Star> stars = new ArrayList<>(starList);
        if (fullUpdate) {
            SwingUtilities.invokeLater(() -> panel.updateList(stars));
        } else {
            SwingUtilities.invokeLater(() -> panel.refreshList(stars));
        }
    }
    public Star getSelectedStar() {
        return starList.stream().filter(Star::isSelected).findFirst().orElse(null);
    }
    private void loadUrlFromProperties() throws IOException {
        Properties properties = new Properties();
        try (InputStream input = ShootingStarPlugin.class.getResourceAsStream("shootingstar.properties")) {
            if (input == null) {
                System.out.println("unable to load shootingstar.properties");
                return;
            }
            properties.load(input);
            httpEndpoint = properties.getProperty("microbot.shootingstar.http");
        }
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/shootingstar/ShootingStarScript.java
================
package net.runelite.client.plugins.microbot.mining.shootingstar;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.inventorysetups.MInventorySetupsPlugin;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.Script;
import net.runelite.client.plugins.microbot.mining.shootingstar.enums.Pickaxe;
import net.runelite.client.plugins.microbot.mining.shootingstar.enums.ShootingStarState;
import net.runelite.client.plugins.microbot.mining.shootingstar.model.Star;
import net.runelite.client.plugins.microbot.util.Rs2InventorySetup;
import net.runelite.client.plugins.microbot.util.antiban.Rs2Antiban;
import net.runelite.client.plugins.microbot.util.antiban.Rs2AntibanSettings;
import net.runelite.client.plugins.microbot.util.antiban.enums.Activity;
import net.runelite.client.plugins.microbot.util.bank.Rs2Bank;
import net.runelite.client.plugins.microbot.util.combat.Rs2Combat;
import net.runelite.client.plugins.microbot.util.equipment.Rs2Equipment;
import net.runelite.client.plugins.microbot.util.gameobject.Rs2GameObject;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Item;
import net.runelite.client.plugins.microbot.util.math.Random;
import net.runelite.client.plugins.microbot.util.math.Rs2Random;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.microbot.util.tile.Rs2Tile;
import net.runelite.client.plugins.microbot.util.walker.Rs2Walker;
import javax.inject.Inject;
import java.util.*;
import java.util.concurrent.TimeUnit;
public class ShootingStarScript extends Script {
    private final ShootingStarPlugin plugin;
    Rs2InventorySetup rs2InventorySetup;
    Pickaxe pickaxe;
    ShootingStarState state;
    Star star;
    private boolean hasEquipment = false;
    private boolean hasInventory = false;
    @Inject
    public ShootingStarScript(ShootingStarPlugin plugin) {
        this.plugin = plugin;
    }
    public boolean run(ShootingStarConfig config) {
        Microbot.enableAutoRunOn = false;
        initialPlayerLocation = null;
        hasEquipment = false;
        hasInventory = false;
        Rs2Antiban.resetAntibanSettings();
        applyAntiBanSettings();
        Rs2Antiban.setActivity(Activity.GENERAL_MINING);
        mainScheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(() -> {
            try {
                if (!Microbot.isLoggedIn()) return;
                if (!super.run()) return;
                long startTime = System.currentTimeMillis();
                if (initialPlayerLocation == null) {
                    initialPlayerLocation = Rs2Player.getWorldLocation();
                }
                if (hasStateChanged()) {
                    state = updateStarState(config);
                }
                if (state == null) {
                    Microbot.showMessage("Unable to evaluate state");
                    shutdown();
                    return;
                }
                if (Rs2AntibanSettings.actionCooldownActive) return;
                if (Rs2Player.isMoving() || Rs2Antiban.getCategory().isBusy() || Microbot.pauseAllScripts) return;
                switch (state) {
                    case WAITING_FOR_STAR:
                        if (plugin.useNearestHighTierStar()) {
                            star = plugin.getClosestHighestTierStar();
                            if (star == null) {
                                Microbot.showMessage("Unable to find a star within your tier range. Consider disabling useNearestHighTierStar until higher mining level.");
                                shutdown();
                                return;
                            }
                            plugin.updateSelectedStar(star);
                        } else {
                            star = plugin.getSelectedStar();
                            if (!checkSelectedStar()) {
                                Microbot.log("Please select a star inside of the panel to start the script.");
                                sleepUntil(this::checkSelectedStar);
                                return;
                            }
                        }
                        state = ShootingStarState.WALKING;
                        break;
                    case WALKING:
                        if (Rs2Player.getWorld() != star.getWorldObject().getId()) {
                            Microbot.hopToWorld(star.getWorldObject().getId());
                            sleepUntil(() -> Microbot.getClient().getGameState() == GameState.LOGGED_IN);
                            return;
                        }
                        boolean isNearShootingStar = Rs2Player.getWorldLocation().distanceTo(star.getShootingStarLocation().getWorldPoint()) < 6;
                        if (!isNearShootingStar) {
                            Rs2Walker.walkTo(star.getShootingStarLocation().getWorldPoint(), 6);
                            return;
                        }
                        initialPlayerLocation = Rs2Player.getWorldLocation();
                        state = ShootingStarState.MINING;
                        break;
                    case MINING:
                        if (!star.hasRequirements()) {
                            Microbot.status = "Waiting for star to degrade";
                            Microbot.log("Unable to mine current star level, waiting..");
                            return;
                        }
                        if (Rs2Inventory.isFull()) {
                            state = ShootingStarState.BANKING;
                            return;
                        }
                        if (Rs2Equipment.isWearing("Dragon pickaxe"))
                            Rs2Combat.setSpecState(true, 1000);
                        GameObject starObject = (GameObject) Rs2GameObject.findObjectById(star.getObjectID());
                        if (starObject != null) {
                            Rs2GameObject.interact(starObject, "mine");
                            Rs2Antiban.actionCooldown();
                        }
                        break;
                    case BANKING:
                        boolean isBankOpen = Rs2Bank.walkToBankAndUseBank();
                        if (!isBankOpen || !Rs2Bank.isOpen()) return;
                        if (Rs2Inventory.hasItem("uncut")) {
                            Rs2Bank.depositAll(x -> x.name.toLowerCase().contains("uncut"));
                        }
                        if (isUsingInventorySetup(config)) {
                            if (!hasEquipment) {
                                hasEquipment = rs2InventorySetup.loadEquipment();
                                Rs2Random.wait(800, 1200);
                            }
                            if (!hasInventory && rs2InventorySetup.doesEquipmentMatch()) {
                                hasInventory = rs2InventorySetup.loadInventory();
                                Rs2Random.wait(800, 1200);
                            }
                            if (!hasEquipment || !hasInventory) return;
                        } else {
                            if (pickaxe == null) {
                                pickaxe = getBestPickaxe(Rs2Bank.bankItems());
                                if (pickaxe != null) {
                                    Rs2Bank.withdrawItem(pickaxe.getItemName());
                                    Rs2Random.wait(800, 1200);
                                } else {
                                    Microbot.showMessage("Unable to find pickaxe, please purchase a pickaxe");
                                    shutdown();
                                    return;
                                }
                            }
                        }
                        boolean bankClosed = Rs2Bank.closeBank();
                        if (!bankClosed || Rs2Bank.isOpen()) return;
                        if (checkSelectedStar()) {
                            if (!star.equals(plugin.getSelectedStar()))
                                return;
                            state = ShootingStarState.WALKING;
                            return;
                        }
                        state = ShootingStarState.WAITING_FOR_STAR;
                        break;
                }
                long endTime = System.currentTimeMillis();
                long totalTime = endTime - startTime;
                System.out.println("Total time for loop " + totalTime);
            } catch (Exception ex) {
                Microbot.log(ex.getMessage());
            }
        }, 0, 600, TimeUnit.MILLISECONDS);
        return true;
    }
    @Override
    public void shutdown() {
        super.shutdown();
        state = null;
        star = null;
        pickaxe = null;
        Rs2Antiban.resetAntibanSettings();
    }
    private boolean isUsingInventorySetup(ShootingStarConfig config) {
        boolean isInventorySetupPluginEnabled = Microbot.isPluginEnabled(MInventorySetupsPlugin.class);
        boolean hasInventorySetupConfigured = MInventorySetupsPlugin.getInventorySetups().stream().anyMatch(x -> x.getName().equalsIgnoreCase(config.inventorySetupName()));
        return isInventorySetupPluginEnabled && hasInventorySetupConfigured;
    }
    private boolean checkSelectedStar() {
        return plugin.getSelectedStar() != null;
    }
    public boolean shouldBank(ShootingStarConfig config) {
        if (isUsingInventorySetup(config)) {
            hasEquipment = rs2InventorySetup.doesEquipmentMatch();
            hasInventory = rs2InventorySetup.doesInventoryMatch();
            System.out.printf("hasEquipment %s%nhasInventory %s%n", hasEquipment, hasInventory);
            return (!hasEquipment || !hasInventory) || Rs2Inventory.isFull();
        }
        return pickaxe == null || Rs2Inventory.isFull();
    }
    public ShootingStarState getState(ShootingStarConfig config) {
        if (shouldBank(config)) {
            return ShootingStarState.BANKING;
        }
        if (checkSelectedStar()) {
            return ShootingStarState.WALKING;
        }
        return ShootingStarState.WAITING_FOR_STAR;
    }
    private ShootingStarState updateStarState(ShootingStarConfig config) {
        if (state == null) {
            if (isUsingInventorySetup(config)) {
                rs2InventorySetup = new Rs2InventorySetup(config.inventorySetupName(), mainScheduledFuture);
                if (!rs2InventorySetup.hasSpellBook()) {
                    Microbot.showMessage("Your spellbook is not matching the inventory setup.");
                    shutdown();
                    return null;
                }
            } else {
                if (Rs2Inventory.hasItem("pickaxe") || Rs2Equipment.isWearing("pickaxe")) {
                    pickaxe = getBestPickaxe(Rs2Equipment.items());
                    if (pickaxe == null) {
                        pickaxe = getBestPickaxe(Rs2Inventory.items());
                    }
                }
            }
            return getState(config);
        }
        Star selectedStar = plugin.getSelectedStar();
        if (selectedStar == null) {
            if (shouldBank(config)) {
                return ShootingStarState.BANKING;
            }
            return ShootingStarState.WAITING_FOR_STAR;
        }
        if (!star.equals(selectedStar)) {
            star = selectedStar;
            if (state == ShootingStarState.MINING) {
                WorldPoint randomNearestWalkableTile = getNearestWalkableTile(1);
                Rs2Walker.walkFastCanvas(randomNearestWalkableTile);
            }
            if (state == ShootingStarState.WALKING) {
                Rs2Walker.setTarget(null);
                Rs2Player.waitForWalking();
            }
            return ShootingStarState.WALKING;
        }
        if (state == ShootingStarState.MINING) {
            GameObject starObject = Rs2GameObject.findObject("crashed star", false, 10, false, initialPlayerLocation);
            if (star == null || starObject == null) {
                plugin.removeStar(plugin.getSelectedStar());
                plugin.updatePanelList(true);
                if (shouldBank(config)) {
                    return ShootingStarState.BANKING;
                }
                return ShootingStarState.WAITING_FOR_STAR;
            }
            star.setObjectID(starObject.getId());
            star.setTier(star.getTierBasedOnObjectID());
            star.setMiningLevel(star.getRequiredMiningLevel());
        }
        return ShootingStarState.MINING;
    }
    private boolean hasStateChanged() {
        // If no state (on plugin start)
        if (state == null) return true;
        // If waiting for star or if you are returning to bank & no selected star, no state change (mainly for manual mode, but also to allow waiting for star to run)
        if (state == ShootingStarState.WAITING_FOR_STAR || (state == ShootingStarState.BANKING && plugin.getSelectedStar() == null))
            return false;
        // If you are walking or mining a star & the star becomes null
        if (plugin.getSelectedStar() == null) return true;
        // If the instance of the current star in the script does not equal the selected star in the plugin (only based on world & location)
        if (!star.equals(plugin.getSelectedStar())) return true;
        // If the state is mining state, scan the crashed star game object & check if the game object id has updated.
        if (state == ShootingStarState.MINING) {
            GameObject starObject = Rs2GameObject.findObject("crashed star", false, 10, false, initialPlayerLocation);
            return hasStarGameObjectChanged(starObject);
        }
        return false;
    }
    private boolean hasStarGameObjectChanged(GameObject starObject) {
        // If the GameObject does not exist anymore
        if (starObject == null) return true;
        // If the GameObject has updated to a new tier
        return star.getObjectID() != starObject.getId();
    }
    private WorldPoint getNearestWalkableTile(int distance) {
        List<WorldPoint> worldPoints = Rs2Tile.getWalkableTilesAroundPlayer(distance);
        WorldPoint playerLocation = Rs2Player.getWorldLocation();
        // Create a map to group tiles by their distance from the player
        Map<Integer, List<WorldPoint>> distanceMap = new HashMap<>();
        for (WorldPoint walkablePoint : worldPoints) {
            int tileDistance = playerLocation.distanceTo(walkablePoint);
            distanceMap.computeIfAbsent(tileDistance, k -> new ArrayList<>()).add(walkablePoint);
        }
        // Find the minimum distance that has walkable points
        Optional<Integer> minDistanceOpt = distanceMap.keySet().stream().min(Integer::compare);
        if (minDistanceOpt.isPresent()) {
            List<WorldPoint> closestPoints = distanceMap.get(minDistanceOpt.get());
            // Return a random point from the closest points
            if (!closestPoints.isEmpty()) {
                int randomIndex = Random.random(0, closestPoints.size());
                return closestPoints.get(randomIndex);
            }
        }
        // Recursively increase the distance if no valid point is found
        return getNearestWalkableTile(distance + 1);
    }
    public Pickaxe getBestPickaxe(List<Rs2Item> items) {
        Pickaxe bestPickaxe = null;
        for (Pickaxe pickaxe : Pickaxe.values()) {
            if (items.stream().noneMatch(i -> i.name.toLowerCase().contains(pickaxe.getItemName()))) continue;
            if (pickaxe.hasRequirements()) {
                if (bestPickaxe == null || pickaxe.getMiningLevel() > bestPickaxe.getMiningLevel()) {
                    bestPickaxe = pickaxe;
                }
            }
        }
        return bestPickaxe;
    }
    private void applyAntiBanSettings() {
        Rs2AntibanSettings.antibanEnabled = true;
        Rs2AntibanSettings.usePlayStyle = true;
        Rs2AntibanSettings.simulateFatigue = true;
        Rs2AntibanSettings.simulateAttentionSpan = true;
        Rs2AntibanSettings.behavioralVariability = true;
        Rs2AntibanSettings.nonLinearIntervals = true;
        Rs2AntibanSettings.naturalMouse = true;
        Rs2AntibanSettings.simulateMistakes = true;
        Rs2AntibanSettings.moveMouseOffScreen = true;
        Rs2AntibanSettings.contextualVariability = true;
        Rs2AntibanSettings.devDebug = false;
        Rs2AntibanSettings.playSchedule = true;
        Rs2AntibanSettings.actionCooldownChance = 0.35;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/AutoMiningConfig.java
================
package net.runelite.client.plugins.microbot.mining;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.plugins.microbot.mining.enums.Rocks;
@ConfigGroup("Mining")
public interface AutoMiningConfig extends Config {
    @ConfigSection(
            name = "General",
            description = "General",
            position = 0
    )
    String generalSection = "general";
    @ConfigItem(
            keyName = "Ore",
            name = "Ore",
            description = "Choose the ore",
            position = 0,
            section = generalSection
    )
    default Rocks ORE()
    {
        return Rocks.TIN;
    }
    @ConfigItem(
            keyName = "DistanceToStray",
            name = "Distance to Stray",
            description = "Set how far you can travel from your initial position in tiles",
            position = 2,
            section = generalSection
    )
    default int distanceToStray()
    {
        return 20;
    }
    @ConfigItem(
            keyName = "UseBank",
            name = "UseBank",
            description = "Use bank and walk back to original location",
            position = 3,
            section = generalSection
    )
    default boolean useBank()
    {
        return false;
    }
    @ConfigItem(
            keyName = "ItemsToBank",
            name = "Items to bank (Comma seperated)",
            description = "Items to bank",
            position = 4
    )
    default String itemsToBank() {
        return "ore";
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/AutoMiningOverlay.java
================
package net.runelite.client.plugins.microbot.mining;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import javax.inject.Inject;
import java.awt.*;
public class AutoMiningOverlay extends OverlayPanel {
    @Inject
    AutoMiningOverlay(AutoMiningPlugin plugin)
    {
        super(plugin);
        setPosition(OverlayPosition.TOP_LEFT);
        setNaughty();
    }
    @Override
    public Dimension render(Graphics2D graphics) {
        try {
            panelComponent.setPreferredSize(new Dimension(200, 300));
            panelComponent.getChildren().add(TitleComponent.builder()
                    .text("AutoMining Plugin V" + AutoMiningScript.version)
                    .color(Color.GREEN)
                    .build());
            panelComponent.getChildren().add(LineComponent.builder().build());
            panelComponent.getChildren().add(LineComponent.builder()
                    .left(Microbot.status)
                    .build());
        } catch(Exception ex) {
            System.out.println(ex.getMessage());
        }
        return super.render(graphics);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/AutoMiningPlugin.java
================
package net.runelite.client.plugins.microbot.mining;
import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import javax.inject.Inject;
import java.awt.*;
@PluginDescriptor(
        name = PluginDescriptor.Mocrosoft + "Auto Mining",
        description = "Mines and banks ores",
        tags = {"mining", "microbot", "skilling"},
        enabledByDefault = false
)
@Slf4j
public class AutoMiningPlugin extends Plugin {
    @Inject
    private AutoMiningConfig config;
    @Provides
    AutoMiningConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(AutoMiningConfig.class);
    }
    @Inject
    private OverlayManager overlayManager;
    @Inject
    private AutoMiningOverlay autoMiningOverlay;
    @Inject
    AutoMiningScript autoMiningScript;
    @Override
    protected void startUp() throws AWTException {
        if (overlayManager != null) {
            overlayManager.add(autoMiningOverlay);
        }
        autoMiningScript.run(config);
    }
    protected void shutDown() {
        autoMiningScript.shutdown();
        overlayManager.remove(autoMiningOverlay);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/mining/AutoMiningScript.java
================
package net.runelite.client.plugins.microbot.mining;
import net.runelite.api.GameObject;
import net.runelite.api.Skill;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.Script;
import net.runelite.client.plugins.microbot.util.antiban.Rs2Antiban;
import net.runelite.client.plugins.microbot.util.antiban.Rs2AntibanSettings;
import net.runelite.client.plugins.microbot.util.bank.Rs2Bank;
import net.runelite.client.plugins.microbot.util.combat.Rs2Combat;
import net.runelite.client.plugins.microbot.util.equipment.Rs2Equipment;
import net.runelite.client.plugins.microbot.util.gameobject.Rs2GameObject;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
enum State {
    MINING,
    RESETTING,
}
public class AutoMiningScript extends Script {
    public static String version = "1.4.2";
    State state = State.MINING;
    public boolean run(AutoMiningConfig config) {
        initialPlayerLocation = null;
        Rs2Antiban.resetAntibanSettings();
        Rs2Antiban.antibanSetupTemplates.applyMiningSetup();
        Rs2AntibanSettings.actionCooldownChance = 0.1;
        mainScheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(() -> {
            try {
                if (!super.run()) return;
                if (!Microbot.isLoggedIn()) return;
                if (Rs2AntibanSettings.actionCooldownActive) return;
                if (initialPlayerLocation == null) {
                    initialPlayerLocation = Rs2Player.getWorldLocation();
                }
                if (!config.ORE().hasRequiredLevel()) {
                    Microbot.log("You do not have the required mining level to mine this ore.");
                    return;
                }
                if (Rs2Equipment.isWearing("Dragon pickaxe"))
                    Rs2Combat.setSpecState(true, 1000);
                if (Rs2Player.isMoving() || Rs2Player.isAnimating() || Microbot.pauseAllScripts) return;
                switch (state) {
                    case MINING:
                        if (Rs2Inventory.isFull()) {
                            state = State.RESETTING;
                            return;
                        }
                        GameObject rock = Rs2GameObject.findObject(config.ORE().getName(), true, config.distanceToStray(), true, initialPlayerLocation);
                        if (rock != null) {
                            if (Rs2GameObject.interact(rock)) {
                                Rs2Player.waitForXpDrop(Skill.MINING, true);
                                Rs2Antiban.actionCooldown();
                                Rs2Antiban.takeMicroBreakByChance();
                            }
                        }
                        break;
                    case RESETTING:
                        List<String> itemNames = Arrays.stream(config.itemsToBank().split(",")).map(String::toLowerCase).collect(Collectors.toList());
                        if (config.useBank()) {
                            if (!Rs2Bank.bankItemsAndWalkBackToOriginalPosition(itemNames, initialPlayerLocation, 0, config.distanceToStray()))
                                return;
                        } else {
                            Rs2Inventory.dropAllExcept("pickaxe");
                        }
                        state = State.MINING;
                        break;
                }
            } catch (Exception ex) {
                Microbot.log(ex.getMessage());
            }
        }, 0, 100, TimeUnit.MILLISECONDS);
        return true;
    }
    @Override
    public void shutdown(){
        super.shutdown();
        Rs2Antiban.resetAntibanSettings();
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/wintertodt/enums/Brazier.java
================
package net.runelite.client.plugins.microbot.wintertodt.enums;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;
@AllArgsConstructor
public enum Brazier {
    SOUTH_EAST(new WorldPoint(1638, 3996, 0), new WorldPoint(1639, 3998, 0));
    @Getter
    public final WorldPoint BRAZIER_LOCATION;
    @Getter
    public final WorldPoint OBJECT_BRAZIER_LOCATION;
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/wintertodt/enums/State.java
================
package net.runelite.client.plugins.microbot.wintertodt.enums;
public enum State {
    GLOBAL,
    BANKING,
    ENTER_ROOM,
    WAITING,
    LIGHT_BRAZIER,
    CHOP_ROOTS,
    FLETCH_LOGS,
    BURN_LOGS,
    FIX_BRAZIER
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/wintertodt/MWintertodtConfig.java
================
package net.runelite.client.plugins.microbot.wintertodt;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.plugins.microbot.util.misc.Rs2Food;
import net.runelite.client.plugins.microbot.wintertodt.enums.Brazier;
@ConfigGroup("wintertodt")
public interface MWintertodtConfig extends Config {
    @ConfigSection(
            name = "General",
            description = "General",
            position = 0
    )
    String generalSection = "general";
    @ConfigSection(
            name = "Food",
            description = "Food",
            position = 1
    )
    String foodSection = "Food";
    @ConfigSection(
            name = "Brazier",
            description = "Braziers are found in the four corners of the Wintertodt's prison north of the Wintertodt Camp. They can be fueled using bruma roots or bruma kindling in order to drain the Wintertodt's energy.",
            position = 2
    )
    String brazierSection = "brazier";
    @ConfigItem(
            keyName = "guide",
            name = "How to use",
            description = "How to use this plugin",
            position = 0,
            section = generalSection
    )
    default String GUIDE() {
        return "Start the script at the wintertodt bank with all your equipment and inventory setup";
    }
    @ConfigItem(
            keyName = "RelightBrazier",
            name = "Relight Brazier",
            description = "If the braziers go out, relighting the brazier will reward 6x the player's Firemaking level in experience.",
            position = 1,
            section = generalSection
    )
    default boolean relightBrazier() {
        return true;
    }
    @ConfigItem(
            keyName = "FletchRoots",
            name = "Fletch roots into kindlings",
            description = "Bruma kindling is obtained by using a knife on a bruma root, granting Fletching experience appropriate to the player's level. The Fletching experience given is equal to 0.6 times the player's Fletching level.",
            position = 2,
            section = generalSection
    )
    default boolean fletchRoots() {
        return true;
    }
    @ConfigItem(
            keyName = "FixBrazier",
            name = "Fix Brazier",
            description = "The Wintertodt will occasionally break the braziers; they must be repaired again before use. This rewards 4x the player's Construction level in experience, provided they own a player-owned house.",
            position = 3,
            section = generalSection
    )
    default boolean fixBrazier() {
        return true;
    }
    @ConfigItem(
            keyName = "OpenCrates",
            name = "Open Supply Crates",
            description = "Open supply crates",
            position = 4,
            section = generalSection
    )
    default boolean openCrates() {
        return true;
    }
    @ConfigItem(
            keyName = "AxeInventory",
            name = "Axe In Inventory?",
            description = "Axe in inventory?",
            position = 5,
            section = generalSection
    )
    default boolean axeInInventory() {
        return false;
    }
    @ConfigItem(
            keyName = "Food",
            name = "Food",
            description = "Select the type of food to use",
            position = 1,
            section = foodSection
    )
    default Rs2Food food() {
        return Rs2Food.MONKFISH;
    }
    @ConfigItem(
            keyName = "Amount",
            name = "Amount",
            description = "Alount of food to use",
            position = 2,
            section = foodSection
    )
    default int foodAmount() {
        return 6;
    }
    @ConfigItem(
            keyName = "MinFood",
            name = "Min Food",
            description = "Minimum food to start a new game",
            position = 3,
            section = foodSection
    )
    default int minFood() {
        return 2;
    }
    @ConfigItem(
            keyName = "Eat at %",
            name = "Eat at %",
            description = "Eat at specific percentage health.",
            position = 4,
            section = foodSection
    )
    default int eatAt() {
        return 70;
    }
    @ConfigItem(
            keyName = "Hitpoints Tresshold",
            name = "HP % to run away",
            description = "Runs to the bank if a specific health treshhold is reached and the player does not have any food in their inventory.",
            position = 5,
            section = foodSection
    )
    default int hpTreshhold() {
        return 30;
    }
    @ConfigItem(
            keyName = "Brazier",
            name = "Brazier",
            description = "The brazier to feed",
            position = 1,
            section = brazierSection
    )
    default Brazier brazierLocation() {
        return Brazier.SOUTH_EAST;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/wintertodt/MWintertodtOverlay.java
================
package net.runelite.client.plugins.microbot.wintertodt;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import javax.inject.Inject;
import java.awt.*;
public class MWintertodtOverlay extends OverlayPanel {
    private final MWintertodtPlugin plugin;
    MWintertodtConfig config;
    @Inject
    MWintertodtOverlay(MWintertodtPlugin plugin, MWintertodtConfig config)
    {
        super(plugin);
        this.plugin = plugin;
        this.config = config;
        setPosition(OverlayPosition.TOP_CENTER);
        setNaughty();
    }
    @Override
    public Dimension render(Graphics2D graphics) {
        try {
            panelComponent.setPreferredSize(new Dimension(200, 300));
            panelComponent.getChildren().add(TitleComponent.builder()
                    .text("Micro Wintertodt V" + MWintertodtScript.version)
                    .color(Color.GREEN)
                    .build());
            panelComponent.getChildren().add(LineComponent.builder().build());
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Running: " + plugin.getTimeRunning())
                    .leftColor(Color.GREEN)
                    .build());
            panelComponent.getChildren().add(LineComponent.builder().build());
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Won: " + plugin.getWon())
                    .leftColor(Color.GREEN)
                    .build());
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Lost: " + plugin.getLost())
                    .leftColor(Color.RED)
                    .build());
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Cut: " + plugin.getLogsCut())
                    .leftColor(Color.GREEN)
                    .build());
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Fletched: " + plugin.getLogsFletched())
                    .leftColor(Color.GREEN)
                    .build());
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Braziers fixed: " + plugin.getBraziersFixed())
                    .leftColor(Color.GREEN)
                    .build());
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Braziers lit: " + plugin.getBraziersLit())
                    .leftColor(Color.GREEN)
                    .build());
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Food consumed: " + plugin.getFoodConsumed())
                    .leftColor(Color.GREEN)
                    .build());
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Times banked: " + plugin.getTimesBanked())
                    .leftColor(Color.GREEN)
                    .build());
            panelComponent.getChildren().add(LineComponent.builder()
                    .left(MWintertodtScript.state.toString())
                    .build());
            panelComponent.getChildren().add(LineComponent.builder()
                    .left(Microbot.status)
                    .build());
        } catch(Exception ex) {
            System.out.println(ex.getMessage());
        }
        return super.render(graphics);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/wintertodt/MWintertodtPlugin.java
================
package net.runelite.client.plugins.microbot.wintertodt;
import com.google.inject.Provides;
import lombok.AccessLevel;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.ChatMessageType;
import net.runelite.api.ItemID;
import net.runelite.api.MessageNode;
import net.runelite.api.Skill;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.events.StatChanged;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.misc.TimeUtils;
import net.runelite.client.ui.overlay.OverlayManager;
import javax.inject.Inject;
import java.awt.*;
import java.time.Instant;
@PluginDescriptor(
        name = PluginDescriptor.Mocrosoft + "Wintertodt",
        description = "Wintertodt Minigame Bot",
        tags = {"Wintertodt", "microbot", "firemaking", "minigame"},
        enabledByDefault = false
)
@Slf4j
public class MWintertodtPlugin extends Plugin {
    @Inject
    MWintertodtScript wintertodtScript;
    @Inject
    private MWintertodtConfig config;
    @Inject
    private OverlayManager overlayManager;
    @Inject
    private MWintertodtOverlay wintertodtOverlay;
    @Getter(AccessLevel.PACKAGE)
    private int won;
    @Getter(AccessLevel.PACKAGE)
    private int lost;
    @Getter(AccessLevel.PACKAGE)
    private int logsCut;
    @Getter(AccessLevel.PACKAGE)
    private int logsFletched;
    @Getter(AccessLevel.PACKAGE)
    private int braziersFixed;
    @Getter(AccessLevel.PACKAGE)
    private int braziersLit;
    @Getter
    @Setter
    private int foodConsumed;
    @Getter
    @Setter
    private int timesBanked;
    @Getter(AccessLevel.PACKAGE)
    private boolean scriptStarted;
    private Instant scriptStartTime;
    @Provides
    MWintertodtConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(MWintertodtConfig.class);
    }
    protected String getTimeRunning() {
        return scriptStartTime != null ? TimeUtils.getFormattedDurationBetween(scriptStartTime, Instant.now()) : "";
    }
    private void reset() {
        this.won = 0;
        this.lost = 0;
        this.logsCut = 0;
        this.logsFletched = 0;
        this.braziersFixed = 0;
        this.braziersLit = 0;
        this.foodConsumed = 0;
        this.timesBanked = 0;
        this.scriptStartTime = null;
        this.scriptStarted = false;
    }
    @Override
    protected void startUp() throws AWTException {
        reset();
        this.scriptStartTime = Instant.now();
        this.scriptStarted = true;
        if (overlayManager != null) {
            overlayManager.add(wintertodtOverlay);
        }
        wintertodtScript.run(config, this);
    }
    protected void shutDown() {
        wintertodtScript.shutdown();
        overlayManager.remove(wintertodtOverlay);
    }
    @Subscribe
    public void onChatMessage(ChatMessage chatMessage) {
        ChatMessageType chatMessageType = chatMessage.getType();
        MessageNode messageNode = chatMessage.getMessageNode();
        if (!scriptStarted
                || !isInWintertodtRegion()
                || chatMessageType != ChatMessageType.GAMEMESSAGE
                && chatMessageType != ChatMessageType.SPAM) {
            return;
        }
        if (messageNode.getValue().startsWith("You fix the brazier")) {
            braziersFixed++;
        }
        if (messageNode.getValue().startsWith("You light the brazier")) {
            braziersLit++;
        }
        if (messageNode.getValue().startsWith("You have gained a supply crate")) {
            won++;
        }
        if (messageNode.getValue().startsWith("You did not earn enough points")) {
            lost++;
        }
    }
    private boolean isInWintertodtRegion() {
        return Microbot.getClient().getLocalPlayer().getWorldLocation().getRegionID() == 6462;
    }
    private int getResourcesInInventory() {
        return Rs2Inventory.count(ItemID.BRUMA_ROOT) + Rs2Inventory.count(ItemID.BRUMA_KINDLING);
    }
    @Subscribe
    public void onHitsplatApplied(HitsplatApplied hitsplatApplied)
    {
        MWintertodtScript.onHitsplatApplied(hitsplatApplied);
    }
    @Subscribe
    public void onStatChanged(StatChanged event) {
        if (event.getSkill() == Skill.WOODCUTTING) {
            logsCut++;
        }
        if (event.getSkill() == Skill.FLETCHING) {
            logsFletched++;
        }
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/wintertodt/MWintertodtScript.java
================
package net.runelite.client.plugins.microbot.wintertodt;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.HitsplatApplied;
import net.runelite.api.widgets.Widget;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.Script;
import net.runelite.client.plugins.microbot.breakhandler.BreakHandlerScript;
import net.runelite.client.plugins.microbot.util.antiban.Rs2Antiban;
import net.runelite.client.plugins.microbot.util.antiban.Rs2AntibanSettings;
import net.runelite.client.plugins.microbot.util.antiban.enums.Activity;
import net.runelite.client.plugins.microbot.util.antiban.enums.PlayStyle;
import net.runelite.client.plugins.microbot.util.bank.Rs2Bank;
import net.runelite.client.plugins.microbot.util.combat.Rs2Combat;
import net.runelite.client.plugins.microbot.util.equipment.Rs2Equipment;
import net.runelite.client.plugins.microbot.util.gameobject.Rs2GameObject;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Item;
import net.runelite.client.plugins.microbot.util.keyboard.Rs2Keyboard;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.microbot.util.walker.Rs2Walker;
import net.runelite.client.plugins.microbot.util.widget.Rs2Widget;
import net.runelite.client.plugins.microbot.wintertodt.enums.State;
import java.util.concurrent.TimeUnit;
import static net.runelite.api.Constants.GAME_TICK_LENGTH;
import static net.runelite.api.ObjectID.BRAZIER_29312;
import static net.runelite.api.ObjectID.BURNING_BRAZIER_29314;
import static net.runelite.client.plugins.microbot.util.Global.sleepUntilTrue;
import static net.runelite.client.plugins.microbot.util.player.Rs2Player.eatAt;
/**
 * 27/04/2024 - Reworking the MWintertodtScript.java
 */
public class MWintertodtScript extends Script {
    public static String version = "1.4.3";
    public static State state = State.BANKING;
    public static boolean resetActions = false;
    static MWintertodtConfig config;
    static MWintertodtPlugin plugin;
    private static boolean lockState = false;
    final WorldPoint BOSS_ROOM = new WorldPoint(1630, 3982, 0);
    final String SUPPLY_CRATE = "supply crate";
    String axe = "";
    int wintertodtHp = -1;
    private GameObject brazier;
    private static void changeState(State scriptState) {
        changeState(scriptState, false);
    }
    private static void changeState(State scriptState, boolean lock) {
        if (state == scriptState || lockState) return;
        System.out.println("Changing current script state from: " + state + " to " + scriptState);
        state = scriptState;
        resetActions = true;
        setLockState(scriptState, lock);
        lockState = lock;
    }
    private static void setLockState(State state, boolean lock) {
        if (lockState == lock) return;
        lockState = lock;
        System.out.println("State " + state.toString() + " has set lockState to " + lockState);
    }
    private static boolean shouldFletchRoots() {
        if (!config.fletchRoots()) return false;
        if (!Rs2Inventory.hasItem(ItemID.BRUMA_ROOT)) {
            setLockState(State.FLETCH_LOGS, false);
            return false;
        }
        changeState(State.FLETCH_LOGS, true);
        return true;
    }
    public static void onHitsplatApplied(HitsplatApplied hitsplatApplied) {
        Actor actor = hitsplatApplied.getActor();
        if (actor != Microbot.getClient().getLocalPlayer()) {
            return;
        }
        resetActions = true;
    }
    public boolean run(MWintertodtConfig config, MWintertodtPlugin plugin) {
        MWintertodtScript.config = config;
        MWintertodtScript.plugin = plugin;
        Rs2Antiban.resetAntibanSettings();
        Rs2Antiban.antibanSetupTemplates.applyGeneralBasicSetup();
        Rs2Antiban.setActivity(Activity.GENERAL_WOODCUTTING);
        Rs2AntibanSettings.usePlayStyle = true;
        Rs2AntibanSettings.universalAntiban = false;
        Rs2AntibanSettings.contextualVariability = true;
        Rs2AntibanSettings.dynamicActivity = true;
        Rs2AntibanSettings.behavioralVariability = true;
        Rs2AntibanSettings.simulateAttentionSpan = false;
        Rs2AntibanSettings.simulateFatigue = true;
        Rs2AntibanSettings.simulateMistakes = true;
        Rs2AntibanSettings.moveMouseRandomly = true;
        Rs2AntibanSettings.moveMouseOffScreen = true;
        Rs2AntibanSettings.naturalMouse = true;
        Rs2AntibanSettings.takeMicroBreaks = true;
        Rs2AntibanSettings.profileSwitching = false;
        Rs2AntibanSettings.actionCooldownChance = 0.15;
        Rs2AntibanSettings.microBreakChance = 0.05;
        Rs2Antiban.setPlayStyle(PlayStyle.EXTREME_AGGRESSIVE);
        state = State.BANKING;
        mainScheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(() -> {
            try {
                if (!Microbot.isLoggedIn()) return;
                if (!super.run()) return;
                if (Rs2AntibanSettings.actionCooldownActive) return;
                long startTime = System.currentTimeMillis();
                if (config.axeInInventory()) {
                    if (!Rs2Inventory.hasItem("axe")) {
                        Microbot.showMessage("It seems that you selected axeInInventory option but no axe was found in your inventory.");
                        sleep(5000);
                        return;
                    }
                    axe = Rs2Inventory.get("axe").name;
                }
                boolean wintertodtRespawning = Rs2Widget.hasWidget("returns in");
                boolean isWintertodtAlive = Rs2Widget.hasWidget("Wintertodt's Energy");
                brazier = Rs2GameObject.findObject(BRAZIER_29312, config.brazierLocation().getOBJECT_BRAZIER_LOCATION());
                GameObject brokenBrazier = Rs2GameObject.findObject(ObjectID.BRAZIER_29313, config.brazierLocation().getOBJECT_BRAZIER_LOCATION());
                GameObject fireBrazier = Rs2GameObject.findObject(ObjectID.BURNING_BRAZIER_29314, config.brazierLocation().getOBJECT_BRAZIER_LOCATION());
                boolean needBanking = !Rs2Inventory.hasItemAmount(config.food().getName(), config.minFood(), false, false)
                        && !isWintertodtAlive;
                Widget wintertodtHealthbar = Rs2Widget.getWidget(25952276);
                if (wintertodtHealthbar != null && isWintertodtAlive) {
                    String widgetText = wintertodtHealthbar.getText();
                    wintertodtHp = Integer.parseInt(widgetText.split("\\D+")[1]);
                } else {
                    wintertodtHp = -1;
                }
                if (Rs2Widget.hasWidget("Leave and lose all progress")) {
                    Rs2Keyboard.typeString("1");
                    sleep(1600, 2000);
                    return;
                }
                dropUnnecessaryItems();
                shouldLightBrazier(isWintertodtAlive, needBanking, fireBrazier, brazier);
                shouldBank(needBanking);
                shouldEat();
                dodgeOrbDamage();
                if (!needBanking) {
                    if (!isWintertodtAlive) {
                        if (state != State.ENTER_ROOM && state != State.WAITING && state != State.BANKING) {
                            setLockState(State.GLOBAL, false);
                            changeState(State.WAITING);
                        }
                    } else {
                        handleMainLoop();
                    }
                } else {
                    setLockState(State.BANKING, false);
                }
                switch (state) {
                    case BANKING:
                        if (!handleBankLogic(config)) return;
                        if (BreakHandlerScript.isLockState())
                            BreakHandlerScript.setLockState(false);
                        if (Rs2Player.isFullHealth() && Rs2Inventory.hasItemAmount(config.food().getName(), config.foodAmount(), false, true)) {
                            MWintertodtScript.plugin.setTimesBanked(plugin.getTimesBanked() + 1);
                            if (Rs2Antiban.takeMicroBreakByChance() || BreakHandlerScript.isBreakActive())
                                break;
                            changeState(State.ENTER_ROOM);
                        }
                        break;
                    case ENTER_ROOM:
                        if (!BreakHandlerScript.isLockState() && !BreakHandlerScript.isBreakActive())
                            BreakHandlerScript.setLockState(true);
                        if (!wintertodtRespawning && !isWintertodtAlive) {
                            Rs2Walker.walkTo(BOSS_ROOM, 12);
                        } else {
                            state = State.WAITING;
                        }
                        break;
                    case WAITING:
                        walkToBrazier();
                        shouldLightBrazier(isWintertodtAlive, needBanking, fireBrazier, brazier);
                        break;
                    case LIGHT_BRAZIER:
                        if (brazier != null && !Rs2Player.isAnimating()) {
                            Rs2GameObject.interact(brazier, "light");
                            sleep(1000);
                            return;
                        }
                        break;
                    case CHOP_ROOTS:
                        Rs2Combat.setSpecState(true, 1000);
                        if (!Rs2Player.isAnimating()) {
                            Rs2GameObject.interact(ObjectID.BRUMA_ROOTS, "Chop");
                            sleepUntil(Rs2Player::isAnimating, 2000);
                            resetActions = false;
                            Rs2Antiban.actionCooldown();
                        }
                        break;
                    case FLETCH_LOGS:
                        if (Rs2Player.getAnimation() != AnimationID.FLETCHING_BOW_CUTTING || resetActions) {
                            walkToBrazier();
                            Rs2Item knife = Rs2Inventory.get("knife");
                            if (knife.slot != 27) {
                                sleep(GAME_TICK_LENGTH * 2);
                                if (Rs2Inventory.moveItemToSlot(knife, 27))
                                    sleepUntil(() -> Rs2Inventory.slotContains(27, "knife"), 5000);
                            }
                            Rs2Inventory.combineClosest(ItemID.KNIFE, ItemID.BRUMA_ROOT);
                            resetActions = false;
                            sleep(GAME_TICK_LENGTH);
                            sleepUntil(() -> Rs2Player.getAnimation() != AnimationID.FLETCHING_BOW_CUTTING, 2000);
                            Rs2Antiban.actionCooldown();
                        }
                        break;
                    case BURN_LOGS:
                        if (!Microbot.isGainingExp || resetActions) {
                            TileObject burningBrazier = Rs2GameObject.findObjectById(BURNING_BRAZIER_29314);
                            if (brokenBrazier != null && config.fixBrazier()) {
                                Rs2GameObject.interact(brokenBrazier, "fix");
                                Microbot.log("Fixing brazier");
                                sleep(1500);
                                return;
                            }
                            // this extra check is needed in case all braziers are broken or not burning
                            if (burningBrazier == null && brazier != null && config.relightBrazier()) {
                                Rs2GameObject.interact(brazier, "light");
                                Microbot.log("Lighting brazier");
                                sleep(1500);
                                return;
                            } else {
                                if (burningBrazier.getWorldLocation().distanceTo(Rs2Player.getWorldLocation()) > 10 && brazier != null && config.relightBrazier()) {
                                    Rs2GameObject.interact(brazier, "light");
                                    Microbot.log("Lighting brazier");
                                    sleep(1500);
                                    return;
                                }
                            }
                            if (burningBrazier.getWorldLocation().distanceTo(Rs2Player.getWorldLocation()) < 10 && hasItemsToBurn()) {
                                Rs2GameObject.interact(BURNING_BRAZIER_29314, "feed");
                                Microbot.log("Feeding brazier");
                                resetActions = false;
                                sleep(GAME_TICK_LENGTH * 3);
                                Rs2Antiban.actionCooldown();
                            }
                        }
                        break;
                }
                long endTime = System.currentTimeMillis();
                long totalTime = endTime - startTime;
                System.out.println("Total time for loop " + totalTime);
            } catch (Exception ex) {
                System.out.println(ex.getMessage());
            }
        }, 0, 100, TimeUnit.MILLISECONDS);
        return true;
    }
    private void handleMainLoop() {
        if (isWintertodtAlmostDead()) {
            setLockState(State.BURN_LOGS, false);
            if (shouldBurnLogs()) {
            }
        } else {
            if (shouldChopRoots()) return;
            if (shouldFletchRoots()) return;
            if (shouldBurnLogs()) {
            }
        }
    }
    private boolean shouldBurnLogs() {
        if (!hasItemsToBurn()) {
            setLockState(State.BURN_LOGS, false);
            return false;
        }
        changeState(State.BURN_LOGS, true);
        return true;
    }
    private boolean shouldEat() {
        if (eatAt(config.eatAt())) {
            sleep(600, 800);
            plugin.setFoodConsumed(plugin.getFoodConsumed() + 1);
            Rs2Inventory.dropAll("jug");
            resetActions = true;
            return true;
        }
        return false;
    }
    private boolean shouldBank(boolean needBanking) {
        if (!needBanking) return false;
        changeState(State.BANKING);
        return true;
    }
    private boolean shouldChopRoots() {
        if (Rs2Inventory.isFull()) {
            if (state == State.CHOP_ROOTS) {
                setLockState(State.CHOP_ROOTS, false);
            }
            return false;
        }
        if (hasItemsToBurn()) return false;
        changeState(State.CHOP_ROOTS, true);
        return true;
    }
    private boolean shouldLightBrazier(boolean isWintertodtAlive, boolean needBanking, GameObject fireBrazier, GameObject brazier) {
        if (!isWintertodtAlive) return false;
        if (needBanking) return false;
        if (state == State.CHOP_ROOTS) return false;// we are most likely to far from the brazier to light it in time
        if (brazier == null || fireBrazier != null) {
            setLockState(State.LIGHT_BRAZIER, false);
            return false;
        }
        changeState(State.LIGHT_BRAZIER, true);
        return true;
    }
    private boolean isWintertodtAlmostDead() {
        return wintertodtHp > 0 && wintertodtHp < 15;
    }
    private boolean hasItemsToBurn() {
        return Rs2Inventory.hasItem(ItemID.BRUMA_KINDLING) || Rs2Inventory.hasItem(ItemID.BRUMA_ROOT);
    }
    private void dropUnnecessaryItems() {
        if (!config.fletchRoots() && Rs2Inventory.hasItem(ItemID.KNIFE)) {
            Rs2Inventory.drop(ItemID.KNIFE);
        }
        if (!config.fixBrazier() && Rs2Inventory.hasItem(ItemID.HAMMER)) {
            Rs2Inventory.drop(ItemID.HAMMER);
        }
        if ((Rs2Equipment.hasEquipped(ItemID.BRUMA_TORCH) || Rs2Equipment.hasEquipped(ItemID.BRUMA_TORCH_OFFHAND)) && Rs2Inventory.hasItem(ItemID.TINDERBOX)) {
            Rs2Inventory.drop(ItemID.TINDERBOX);
        }
    }
    @Override
    public void shutdown() {
        Rs2Antiban.resetAntibanSettings();
        super.shutdown();
    }
    private void walkToBrazier() {
        if (Rs2Player.getWorldLocation().distanceTo(config.brazierLocation().getBRAZIER_LOCATION()) > 6) {
            Rs2Walker.walkTo(config.brazierLocation().getBRAZIER_LOCATION(), 2);
        } else if (!Rs2Player.getWorldLocation().equals(config.brazierLocation().getBRAZIER_LOCATION())) {
            Rs2Walker.walkFastCanvas(config.brazierLocation().getBRAZIER_LOCATION());
            sleep(GAME_TICK_LENGTH);
//            if (Rs2Player.getWorldLocation().distanceTo(config.brazierLocation().getBRAZIER_LOCATION()) > 4) {
//                Rs2Player.waitForWalking();
//            } else {
//                //sleep(3000);
//            }
        } else if (Rs2Player.getWorldLocation().equals(config.brazierLocation().getBRAZIER_LOCATION()) && state == State.WAITING) {
            Rs2GameObject.hoverOverObject(brazier);
        }
    }
    private void dodgeOrbDamage() {
        for (GraphicsObject graphicsObject : Microbot.getClient().getGraphicsObjects()) {
            if (!resetActions && graphicsObject.getId() == 502
                    && WorldPoint.fromLocalInstance(Microbot.getClient(),
                    graphicsObject.getLocation()).distanceTo(Rs2Player.getWorldLocation()) == 1) {
                System.out.println(WorldPoint.fromLocalInstance(Microbot.getClient(),
                        graphicsObject.getLocation()).distanceTo(Rs2Player.getWorldLocation()));
                //walk south
                Rs2Walker.walkFastCanvas(new WorldPoint(Rs2Player.getWorldLocation().getX(), Rs2Player.getWorldLocation().getY() - 1, Rs2Player.getWorldLocation().getPlane()));
                Rs2Player.waitForWalking(1000);
                sleep(GAME_TICK_LENGTH * 2);
                resetActions = true;
            }
        }
    }
    private boolean handleBankLogic(MWintertodtConfig config) {
        if (!Rs2Player.isFullHealth() && Rs2Inventory.hasItem(config.food().getName(), false)) {
            eatAt(99);
            return true;
        }
        if (Rs2Inventory.hasItemAmount(config.food().getName(), config.foodAmount(), true)) {
            state = State.ENTER_ROOM;
            return true;
        }
        WorldPoint bankLocation = new WorldPoint(1640, 3944, 0);
        if (Rs2Player.getWorldLocation().distanceTo(bankLocation) > 6) {
            Rs2Walker.walkTo(bankLocation);
            Rs2Player.waitForWalking();
            if (config.openCrates()) {
                Rs2Inventory.interact(SUPPLY_CRATE, "open");
            }
        }
        Rs2Bank.useBank();
        if (!Rs2Bank.isOpen()) return true;
        Rs2Bank.depositAll();
        int foodCount = (int) Rs2Inventory.getInventoryFood().stream().count();
        if (config.fixBrazier()) {
            Rs2Bank.withdrawX(true, "hammer", 1);
        }
        if (!Rs2Equipment.hasEquipped(ItemID.BRUMA_TORCH) && !Rs2Equipment.hasEquipped(ItemID.BRUMA_TORCH_OFFHAND)) {
            Rs2Bank.withdrawX(true, "tinderbox", 1, true);
        }
        if (config.fletchRoots()) {
            Rs2Bank.withdrawX(true, "knife", 1, true);
        }
        if (config.axeInInventory()) {
            Rs2Bank.withdrawX(true, axe, 1);
        }
        if (!Rs2Bank.hasBankItem(config.food().getName(), config.foodAmount(), true)) {
            Microbot.showMessage("Insufficient food supply");
            Microbot.pauseAllScripts = true;
            return true;
        }
        Rs2Bank.withdrawX(config.food().getId(), config.foodAmount() - foodCount);
        return sleepUntilTrue(() -> Rs2Inventory.hasItemAmount(config.food().getName(), config.foodAmount(), false, true), 100, 5000);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/data/teleportationData/FairyRingTeleportLoader.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.data.locationData;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.VoxSylvaePlugins.util.teleport.*;
import java.io.FileReader;
import java.io.IOException;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
public class FairyRingTeleportLoader {
    private static final String FAIRY_RING_JSON_PATH = "../data/locationData/";
    // Method to load the fairy ring teleports from the JSON file
    public void loadFairyRingTeleports(Map<TeleportType, List<Teleport>> teleports, String fileName) {
        try (FileReader reader = new FileReader(FAIRY_RING_JSON_PATH + fileName)) {
            Gson gson = new Gson();
            Type fairyRingTeleportListType = new TypeToken<ArrayList<JsonFairyRingTeleport>>(){}.getType();
            List<JsonFairyRingTeleport> jsonFairyRingTeleports = gson.fromJson(reader, fairyRingTeleportListType);
            // Convert JSON to FairyRingTeleport objects
            List<FairyRingTeleport> fairyRingTeleports = jsonFairyRingTeleports.stream()
                .map(this::convertJsonToFairyRingTeleport)
                .collect(Collectors.toList());
            // Add them to the teleport map
            teleports.put(TeleportType.FAIRY_RING, new ArrayList<>(fairyRingTeleports));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    // Helper method to convert the JSON structure to FairyRingTeleport objects
    private FairyRingTeleport convertJsonToFairyRingTeleport(JsonFairyRingTeleport json) {
        return new FairyRingTeleport(
            json.name,
            json.requiredLevel,
            json.requiredItems,
            json.requiredQuests,
            json.destinations,
            json.additionalInfo.code,
            json.additionalInfo.location,
            json.additionalInfo.notes,
            json.additionalInfo.points_of_interest
        );
    }
    // Helper class to match the JSON structure
    private static class JsonFairyRingTeleport {
        String name;
        int requiredLevel;
        List<ItemQuantity> requiredItems;
        List<String> requiredQuests;
        List<WorldPoint> destinations;
        AdditionalInfo additionalInfo;
        // Inner class to match additional information in the JSON
        static class AdditionalInfo {
            String code;
            String location;
            String notes;
            List<String> points_of_interest;
        }
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/data/teleportationData/SpellbookTeleportLoader.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.data.locationData;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.VoxSylvaePlugins.util.teleport.*;
import java.io.FileReader;
import java.io.IOException;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
public class SpellbookTeleportLoader {
    private static final String SPELLBOOK_JSON_PATH = "../data/locationData/";
    public void loadSpellbookTeleports(Map<TeleportType, List<Teleport>> teleports, String filename) {
        try (FileReader reader = new FileReader(SPELLBOOK_JSON_PATH + filename)) {
            Gson gson = new Gson();
            Type spellbookTeleportListType = new TypeToken<ArrayList<JsonSpellbookTeleport>>(){}.getType();
            List<JsonSpellbookTeleport> jsonSpellbookTeleports = gson.fromJson(reader, spellbookTeleportListType);
            List<SpellbookTeleport> spellbookTeleports = jsonSpellbookTeleports.stream()
                .map(this::convertJsonToSpellbookTeleport)
                .collect(Collectors.toList());
            for (SpellbookTeleport teleport : spellbookTeleports) {
                teleports.computeIfAbsent(teleport.getType(), k -> new ArrayList<>()).add(teleport);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    private SpellbookTeleport convertJsonToSpellbookTeleport(JsonSpellbookTeleport json) {
        return new SpellbookTeleport(
            json.name,
            TeleportType.valueOf(json.type),
            json.requiredLevel,
            json.requiredItems,
            json.requiredQuests,
            json.destinations,
            json.additionalInfo.location,
            json.additionalInfo.membersOnly
        );
    }
    // Helper class to match the JSON structure
    private static class JsonSpellbookTeleport {
        String name;
        String type;
        int requiredLevel;
        List<ItemQuantity> requiredItems;
        List<String> requiredQuests;
        List<WorldPoint> destinations;
        AdditionalInfo additionalInfo;
        // Additional info matches the JSON structure for location and membersOnly
        static class AdditionalInfo {
            String location;
            boolean membersOnly;
        }
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/data/teleportationData/TeleportItemLoader.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.data.locationData;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.VoxSylvaePlugins.util.teleport.*;
import java.io.FileReader;
import java.io.IOException;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
public class TeleportItemLoader {
    private static final String ITEM_TELEPORT_JSON_PATH = "../data/locationData/";
    public void loadTeleportItemLoaderTeleports(Map<TeleportType, List<Teleport>> teleports, String fileName) {
        try (FileReader reader = new FileReader(ITEM_TELEPORT_JSON_PATH+fileName)) {
            Gson gson = new Gson();
            Type jewelryTeleportListType = new TypeToken<ArrayList<JsonTeleportItemLoaderTeleport>>() {}.getType();
            List<JsonTeleportItemLoaderTeleport> jsonJewelryTeleports = gson.fromJson(reader, jewelryTeleportListType);
            List<TeleportItem> jewelryTeleports = jsonJewelryTeleports.stream()
                .map(this::convertJsonToTeleportItem)
                .collect(Collectors.toList());
            for (TeleportItem teleport : jewelryTeleports) {
                teleports.computeIfAbsent(teleport.getType(), k -> new ArrayList<>()).add(teleport);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    private TeleportItem convertJsonToTeleportItem(JsonTeleportItemLoaderTeleport json) {
        List<WorldPoint> destinations = json.destinations.stream()
            .map(point -> new WorldPoint(point.x, point.y, point.z))
            .collect(Collectors.toList());
        return new TeleportItem(
            json.name,
            TeleportType.valueOf(json.type),
            -1,  // Assuming itemId is not provided in the JSON; use -1 as default
            json.requiredLevel,
            json.requiredItems,
            json.requiredQuests,
            destinations,
            json.isEquippable,
            json.charges,
            json.additionalInfo.locations,
            json.additionalInfo.membersOnly,
            json.additionalInfo.rechargeable,
            json.additionalInfo.notes
        );
    }
    // Helper class to match the JSON structure
    private static class JsonTeleportItemLoaderTeleport {
        String name;
        String type;
        int requiredLevel;
        List<ItemQuantity> requiredItems;
        List<String> requiredQuests;
        List<JsonWorldPoint> destinations;
        boolean isEquippable;
        int charges;
        AdditionalInfo additionalInfo;
        // Inner class for the additionalInfo field
        static class AdditionalInfo {
            List<String> locations;
            boolean membersOnly;
            boolean rechargeable;
            String notes;
        }
        // Inner class for the destination points
        static class JsonWorldPoint {
            int x, y, z;
        }
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/scraper/api/WikipediaApi.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.scraper.api;
import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import net.runelite.client.plugins.VoxSylvaePlugins.scraper.model.WikipediaPage;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.Response;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;
public class WikipediaApi {
    private final OkHttpClient client;
    private final Gson gson;
    private final String baseUrl = "https://oldschool.runescape.wiki/api.php";
    public WikipediaApi() {
        this.client = new OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .build();
        this.gson = new Gson();
    }
    public CompletableFuture<WikipediaPage> getPageContent(String pageName) {
        return CompletableFuture.supplyAsync(() -> {
            HttpUrl url = HttpUrl.parse(baseUrl).newBuilder()
                .addQueryParameter("action", "parse")
                .addQueryParameter("page", pageName)
                .addQueryParameter("format", "json")
                .addQueryParameter("prop", "wikitext|revid")
                .build();
            Request request = new Request.Builder()
                .url(url)
                .header("User-Agent", "RuneLite/MicrobotScraper")
                .build();
            try (Response response = client.newCall(request).execute()) {
                if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
                String responseBody = response.body().string();
                JsonObject jsonObject = gson.fromJson(responseBody, JsonObject.class);
                if (jsonObject.has("error")) {
                    throw new IOException("API error: " + jsonObject.get("error").getAsJsonObject().get("info").getAsString());
                }
                JsonObject parse = jsonObject.getAsJsonObject("parse");
                String title = parse.get("title").getAsString();
                String wikitext = parse.getAsJsonObject("wikitext").get("*").getAsString();
                int revisionId = parse.get("revid").getAsInt();
                return new WikipediaPage(title, wikitext, revisionId);
            } catch (Exception e) {
                throw new RuntimeException("Failed to fetch page content for " + pageName, e);
            }
        });
    }
    public CompletableFuture<Map<String, String>> getPageCategories(String pageName) {
        return CompletableFuture.supplyAsync(() -> {
            HttpUrl url = HttpUrl.parse(baseUrl).newBuilder()
                .addQueryParameter("action", "query")
                .addQueryParameter("titles", pageName)
                .addQueryParameter("prop", "categories")
                .addQueryParameter("format", "json")
                .build();
            Request request = new Request.Builder()
                .url(url)
                .header("User-Agent", "RuneLite/MicrobotScraper")
                .build();
            try (Response response = client.newCall(request).execute()) {
                if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
                String responseBody = response.body().string();
                JsonObject jsonObject = gson.fromJson(responseBody, JsonObject.class);
                Map<String, String> categories = new HashMap<>();
                JsonObject pages = jsonObject.getAsJsonObject("query").getAsJsonObject("pages");
                String pageId = pages.keySet().iterator().next();
                JsonObject page = pages.getAsJsonObject(pageId);
                if (page.has("categories")) {
                    page.getAsJsonArray("categories").forEach(category -> {
                        String categoryTitle = category.getAsJsonObject().get("title").getAsString();
                        categories.put(categoryTitle, categoryTitle.replace("Category:", ""));
                    });
                }
                return categories;
            } catch (Exception e) {
                throw new RuntimeException("Failed to fetch categories for " + pageName, e);
            }
        });
    }
    public CompletableFuture<byte[]> getImage(String fileName) {
        return CompletableFuture.supplyAsync(() -> {
            HttpUrl url = HttpUrl.parse(baseUrl).newBuilder()
                .addQueryParameter("action", "query")
                .addQueryParameter("titles", "File:" + fileName)
                .addQueryParameter("prop", "imageinfo")
                .addQueryParameter("iiprop", "url")
                .addQueryParameter("format", "json")
                .build();
            Request request = new Request.Builder()
                .url(url)
                .header("User-Agent", "RuneLite/MicrobotScraper")
                .build();
            try (Response response = client.newCall(request).execute()) {
                if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
                String responseBody = response.body().string();
                JsonObject jsonObject = gson.fromJson(responseBody, JsonObject.class);
                JsonObject pages = jsonObject.getAsJsonObject("query").getAsJsonObject("pages");
                String pageId = pages.keySet().iterator().next();
                JsonObject page = pages.getAsJsonObject(pageId);
                if (page.has("imageinfo")) {
                    String imageUrl = page.getAsJsonArray("imageinfo").get(0).getAsJsonObject().get("url").getAsString();
                    // Now fetch the actual image
                    Request imageRequest = new Request.Builder()
                        .url(imageUrl)
                        .header("User-Agent", "RuneLite/MicrobotScraper")
                        .build();
                    try (Response imageResponse = client.newCall(imageRequest).execute()) {
                        if (!imageResponse.isSuccessful()) throw new IOException("Unexpected code " + imageResponse);
                        return imageResponse.body().bytes();
                    }
                } else {
                    throw new IOException("Image not found: " + fileName);
                }
            } catch (Exception e) {
                throw new RuntimeException("Failed to fetch image " + fileName, e);
            }
        });
    }
    public CompletableFuture<List<String>> searchPages(String query, int limit) {
        return CompletableFuture.supplyAsync(() -> {
            HttpUrl url = HttpUrl.parse(baseUrl).newBuilder()
                .addQueryParameter("action", "opensearch")
                .addQueryParameter("search", query)
                .addQueryParameter("limit", String.valueOf(limit))
                .addQueryParameter("namespace", "0")
                .addQueryParameter("format", "json")
                .build();
            Request request = new Request.Builder()
                .url(url)
                .header("User-Agent", "RuneLite/MicrobotScraper")
                .build();
            try (Response response = client.newCall(request).execute()) {
                if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
                String responseBody = response.body().string();
                JsonArray jsonArray = gson.fromJson(responseBody, JsonArray.class);
                JsonArray resultArray = jsonArray.get(1).getAsJsonArray();
                List<String> results = new ArrayList<>();
                resultArray.forEach(element -> results.add(element.getAsString()));
                return results;
            } catch (Exception e) {
                throw new RuntimeException("Failed to search pages for query: " + query, e);
            }
        });
    }
    public CompletableFuture<Map<String, String>> getPageLinks(String pageName) {
        return CompletableFuture.supplyAsync(() -> {
            HttpUrl url = HttpUrl.parse(baseUrl).newBuilder()
                .addQueryParameter("action", "query")
                .addQueryParameter("titles", pageName)
                .addQueryParameter("prop", "links")
                .addQueryParameter("pllimit", "max")
                .addQueryParameter("format", "json")
                .build();
            Request request = new Request.Builder()
                .url(url)
                .header("User-Agent", "RuneLite/MicrobotScraper")
                .build();
            try (Response response = client.newCall(request).execute()) {
                if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
                String responseBody = response.body().string();
                JsonObject jsonObject = gson.fromJson(responseBody, JsonObject.class);
                Map<String, String> links = new HashMap<>();
                JsonObject pages = jsonObject.getAsJsonObject("query").getAsJsonObject("pages");
                String pageId = pages.keySet().iterator().next();
                JsonObject page = pages.getAsJsonObject(pageId);
                if (page.has("links")) {
                    page.getAsJsonArray("links").forEach(link -> {
                        JsonObject linkObj = link.getAsJsonObject();
                        links.put(linkObj.get("title").getAsString(), linkObj.get("ns").getAsString());
                    });
                }
                return links;
            } catch (Exception e) {
                throw new RuntimeException("Failed to fetch links for " + pageName, e);
            }
        });
    }
    public CompletableFuture<List<String>> getCategoryMembers(String categoryName, int limit) {
        return CompletableFuture.supplyAsync(() -> {
            HttpUrl url = HttpUrl.parse(baseUrl).newBuilder()
                .addQueryParameter("action", "query")
                .addQueryParameter("list", "categorymembers")
                .addQueryParameter("cmtitle", "Category:" + categoryName)
                .addQueryParameter("cmlimit", String.valueOf(limit))
                .addQueryParameter("format", "json")
                .build();
            Request request = new Request.Builder()
                .url(url)
                .header("User-Agent", "RuneLite/MicrobotScraper")
                .build();
            try (Response response = client.newCall(request).execute()) {
                if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
                String responseBody = response.body().string();
                JsonObject jsonObject = gson.fromJson(responseBody, JsonObject.class);
                List<String> members = new ArrayList<>();
                JsonArray categoryMembers = jsonObject.getAsJsonObject("query")
                    .getAsJsonArray("categorymembers");
                categoryMembers.forEach(member -> {
                    members.add(member.getAsJsonObject().get("title").getAsString());
                });
                return members;
            } catch (Exception e) {
                throw new RuntimeException("Failed to fetch category members for " + categoryName, e);
            }
        });
    }
    public CompletableFuture<Map<String, String>> getPageInfo(String pageName) {
        return CompletableFuture.supplyAsync(() -> {
            HttpUrl url = HttpUrl.parse(baseUrl).newBuilder()
                .addQueryParameter("action", "query")
                .addQueryParameter("titles", pageName)
                .addQueryParameter("prop", "info")
                .addQueryParameter("inprop", "url|displaytitle")
                .addQueryParameter("format", "json")
                .build();
            Request request = new Request.Builder()
                .url(url)
                .header("User-Agent", "RuneLite/MicrobotScraper")
                .build();
            try (Response response = client.newCall(request).execute()) {
                if (!response.isSuccessful()) throw new IOException("Unexpected code " + response);
                String responseBody = response.body().string();
                JsonObject jsonObject = gson.fromJson(responseBody, JsonObject.class);
                Map<String, String> pageInfo = new HashMap<>();
                JsonObject pages = jsonObject.getAsJsonObject("query").getAsJsonObject("pages");
                String pageId = pages.keySet().iterator().next();
                JsonObject page = pages.getAsJsonObject(pageId);
                pageInfo.put("pageId", pageId);
                pageInfo.put("title", page.get("title").getAsString());
                pageInfo.put("fullUrl", page.get("fullurl").getAsString());
                pageInfo.put("displayTitle", page.get("displaytitle").getAsString());
                return pageInfo;
            } catch (Exception e) {
                throw new RuntimeException("Failed to fetch page info for " + pageName, e);
            }
        });
    }
    // You can add more methods here as needed, such as:
    // - getPageRevisions: to get revision history of a page
    // - getPageProperties: to get specific properties of a page
    // - getRandomPages: to get a list of random pages
    // - getPageTranscluded: to get pages that transclude a given page
    // - etc.
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/scraper/model/ImageType.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.scraper.model;
public enum ImageType {
    NORMAL,
    BANK,
    ALL
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/scraper/model/ScraperResult.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.scraper.model;
import java.util.List;
import java.util.Map;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.coords.WorldPoint;
@Getter
@Setter
public abstract class ScraperResult {
    private List<String> names;
    private List<Integer> ids;
    private List<String> imagePaths;
    private Map<String, String> additionalInfo;
    @Getter
    @Setter
    public static class NPCResult extends ScraperResult {
        private String name;
        private List<String> names; // For monsters with multiple versions
        private int id;
        private List<Integer> ids; // For monsters with multiple versions
        private List<String> imagePaths;
        private String examine;
        private int combatLevel;
        private List<String> attackTypes;
        private Map<String, Integer> stats;
        private List<ItemResult> drops;
        private String location;
        private boolean aggressive;
        private boolean isMonster;
        // Additional fields that might be useful
        private int hitpoints;
        private int maxHit;
        private String weakness;
        private List<String> attributes; // e.g., "undead", "demon", etc.
        @Override
        public String toString() {
            return "NPCResult{" +
                    "name='" + name + '\'' +
                    ", names=" + names +
                    ", id=" + id +
                    ", ids=" + ids +
                    ", imagePaths=" + imagePaths +
                    ", examine='" + examine + '\'' +
                    ", combatLevel=" + combatLevel +
                    ", attackTypes=" + attackTypes +
                    ", stats=" + stats +
                    ", drops=" + drops +
                    ", location='" + location + '\'' +
                    ", aggressive=" + aggressive +
                    ", isMonster=" + isMonster +
                    ", hitpoints=" + hitpoints +
                    ", maxHit=" + maxHit +
                    ", weakness='" + weakness + '\'' +
                    ", attributes=" + attributes +
                    '}';
        }
    }
    @Getter
    @Setter
    public static class ItemResult extends ScraperResult {
        private String name;
        private List<Integer> ids;
        private List<String> imagePaths;
        private boolean noteable;
        private List<String> options;
        private boolean stackable;
        private boolean tradeable;
        private boolean equipable;
        private String examine;
        private List<Integer> quantity; // For drops
        private double rarity; // For drops
        private boolean lootStatus; // For drops
        @Override
        public String toString() {
            return "ItemResult{" +
                    "name='" + name + '\'' +
                    ", ids=" + ids +
                    ", imagePaths=" + imagePaths +
                    ", noteable=" + noteable +
                    ", options=" + options +
                    ", stackable=" + stackable +
                    ", tradeable=" + tradeable +
                    ", equipable=" + equipable +
                    ", examine='" + examine + '\'' +
                    ", quantity=" + quantity +
                    ", rarity=" + rarity +
                    ", lootStatus=" + lootStatus +
                    '}';
        }
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/scraper/model/WikipediaPage.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.scraper.model;
import lombok.Getter;
import lombok.Setter;
import java.util.List;
import java.util.Map;
@Getter
@Setter
public class WikipediaPage {
    private String title;
    private String content;
    private int revisionId;
    private String url;
    private Map<String, String> categories;
    private List<String> links;
    public WikipediaPage(String title, String content, int revisionId) {
        this.title = title;
        this.content = content;
        this.revisionId = revisionId;
    }
    public boolean hasCategory(String category) {
        return categories != null && categories.containsKey(category);
    }
    public boolean hasLink(String link) {
        return links != null && links.contains(link);
    }
    @Override
    public String toString() {
        return "WikipediaPage{" +
                "title='" + title + '\'' +
                ", revisionId=" + revisionId +
                ", url='" + url + '\'' +
                ", categories=" + categories +
                ", links=" + links +
                '}';
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/scraper/util/ImageUtil.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.scraper.util;
public class ImageUtil {
    public static void downloadAndSaveImage(String url, String destination) {
        // Implement image download and save logic
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/scraper/util/StringUtil.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.scraper.util;
import java.util.ArrayList;
import java.util.List;
public class StringUtil {
    public static List<String> formatArgs(String input) {
        List<String> result = new ArrayList<>();
        if (input == null || input.trim().isEmpty()) {
            return result;
        }
        String[] parts = input.split(",");
        for (String part : parts) {
            String formattedPart = part.trim();
            formattedPart = formattedPart.substring(0, 1).toUpperCase() + formattedPart.substring(1).toLowerCase();
            formattedPart = formattedPart.replace(' ', '_');
            result.add(formattedPart);
        }
        return result;
    }
    public static String capitalizeEachWord(String input) {
        if (input == null || input.isEmpty()) {
            return input;
        }
        String[] words = input.split("_");
        StringBuilder result = new StringBuilder();
        for (String word : words) {
            if (!word.isEmpty()) {
                result.append(Character.toUpperCase(word.charAt(0)))
                      .append(word.substring(1).toLowerCase())
                      .append("_");
            }
        }
        return result.substring(0, result.length() - 1); // Remove the last underscore
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/scraper/VSItemScraper.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.scraper;
import net.runelite.client.plugins.VoxSylvaePlugins.scraper.model.ImageType;
import net.runelite.client.plugins.VoxSylvaePlugins.scraper.model.ScraperResult;
import net.runelite.client.plugins.VoxSylvaePlugins.scraper.model.WikipediaPage;
import net.runelite.client.plugins.VoxSylvaePlugins.scraper.util.StringUtil;
import java.nio.file.Path;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class VSItemScraper extends VSWikiScraper<ScraperResult.ItemResult> {
    private final Path itemDatabaseFile;
    private final List<String> itemKeys = Arrays.asList("name", "ids", "imagePaths", "noteable", "options", "stackable", "tradeable", "equipable", "examine", "quantity", "rarity", "lootStatus");
    private Map<String, ScraperResult.ItemResult> itemDatabase;
    public VSItemScraper(Map<String, Object> databaseDict, Path destination, String databaseName, Path imageFolder, boolean resetDatabase) {
        super(destination, databaseName, imageFolder, resetDatabase);
        this.itemDatabaseFile = getDefaultDatabaseJson().resolveSibling("itemsDB.json");
        this.itemDatabase = loadDatabase(itemDatabaseFile, resetDatabase, ScraperResult.ItemResult.class);
        databaseDict.put("items", this.itemDatabase);
    }
    @Override
    public void saveDatabases() {
        saveDatabase(itemDatabase, itemDatabaseFile);
    }
    public List<String> getItemKey(String itemNamesSearchString) {
        return StringUtil.formatArgs(itemNamesSearchString);
    }
    public Map<String, ScraperResult.ItemResult> getItemsInfo(String itemNamesSearchString, boolean forceReload, boolean downloadImage, ImageType imageType, String imagePath, boolean withTradeInfo) {
        Map<String, Object> kwargs = new HashMap<>();
        kwargs.put("image_type", imageType);
        kwargs.put("destination", imagePath != null ? imagePath : getImageFolder().toString());
        List<String> itemNames = getItemKey(itemNamesSearchString);
        Map<String, ScraperResult.ItemResult> itemInfo = new HashMap<>();
        for (String itemName : itemNames) {
            boolean downloadImageLoc = shouldDownloadImage(itemName, downloadImage);
            if ((itemDatabase.containsKey(itemName) || itemDatabase.containsKey(StringUtil.capitalizeEachWord(itemName)))
                    && !forceReload && !downloadImageLoc) {
                itemInfo.put(itemName, itemDatabase.get(itemName));
                continue;
            }
            WikipediaPage page = getWikiPage(itemName);
            if (page == null) {
                throw new RuntimeException("<RuneMatio> " + itemName + ": Wiki Page doesn't exist and is not in DB");
            }
            ScraperResult.ItemResult itemInfoWiki = getItemInfoFromWikiText(page, downloadImageLoc, imageType, kwargs);
            itemInfo.put(itemName, itemInfoWiki);
            itemDatabase.put(itemName, itemInfoWiki);
        }
        checkDictKeys(itemInfo, itemKeys);
        return itemInfo;
    }
    private boolean shouldDownloadImage(String itemName, boolean downloadImage) {
        if (!downloadImage) return false;
        if (!itemDatabase.containsKey(itemName)) return true;
        ScraperResult.ItemResult item = itemDatabase.get(itemName);
        return item.getImagePaths() == null || item.getImagePaths().stream().noneMatch(path -> Path.of(path).toFile().exists());
    }
    private ScraperResult.ItemResult getItemInfoFromWikiText(WikipediaPage page, boolean downloadImage, ImageType imageType, Map<String, Object> kwargs) {
        ScraperResult.ItemResult itemResult = new ScraperResult.ItemResult();
        Map<String, String> infoboxData = parseInfobox(page.getContent(), "Item");
        itemResult.setName(infoboxData.get("name"));
        itemResult.setIds(parseIds(infoboxData.get("id")));
        itemResult.setNoteable(Boolean.parseBoolean(infoboxData.getOrDefault("noteable", "false")));
        itemResult.setOptions(parseOptions(infoboxData.get("options")));
        itemResult.setStackable(Boolean.parseBoolean(infoboxData.getOrDefault("stackable", "false")));
        itemResult.setTradeable(Boolean.parseBoolean(infoboxData.getOrDefault("tradeable", "false")));
        itemResult.setEquipable(Boolean.parseBoolean(infoboxData.getOrDefault("equipable", "false")));
        itemResult.setExamine(infoboxData.get("examine"));
        if (downloadImage) {
            List<String> imagePaths = downloadImagesFromTemplate(Collections.singletonList(itemResult.getName()), infoboxData.get("image"), imageType, kwargs);
            itemResult.setImagePaths(imagePaths);
        }
        return itemResult;
    }
    private List<Integer> parseIds(String idString) {
        List<Integer> ids = new ArrayList<>();
        if (idString != null) {
            for (String id : idString.split(",")) {
                try {
                    ids.add(Integer.parseInt(id.trim()));
                } catch (NumberFormatException e) {
                    System.out.println("Failed to parse ID: " + id);
                }
            }
        }
        return ids;
    }
    private List<String> parseOptions(String optionsString) {
        List<String> options = new ArrayList<>();
        if (optionsString != null) {
            for (String option : optionsString.split(",")) {
                options.add(option.trim());
            }
        }
        return options;
    }
    private void checkDictKeys(Map<String, ScraperResult.ItemResult> dict, List<String> keys) {
        for (ScraperResult.ItemResult item : dict.values()) {
            for (String key : keys) {
                if (!hasProperty(item, key)) {
                    throw new IllegalStateException("Missing key in item result: " + key);
                }
            }
        }
    }
    private boolean hasProperty(Object obj, String propertyName) {
        try {
            obj.getClass().getDeclaredField(propertyName);
            return true;
        } catch (NoSuchFieldException e) {
            return false;
        }
    }
    private List<String> downloadImagesFromTemplate(List<String> names, String imageData, ImageType imageType, Map<String, Object> kwargs) {
        List<String> imagePaths = new ArrayList<>();
        for (String name : names) {
            String imageUrl = extractImageUrl(imageData);
            if (imageUrl != null) {
                String imagePath = downloadAndSaveImage(name, imageUrl, imageType, (String) kwargs.get("destination"));
                imagePaths.add(imagePath);
            }
        }
        return imagePaths;
    }
    private String extractImageUrl(String imageData) {
        Pattern pattern = Pattern.compile("\\[\\[File:(.*?)\\]\\]");
        Matcher matcher = pattern.matcher(imageData);
        if (matcher.find()) {
            return baseUrl + "images/" + matcher.group(1);
        }
        return null;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/scraper/VSNPCScraper.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.scraper;
import net.runelite.client.plugins.VoxSylvaePlugins.scraper.model.ImageType;
import net.runelite.client.plugins.VoxSylvaePlugins.scraper.model.ScraperResult;
import net.runelite.client.plugins.VoxSylvaePlugins.scraper.model.WikipediaPage;
import net.runelite.client.plugins.VoxSylvaePlugins.scraper.util.StringUtil;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public class VSNPCScraper extends VSWikiScraper<ScraperResult.NPCResult> {
    private final Path npcDatabaseFile;
    private final List<String> npcKeys = Arrays.asList("name", "id", "imagePaths");
    private final List<String> monsterKeys = Arrays.asList("names", "drops", "ids", "imagePaths");
    private final List<String> dropKeys = Arrays.asList("names", "quantity", "rarity", "ids", "imagePaths", "lootStatus");
    private Map<String, ScraperResult.NPCResult> npcDatabase;
    public VSNPCScraper(Map<String, Object> databaseDict, Path destination, String databaseName, Path imageFolder, boolean resetDatabase) {
        super(destination, databaseName, imageFolder, resetDatabase);
        this.npcDatabaseFile = getDefaultDatabaseJson().resolveSibling("npcDB.json");
        this.npcDatabase = loadDatabase(npcDatabaseFile, resetDatabase, ScraperResult.NPCResult.class);
        databaseDict.put("npcs", this.npcDatabase);
    }
    @Override
    public void saveDatabases() throws IOException {
        saveDatabase(npcDatabase, npcDatabaseFile);
    }
    public Map<String, ScraperResult.NPCResult> getNPCInfo(String npcNamesSearchString, boolean forceReload, boolean downloadImage, boolean saveDatabase, ImageType imageType, String imagePath) {
        List<String> npcNames = StringUtil.formatArgs(npcNamesSearchString);
        Map<String, ScraperResult.NPCResult> npcInfo = new HashMap<>();
        boolean isMonster = false;
        for (String npcName : npcNames) {
            if ((npcDatabase.containsKey(npcName) || npcDatabase.containsKey(StringUtil.capitalizeEachWord(npcName)))
                    && !forceReload && !downloadImage) {
                ScraperResult.NPCResult result = npcDatabase.get(npcName);
                npcInfo.put(npcName, result);
                if (result.getDrops() != null && !result.getDrops().isEmpty()) {
                    isMonster = true;
                }
                continue;
            }
            WikipediaPage page = getWikiPage(npcName);
            if (page == null) {
                throw new RuntimeException("<RuneMatio> " + npcName + ": Wiki Page doesn't exist and is not in DB");
            }
            ScraperResult.NPCResult npcInfoWiki = getNPCInfoFromWikiText(page, downloadImage, imageType, imagePath);
            npcInfo.put(npcName, npcInfoWiki);
            npcDatabase.put(npcName, npcInfoWiki);
            if (npcInfoWiki.getDrops() != null && !npcInfoWiki.getDrops().isEmpty()) {
                isMonster = true;
            }
        }
        checkDictKeys(npcInfo, isMonster ? monsterKeys : npcKeys);
        try {
            // Save database
            if (saveDatabase) {
                saveDatabases();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return npcInfo;
    }
    private ScraperResult.NPCResult getNPCInfoFromWikiText(WikipediaPage page, boolean downloadImage, ImageType imageType, String imagePath) {
        ScraperResult.NPCResult npcResult = new ScraperResult.NPCResult();
        Map<String, String> infoboxData = parseInfobox(page.getContent(), "NPC");
        Map<String, ScraperResult.ItemResult> npcDrops = new HashMap<>();
        if (infoboxData.containsKey("name")) {
            npcResult.setName(infoboxData.get("name"));
            npcResult.setId(Integer.parseInt(infoboxData.getOrDefault("id", "-1")));
            if (downloadImage) {
                List<String> imagePaths = downloadImagesFromTemplate(Collections.singletonList(npcResult.getName()), infoboxData.get("image"), imageType, imagePath);
                npcResult.setImagePaths(imagePaths);
            }
        } else {
            // Handle monster infobox
            npcResult = getInfoboxMonster(infoboxData, downloadImage, imageType, imagePath);
        }
        // Parse drops
        List<Map<String, String>> dropsData = parseDropsLines(page.getContent());
        for (Map<String, String> dropData : dropsData) {
            ScraperResult.ItemResult drop = getDropFromLine(dropData, downloadImage, imageType, imagePath);
            npcDrops.put(drop.getName(), drop);
        }
        npcResult.setDrops(new ArrayList<>(npcDrops.values()));
        return npcResult;
    }
    private ScraperResult.NPCResult getInfoboxMonster(Map<String, String> infoboxData, boolean downloadImage, ImageType imageType, String imagePath) {
        ScraperResult.NPCResult monsterResult = new ScraperResult.NPCResult();
        List<String> names = new ArrayList<>();
        List<Integer> ids = new ArrayList<>();
        if (infoboxData.containsKey("version1")) {
            int version = 1;
            while (infoboxData.containsKey("version" + version)) {
                names.add(infoboxData.get("name" + version));
                ids.add(Integer.parseInt(infoboxData.getOrDefault("id" + version, "-1")));
                version++;
            }
        } else {
            names.add(infoboxData.get("name"));
            ids.add(Integer.parseInt(infoboxData.getOrDefault("id", "-1")));
        }
        monsterResult.setNames(names);
        monsterResult.setIds(ids);
        if (downloadImage) {
            List<String> imagePaths = downloadImagesFromTemplate(names, infoboxData.get("image"), imageType, imagePath);
            monsterResult.setImagePaths(imagePaths);
        }
        return monsterResult;
    }
    private ScraperResult.ItemResult getDropFromLine(Map<String, String> dropData, boolean downloadImage, ImageType imageType, String imagePath) {
        ScraperResult.ItemResult drop = new ScraperResult.ItemResult();
        drop.setName(dropData.get("name"));
        String quantityStr = dropData.getOrDefault("quantity", "1");
        List<Integer> quantity = parseQuantity(quantityStr);
        drop.setQuantity(quantity);
        String rarityStr = dropData.get("rarity");
        double rarity = parseRarity(rarityStr);
        drop.setRarity(rarity);
        drop.setLootStatus(false);
        // Here you would typically fetch more item info, similar to how the Python version calls get_itemsInfo
        // For simplicity, we'll just set the basic info we have
        drop.setIds(Collections.singletonList(Integer.parseInt(dropData.getOrDefault("id", "-1"))));
        if (downloadImage) {
            List<String> imagePaths = downloadImagesFromTemplate(Collections.singletonList(drop.getName()), dropData.get("image"), imageType, imagePath);
            drop.setImagePaths(imagePaths);
        }
        return drop;
    }
    private List<Integer> parseQuantity(String quantityStr) {
        List<Integer> quantity = new ArrayList<>();
        if (quantityStr.contains("-")) {
            String[] parts = quantityStr.split("-");
            quantity.add(Integer.parseInt(parts[0].trim()));
            quantity.add(Integer.parseInt(parts[1].trim()));
        } else {
            int q = Integer.parseInt(quantityStr.trim());
            quantity.add(q);
            quantity.add(q);
        }
        return quantity;
    }
    private double parseRarity(String rarityStr) {
        if ("Always".equalsIgnoreCase(rarityStr)) {
            return 1.0;
        } else if (rarityStr.endsWith("%")) {
            return Double.parseDouble(rarityStr.substring(0, rarityStr.length() - 1)) / 100;
        } else {
            String[] parts = rarityStr.split("/");
            return Double.parseDouble(parts[0]) / Double.parseDouble(parts[1]);
        }
    }
    private List<Map<String, String>> parseDropsLines(String wikiText) {
        List<Map<String, String>> drops = new ArrayList<>();
        Pattern pattern = Pattern.compile("\\{\\{DropsLine\\|([^}]+)\\}\\}");
        Matcher matcher = pattern.matcher(wikiText);
        while (matcher.find()) {
            String dropLine = matcher.group(1);
            Map<String, String> dropData = new HashMap<>();
            String[] parts = dropLine.split("\\|");
            for (String part : parts) {
                String[] keyValue = part.split("=");
                if (keyValue.length == 2) {
                    dropData.put(keyValue[0].trim(), keyValue[1].trim());
                }
            }
            drops.add(dropData);
        }
        return drops;
    }
    private void checkDictKeys(Map<String, ScraperResult.NPCResult> dict, List<String> keys) {
        for (ScraperResult.NPCResult npc : dict.values()) {
            for (String key : keys) {
                if (!hasProperty(npc, key)) {
                    throw new IllegalStateException("Missing key in NPC result: " + key);
                }
            }
        }
    }
    private boolean hasProperty(Object obj, String propertyName) {
        try {
            obj.getClass().getDeclaredField(propertyName);
            return true;
        } catch (NoSuchFieldException e) {
            return false;
        }
    }
     // Implement the abstract method from VSWikiScraper
     @Override
     protected String downloadAndSaveImage(String name, String imageUrl, ImageType imageType, String destination) {
         // Implement the actual image downloading and saving logic here
         // For now, we'll just return a placeholder string
         return destination + "/" + name + "_" + imageType.toString().toLowerCase() + ".png";
     }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/scraper/VSWikiScraper.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.scraper;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import net.runelite.client.plugins.VoxSylvaePlugins.scraper.model.ImageType;
import net.runelite.client.plugins.VoxSylvaePlugins.scraper.model.ScraperResult;
import net.runelite.client.plugins.VoxSylvaePlugins.scraper.model.WikipediaPage;
import net.runelite.client.plugins.VoxSylvaePlugins.scraper.api.WikipediaApi;
import java.io.*;
import java.lang.reflect.Type;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.nio.file.Path;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
public abstract class VSWikiScraper<T extends ScraperResult> {
    protected final WikipediaApi wikipediaApi;
    protected final String baseUrl = "https://oldschool.runescape.wiki/";
    protected final Map<String, CompletableFuture<T>> ongoingSearches;
    protected final Map<String, T> cachedResults;
    protected final Path DEFAULT_DESTINATION;
    protected final Path DEFAULT_DATABASE_JSON;
    protected final Path imageFolder;
    protected final Gson gson;
    public enum ScraperState {
        IDLE, SEARCHING, PROCESSING, COMPLETED, ERROR
    }
    protected ScraperState state;
    public VSWikiScraper(Path destination, String databaseName, Path imageFolder, boolean resetDatabase) {
        if (destination == null || destination.toString().isEmpty()) {
            destination = Paths.get("../data/wikidata");
        }
        this.wikipediaApi = new WikipediaApi();
        this.ongoingSearches = new ConcurrentHashMap<>();
        this.cachedResults = new ConcurrentHashMap<>();
        this.state = ScraperState.IDLE;
        this.DEFAULT_DESTINATION = destination.resolve(databaseName);
        this.DEFAULT_DATABASE_JSON = this.DEFAULT_DESTINATION.resolve(databaseName + ".json");
        this.imageFolder = imageFolder;
        this.gson = new GsonBuilder().setPrettyPrinting().create();
        if (resetDatabase && DEFAULT_DATABASE_JSON.toFile().exists()) {
            DEFAULT_DATABASE_JSON.toFile().delete();
        }
    }
    protected <V extends ScraperResult> Map<String, V> loadDatabase(Path databaseFile, boolean reset, Class<V> valueType) {
        if (!reset && databaseFile.toFile().exists()) {
            try (Reader reader = new FileReader(databaseFile.toFile())) {
                Type mapType = TypeToken.getParameterized(Map.class, String.class, valueType).getType();
                return gson.fromJson(reader, mapType);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return new HashMap<>();
    }
    protected <V extends ScraperResult> void saveDatabase(Map<String, V> data, Path filePath) {
        try (Writer writer = new FileWriter(filePath.toFile())) {
            gson.toJson(data, writer);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    protected WikipediaPage getWikiPage(String pageName) {
        try {
            return wikipediaApi.getPageContent(pageName).get();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
    public abstract void saveDatabases() throws IOException;
    protected Path getDefaultDestination() {
        return DEFAULT_DESTINATION;
    }
    protected Path getDefaultDatabaseJson() {
        return DEFAULT_DATABASE_JSON;
    }
    protected Path getImageFolder() {
        return imageFolder;
    }
    public ScraperState getState() {
        return state;
    }
    public boolean isDataAvailable(String searchString) {
        return cachedResults.containsKey(searchString);
    }
    public boolean isSearchCompleted(String searchString) {
        return !ongoingSearches.containsKey(searchString) && cachedResults.containsKey(searchString);
    }
    protected Map<String, String> parseInfobox(String wikiText, String infoboxType) {
        Map<String, String> infoboxData = new HashMap<>();
        Pattern pattern = Pattern.compile("\\{\\{" + infoboxType + "[\\s\\S]*?\\}\\}");
        Matcher matcher = pattern.matcher(wikiText);
        if (matcher.find()) {
            String infobox = matcher.group();
            Pattern keyValuePattern = Pattern.compile("\\|\\s*(\\w+)\\s*=\\s*([^|\\}]+)");
            Matcher keyValueMatcher = keyValuePattern.matcher(infobox);
            while (keyValueMatcher.find()) {
                String key = keyValueMatcher.group(1).trim();
                String value = keyValueMatcher.group(2).trim();
                infoboxData.put(key, value);
            }
        }
        return infoboxData;
    }
    protected List<String> downloadImagesFromTemplate(List<String> names, String imageData, ImageType imageType, String destination) {
        List<String> imagePaths = new ArrayList<>();
        for (String name : names) {
            String imageUrl = extractImageUrl(imageData);
            if (imageUrl != null) {
                String imagePath = downloadAndSaveImage(name, imageUrl, imageType, destination);
                imagePaths.add(imagePath);
            }
        }
        return imagePaths;
    }
    private String extractImageUrl(String imageData) {
        Pattern pattern = Pattern.compile("\\[\\[File:(.*?)\\]\\]");
        Matcher matcher = pattern.matcher(imageData);
        if (matcher.find()) {
            return baseUrl + "images/" + matcher.group(1);
        }
        return null;
    }
    protected String downloadAndSaveImage(String name, String imageUrl, ImageType imageType, String destination) {
        try {
            HttpClient client = HttpClient.newHttpClient();
            HttpRequest request = HttpRequest.newBuilder()
                    .uri(URI.create(imageUrl))
                    .build();
            HttpResponse<byte[]> response = client.send(request, HttpResponse.BodyHandlers.ofByteArray());
            if (response.statusCode() == 200) {
                String fileName = name.replaceAll("[^a-zA-Z0-9.-]", "_") + "_" + imageType.toString().toLowerCase() + ".png";
                Path outputPath = Paths.get(destination, fileName);
                Files.createDirectories(outputPath.getParent());
                Files.write(outputPath, response.body());
                return outputPath.toString();
            } else {
                System.err.println("Failed to download image: " + imageUrl + ", Status code: " + response.statusCode());
            }
        } catch (IOException | InterruptedException e) {
            System.err.println("Error downloading image: " + imageUrl);
            e.printStackTrace();
        }
        return null;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/skilling/hunter/VoxSylvaeAIOHunter/AIOHunterConfig.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.skilling.hunter.VoxSylvaeAIOHunter;
import static net.runelite.client.plugins.VoxSylvaePlugins.skilling.hunter.VoxSylvaeAIOHunter.AIOHunterConfig.GROUP;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Keybind;
import net.runelite.client.plugins.microbot.util.inventory.DropOrder;
import net.runelite.api.coords.WorldPoint;
import java.util.List;
@ConfigGroup(GROUP)
public interface AIOHunterConfig extends Config {
    String GROUP = "HuntersRumours";
    @ConfigSection(
            name = "General",
            description = "General settings",
            position = 0
    )
    String generalSection = "general";
    String huntingSection = "hunting";
    String antiBanSection = "AntiBan";
    @ConfigItem(
            keyName = "GUIDE",
            name = "GUIDE",
            description = "GUIDE",
            position = 0,
            section = generalSection
    )
    default String GUIDE() {
        return "This plugin allows for fully automated barbarian fishing at Otto's Grotto. \n\n" +
                "To use this plugin, simply start the script at Otto's Grotto with a Barbarian rod and feathers in your inventory.";
    }
    @ConfigItem(
        keyName = "toggleKeybind",
        name = "Toggle Hunter Plugin",
        description = "Keybind to start/stop the hunter plugin",        
        position = 1, // Adjust position as needed
        section = generalSection
    )
    default Keybind toggleKeybind() {
        return Keybind.NOT_SET;
    }
    @ConfigItem(
        keyName = "devDebug",
        name = "Enable developer debug",
        description = "Enable developer debug",
        position = 2, // Adjust position as needed
        section = generalSection
    )
    default boolean devDebug() {
        return true;
    }
    // drop order
    @ConfigItem(
            keyName = "dropOrder",
            name = "Drop Order",
            description = "The order in which to drop items",
            position = 3,
            section = generalSection
    )
    default DropOrder dropOrder() {
        return DropOrder.STANDARD;
    }
    @ConfigItem(
        keyName = "huntingMode",
        name = "Hunting Mode",
        description = "Choose between Hunter Rumours or Classic Hunting",
        position = 0,
        section = huntingSection
    )
    default HuntingMode huntingMode() {
        return HuntingMode.CLASSIC_HUNTING;
    }
    @ConfigItem(
        keyName = "preferredHuntingCreature",
        name = "preferred Hunting Creature",
        description = "Select the creature to hunt in classic mode",
        position = 1,
        section = huntingSection
    )
    default HunterCreatureTarget preferredHuntingCreature() {
        CreatureLocation location = new CreatureLocation("Feldip Hills", new WorldPoint(2536, 2910, 0));
        List<CreatureLocation> locations = List.of(location);
        HunterCreatureTarget tmp = new HunterCreatureTarget ("Red Chinchompa" , 63, "Box Traps", locations);
        return tmp;
    }
    @ConfigItem(
        keyName = "trapLimit",
        name = "Trap Limit",
        description = "The maximum number of traps to set"
    )
    default int trapLimit() {
        return 5;
    }
//######################### antiban settings
    @ConfigItem(
        keyName = "useAntiban",
        name = "Enable Antiban",
        description = "Enable antiban measures like random camera movements",
        section = antiBanSection
    )
    default boolean useAntiban() {
        return true;
    }
    @ConfigItem(
        keyName = "breakDuration",
        name = "Break Duration",
        description = "Duration of breaks in milliseconds",
        section = antiBanSection
    )
    default int breakDuration() {
        return 30000; // 30 seconds
    }
    enum HuntingMode {
        HUNTER_RUMOURS,
        CLASSIC_HUNTING
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/skilling/hunter/VoxSylvaeAIOHunter/AIOHunterOverlay.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.skilling.hunter.VoxSylvaeAIOHunter;
import net.runelite.client.plugins.hunter.HunterPlugin;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.fishing.barbarian.BarbarianFishingScript;
import net.runelite.client.plugins.microbot.util.antiban.Rs2Antiban;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import com.google.inject.Provides;
import net.runelite.api.Client;
import net.runelite.api.events.GameTick;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.microbot.util.mouse.VirtualMouse;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPanel;
import javax.inject.Inject;
import java.awt.*;
public class AIOHunterOverlay extends OverlayPanel{
    private final AIOHunterPlugin plugin;
    private final HuntersRumoursScript script;
    private final AIOHunterConfig config;
    @Inject
    public AIOHunterOverlay(AIOHunterPlugin plugin, HuntersRumoursScript  script,AIOHunterConfig config) {        
        super(plugin);
        this.plugin = plugin;
        this.config = config;
        this.script = script;
        setPosition(OverlayPosition.TOP_LEFT);
        setLayer(OverlayLayer.ABOVE_SCENE);        
        setNaughty();
    }
    @Override
    public Dimension render(Graphics2D graphics) {
        // Display information like traps set, animals caught, and antiban status
        //graphics.setColor(Color.WHITE);
        //graphics.drawString("Traps set: " + plugin.getTrapsSet(), 10, 10);
        //graphics.drawString("Animals caught: " + plugin.getAnimalsCaught(), 10, 25);
        try {
            panelComponent.setPreferredSize(new Dimension(250, 400));
            panelComponent.getChildren().add(TitleComponent.builder()
                    .text("\uD83E\uDD86 AIO Hunter Fisher \uD83E\uDD86")
                    .color(Color.ORANGE)
                    .build());
            panelComponent.getChildren().add(LineComponent.builder().build());
            // check if player is in the correct region(10038)
            int correctRegionId = 10038;
            HunterCreatureTarget configuredCreature = script.getTargetCreature();
            String region = Rs2Player.getWorldLocation() != null ? Rs2Player.getWorldLocation().getRegionID() == 10038 ? "In Region" : "Not in Region" : "Not in Region";
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Region: " + region)
                    .build());
            panelComponent.getChildren().add(LineComponent.builder().build());
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Barbarian rod: " + (Rs2Inventory.hasItem("Barbarian rod") ? "Present" : "Not Present"))
                    .build());
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Feathers: " + (Rs2Inventory.hasItem("feather") ? String.valueOf(Rs2Inventory.get("feather").quantity) : "Not Present"))
                    .build());
            if (configuredCreature != null) {
                String creatureName = configuredCreature.getName();               
                String method = configuredCreature.getMethod();
                int level = configuredCreature.getRequiredLevel();
                String goal = configuredCreature.getGoalName();
                int goalAmount = configuredCreature.getGoalAmount();
                String goalType = configuredCreature.getGoalTypeName();
            }else{
                String creatureName = "No creature selected";
                String method = "No method selected";
                int level = 0;
                String goal = "No goal selected";
                int goalAmount = 0;
                String goalType = "No goal type selected";
            }
            panelComponent.getChildren().add(LineComponent.builder().build());
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Creature: " + String(creatureName))
                    .build());
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Method: " + method)
                    .build());
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Level: " + configuredCreature.getRequiredLevel())
                    .build());
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Goal: " + configuredCreature.getGoalName().getGoalName())
                    .build());
            panelComponent.getChildren().add(LineComponent.builder().build());
            panelComponent.getChildren().add(LineComponent.builder().build());
            Rs2Antiban.renderAntibanOverlayComponents(panelComponent);
            panelComponent.getChildren().add(LineComponent.builder()
                    .left(Microbot.status)
                    .right("Version:" + HuntersRumoursScript.version)
                    .build());
            panelComponent.getChildren().add(LineComponent.builder().build());
                    Rs2Antiban.renderAntibanOverlayComponents(panelComponent);
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
        return super.render(graphics);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/skilling/hunter/VoxSylvaeAIOHunter/AIOHunterPlugin.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.skilling.hunter.VoxSylvaeAIOHunter;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.hunter.HunterConfig;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.antiban.AntibanOverlay;
import net.runelite.client.plugins.microbot.util.antiban.Rs2Antiban;
import net.runelite.client.plugins.microbot.util.antiban.Rs2AntibanSettings;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.mouse.VirtualMouse;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.xptracker.XpTrackerPlugin;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import net.runelite.api.AnimationID;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.InventoryID;
import net.runelite.api.Skill;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.events.StatChanged;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ProfileChanged;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.microbot.breakhandler.BreakHandlerPlugin;
import net.runelite.client.plugins.microbot.util.antiban.AntibanPlugin;
//import net.runelite.client.plugins.microbot.fishing.barbarian.BarbarianFishingConfig;
//import net.runelite.client.plugins.microbot.fishing.barbarian.BarbarianFishingScript;
import net.runelite.client.plugins.microbot.util.antiban.enums.Activity;
import net.runelite.client.plugins.microbot.util.antiban.enums.ActivityIntensity;
import net.runelite.client.plugins.microbot.util.antiban.enums.CombatSkills;
import net.runelite.client.plugins.microbot.util.antiban.ui.MasterPanel;
import net.runelite.client.plugins.VoxSylvaePlugins.util.*;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.HotkeyListener;
import net.runelite.client.util.ImageUtil;
import javax.inject.Inject;
import javax.swing.*;
import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import java.awt.image.BufferedImage;
import java.time.Duration;
import java.time.Instant;
import java.util.EnumMap;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;
import java.awt.*;
@PluginDescriptor(
    name = PluginDescriptor.TRUNC+"Hunter Rumours Plugin",
    description = "Automatically handles hunter tasks",
    tags = {"hunter", "rumours", "automation"},
    alwaysOn = false,
    hidden = false
)
@PluginDependency(XpTrackerPlugin.class)
@PluginDependency(XpTrackerPlugin.class)
@Slf4j
public class AIOHunterPlugin extends Plugin{
    public static int ticksSinceLogin;
    private static int idleTicks = 0;
    private final Map<Skill, Integer> skillExp = new EnumMap<>(Skill.class);
    private boolean ready;
    private Skill lastSkillChanged;
    private NavigationButton navButton;
    private int IDLE_TIMEOUT = 400;
    @Inject
    Notifier notifier;
    @Inject
    private Client client;
    @Inject
    private ClientThread clientThread;
    @Inject
    private AIOHunterConfig config;
    @Inject
    private OverlayManager overlayManager;
    @Inject
    private AIOHunterOverlay AIOHunterOverlay_instance;
    @Inject
    HuntersRumoursScript HuntersRumoursScript;
    private boolean isRunning = false;
    @Inject
    private KeyManager keyManager;
    private final HotkeyListener hotkeyListener = new HotkeyListener(() -> config.toggleKeybind()) {
        @Override
        public void hotkeyPressed() {
            togglePlugin();
        }
    };
    @Override
    protected void startUp() throws Exception{
       /*  final MasterPanel panel = injector.getInstance(MasterPanel.class);
        final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "antiban.png");
        navButton = NavigationButton.builder()
                .tooltip("Antiban")
                .icon(icon)
                .priority(1)
                .panel(panel)
                .build();
        Timer timer = new Timer();
        timer.scheduleAtFixedRate(new TimerTask() {
            @Override
            public void run() {
                SwingUtilities.invokeLater(panel::loadSettings);
            }
        }, 0, 600); */
        Microbot.pauseAllScripts = false;
        Microbot.setClient(client);
        Microbot.setClientThread(clientThread);
        Microbot.setNotifier(notifier);
        Microbot.setMouse(new VirtualMouse());
        if (overlayManager != null) {            
            overlayManager.add(AIOHunterOverlay_instance);
        }
        keyManager.registerKeyListener(hotkeyListener);
        //eventBus.register(this);
        //clientToolbar.addNavigation(navButton);
        //overlayManager.add(new AntibanOverlay());
    }
    @Override
    protected void shutDown() throws Exception{
        overlayManager.removeIf(overlay -> overlay instanceof AIOHunterOverlay);
        //clientToolbar.removeNavigation(navButton);
        keyManager.unregisterKeyListener(hotkeyListener);
        stopPlugin();
    }
    private void togglePlugin() {
        if (isRunning) {
            stopPlugin();
        } else {
            startPlugin();
        }
    }
    private void startPlugin() {
        if (!isRunning) {
            isRunning = true;
            ensurePluginEnabled(BreakHandlerPlugin.class , config.devDebug());
            ensurePluginEnabled(AntibanPlugin.class , config.devDebug());
            HuntersRumoursScript.run(config);
            Microbot.showMessage("AIO hunter plugin started by user");               
        }
    }
    private void stopPlugin() {
        if (isRunning) {
            isRunning = false;
            HuntersRumoursScript.shutdown();
            Microbot.showMessage("AIO hunter plugin stopped by user");                                
        }
    }
    @Provides
    AIOHunterConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(AIOHunterConfig.class);
    }
    @Subscribe
    public void onChatMessage(ChatMessage event) {
        //if (Rs2Antiban.checkForCookingEvent(event)) {
        //   updateLastCookingAction();
        //}
        if (isRunning) {
            HuntersRumoursScript.onChatMessage(event);
        }
    }
    @Subscribe
    public void onProfileChanged(ProfileChanged event) {
        Rs2Antiban.resetAntibanSettings();
        if (isRunning) {
            HuntersRumoursScript.onProfileChanged(event);
        }
    }
    @Subscribe
    public void onGameTick(GameTick event) {      
        if (isRunning) {
            HuntersRumoursScript.onGameTick();
        }        
    }
    @Subscribe
    public void onItemContainerChanged(ItemContainerChanged itemContainerChangedEvent)
    {
        if (itemContainerChangedEvent.getContainerId() == InventoryID.INVENTORY.getId())
        {
        }
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/skilling/hunter/VoxSylvaeAIOHunter/AIOHunterTaskManager.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.skilling.hunter.VoxSylvaeAIOHunter;
import com.google.gson.Gson;
import java.io.FileReader;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
public class AIOHunterTaskManager {
    private List<HunterMaster> taskMasters;
    private Map<String, HunterCreature> creatures;
    public AIOHunterTaskManager() {
        loadTaskMastersFromJson("path/to/hunterMasters.json");
        loadCreaturesFromJson("path/to/hunterCreatures.json");
    }
    private void loadTaskMastersFromJson(String path) {
        try (FileReader reader = new FileReader(path)) {
            Gson gson = new Gson();
            TaskMastersWrapper wrapper = gson.fromJson(reader, TaskMastersWrapper.class);
            taskMasters = wrapper.hunterMasters;
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    private void loadCreaturesFromJson(String path) {
        try (FileReader reader = new FileReader(path)) {
            Gson gson = new Gson();
            CreaturesWrapper wrapper = gson.fromJson(reader, CreaturesWrapper.class);
            creatures = wrapper.hunterCreatures.stream()
                .collect(Collectors.toMap(HunterCreature::getName, creature -> creature));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    public List<HunterCreature> getTasksForLevel(int hunterLevel, String taskMasterName) {
        for (HunterMaster master : taskMasters) {
            if (master.getName().equals(taskMasterName) && hunterLevel >= master.getRequiredLevel()) {
                return master.getCreatures().stream()
                    .map(creatures::get)
                    .filter(creature -> creature != null && hunterLevel >= creature.getRequiredLevel())
                    .collect(Collectors.toList());
            }
        }
        return null;
    }
    public List<HunterMaster> getTaskMasters() {
        return taskMasters;
    }
    public Map<String, HunterCreature> getCreatures() {
        return creatures;
    }
    // Wrapper classes for JSON deserialization
    private static class TaskMastersWrapper {
        List<HunterMaster> hunterMasters;
    }
    private static class CreaturesWrapper {
        List<HunterCreature> hunterCreatures;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/skilling/hunter/VoxSylvaeAIOHunter/CreatureLocation.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.skilling.hunter.VoxSylvaeAIOHunter;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
public class CreatureLocation {
    private String locationName;
    private WorldPoint worldPoint;
    public CreatureLocation(String locationName, WorldPoint worldPoint) {
        this.locationName = locationName;
        this.worldPoint = worldPoint;
    }
    // Getters
    public String getLocationName() { return locationName; }
    public WorldPoint getWorldPoint() { return worldPoint; }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/skilling/hunter/VoxSylvaeAIOHunter/HunterAreaUtils.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.skilling.hunter.VoxSylvaeAIOHunter;
import net.runelite.api.coords.WorldPoint;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
public class HunterAreaUtils {
    private static final String HUNTER_AREA_LOCATION_CLASS = "net.runelite.client.plugins.worldmap.HunterAreaLocation";
    public static List<String> getAllAreaNames() {
        try {
            Class<?> enumClass = Class.forName(HUNTER_AREA_LOCATION_CLASS);
            return Arrays.stream(enumClass.getEnumConstants())
                    .map(Object::toString)
                    .collect(Collectors.toList());
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
            return List.of();
        }
    }
    public static List<String> getAreaNamesForCreature(String creatureName) {
        try {
            Class<?> enumClass = Class.forName(HUNTER_AREA_LOCATION_CLASS);
            Method getTooltip = enumClass.getMethod("getTooltip");
            return Arrays.stream(enumClass.getEnumConstants())
                    .filter(area -> {
                        try {
                            return ((String) getTooltip.invoke(area)).toLowerCase().contains(creatureName.toLowerCase());
                        } catch (IllegalAccessException | InvocationTargetException e) {
                            e.printStackTrace();
                            return false;
                        }
                    })
                    .map(Object::toString)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            e.printStackTrace();
            return List.of();
        }
    }
    public static List<WorldPoint> getLocationsForCreature(String creatureName) {
        try {
            Class<?> enumClass = Class.forName(HUNTER_AREA_LOCATION_CLASS);
            Method getTooltip = enumClass.getMethod("getTooltip");
            Method getLocation = enumClass.getMethod("getLocation");
            return Arrays.stream(enumClass.getEnumConstants())
                    .filter(area -> {
                        try {
                            return ((String) getTooltip.invoke(area)).toLowerCase().contains(creatureName.toLowerCase());
                        } catch (IllegalAccessException | InvocationTargetException e) {
                            e.printStackTrace();
                            return false;
                        }
                    })
                    .map(area -> {
                        try {
                            return (WorldPoint) getLocation.invoke(area);
                        } catch (IllegalAccessException | InvocationTargetException e) {
                            e.printStackTrace();
                            return null;
                        }
                    })
                    .filter(wp -> wp != null)
                    .collect(Collectors.toList());
        } catch (Exception e) {
            e.printStackTrace();
            return List.of();
        }
    }
    public static List<String> getAllCreatures() {
        try {
            Class<?> enumClass = Class.forName(HUNTER_AREA_LOCATION_CLASS);
            Method getTooltip = enumClass.getMethod("getTooltip");
            return Arrays.stream(enumClass.getEnumConstants())
                    .flatMap(area -> {
                        try {
                            return Arrays.stream(((String) getTooltip.invoke(area)).split("<br>"));
                        } catch (IllegalAccessException | InvocationTargetException e) {
                            e.printStackTrace();
                            return null;
                        }
                    })
                    .filter(creature -> creature != null)
                    .map(creature -> creature.substring(0, creature.lastIndexOf('(')).trim())
                    .distinct()
                    .sorted()
                    .collect(Collectors.toList());
        } catch (Exception e) {
            e.printStackTrace();
            return List.of();
        }
    }
    public static int getRequiredLevelForCreature(String creatureName) {
        try {
            Class<?> enumClass = Class.forName(HUNTER_AREA_LOCATION_CLASS);
            Method getTooltip = enumClass.getMethod("getTooltip");
            return Arrays.stream(enumClass.getEnumConstants())
                    .flatMap(area -> {
                        try {
                            return Arrays.stream(((String) getTooltip.invoke(area)).split("<br>"));
                        } catch (IllegalAccessException | InvocationTargetException e) {
                            e.printStackTrace();
                            return null;
                        }
                    })
                    .filter(creature -> creature != null && creature.toLowerCase().startsWith(creatureName.toLowerCase()))
                    .findFirst()
                    .map(creature -> {
                        int start = creature.lastIndexOf('(') + 1;
                        int end = creature.lastIndexOf(')');
                        return Integer.parseInt(creature.substring(start, end));
                    })
                    .orElse(-1);
        } catch (Exception e) {
            e.printStackTrace();
            return -1;
        }
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/skilling/hunter/VoxSylvaeAIOHunter/HunterCreatureTarget.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.skilling.hunter.VoxSylvaeAIOHunter;
import java.util.Arrays;
import java.util.List;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Item;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
public class HunterCreatureTarget {
    private String name;
    private int requiredLevel;
    private String method;
    private List<Integer> lootIds;
    private List<CreatureLocation> locations;
    private Goal goal;
    private enum GoalType{
        CATCHES, ITEMS
    }
    private class Goal{
        private String name;
        private int id;
        private int goalAmount;
        private int currentCatchCount;
        private boolean completed;
        private GoalType type;
        public Goal(String name, int amount, GoalType type){
            this.name = name;
            this.goalAmount = goalAmount;
            this.currentCatchCount = 0;
            this.completed = false;
            this.type = type;
            //int unprocessedItemPrice = Microbot.getItemManager().search(config.ITEM().getName()).get(0).getPrice();
            //int processedItemPrice = Microbot.getItemManager().search(config.ITEM().getFinished()).get(0).getPrice();
            //profitPerPlank = processedItemPrice - unprocessedItemPrice;
        }
        public void incrementCatch(){
            this.currentCatchCount++;
            if (type == GoalType.CATCHES && this.currentCatchCount >= this.goalAmount){
                this.completed = true;
            }
        }
        public boolean isCompleted(){
            return this.completed;
        }
        public int getGoalAmount(){
            return this.goalAmount;
        }
        public String getGoalName(){
            return this.name;
        }
        public String getGoalTypeName(){
            return this.type.name();
        }
    }
    public HunterCreature(String name, int requiredLevel, String method, List<CreatureLocation> locations) {
        this.name = name;
        this.requiredLevel = requiredLevel;
        this.method = method;
        this.locations = locations;
    }
    // Getters
    public String getName() { return name; }
    public int getRequiredLevel() { return requiredLevel; }
    public String getMethod() { return method; }
    public List<CreatureLocation> getLocations() { return locations; }
    public List<Integer> getLootIds() { return lootIds; }
    public void setLootIds(List<Integer> lootIds) { this.lootIds = lootIds; }
    public int getGoalAmount() { return this.goal.getGoalAmount(); }
    public boolean isCompleted() { return this.goal.isCompleted(); }
    public void incrementCatch() { this.goal.incrementCatch(); }
    public String getGoalName() { return this.goal.getGoalName(); }
    public String getGoalTypeName() { return this.goal.getGoalTypeName(); }
    public List<String> getHuntingAreaNames(){
        //HunterAreaUtils hunterAreaUtils = new HunterAreaUtils();
        return HunterAreaUtils.getAreaNamesForCreature(this.name);
    }
    public List<WorldPoint> getHuntingAreaLocations(){
        //HunterAreaUtils hunterAreaUtils = new HunterAreaUtils();
        return HunterAreaUtils.getLocationsForCreature(this.name);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/skilling/hunter/VoxSylvaeAIOHunter/HunterMaster.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.skilling.hunter.VoxSylvaeAIOHunter;
import java.util.List;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
public class HunterMaster {
    private String name;
    private String tier;
    private int requiredLevel;
    private WorldPoint worldPoint;
    private List<String> creatures;
    private String questRequirement;
    public HunterMaster(String name, String tier, int requiredLevel, WorldPoint worldPoint, List<String> creatures, String questRequirement) {
        this.name = name;
        this.tier = tier;
        this.requiredLevel = requiredLevel;
        this.worldPoint = worldPoint;
        this.creatures = creatures;
        this.questRequirement = questRequirement;
    }
    // Getters
    public String getName() { return name; }
    public String getTier() { return tier; }
    public int getRequiredLevel() { return requiredLevel; }
    public WorldPoint getWorldPoint() { return worldPoint; }
    public List<String> getCreatures() { return creatures; }
    public String getQuestRequirement() { return questRequirement; }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/skilling/hunter/VoxSylvaeAIOHunter/HuntersRumoursScript.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.skilling.hunter.VoxSylvaeAIOHunter;
import java.util.List;
import java.util.concurrent.TimeUnit;
import com.google.inject.Inject;
import net.runelite.api.Skill;
import net.runelite.api.WallObject;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.events.ProfileChanged;
import net.runelite.client.plugins.VoxSylvaePlugins.skilling.hunter.VoxSylvaeAIOHunter.AIOHunterConfig.HuntingMode;
import net.runelite.client.plugins.VoxSylvaePlugins.util.*;
import net.runelite.client.plugins.VoxSylvaePlugins.util.navigation.*;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.Script;
import net.runelite.client.plugins.microbot.util.antiban.Rs2Antiban;
import net.runelite.client.plugins.microbot.util.antiban.Rs2AntibanSettings;
import net.runelite.client.plugins.microbot.util.antiban.enums.Activity;
import net.runelite.client.plugins.microbot.util.antiban.enums.ActivityIntensity;
import net.runelite.client.plugins.microbot.util.gameobject.Rs2GameObject;
import net.runelite.client.plugins.microbot.util.grounditem.LootingParameters;
import net.runelite.client.plugins.microbot.util.grounditem.Rs2GroundItem;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Item;
import net.runelite.client.plugins.microbot.util.npc.Rs2NpcManager;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.microbot.util.tile.Rs2Tile;
import net.runelite.client.plugins.microbot.wintertodt.enums.State;
import net.runelite.client.plugins.questhelper.runeliteobjects.extendedruneliteobjects.FaceAnimationIDs;
public class HuntersRumoursScript extends Script {
    public static String version = "0.0.1";
    public static int timeout = 0;
    private HunterCreatureTarget currentHuntingCreatureTarget = null;
    private AIOHunterConfig config;
    private AIOHunterTaskManager rumoursTaskManager;
    @Inject
    private VoxSylvaeInventoryAndBankManagementScript inventoryAndBankManagementScript;
    @Inject
    private VoxSylvaeNavigationScript navigationScript;
    /*public enum HunterState {
        CHECK_REQUIREMENTS,   // Check if the player meets the requirements for the task
        SELECT_TASK_MASTER,   // Select the task master (configured or default)
        GET_TASK,             // Get a new task from the task master
        NAVIGATE_TO_HUNT,     // Navigate to the hunting area
        PERFORM_HUNTING,      // Perform the hunting task
        CHECK_BREAK,          // Check if a break should be taken
        GET_NEW_TASK,         // After hunting, get a new task
        FINISHED              // Bot is done with the task or has finished
    }*/
    public enum HunterState {
        INITIALIZE,   // Initialize the bot
        CHECK_REQUIREMENTS,   // Check if the player meets the requirements for the task
        SELECT_TASK,   // Select the task master (configured or default)
        GET_TASK,             // Get a new task from the task master
        SETUP_INVENTORY,      // Setup the inventory for the task
        NAVIGATE_TO_HUNT,     // Navigate to the hunting area
        PERFORM_HUNTING,      // Perform the hunting task
        PERFORM_SNARE,        // Perform the snare hunting task
        CHECK_BREAK,          // Check if a break should be taken
        FINISHED              // Bot is done with the task or has finished
    }
    private HunterState currentState = HunterState.INITIALIZE;
    public static boolean resetActions = false;
    private static boolean lockState = false;
    public HunterState getCurrentState() {
        return currentState;
    }
    private void initialize(AIOHunterConfig config) {
        int hunterLevel = getSkillLevel(Skill.HUNTER);
        /*HunterTask currentTask = rumoursTaskManager.getRumourTaskForLevel(hunterLevel);*/
        //rumoursTaskManager = new HunterRumoursTaskManager();
        //classicHuntingManager = new ClassicHuntingManager();
        this.config = config;
        currentState = HunterState.CHECK_REQUIREMENTS;
        inventoryAndBankManagementScript = new VoxSylvaeInventoryAndBankManagementScript();
        navigationScript = new VoxSylvaeNavigationScript();
        loadNpcData();
    }
     private static void changeState(HunterState scriptState) {
        changeState(scriptState, false);
    }
    private static void changeState(HunterState scriptState, boolean lock) {
        if (state == scriptState || lockState) return;
        System.out.println("Changing current script state from: " + state + " to " + scriptState);
        state = scriptState;
        resetActions = true;
        setLockState(scriptState, lock);
        lockState = lock;
    }
    private static void setLockState(HunterState state, boolean lock) {
        if (lockState == lock) return;
        lockState = lock;
        System.out.println("State " + state.toString() + " has set lockState to " + lockState);
    }
    public boolean run(AIOHunterConfig config) {        
        Rs2Antiban.resetAntibanSettings();
        //Rs2Antiban.antibanSetupTemplates.applyHunterSetup();
        applyAntiBanSettings();
        Rs2Antiban.setActivity(Activity.GENERAL_HUNTER);
        //int unprocessedItemPrice = Microbot.getItemManager().search(config.ITEM().getName()).get(0).getPrice();
        //int processedItemPrice = Microbot.getItemManager().search(config.ITEM().getFinished()).get(0).getPrice();
        //profitPerPlank = processedItemPrice - unprocessedItemPrice;
        //useSetDelay = config.useSetDelay();
        //setDelay = config.setDelay();
        //useRandomDelay = config.useRandomDelay();
        //maxRandomDelay = config.maxRandomDelay();     
        initialize(config);
        mainScheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(() -> {
          try {
                if (!Microbot.isLoggedIn()) return;
                if (Microbot.pauseAllScripts) return;
                if (!super.run()) return;
                if (Rs2AntibanSettings.actionCooldownActive) return;
                /*if (startCourse == null) {
                    Microbot.showMessage("Agility course: " + config.agilityCourse().name() + " is not supported.");
                    sleep(10000);
                    return;
                }*/
                long startTime = System.currentTimeMillis();
                final LocalPoint playerLocation = Microbot.getClient().getLocalPlayer().getLocalLocation();
                final WorldPoint playerWorldLocation = Microbot.getClient().getLocalPlayer().getWorldLocation();
                handleState();
                long endTime = System.currentTimeMillis();
                long totalTime = endTime - startTime;
                System.out.println("Total time for loop " + totalTime);
            } catch (Exception ex) {
                System.out.println(ex.getMessage());
            }
        }, 0, 600, TimeUnit.MILLISECONDS);
        return true;
    }
    public void onGameTick() {
    }
    public void onChatMessage(ChatMessage event) {
    }
    public void onProfileChanged(ProfileChanged event) {
    }
    private int getSkillLevel(Skill skill) {
        return Microbot.getClient().getRealSkillLevel(skill);
    }
    @Override
    public void shutdown() {
        Rs2Antiban.resetAntibanSettings();
        super.shutdown();
        Microbot.pauseAllScripts = true;
    }
    private void loadNpcData() {
        try {
            Rs2NpcManager.loadJson();
        } catch (Exception e) {
            throw new RuntimeException("Failed to load NPC data", e);
        }
    }
    /*private void loadFoodItems() {
        try {
            List<Rs2Item> foods = Microbot.getClientThread().runOnClientThread(Rs2Inventory::getInventoryFood);
        } catch (Exception e) {
            throw new RuntimeException("Failed to load item data", e);
        }
    }*/
    private void handleState() {
        if (!super.run() || !Microbot.isLoggedIn() || Rs2Antiban.isIdleTooLong(500)) {
            //oreVein = null;
            //miningSpot = MLMMiningSpot.IDLE;
            currentState = HunterState.INITIALIZE;
            return;
        }
        //if (pickAxeInInventory.isEmpty() && config.pickAxeInInventory()) {
            //Microbot.showMessage("Pickaxe was not found in your inventory");
        //    sleep(5000);
        //    return;
        //}
        if (Rs2AntibanSettings.actionCooldownActive) return;
        if (Rs2Player.isAnimating() || Microbot.getClient().getLocalPlayer().isInteracting()) return;
        switch (currentState) {
            case INITIALIZE:
                Rs2Antiban.setActivityIntensity(Rs2Antiban.getActivity().getActivityIntensity());
                initializeHunting();
                break;
            case SELECT_TASK:
                Rs2Antiban.setActivityIntensity(Rs2Antiban.getActivity().getActivityIntensity());
                selectNewHunterTask();
                break;
            case GET_TASK:
                Rs2Antiban.setActivityIntensity(Rs2Antiban.getActivity().getActivityIntensity());
                getNewHunterTask();
                break;
            case SETUP_INVENTORY:
                Rs2Antiban.setActivityIntensity(Rs2Antiban.getActivity().getActivityIntensity());
                loadInventorySetup();
                break;
            case CHECK_REQUIREMENTS:
                //
                if (checkHunterRequirements()) {
                    currentState = HunterState.NAVIGATE_TO_HUNT;
                } else {
                    currentState = HunterState.FINISHED;
                }
                break;
            case NAVIGATE_TO_HUNT:
                if (navigateToHuntingArea()) {
                    currentState = HunterState.PERFORM_HUNTING;
                }
                break;
            case PERFORM_HUNTING:
                if (currentHuntingCreature == null) {
                    currentState = HunterState.SELECT_TASK;
                    return;
                }
                //any chinchompa: black, red, grey
                if (currentHuntingCreatureTarget.getName().toLowerCase() == "Black chinchompa".toLowerCase()
                    || currentHuntingCreatureTarget.getName().toLowerCase() == "Grey chinchompa".toLowerCase()
                    || currentHuntingCreatureTarget.getName().toLowerCase() == "Red chinchompa".toLowerCase()) {
                    Rs2Antiban.setActivity(Activity.HUNTING_BLACK_CHINCHOMPAS);                                        
                }elif (currentHuntingCreatureTarget.getName().toLowerCase() == "Moonlight Antelope".toLowerCase()) {
                    Rs2Antiban.setActivity(Activity.HUNTING_BLACK_CHINCHOMPAS);                                        
                }elif (currentHuntingCreatureTarget.getName().toLowerCase() == "Sunligth Antelope".toLowerCase()) {
                    Rs2Antiban.setActivity(Activity.HUNTING_SUNLIGHT_ANTELOPES); 
                }elif (currentHuntingCreatureTarget.getName() == "Herbiboar") {
                    Rs2Antiban.setActivity(Activity.HUNTING_HERBIBOARS);    
                }elif (currentHuntingCreatureTarget.getName() == "Moonlight Moth") {
                    Rs2Antiban.setActivityIntensity(ActivityIntensity.EXTREME);    
                }else{
                    Rs2Antiban.setActivity(Activity.GENERAL_HUNTER);
                }
                performHunting(this.currentHuntingCreatureTarget);
                break;
            case CHECK_BREAK:
                break;
            case FINISHED:
                shutdown();
                break;
        }
    }
    private void loadInventorySetup(){
        String inventorySetupName = "";//placeholder, get name from currentHuntingCreature
        if (!inventoryAndBankManagementScript.loadInventoryAndEquipment(inventorySetupName)){
            currentState = HunterState.FINISHED;
            Microbot.showMessage("Failed to load inventory setup");
        }else{
            Microbot.log(version + "<loadInventorySetup> loaded inventory setup: " + inventorySetupName+ " for hunter task: " + currentHuntingCreatureTarget.getName()+ "completed at: " +System.currentTimeMillis());
            currentState = HunterState.CHECK_REQUIREMENTS;
        }
    }
    private void selectNewHunterTask(){
        if (config.huntingMode() == HuntingMode.CLASSIC_HUNTING ) {
            //rumoursTaskManager.initialize();
            currentHuntingCreatureTarget = config.preferredHuntingCreature();
        } else {
            currentHuntingCreatureTarget = null;
            //classicHuntingManager.initialize(config.classicHuntingCreature());
        }
        currentState = HunterState.GET_TASK;
    }
    private void getNewHunterTask() {
        //getnew hunter task when we do hunter rounmours
        if (currentHuntingCreatureTarget == null) {
            //get possible task master(highst for the current level)
            //navigate to task master
            //get task by interaction with the task master npc
            //chat box, check which tast we have gotten
            //set currentHuntingCreatureTarget to the task we have gotten
            //when successful, set currentState = HunterState.SETUP_INVENTORY;
            //otherwise wait for the until we have been there,, when some thing fails, set currentState = HunterState.FINISHED;
            // currentState = HunterState.SETUP_INVENTORY;
            return;
        }
        currentState = HunterState.SETUP_INVENTORY;
        // Walk to the task master, only one step at a time
        //Microbot.getWalker().walkTo(master.getLocation());
        // Interact with the task master to get a new task (performed over multiple ticks)
        //interactWithTaskMaster(master);
    }
    private void initializeHunting() {
    }
    private WallObject findClosestVein() {
        return Rs2GameObject.getWallObjects().stream()
                .filter(this::isVein).filter(this::isWithinMiningArea).min((a, b) -> Integer.compare(distanceToPlayer(a), distanceToPlayer(b))).orElse(null);
    }
    private boolean isVein(WallObject wallObject) {
        int id = wallObject.getId();
        return id == 26661 || id == 26662 || id == 26663 || id == 26664;
    }
    private boolean isWithinMiningArea(WallObject wallObject) {
        WorldArea WEST_UPPER_AREA = new WorldArea(3748, 5676, 7, 9, 0);
        WorldArea EAST_UPPER_AREA = new WorldArea(3755, 5668, 8, 8, 0);
        boolean mineUpstairs = true;
        if (!mineUpstairs)
            return true;
        WorldPoint walkableTile = wallObject.getWorldLocation();
        return WEST_UPPER_AREA.contains(walkableTile) || EAST_UPPER_AREA.contains(walkableTile);
    }
    private int distanceToPlayer(WallObject wallObject) {
        WorldPoint closestWalkableNeighbour = Rs2Tile.getNearestWalkableTile(wallObject.getWorldLocation());
        if (closestWalkableNeighbour == null) return 999;
        return Microbot.getClient().getLocalPlayer().getWorldLocation().distanceTo2D(closestWalkableNeighbour);
    }
    private void performHunting(HunterCreatureTarget creatureTarget) {
        //check which hunting acction must be peformed, based on the current creature target
        //only start with implentation of snare hunting         
        // when we have to setup traps, find optimal locations
        // based on the current number of creatures near by number of available traps, check if the location is not occupied by game obejects(like trees, rocks, etc)-> valid tile for placeing a trap
        // for deadfall hunting only only location ->  stay at the location, check if the trap is setup, if not set it up
        // pidfall, find all near by pitfalls, check if they are setup, other player near by, switch world, occupy the location
        /*LootingParameters itemLootParams = new LootingParameters(
                                config.distanceToStray(),
                                1,
                                1,
                                config.minFreeSlots(),
                                config.toggleDelayedLooting(),
                                config.toggleLootMyItemsOnly(),
                                config.listOfItemsToLoot().split(",")
                        );
        */
        /*if (Rs2GroundItem.lootItemsBasedOnNames(itemLootParams)) {
            Microbot.pauseAllScripts = false;
            Rs2Antiban.actionCooldown();
            Rs2Antiban.takeMicroBreakByChance();
        }*/
       /* LootingParameters valueParams = new LootingParameters(
            config.minPriceOfItem(),
            config.maxPriceOfItem(),
            config.distanceToStray(),
            1,
            config.minFreeSlots(),
            config.toggleDelayedLooting(),
            config.toggleLootMyItemsOnly()
        );
        if (Rs2GroundItem.lootItemBasedOnValue(valueParams)) {
            Microbot.pauseAllScripts = false;
            Rs2Antiban.actionCooldown();
            Rs2Antiban.takeMicroBreakByChance();
        }
            Rs2Antiban.takeMicroBreakByChance();
        } */
    private void performBox(HunterCreatureTarget creatureTarget) {
        // Add logic to set traps, catch animals, and complete the task
        // This would include using the trap type in the specified location
        Rs2Antiban.actionCooldown();
        Rs2Antiban.takeMicroBreakByChance();
    }
    private void performHerbiboarHunting(HunterCreatureTarget creatureTarget) {
        // Add logic to set traps, catch animals, and complete the task
        // This would include using the trap type in the specified location
        Rs2Antiban.actionCooldown();
        Rs2Antiban.takeMicroBreakByChance();
    }
    private void performBirdHunting(HunterCreatureTarget creatureTarget) {
        // Add logic to set traps, catch animals, and complete the task
        // This would include using the trap type in the specified location
        Rs2Antiban.actionCooldown();
        Rs2Antiban.takeMicroBreakByChance();
    }
    private void performButterflyHunting(HunterCreatureTarget creatureTarget) {
        // Add logic to set traps, catch animals, and complete the task
        // This would include using the trap type in the specified location
        Rs2Antiban.actionCooldown();
        Rs2Antiban.takeMicroBreakByChance();
    }
    private void performDeadfall(HunterCreatureTarget creatureTarget) {
        // Add logic to set traps, catch animals, and complete the task
        // This would include using the trap type in the specified location
        Rs2Antiban.actionCooldown();
        Rs2Antiban.takeMicroBreakByChance();
    }
    private void performNet(HunterCreatureTarget creatureTarget) {
        // Add logic to set traps, catch animals, and complete the task
        // This would include using the trap type in the specified location
        Rs2Antiban.actionCooldown();
        Rs2Antiban.takeMicroBreakByChance();
    }
    private void performPitfall(HunterCreatureTarget creatureTarget) {
        // Add logic to set traps, catch animals, and complete the task
        // This would include using the trap type in the specified location
        Rs2Antiban.actionCooldown();
        Rs2Antiban.takeMicroBreakByChance();
    }
    private void performSnare(HunterCreatureTarget creatureTarget) {
        // Add logic to set traps, catch animals, and complete the task
        // This would include using the trap type in the specified location
        Rs2Antiban.actionCooldown();
        Rs2Antiban.takeMicroBreakByChance();
    }
    private void performTracking(HunterCreatureTarget creatureTarget) {
        // Add logic to set traps, catch animals, and complete the task
        // This would include using the trap type in the specified location
        Rs2Antiban.actionCooldown();
        Rs2Antiban.takeMicroBreakByChance();
    }
    private void findAllInteractableTraps(){
        //find all traps that are setup and ready to catch an animal
        //huntingplugin must have these logic
    }
    private void checkTrap(String trapName){
        //check if trap is setup and if it has caught an animal
        //huntingplugin must have these logic
    }
    private void setupTrap(String trapName){
        //setup trap, place it in the correct location, move loc to the correct tile, place down the trap, wait animation to finish with sleepunitl
    }
    private boolean checkHunterRequirements() {
        int hunterLevel = getSkillLevel(Skill.HUNTER);
        return true;
    }
    private boolean navigateToHuntingArea() {
        WorldPoint destination = null;
        if (currentHuntingCreatureTarget != null) {
            List<CreatureLocation> locations = currentHuntingCreatureTarget.getLocations();
            if (locations != null && !locations.isEmpty()) {
                destination = locations.get(0).getWorldPoint();
            }
            if (!navigationScript.walkTo(destination, 1)){
                Microbot.showMessage("Failed to navigate to hunting area");
                currentState= HunterState.FINISHED;
            }
        }
        //Rs2Antiban.actionCooldown();
        Rs2Antiban.takeMicroBreakByChance();
        return false;
    }
    private void applyAntiBanSettings() {
        Rs2AntibanSettings.antibanEnabled = true;
        Rs2AntibanSettings.usePlayStyle = true;
        Rs2AntibanSettings.simulateFatigue = true;
        Rs2AntibanSettings.simulateAttentionSpan = true;
        Rs2AntibanSettings.behavioralVariability = true;
        Rs2AntibanSettings.nonLinearIntervals = true;
        Rs2AntibanSettings.naturalMouse = true;
        Rs2AntibanSettings.moveMouseOffScreen = true;
        Rs2AntibanSettings.contextualVariability = true;
        Rs2AntibanSettings.dynamicIntensity = true;
        Rs2AntibanSettings.devDebug = false;
        Rs2AntibanSettings.moveMouseRandomly = true;
        Rs2AntibanSettings.takeMicroBreaks = true;
        Rs2AntibanSettings.microBreakDurationLow = 3;
        Rs2AntibanSettings.microBreakDurationHigh = 15;
        Rs2AntibanSettings.actionCooldownChance = 0.4;
        Rs2AntibanSettings.microBreakChance = 0.15;
        Rs2AntibanSettings.moveMouseRandomlyChance = 0.1;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/navigation/VoxSylvaeNavigationConfig.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.util.navigation;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.plugins.microbot.giantsfoundry.enums.SmithableBars;
import net.runelite.client.plugins.microbot.thieving.enums.ThievingNpc;
@ConfigGroup(VoxSylvaeNavigationConfig.GROUP)
public interface VoxSylvaeNavigationConfig extends Config {
    String GROUP = "VoxSylvaeNavigation";
    @ConfigItem(
            keyName = "guide",
            name = "How to use",
            description = "How to use this plugin",
            position = 1
    )
    default String GUIDE() {
        return "Start at the giants foundry minigame\n" +
                "Please select the bars in your UI\n" +
                "Make sure to have ice gloves on\n" +
                "Make sure to have no weapon or shield on";
    }
    @ConfigItem(
            keyName = "FirstBar",
            name = "First Bar",
            description = "Choose the first type of bar",
            position = 0
    )
    default SmithableBars FirstBar()
    {
        return SmithableBars.STEEL_BAR;
    }
    @ConfigItem(
            keyName = "SecondBars",
            name = "Second Bar",
            description = "Choose the second type of bar",
            position = 0
    )
    default SmithableBars SecondBar()
    {
        return SmithableBars.MITHRIL_BAR;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/navigation/VoxSylvaeNavigationOverlay.java
================
/*
 * Copyright (c) 2018, Seth <https://github.com/sethtroll>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package net.runelite.client.plugins.VoxSylvaePlugins.util.navigation;
import net.runelite.api.Client;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import javax.inject.Inject;
import java.awt.*;
import static net.runelite.api.Constants.CHUNK_SIZE;
public class VoxSylvaeNavigationOverlay extends OverlayPanel {
    private final Client client;
    //private final VoxSylvaeNavigationPlugin plugin;
    private final VoxSylvaeNavigationScript navigationScript;
    @Inject
    //VoxSylvaeNavigationOverlay(Client client, VoxSylvaeNavigationPlugin plugin, VoxSylvaeNavigationScript script) {
    VoxSylvaeNavigationOverlay(Client client, VoxSylvaeNavigationScript script) {
        this.client = client;        
        this.navigationScript = script;
        setPosition(OverlayPosition.TOP_LEFT);
        setLayer(OverlayLayer.ABOVE_SCENE);        
        setNaughty();
        setPosition(OverlayPosition.TOP_LEFT);
    }
    @Override
    public Dimension render(Graphics2D graphics) {
        //if (!navigationScript.getCurrentDesiredLocation()) {
         //   return null;
        //}
        WorldPoint worldPoint = client.getLocalPlayer().getWorldLocation();
        LocalPoint localPoint = client.getLocalPlayer().getLocalLocation();
        if (client.isInInstancedRegion()) {
            worldPoint = WorldPoint.fromLocalInstance(client, localPoint);
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Instance")
                    .build());
        }
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Local")
                .right(localPoint.getX() + ", " + localPoint.getY())
                .build());
        panelComponent.getChildren().add(LineComponent.builder()
                .left("World")
                .right(worldPoint.getX() + ", " + worldPoint.getY() + ", " + client.getPlane())
                .build());
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Region")
                .right(worldPoint.getRegionX() + ", " + worldPoint.getRegionY() + ", " + worldPoint.getRegionID())
                .build());
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Scene")
                .right(localPoint.getSceneX() + ", " + localPoint.getSceneY())
                .build());
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Tile")
                .right(localPoint.getSceneX() / 128 + ", " + localPoint.getSceneY() / 128)
                .build());
        WorldPoint currentDesWorldPoint = navigationScript.getCurrentDesiredLocation();
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Desired Location")
                .right( currentDesWorldPoint.getX()+ ", " + currentDesWorldPoint.getY() + ", " + currentDesWorldPoint.getPlane())
                .build());
        int[][][] instanceTemplateChunks = client.getInstanceTemplateChunks();
        int z = client.getPlane();
        int chunkData = instanceTemplateChunks[z][localPoint.getSceneX() / CHUNK_SIZE][localPoint.getSceneY() / CHUNK_SIZE];
        int rotation = chunkData >> 1 & 0x3;
        int chunkY = (chunkData >> 3 & 0x7FF) * CHUNK_SIZE;
        int chunkX = (chunkData >> 14 & 0x3FF) * CHUNK_SIZE;
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Chunk " + localPoint.getSceneX() / CHUNK_SIZE + "," + localPoint.getSceneY() / CHUNK_SIZE)
                .right(rotation + " " + chunkX + " " + chunkY)
                .build());
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Base")
                .right(client.getBaseX() + ", " + client.getBaseY())
                .build());
        for (int i = 0; i < client.getMapRegions().length; i++) {
            int region = client.getMapRegions()[i];
            int mx = region >> 8;
            int my = region & 0xff;
            panelComponent.getChildren().add(LineComponent.builder()
                    .left((i == 0) ? "Map regions" : " ")
                    .right(mx + ", " + my)
                    .rightColor((region == worldPoint.getRegionID()) ? Color.GREEN : Color.WHITE)
                    .build());
        }
        panelComponent.getChildren().add(LineComponent.builder()
                .left("State: ")
                .right(navigationScript.getNavigationState()+"")
                .rightColor( (navigationScript.getNavigationState() == VoxSylvaeNavigationScript.NavigationState.IDLE)? Color.GREEN:Color.RED )
                .build());
        panelComponent.getChildren().add(LineComponent.builder()
        .left("Status:")
        .right(navigationScript.getNavigationStatus()+"")
        .build());
        return super.render(graphics);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/navigation/VoxSylvaeNavigationPlugin.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.util.navigation;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.shortestpath.ShortestPathPlugin;
import net.runelite.client.plugins.microbot.shortestpath.Transport;
import net.runelite.client.plugins.microbot.shortestpath.pathfinder.Pathfinder;
import net.runelite.client.plugins.microbot.shortestpath.Transport;
import net.runelite.client.plugins.microbot.util.walker.Rs2Walker;
import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Point;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.GameTick;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.JagexColors;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ColorUtil;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.util.Text;
import java.awt.image.BufferedImage;
import net.runelite.api.*;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.MenuEntryAdded;
import net.runelite.api.events.MenuOpened;
import net.runelite.api.widgets.*;
import net.runelite.api.widgets.Widget;
import net.runelite.api.worldmap.WorldMap;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ConfigChanged;
import net.runelite.client.game.SpriteManager;
import net.runelite.client.input.KeyListener;
import net.runelite.client.input.KeyManager;
import javax.inject.Inject;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Arrays;
import java.util.LinkedList;
import java.awt.datatransfer.StringSelection;
@PluginDescriptor(
        name = PluginDescriptor.TRUNC + "Example",
        description = "Microbot example plugin",
        tags = {"example", "microbot"},
        enabledByDefault = false
)
@Slf4j
public class VoxSylvaeNavigationPlugin extends Plugin {
    @Inject
    private VoxSylvaeNavigationConfig config;
    @Inject
    private Client client;
    @Provides
    VoxSylvaeNavigationConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(VoxSylvaeNavigationConfig.class);
    }
    @Inject
    private OverlayManager overlayManager;
    @Inject
    private VoxSylvaeNavigationOverlay VoxSylvaeNavigationOverlay;
    @Inject
    VoxSylvaeNavigationScript VoxSylvaeNavigationScript;
    @Override
    protected void startUp() throws AWTException {
        if (overlayManager != null) {
            overlayManager.add(VoxSylvaeNavigationOverlay);
        }
        VoxSylvaeNavigationScript.run(Microbot.getClient(),config);
    }
    protected void shutDown() {
        VoxSylvaeNavigationScript.shutdown();
        overlayManager.remove(VoxSylvaeNavigationOverlay);
    }
    int ticks = 10;
    @Subscribe
    public void onGameTick(GameTick tick)
    {
        //System.out.println(getName().chars().mapToObj(i -> (char)(i + 3)).map(String::valueOf).collect(Collectors.joining()));
        if (ticks > 0) {
            ticks--;
        } else {
            ticks = 10;
        }
    }
    private void addMenuEntry(MenuEntryAdded event, String option, String target, int position) {
        List<MenuEntry> entries = new LinkedList<>(Arrays.asList(client.getMenuEntries()));
        if (entries.stream().anyMatch(e -> e.getOption().equals(option) && e.getTarget().equals(target))) {
            return;
        }
        client.createMenuEntry(position)
                .setOption(option)
                .setTarget(target)
                .setParam0(event.getActionParam0())
                .setParam1(event.getActionParam1())
                .setIdentifier(event.getIdentifier())
                .setType(MenuAction.RUNELITE)
                .onClick(this::onMenuOptionClicked);
    }
    @Subscribe
    public void onMenuEntryAdded(MenuEntryAdded event) {
        Pathfinder pathfinder = ShortestPathPlugin.getPathfinder();
        if (client.isKeyPressed(KeyCode.KC_SHIFT) && event.getOption().equals(WALK_HERE) && event.getTarget().isEmpty()) {
            if (config.drawTransports()) {
                addMenuEntry(event, ADD_START, TRANSPORT, 1);
                addMenuEntry(event, ADD_END, TRANSPORT, 1);
                // addMenuEntry(event, "Copy Position");
            }
            addMenuEntry(event, SET, TARGET, 1);
            if (pathfinder != null) {
                if (pathfinder.getTarget() != null) {
                    addMenuEntry(event, SET, START, 1);
                }
                WorldPoint selectedTile = getSelectedWorldPoint();
                if (pathfinder.getPath() != null) {
                    for (WorldPoint tile : pathfinder.getPath()) {
                        if (tile.equals(selectedTile)) {
                            addMenuEntry(event, CLEAR, PATH, 1);
                            break;
                        }
                    }
                }
            }
        }
        final Widget map = client.getWidget(ComponentID.WORLD_MAP_MAPVIEW);
        if (map != null && map.getBounds().contains(client.getMouseCanvasPosition().getX(), client.getMouseCanvasPosition().getY())) {
            addMenuEntry(event, SET, TARGET, 0);
            if (pathfinder != null) {
                if (pathfinder.getTarget() != null) {
                    addMenuEntry(event, SET, START, 0);
                    addMenuEntry(event, CLEAR, PATH, 0);
                }
            }
        }
        final Shape minimap = getMinimapClipArea();
        if (minimap != null && pathfinder != null &&
                minimap.contains(client.getMouseCanvasPosition().getX(), client.getMouseCanvasPosition().getY())) {
            addMenuEntry(event, CLEAR, PATH, 0);
        }
        if (minimap != null && pathfinder != null &&
                ("Floating World Map".equals(Text.removeTags(event.getOption())) ||
                        "Close Floating panel".equals(Text.removeTags(event.getOption())))) {
            addMenuEntry(event, CLEAR, PATH, 1);
        }
    }
    protected static final String CONFIG_GROUP = "shortestpath";
    private static final String ADD_START = "Add start";
    private static final String ADD_END = "Add end";
    private static final String CLEAR = "Clear";
    private static final String PATH = ColorUtil.wrapWithColorTag("Path", JagexColors.MENU_TARGET);
    private static final String SET = "Set";
    private static final String START = ColorUtil.wrapWithColorTag("Start", JagexColors.MENU_TARGET);
    private static final String TARGET = ColorUtil.wrapWithColorTag("Target[VS]", JagexColors.MENU_TARGET);
    private static final String TRANSPORT = ColorUtil.wrapWithColorTag("Transport", JagexColors.MENU_TARGET);
    private static final String WALK_HERE = "Walk here";
    public static final BufferedImage MARKER_IMAGE = ImageUtil.loadImageResource(ShortestPathPlugin.class, "marker.png");
    private MenuEntry lastClick;
    private Point lastMenuOpenedPoint;
    private static final WorldPoint transportStart = null;
    @Subscribe
    public void onMenuOpened(MenuOpened event) {
        lastMenuOpenedPoint = client.getMouseCanvasPosition();
    }
    private void onMenuOptionClicked(MenuEntry entry) {
        Player localPlayer = client.getLocalPlayer();
        if (localPlayer == null) {
            return;
        }
        WorldPoint currentLocation = client.isInInstancedRegion() ?
                WorldPoint.fromLocalInstance(client, localPlayer.getLocalLocation()) : localPlayer.getWorldLocation();
        if (entry.getOption().equals(ADD_START) && entry.getTarget().equals(TRANSPORT)) {
            transportStart = currentLocation;
        }
        if (entry.getOption().equals(ADD_END) && entry.getTarget().equals(TRANSPORT)) {
            WorldPoint transportEnd = client.isInInstancedRegion() ?
                    WorldPoint.fromLocalInstance(client, localPlayer.getLocalLocation()) : localPlayer.getWorldLocation();
            System.out.println(transportStart.getX() + " " + transportStart.getY() + " " + transportStart.getPlane() + " " +
                    currentLocation.getX() + " " + currentLocation.getY() + " " + currentLocation.getPlane() + " " +
                    lastClick.getOption() + " " + Text.removeTags(lastClick.getTarget()) + " " + lastClick.getIdentifier()
            );
            Transport transport = new Transport((WorldPoint)transportStart,(WorldPoint) transportEnd);
            pathfinderConfig.getTransports().computeIfAbsent(transportStart, k -> new ArrayList<>()).add(transport);
        }
        if (entry.getOption().equals("Copy Position")) {
            Toolkit.getDefaultToolkit().getSystemClipboard().setContents(
                    new StringSelection("(" + currentLocation.getX() + ", "
                            + currentLocation.getY() + ", "
                            + currentLocation.getPlane() + ")"), null);
        }
        if (entry.getOption().equals(SET) && entry.getTarget().equals(TARGET)) {
            Rs2Walker.walkTo(getSelectedWorldPoint());
        }
        if (entry.getOption().equals(SET) && entry.getTarget().equals(START)) {
            setStart(getSelectedWorldPoint());
        }
        if (entry.getOption().equals(CLEAR) && entry.getTarget().equals(PATH)) {
            Rs2Walker.setTarget(null);
        }
        if (entry.getType() != MenuAction.WALK) {
            lastClick = entry;
        }
    }
    private WorldPoint getSelectedWorldPoint() {
        if (client.getWidget(ComponentID.WORLD_MAP_MAPVIEW) == null) {
            if (client.getSelectedSceneTile() != null) {
                return client.isInInstancedRegion() ?
                        WorldPoint.fromLocalInstance(client, client.getSelectedSceneTile().getLocalLocation()) :
                        client.getSelectedSceneTile().getWorldLocation();
            }
        } else {
            return calculateMapPoint(client.isMenuOpen() ? lastMenuOpenedPoint : client.getMouseCanvasPosition());
        }
        return null;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/navigation/VoxSylvaeNavigationScript.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.util.navigation;
import net.runelite.client.plugins.VoxSylvaePlugins.util.*;
import net.runelite.client.plugins.VoxSylvaePlugins.util.teleport.TeleportationManager;
import net.runelite.client.plugins.microbot.util.antiban.Rs2Antiban;
import net.runelite.client.plugins.microbot.util.antiban.Rs2AntibanSettings;
import net.runelite.client.plugins.VoxSylvaePlugins.util.teleport.Teleport;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.magic.Rs2Magic;
import net.runelite.client.plugins.microbot.util.walker.Rs2Walker;
import net.runelite.client.plugins.microbot.vorkath.VorkathScript;
import net.runelite.client.plugins.microbot.util.gameobject.Rs2GameObject;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.bank.Rs2Bank;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.microbot.util.tile.Rs2Tile;
import net.runelite.client.plugins.skillcalculator.skills.MagicAction;
import net.runelite.client.plugins.microbot.Script;
import net.runelite.client.plugins.microbot.crafting.enums.BoltTips;
import net.runelite.client.plugins.microbot.shortestpath.ShortestPathPlugin;
import net.runelite.client.plugins.microbot.util.keyboard.Rs2Keyboard;
import javax.inject.Inject;
import lombok.Getter;
import java.awt.event.KeyEvent;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.Random;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import static net.runelite.client.plugins.microbot.util.Global.sleep;
import net.runelite.api.*;
public class VoxSylvaeNavigationScript extends Script {
    enum NavigationState {
        IDLE,
        WAITING_FOR_PATH_FINDING,
        WALKING,
        WAITING_FOR_TELEPORTAION,
        TELEPORTING,        
    }
    @Inject
    private VoxSylvaeInventoryAndBankManagementScript inventoryAndBankManagementScript;
    @Inject
    private Client client;
    private static TeleportationManager teleportationManager;
    private static Map<String, Teleport> availableTeleports = new HashMap<>();
    private static final WorldPoint BANK_LOCATION = new WorldPoint(3183, 3436, 0); // Example: Varrock West Bank
    private NavigationState navigationState = NavigationState.IDLE;
    @Getter
    private String statusLast = "...";
    private WorldPoint currentDesiredLocation = null;
    private VoxSylvaeNavigationConfig config;
    public String getNavigationStatus() {
       return statusLast; 
    }
    public NavigationState getNavigationState() {
        return navigationState;
    }
    public WorldPoint getCurrentDesiredLocation() {
        return currentDesiredLocation;
    }
    private void initialize() {
        //add cache for path, init teleporatiom manager
        teleportationManager = new TeleportationManager(client);
        loadAllTeleports();
        checkPlayerTeleports();
    }
    private void loadAllTeleports() {
    }
    public boolean run(Client client, VoxSylvaeNavigationConfig config) {
        Microbot.enableAutoRunOn = true;
        Microbot.pauseAllScripts = false;
        //init = true;
        //state = State.BANKING;
        //hasEquipment = false;
        //hasInventory = false;
        //VorkathScript.config = config;
        //tempVorkathKills = config.SellItemsAtXKills();
        Microbot.getSpecialAttackConfigs().setSpecialAttack(true);
        this.config = config;
        if (client == null) {
          this.client = Microbot.getClient();
        }else{
          this.client = client;
        }        
        initialize();
        mainScheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(() -> {
            try {
                if (!Microbot.isLoggedIn()) return;
                if (!super.run()) return;
            } catch (Exception ex) {
                System.out.println(ex.getMessage());
            }
        }, 0, 1000, TimeUnit.MILLISECONDS);
        return true;
    }
    private static void checkPlayerTeleports() {
        int magicLevel = getSkillLevel(Skill.MAGIC);
        for (Map.Entry<String, Teleport> entry : availableTeleports.entrySet()) {
            Teleport teleportEntry = entry.getValue();
            if (magicLevel >= teleportEntry.getRequiredLevel() && VoxSylvaeInventoryAndBankManagementScript.hasAllItemsInInventory(teleportEntry.getRequiredItems())) {
                //info.isAvailable = true;
            }
        }
    }
    /*public boolean teleportToLocation(String teleportName, WorldPoint finalDestination) {
        TeleportInfo teleport = availableTeleports.get(teleportName);
        if (teleport != null && teleport.isAvailable) {
            Rs2Magic.castSpell(teleport.spell);
            sleep(3000, 4000);
            if (!Microbot.getClient().getLocalPlayer().getWorldLocation().equals(finalDestination)) {
                return walkTo(finalDestination,2);
            }
            return true;
        } else {
            System.out.println("Teleport not available: " + teleportName);
            return walkTo(finalDestination,2);
        }
    }*/
    private boolean navigateToWithTeleport(WorldPoint destination, int distance) {
        // find the nearest teleport to the destination
        Teleport nearestTeleport = teleportationManager.findNearestTeleport(destination, true);
        if (Rs2Walker.getDistanceBetween(Rs2Player.getWorldLocation(), destination) > distance) {
            return navigateTo(destination, distance);
        } else {
            return true;
        }
    }
    private boolean navigateTo(WorldPoint destination, int distance) {
        this.navigationState = NavigationState.WAITING_FOR_PATH_FINDING;
        this.currentDesiredLocation = destination;
        mainScheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(() -> {
            try {
                while (this.navigationState != NavigationState.IDLE) {
                    //Rs2Walker.walkTo(NORTH_OF_WEB, 2);
                    //return sleepUntil(() -> Rs2Walker.getDistanceBetween(playerLocation, NORTH_OF_WEB) < 5 && !Rs2Player.isMoving(), 300);
                    if (ShortestPathPlugin.getPathfinder() == null) {
                        if (ShortestPathPlugin.getMarker() == null)
                            break;
                            statusLast = "[VS Navigation] Waiting for pathfinder ready...";
                        continue;
                    }
                    if (!ShortestPathPlugin.getPathfinder().isDone()) {
                        statusLast = "[VS Navigation] Waiting for path calculation...";
                        continue;
                    }
                    Microbot.log("Start Walk to destination. " + "x:" + destination.getX() + "y:" + destination.getY() + "distance:" + distance);
                    this.navigationState = NavigationState.WALKING;
                    sleepUntil(() -> Rs2Walker.walkTo(destination, distance) && !Rs2Player.isMoving());
                    this.navigationState = NavigationState.IDLE;
                }
            } catch (Exception ex) {
                this.navigationState = NavigationState.IDLE;
                System.out.println(ex.getMessage());
            }
        }, 0, 600, TimeUnit.MILLISECONDS);
        //sleepUntil(() -> Rs2Walker.walkTo(destination, distance) && !Rs2Player.isMoving(), 300);
        return true;
    }
    public boolean navigateAndOpenBank ( WorldPoint desiredBankLocation) {
        if (Rs2Player.getWorldLocation().equals(desiredBankLocation)) {
            return inventoryAndBankManagementScript.openBank();
        } else {
            naviagateTo(desiredBankLocation, 2);
            sleepUntil(()->NavigationState.IDLE == navigationState);
            return inventoryAndBankManagementScript.openBank();
        }
    }
    public boolean navigateWithAntiBan(WorldPoint destination, int distance) {
        // get antiban settings
        //Rs2AntibanSettings Rs2AntibanSettings = new Rs2AntibanSettings();
        Microbot.pauseAllScripts = false;
        return walkTo(Rs2Player.getWorldLocation(), 2);
        //Rs2Antiban.actionCooldown();
        //Rs2Antiban.takeMicroBreakByChance();
    }
    private void applyAntiBanSettings() {
        Rs2AntibanSettings.antibanEnabled = true;
        Rs2AntibanSettings.usePlayStyle = true;
        Rs2AntibanSettings.simulateFatigue = true;
        Rs2AntibanSettings.simulateAttentionSpan = true;
        Rs2AntibanSettings.behavioralVariability = true;
        Rs2AntibanSettings.nonLinearIntervals = true;
        Rs2AntibanSettings.naturalMouse = true;
        Rs2AntibanSettings.moveMouseOffScreen = true;
        Rs2AntibanSettings.contextualVariability = true;
        Rs2AntibanSettings.dynamicIntensity = true;
        Rs2AntibanSettings.devDebug = false;
        Rs2AntibanSettings.moveMouseRandomly = true;
        Rs2AntibanSettings.takeMicroBreaks = true;
        Rs2AntibanSettings.microBreakDurationLow = 3;
        Rs2AntibanSettings.microBreakDurationHigh = 15;
        Rs2AntibanSettings.actionCooldownChance = 0.4;
        Rs2AntibanSettings.microBreakChance = 0.15;
        Rs2AntibanSettings.moveMouseRandomlyChance = 0.1;
    }
    public boolean navigateToAreaByName(String  AreaName, int radius) {
        //notimplented yet
        assert false;
        WorldPoint currentLocation = Rs2Player.getWorldLocation();
        // logic for getting area location coordiantes
        if (currentLocation != null) {
            WorldPoint destinationArea = null;
            // First, try to teleport close to the destination
            //TODO implement this
            //TeleportationType nearestTeleport = findNearestTeleport(destination);
            WorldPoint nearestTeleportationLocation = null;
            //
            if (nearestTeleportationLocation != null) {
                return false;
                //HunterMovementUtils.teleportToLocation(nearestTeleport, destination);
            }
            // Then, walk to the exact location
            return walkTo(destinationArea,radius);
        }
        return false;   
    }
    public boolean navigateToAreaByName(String areaName) {
        return navigateToAreaByName(areaName, 2);
    }
    public boolean canNavigateToObject(GameObject gameObject) {
        return !Rs2Tile.areSurroundingTilesWalkable(gameObject.getWorldLocation(), gameObject.sizeX(), gameObject.sizeY());
    }
    public static boolean useItemOnObject(String itemName, int objectId) {
        TileObject targetObject = Rs2GameObject.findObjectById(objectId);            
        taragetObjectReachable = h
        if (Rs2Inventory.hasItem(itemName)) {
            if (targetObject != null ) {
                useItemOnObject(Rs2Inventory.get(itemName)).getId(),cookingObject.getId())
                return true;
            }
        }else{
            Microbot.log(itemName + " not in inventory. ," + targetObject!=null:targetObeject.getName(), null);
            return false;
        }
    }
    private static int getSkillLevel(Skill skill) {
        return Microbot.getClient().getRealSkillLevel(skill);
    }
    @Override
    public void shutdown() {
        super.shutdown();
        Microbot.pauseAllScripts = true;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/teleport/AbstractTeleport.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.util.teleport;
import net.runelite.api.QuestState;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.api.Quest;
import java.util.ArrayList;
import java.util.List;
public abstract class AbstractTeleport implements Teleport {
    protected String name;
    protected TeleportType type;
    protected int requiredLevel;
    protected List<ItemQuantity> requiredItems;
    protected List<String> requiredQuests;
    protected List<WorldPoint> destinations;
    protected boolean isEquippable;
    protected int charges;
    public AbstractTeleport(String name, TeleportType type, int requiredLevel, List<ItemQuantity> requiredItems, List<String> requiredQuests, List<WorldPoint> destinations, boolean isEquippable, int charges) {
        this.name = name;
        this.type = type;
        this.requiredLevel = requiredLevel;
        this.requiredItems = requiredItems;
        this.requiredQuests = requiredQuests;
        this.destinations = destinations;
        this.isEquippable = isEquippable;
        this.charges = charges;
    }
    // Implement getters for all fields
    @Override
    public boolean isEquippable() {
        return isEquippable;
    }
    @Override
    public int getCharges() {
        return charges;
    }
    @Override
    public String getName() { return name; }
    @Override
    public TeleportType getType() { return type; }
    @Override
    public int getRequiredLevel() { return requiredLevel; }
    @Override
    public List<Quest> getRequiredQuests() { 
        List<Quest> quests = new ArrayList<>();
        for (String questName : requiredQuests) {
            for (Quest quest : Quest.values()) {
                if (quest.getName().equals(questName)) {
                    quests.add(quest);
                    break;
                }
            }
            //if (!Rs2Player.isQuestCompleted(quest)) {
            //    return false;
            //}
        }
        return quests; 
    }
    @Override
    public List<String> getRequiredQuestsString() { 
            return requiredQuests; }
    @Override
    public List<WorldPoint> getDestinations() { return destinations; }
    @Override
    public double getDistanceTo(WorldPoint destination) {
        return destinations.stream()
                .mapToDouble(d -> d.distanceTo2D(destination))
                .min()
                .orElse(Double.MAX_VALUE);
    }
    @Override
    public List<ItemQuantity> getRequiredItems() {
        return requiredItems;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/teleport/FairyRingTeleport.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.util.teleport;
import net.runelite.api.coords.WorldPoint;
import java.io.FileReader;
import java.io.IOException;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.Map;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
public class FairyRingTeleport extends AbstractTeleport {
    private String code;
    private String location;
    private String notes;
    private List<String> pointsOfInterest;
    public FairyRingTeleport(String name, int requiredLevel, List<ItemQuantity> requiredItems, 
                             List<String> requiredQuests, List<WorldPoint> destinations, 
                             String code, String location, String notes, List<String> pointsOfInterest) {
        super(name, TeleportType.FAIRY_RING, requiredLevel, requiredItems, requiredQuests, destinations, false, -1);
        this.code = code;
        this.location = location;
        this.notes = notes;
        this.pointsOfInterest = pointsOfInterest;
    }
    public String getCode() {
        return code;
    }
    public String getLocation() {
        return location;
    }
    public String getNotes() {
        return notes;
    }
    @Override
    public boolean isEquippable() {
        return false;  // Fairy rings are not equippable items
    }
    @Override
    public int getCharges() {
        return -1;  // Fairy rings have infinite charges
    }
    public List<String> getPointsOfInterest() {
        return pointsOfInterest;
    }
    public WorldPoint getDestination() {
        assert getDestinations().size() == 1;
        return getDestinations().get(0);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/teleport/ItemQuantity.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.util.teleport;
public class ItemQuantity {
    private String name;
    private int quantity;
    public ItemQuantity(String name, int quantity) {
        this.name = name;
        this.quantity = quantity;
    }
    public String getName() {
        return name;
    }
    public int getQuantity() {
        return quantity;
    }
    @Override
    public String toString() {
        return quantity + " x " + name;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/teleport/POHTeleport.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.util.teleport;
import net.runelite.api.coords.WorldPoint;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
public class POHTeleport extends AbstractTeleport {
    private String furniture;
    private Map<String, List<POHDestination>> teleports;
    public POHTeleport(String name, String furniture, Map<String, List<POHDestination>> teleports, int requiredLevel, List<ItemQuantity> requiredItems, List<String> requiredQuests) {
        super(
            name,
            TeleportType.POH,
            requiredLevel,
            requiredItems,
            requiredQuests,
            teleports.values().stream()
                .flatMap(List::stream)
                .map(POHDestination::getCoordinates)
                .collect(Collectors.toList()),
            false,  // isEquippable
            -1      // charges (generally infinite for POH teleports)
        );
        this.furniture = furniture;
        this.teleports = teleports;
    }
    public String getFurniture() {
        return furniture;
    }
    public Map<String, List<POHDestination>> getTeleports() {
        return teleports;
    }
    @Override
    public boolean isEquippable() {
        return false;  // POH teleports are not equippable items
    }
    @Override
    public int getCharges() {
        return -1;  // POH teleports generally have infinite charges
    }
    public static class POHDestination {
        private String name;
        private WorldPoint coordinates;
        public POHDestination(String name, WorldPoint coordinates) {
            this.name = name;
            this.coordinates = coordinates;
        }
        public String getName() {
            return name;
        }
        public WorldPoint getCoordinates() {
            return coordinates;
        }
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/teleport/ShortestPathResult.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.util.teleport;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.microbot.shortestpath.Transport;
import java.io.*;
import java.lang.reflect.Type;
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.Collectors; 
public class ShortestPathResult {
    private final List<WorldPoint> path;
    private final Map<WorldPoint, List<Transport>> transports;
    private final int distance;
    private final WorldPoint start;
    private final WorldPoint end;
    ShortestPathResult(List<WorldPoint> path, Map<WorldPoint, List<Transport>> transports, int distance, WorldPoint start, WorldPoint end) {
        this.path = path;
        this.transports = transports;
        this.distance = distance;
        this.start = start;
        this.end = end;
    }
    public int getDistance() {
        return distance;
    }
    public WorldPoint getStart() {
        return start;
    }
    public WorldPoint getEnd() {
        return end;
    }
    public List<WorldPoint> getPath() {
        return path;
    }
    public Map<WorldPoint, List<Transport>> getTransports() {
        return transports;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/teleport/SpellbookTeleport.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.util.teleport;
import net.runelite.api.coords.WorldPoint;
import java.util.List;
public class SpellbookTeleport extends AbstractTeleport {
    private final String location;
    private final boolean membersOnly;
    public SpellbookTeleport(String name, TeleportType type, int requiredLevel, List<ItemQuantity> requiredItems, 
                             List<String> requiredQuests, List<WorldPoint> destinations, 
                             String location, boolean membersOnly) {
        super(
            name,
            type,
            requiredLevel,
            requiredItems,
            requiredQuests,
            destinations,
            false,  // isEquippable
            -1      // charges (spellbook teleports don't have charges)
        );
        this.location = location;
        this.membersOnly = membersOnly;
    }
    @Override
    public boolean isEquippable() {
        return false;  // Spellbook teleports are not equippable items
    }
    @Override
    public int getCharges() {
        return -1;  // Spellbook teleports don't have charges
    }
    // You might want to add a method to get the rune cost of the spell
    public List<ItemQuantity> getRuneCost() {
        return getRequiredItems();
    }
    public WorldPoint getDestination() {
        assert getDestinations().size() == 1;
        return getDestinations().get(0);
    }
    // Getter for location
    public String getLocation() {
        return location;
    }
    // Getter for membersOnly flag
    public boolean isMembersOnly() {
        return membersOnly;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/teleport/Teleport.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.util.teleport;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.Quest;
import java.util.List;
public interface Teleport {
    String getName();
    TeleportType getType();
    int getRequiredLevel();
    List<ItemQuantity> getRequiredItems();
    List<String> getRequiredQuestsString();
    List<Quest> getRequiredQuests();
    List<WorldPoint> getDestinations();
    double getDistanceTo(WorldPoint destination);
    boolean isEquippable();
    int getCharges();    
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/teleport/TeleportationManager.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.util.teleport;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.VoxSylvaePlugins.data.teleportationData.FairyRingTeleportLoader;
import net.runelite.client.plugins.VoxSylvaePlugins.data.teleportationData.SpellbookTeleportLoader;
import net.runelite.client.plugins.VoxSylvaePlugins.data.teleportationData.TeleportItemLoader;
import net.runelite.client.plugins.VoxSylvaePlugins.util.VoxSylvaeInventoryAndBankManagementScript;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.antiban.Rs2AntibanSettings;
import net.runelite.client.plugins.microbot.util.bank.Rs2Bank;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.magic.Rs2Magic;
import net.runelite.client.plugins.microbot.util.math.Rs2Random;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.microbot.util.shop.Rs2Shop;
import net.runelite.client.plugins.skillcalculator.skills.MagicAction;
import net.runelite.client.plugins.microbot.shortestpath.ShortestPathPlugin;
import net.runelite.client.plugins.microbot.shortestpath.Transport;
import net.runelite.client.plugins.microbot.shortestpath.pathfinder.Pathfinder;
import javax.inject.Inject;
import static net.runelite.client.plugins.microbot.util.Global.sleepUntil;
import java.io.*;
import java.lang.reflect.Type;
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.Collectors; 
public class TeleportationManager{
    @Inject
    private Client client;
    @Inject
    private VoxSylvaeInventoryAndBankManagementScript inventoryAndBankManagementScript;
    private Map<TeleportType, List<Teleport>> teleports;
    private Map<String, MagicAction> teleportToMagicActionMap;
    private Teleport currentTeleport;
    private boolean isTeleporting;
    private int teleportStartTick;
    private Map<String, CachedPathInfo> distanceCache;
    private String cacheDir = "../.../data/teleportCacheData/";
    private WorldPoint currentTarget;
    private Future<?> currentPathfindingTask;
    private ExecutorService pathfindingExecutor;
    private static final int CACHE_PROXIMITY_THRESHOLD = 5; // Tiles
    private static class CachedPathInfo {
        int distance;
        long timestamp;
        CachedPathInfo(int distance, long timestamp) {
            this.distance = distance;
            this.timestamp = timestamp;
        }
    }
    private static class TeleportDistancePair {
        private final Teleport teleport;
        private final double distance;
        TeleportDistancePair(Teleport teleport, double distance) {
            this.teleport = teleport;
            this.distance = distance;
        }
        public Teleport getTeleport() {
            return teleport;
        }
        public double getDistance() {
            return distance;
        }
    }
    public TeleportationManager(Client client) {
        if (client == null) {
          this.client = Microbot.getClient();
        }else{
          this.client = client;
        }        
        initialize();
    }
    public void initialize() {
        loadTeleportData();
        initializeTeleportToMagicActionMap();
        loadDistanceCache();
        this.isTeleporting = false;
        this.pathfindingExecutor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
    }
    private List<Teleport> loadTeleportsFromFile(String filename) {
        try (FileReader reader = new FileReader("../data/locationData/" + filename)) {
            Gson gson = new Gson();
            Type teleportListType = new TypeToken<ArrayList<Teleport>>(){}.getType();
            return gson.fromJson(reader, teleportListType);
        } catch (IOException e) {
            e.printStackTrace();
            return new ArrayList<>();
        }
    }
    private void initializeTeleportToMagicActionMap() {
        this.teleportToMagicActionMap = new HashMap<>();
        teleportToMagicActionMap.put("Varrock Teleport", MagicAction.VARROCK_TELEPORT);
        teleportToMagicActionMap.put("Lumbridge Teleport", MagicAction.LUMBRIDGE_TELEPORT);
        teleportToMagicActionMap.put("Falador Teleport", MagicAction.FALADOR_TELEPORT);
        teleportToMagicActionMap.put("Camelot Teleport", MagicAction.CAMELOT_TELEPORT);
        teleportToMagicActionMap.put("Ardougne Teleport", MagicAction.ARDOUGNE_TELEPORT);
        teleportToMagicActionMap.put("Watchtower Teleport", MagicAction.WATCHTOWER_TELEPORT);
        teleportToMagicActionMap.put("Teleport To House", MagicAction.TELEPORT_TO_HOUSE);
        teleportToMagicActionMap.put("Trollheim Teleport", MagicAction.TROLLHEIM_TELEPORT);
        teleportToMagicActionMap.put("Ape Atoll Teleport", MagicAction.APE_ATOLL_TELEPORT);
        teleportToMagicActionMap.put("Kourend Castle Teleport", MagicAction.KOUREND_CASTLE_TELEPORT);
        teleportToMagicActionMap.put("Teleport To Ape Atoll", MagicAction.TELEPORT_APE_ATOLL);
        //MagicAction BATTLEFRONT_TELEPORT= new MagicAction("Battlefront Teleport", 1, 5.5f, SpriteID.SPELL_WIND_STRIKE, false);
        // Arceuus spellbook teleports
        teleportToMagicActionMap.put("Arceuus Library Teleport", MagicAction.ARCEUUS_LIBRARY_TELEPORT);
        teleportToMagicActionMap.put("Draynor Manor Teleport", MagicAction.DRAYNOR_MANOR_TELEPORT);
        //teleportToMagicActionMap.put("Battlefront Teleport", MagicAction.BATTLEFRONT_TELEPORT);
        teleportToMagicActionMap.put("Mind Altar Teleport", MagicAction.MIND_ALTAR_TELEPORT);
        teleportToMagicActionMap.put("Respawn Teleport", MagicAction.RESPAWN_TELEPORT);
        teleportToMagicActionMap.put("Salve Graveyard Teleport", MagicAction.SALVE_GRAVEYARD_TELEPORT);
        teleportToMagicActionMap.put("Fenkenstrains Castle Teleport", MagicAction.FENKENSTRAINS_CASTLE_TELEPORT);
        teleportToMagicActionMap.put("West Ardougne Teleport", MagicAction.WEST_ARDOUGNE_TELEPORT);
        teleportToMagicActionMap.put("Harmony Island Teleport", MagicAction.HARMONY_ISLAND_TELEPORT);
        teleportToMagicActionMap.put("Cemetery Teleport", MagicAction.CEMETERY_TELEPORT);
        teleportToMagicActionMap.put("Barrows Teleport", MagicAction.BARROWS_TELEPORT);
        teleportToMagicActionMap.put("Ape Atoll Teleport", MagicAction.APE_ATOLL_TELEPORT);
        // Ancient Magicks teleports
        teleportToMagicActionMap.put("Paddewwa Teleport", MagicAction.PADDEWWA_TELEPORT);
        teleportToMagicActionMap.put("Senntisten Teleport", MagicAction.SENNTISTEN_TELEPORT);
        teleportToMagicActionMap.put("Kharyrll Teleport", MagicAction.KHARYRLL_TELEPORT);
        teleportToMagicActionMap.put("Lassar Teleport", MagicAction.LASSAR_TELEPORT);
        teleportToMagicActionMap.put("Dareeyak Teleport", MagicAction.DAREEYAK_TELEPORT);
        teleportToMagicActionMap.put("Carrallangar Teleport", MagicAction.CARRALLANGER_TELEPORT);
        teleportToMagicActionMap.put("Annakarl Teleport", MagicAction.ANNAKARL_TELEPORT);
        teleportToMagicActionMap.put("Ghorrock Teleport", MagicAction.GHORROCK_TELEPORT);
        // Lunar spellbook teleports
        teleportToMagicActionMap.put("Moonclan Teleport", MagicAction.MOONCLAN_TELEPORT);
        teleportToMagicActionMap.put("Ourania Teleport", MagicAction.OURANIA_TELEPORT);
        teleportToMagicActionMap.put("Waterbirth Teleport", MagicAction.WATERBIRTH_TELEPORT);
        teleportToMagicActionMap.put("Barbarian Teleport", MagicAction.BARBARIAN_TELEPORT);
        teleportToMagicActionMap.put("Khazard Teleport", MagicAction.KHAZARD_TELEPORT);
        teleportToMagicActionMap.put("Fishing Guild Teleport", MagicAction.FISHING_GUILD_TELEPORT);
        teleportToMagicActionMap.put("Catherby Teleport", MagicAction.CATHERBY_TELEPORT);
        teleportToMagicActionMap.put("Ice Plateau Teleport", MagicAction.ICE_PLATEAU_TELEPORT);
    }
    private void loadTeleportData() {
        this.teleports = new HashMap<>();
        SpellbookTeleportLoader SpellbookLoader = new SpellbookTeleportLoader();
        SpellbookLoader.loadSpellbookTeleports(teleports, "standardSpellbookTeleports.json");
        SpellbookLoader.loadSpellbookTeleports(teleports, "ancientMagicksTeleports.json");
        SpellbookLoader.loadSpellbookTeleports(teleports, "lunarSpellbookTeleports.json");
        SpellbookLoader.loadSpellbookTeleports(teleports, "arceuusSpellbookTeleports.json");
        /*
        //loadItemTeleports("enchantedJewellery.json", TeleportType.ENCHANTED_JEWELLERY);
        //loadItemTeleports("teleportTablets.json", TeleportType.TELEPORT_TABLETS);
        loadItemTeleports("teleportScrolls.json", TeleportType.TELEPORT_SCROLLS);
        loadItemTeleports("achievementDiaryItems.json", TeleportType.ACHIEVEMENT_DIARY_ITEMS);
        loadItemTeleports("otherItems.json", TeleportType.OTHER_ITEMS);
        loadItemTeleports("questRelatedItems.json", TeleportType.QUEST_RELATED_ITEMS);
        loadItemTeleports("skillCapes.json", TeleportType.SKILL_CAPES);
        loadItemTeleports("combatAchievementItems.json", TeleportType.COMBAT_ACHIEVEMENT_ITEMS); */
        // Example usage in your main code or plugin
        FairyRingTeleportLoader fairyRingLoader = new FairyRingTeleportLoader();
        fairyRingLoader.loadFairyRingTeleports(teleports, "fairyRingTeleports.json");
        TeleportItemLoader teleportItemLoader = new TeleportItemLoader();
        teleportItemLoader.loadTeleportItemLoaderTeleports(teleports, "teleportTablets.json");
        teleportItemLoader.loadTeleportItemLoaderTeleports(teleports, "enchantedJewelryTeleports.json");
        //loadPOHTeleports();
        //loadAncientMagicksTeleports();
        //loadArceuusTeleports();
        //loadLunarMagicTeleports();
        // ... (load other teleport types if needed)
    }
    private void loadPOHTeleports() {
        try (FileReader reader = new FileReader("../data/locationData/POHTeleportOptions.json")) {
            Gson gson = new Gson();
            Type pohTeleportListType = new TypeToken<ArrayList<POHTeleport>>(){}.getType();
            List<POHTeleport> pohTeleports = gson.fromJson(reader, pohTeleportListType);
            teleports.put(TeleportType.POH, new ArrayList<>(pohTeleports));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    private void loadDistanceCache() {
        this.distanceCache = new HashMap<>();        
        File cacheFile = new File(cacheDir + "distance_cache.json");
        if (cacheFile.exists()) {
            try (Reader reader = new FileReader(cacheFile)) {
                Gson gson = new Gson();
                Type type = new TypeToken<Map<String, Integer>>(){}.getType();
                distanceCache = gson.fromJson(reader, type);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
    private void saveDistanceCache() {
        File cacheDir = new File(this.cacheDir);
        if (!cacheDir.exists()) {
            cacheDir.mkdirs();
        }
        File cacheFile = new File(cacheDir, "distance_cache.json");
        try (Writer writer = new FileWriter(cacheFile)) {
            Gson gson = new Gson();
            gson.toJson(distanceCache, writer);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    public void cleanOldCacheEntries(long maxAgeMillis) {
        long now = System.currentTimeMillis();
        distanceCache.entrySet().removeIf(entry -> now - entry.getValue().timestamp > maxAgeMillis);
    }
    public String getRegionName(WorldPoint point) {
        // This method should be implemented to fetch the region name from the OSRS Wiki
        // You might need to create a separate utility class for this functionality
        // For now, we'll return a placeholder
        return "Unknown Region";
    }
    // ... (other methods remain the same)
    public Teleport findNearestTeleport(WorldPoint destination, boolean useShortestPath) {
        return findNearestTeleport(destination, useShortestPath, null);
    }   
    /*public Teleport findNearestTeleport(WorldPoint destination) {
        if (currentTarget != null && currentTarget.equals(destination) && currentPathfindingTask != null && !currentPathfindingTask.isDone()) {
            return null; // Pathfinding is already in progress for this destination
        }
        setTarget(destination);
        CompletableFuture<Teleport> pathfindingFuture = new CompletableFuture<>();
        currentPathfindingTask = CompletableFuture.runAsync(() -> {
            Microbot.getClientThread().runOnSeperateThread(() -> {
                try {
                    Teleport nearest = null;
                    double minDistance = Double.MAX_VALUE;
                    for (List<Teleport> teleportList : teleports.values()) {
                        for (Teleport teleport : teleportList) {
                            double distance = getDistanceToViaShortestPath(teleport.getDestination(), destination);
                            if (distance < minDistance) {
                                minDistance = distance;
                                nearest = teleport;
                            }
                        }
                    }
                    pathfindingFuture.complete(nearest);
                } catch (Exception e) {
                    pathfindingFuture.completeExceptionally(e);
                }
                return null;
            });
        });
        try {
            return pathfindingFuture.get(30, TimeUnit.SECONDS); // Adjust timeout as needed
        } catch (InterruptedException | ExecutionException | TimeoutException e) {
            e.printStackTrace();
            return null;
        }
    }*/
    public Teleport findNearestTeleportShortestPath(WorldPoint destination) {
        if (currentTarget != null && currentTarget.equals(destination) && currentPathfindingTask != null && !currentPathfindingTask.isDone()) {
            return null; // Pathfinding is already in progress for this destination
        }
        setTarget(destination);
        CompletableFuture<Teleport> pathfindingFuture = new CompletableFuture<>();
        currentPathfindingTask = CompletableFuture.runAsync(() -> {
            Microbot.getClientThread().runOnSeperateThread(() -> {
                try {
                    List<CompletableFuture<TeleportDistancePair>> futures = teleports.values().stream()
                        .flatMap(List::stream)
                        .map(teleport -> CompletableFuture.supplyAsync(() -> {
                            double distance = getDistanceToViaShortestPath(teleport.getDestinations().get(0), destination);
                            return new TeleportDistancePair(teleport, distance);
                        }, pathfindingExecutor))
                        .collect(Collectors.toList());
                    CompletableFuture<Void> allFutures = CompletableFuture.allOf(
                        futures.toArray(new CompletableFuture[0])
                    );
                    CompletableFuture<TeleportDistancePair> minDistanceFuture = allFutures.thenApply(v ->
                        futures.stream()
                            .map(CompletableFuture::join)
                            .min(Comparator.comparingDouble(TeleportDistancePair::getDistance))
                            .orElse(null)
                    );
                    TeleportDistancePair result = minDistanceFuture.get(30, TimeUnit.SECONDS);
                    pathfindingFuture.complete(result != null ? result.getTeleport() : null);
                } catch (Exception e) {
                    pathfindingFuture.completeExceptionally(e);
                }
                return null;
            });
        });
        try {
            return pathfindingFuture.get(30, TimeUnit.SECONDS); // Adjust timeout as needed
        } catch (InterruptedException | ExecutionException | TimeoutException e) {
            e.printStackTrace();
            return null;
        }
    }
    public Teleport findNearestTeleport(WorldPoint destination, boolean useShortestPath, TeleportType type) {
        if (currentTarget != null && currentTarget.equals(destination) && currentPathfindingTask != null && !currentPathfindingTask.isDone()) {
            return null; // Pathfinding is already in progress for this destination
        }
        setTarget(destination);
        CompletableFuture<Teleport> pathfindingFuture = new CompletableFuture<>();
        currentPathfindingTask = CompletableFuture.runAsync(() -> {
            Microbot.getClientThread().runOnSeperateThread(() -> {
                try {
                    List<Teleport> teleportList = (type != null) ? teleports.get(type) : 
                        teleports.values().stream().flatMap(List::stream).collect(Collectors.toList());
                    if (teleportList == null || teleportList.isEmpty()) {
                        pathfindingFuture.complete(null);
                        return null;
                    }
                    // List to hold CompletableFuture of TeleportDistancePair (for each teleport)
                    List<CompletableFuture<TeleportDistancePair>> futures = teleportList.stream()
                        .map(teleport -> CompletableFuture.supplyAsync(() -> {
                            // For each teleport, calculate the minimum distance across all destinations
                            List<WorldPoint> destinations = teleport.getDestinations();
                            // Create futures for each destination
                            List<CompletableFuture<Double>> distanceFutures = destinations.stream()
                                .map(dest -> CompletableFuture.supplyAsync(() -> {
                                    if (useShortestPath) {
                                        return getDistanceToViaShortestPath(dest, destination);
                                    } else {
                                        return teleport.getDistanceTo(dest);
                                    }
                                }, pathfindingExecutor))
                                .collect(Collectors.toList());
                            // Wait for all destination distance futures to complete and get the minimum
                            CompletableFuture<Void> allDestFutures = CompletableFuture.allOf(
                                distanceFutures.toArray(new CompletableFuture[0])
                            );
                            Double minDistance = allDestFutures.thenApply(v ->
                                distanceFutures.stream()
                                    .map(CompletableFuture::join)
                                    .min(Comparator.comparingDouble(Double::doubleValue))
                                    .orElse(Double.MAX_VALUE)
                            ).join(); // Block and wait for the minimum distance for this teleport
                            return new TeleportDistancePair(teleport, minDistance);
                        }, pathfindingExecutor))
                        .collect(Collectors.toList());
                    CompletableFuture<Void> allFutures = CompletableFuture.allOf(
                        futures.toArray(new CompletableFuture[0])
                    );
                    // After all teleport distance pairs are computed, get the minimum distance pair
                    CompletableFuture<TeleportDistancePair> minDistanceFuture = allFutures.thenApply(v ->
                        futures.stream()
                            .map(CompletableFuture::join)
                            .min(Comparator.comparingDouble(TeleportDistancePair::getDistance))
                            .orElse(null)
                    );
                    // Block and get the result
                    TeleportDistancePair result = minDistanceFuture.get(30, TimeUnit.SECONDS);
                    pathfindingFuture.complete(result != null ? result.getTeleport() : null);
                } catch (Exception e) {
                    pathfindingFuture.completeExceptionally(e);
                }
                return null;
            });
        });
        // Wait for the pathfinding to complete, no timeout
        return pathfindingFuture.join(); // This will block until the task is done
        /*try {
            return pathfindingFuture.get(30, TimeUnit.SECONDS); // Adjust timeout as needed
        } catch (InterruptedException | ExecutionException | TimeoutException e) {
            e.printStackTrace();
            return null;
        }*/
    }
    private void setTarget(WorldPoint target) {
        if (!Microbot.isLoggedIn()) return;
        currentTarget = target;
        if (target == null) {
            if (currentPathfindingTask != null) {
                currentPathfindingTask.cancel(true);
                currentPathfindingTask = null;
            }
        }
    }
    public double getDistanceToViaShortestPath(WorldPoint start, WorldPoint end) {
        // Check if there's a nearby cached path
        Optional<Map.Entry<String, CachedPathInfo>> nearbyCachedPath = findNearbyCachedPath(start, end);
        if (nearbyCachedPath.isPresent()) {
            return nearbyCachedPath.get().getValue().distance;
        }
        String cacheKey = start.getRegionID()+"-"+start.getX()+"_"+start.getY()+ "-" + end.getX()+"_"+end.getY()+"-"+end.getRegionID();
        CompletableFuture<ShortestPathResult> pathFuture = new CompletableFuture<>();
        currentPathfindingTask = CompletableFuture.runAsync(() -> {
            Microbot.getClientThread().runOnSeperateThread(() -> {
                try {
                    Pathfinder pathfinder = new Pathfinder(ShortestPathPlugin.getPathfinderConfig(), start, end);
                    sleepUntil(pathfinder::isDone);
                    while (!pathfinder.isDone()) {
                        Thread.sleep(100);
                    }
                    int distance = pathfinder.getPath().size();
                    List<WorldPoint> foundPath = pathfinder.getPath();
                    int indexOfStartPoint = 0;
                    Map<WorldPoint,List<Transport>> foundPathTransports = ShortestPathPlugin.getTransports();
                    List<Transport> foundTransportation= ShortestPathPlugin.getTransports().getOrDefault(foundPath.get(indexOfStartPoint), new ArrayList<>());
                    ShortestPathResult foundPathResult = new ShortestPathResult(foundPath, foundPathTransports, distance, start, end);
                    pathFuture.complete(foundPathResult);
                    return foundPathResult;
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    pathFuture.completeExceptionally(e);
                }
                return null;
            });
        });
        try {
            ShortestPathResult foundPathResult = pathFuture.get(5, TimeUnit.SECONDS);
            int distance = foundPathResult.getDistance();
            distanceCache.put(cacheKey, new CachedPathInfo(distance, System.currentTimeMillis()));
            saveDistanceCache();
            return distance;
        } catch (InterruptedException | ExecutionException | TimeoutException e) {
            e.printStackTrace();
            return Double.MAX_VALUE;
        }
    }
    private Optional<Map.Entry<String, CachedPathInfo>> findNearbyCachedPath(WorldPoint start, WorldPoint end) {
        return distanceCache.entrySet().stream()
            .filter(entry -> {
                String[] splitCachedKey = entry.getKey().split("-");
                assert splitCachedKey.length == 4;
                int startRegionId = Integer.parseInt(splitCachedKey[0]);                
                int cachedEndRegionId = Integer.parseInt(splitCachedKey[3]);
                String[] startPointCoordStrings = splitCachedKey[1].split("_");                
                String[] endPointCoordStrings = splitCachedKey[2].split("_");
                assert startPointCoordStrings.length == 2;
                assert endPointCoordStrings.length == 2;
                int cachedStartX = Integer.parseInt(startPointCoordStrings[0]);
                int cachedStartY = Integer.parseInt(startPointCoordStrings[1]);
                int cachedEndX = Integer.parseInt(endPointCoordStrings[0]);
                int cachedEndY = Integer.parseInt(endPointCoordStrings[1]);
                WorldPoint cachedStart = new WorldPoint(cachedStartX, cachedStartY,0);
                WorldPoint cachedEnd = new WorldPoint(cachedEndX, cachedEndY,0);
                boolean isSameRegion = startRegionId == start.getRegionID() && cachedEndRegionId == end.getRegionID();
                return cachedStart.distanceTo(start) <= CACHE_PROXIMITY_THRESHOLD &&
                       cachedEnd.distanceTo(end) <= CACHE_PROXIMITY_THRESHOLD;
            })
            .min(Comparator.comparingLong(entry -> entry.getValue().timestamp));
    }
    public Teleport findNearestTeleportSimple(WorldPoint destination) {
        return findNearestTeleport(destination, false, null);   
    }
    public Teleport findNearestTeleportSimple(WorldPoint destination, TeleportType type) {
        return findNearestTeleport(destination, false, type);         
    }
    public Teleport findNearestTeleport(WorldPoint destination, List<String> completedQuests) {
        Teleport nearest = null;
        double minDistance = Double.MAX_VALUE;
        for (List<Teleport> teleportList : teleports.values()) {
            for (Teleport teleport : teleportList) {
                if (meetsQuestRequirements(teleport)) {
                    double distance = teleport.getDistanceTo(destination);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearest = teleport;
                    }
                }
            }
        }
        return nearest;
    }
    private Teleport findNearestTeleportInList(WorldPoint destination, List<Teleport> teleportList) {
        Teleport nearest = null;
        double minDistance = Double.MAX_VALUE;
        for (Teleport teleport : teleportList) {
            double distance = teleport.getDistanceTo(destination);
            if (distance < minDistance) {
                minDistance = distance;
                nearest = teleport;
            }
        }
        return nearest;
    }
    private boolean meetsQuestRequirements(Teleport teleport ) {
        if (teleport.getRequiredQuests() == null || teleport.getRequiredQuests().isEmpty()) {
            return true;
        }
        for (Quest questReq : teleport.getRequiredQuests()) {
            if (!QuestState.FINISHED.equals(questReq.getState(Microbot.getClient()))) {
                return false;
            }
        }
        return true;
    }
    public boolean hasRequiredItems(Teleport teleport) {
        for (ItemQuantity requiredItem : teleport.getRequiredItems()) {
            if (!Rs2Inventory.hasItemAmount(requiredItem.getName(), requiredItem.getQuantity())) {
                return false;
            }
        }
        return true;
    }
    public boolean hasRequiredItemsInBank(Teleport teleport, boolean useBank) {
        List<VoxSylvaeInventoryAndBankManagementScript.BankItemInfo> needBankItems = new ArrayList<>();
        for (ItemQuantity requiredItem : teleport.getRequiredItems()) {
            VoxSylvaeInventoryAndBankManagementScript.BankItemInfo bankItem = null;
            bankItem = inventoryAndBankManagementScript.findItemInBank(requiredItem.getName(), 
                                                                        requiredItem.getQuantity());
            if (bankItem != null) {
                needBankItems.add(bankItem);
            }
        }        
        return needBankItems.size() == teleport.getRequiredItems().size();
    }
    // get items from bank
    public boolean getRequiredItemsFromBank(Teleport teleport) {
        List<VoxSylvaeInventoryAndBankManagementScript.BankItemInfo> needBankItems = new ArrayList<>();
        for (ItemQuantity requiredItem : teleport.getRequiredItems()) {
            VoxSylvaeInventoryAndBankManagementScript.BankItemInfo bankItem = null;
            bankItem = inventoryAndBankManagementScript.findItemInBank(requiredItem.getName(), 
                                                                        requiredItem.getQuantity());
            boolean itemRetrieved = inventoryAndBankManagementScript.retrieveAmountItemsFromBank(bankItem.itemId,
                                                                                                    requiredItem.getQuantity());
            if (itemRetrieved) {
                needBankItems.add(bankItem);
            }
        }
        boolean inVentory = true;
        if (!needBankItems.isEmpty()) {
            for (VoxSylvaeInventoryAndBankManagementScript.BankItemInfo bankItem : needBankItems) {
                if (!Rs2Inventory.hasItem(bankItem.itemId)) {
                    inVentory = false;
                    break;
                }
            }
        }
        return needBankItems.size() == teleport.getRequiredItems().size() && inVentory;
    }
    public boolean hasRequiredSkillLevel(Teleport teleport) {
        if (teleport.getType() != TeleportType.STANDARD_SPELLBOOK || teleport.getType() != TeleportType.ANCIENT_MAGICKS ||
            teleport.getType() != TeleportType.LUNAR_SPELLBOOK || teleport.getType() != TeleportType.ARCEUUS_SPELLBOOK) {
            return true;
        }
        return client.getRealSkillLevel(Skill.MAGIC) >= teleport.getRequiredLevel();
    }
     public boolean performTeleport(Teleport teleport) {
        if (!canPerformTeleport(teleport)) {
            Microbot.showMessage("Cannot perform teleport: " + teleport.getName());
            return false;
        }
        if (teleport instanceof SpellbookTeleport) {
            return castTeleportSpell((SpellbookTeleport) teleport);
        } else if (teleport instanceof TeleportItem) {
            return useItemTeleport((TeleportItem) teleport);
        } else if (teleport instanceof POHTeleport) {
            return usePOHTeleport((POHTeleport) teleport);
        }
        Microbot.showMessage("Unsupported teleport type: " + teleport.getClass().getSimpleName());
        return false;
    }
    private boolean canPerformTeleport(Teleport teleport) {
        int magicLevel = client.getRealSkillLevel(Skill.MAGIC);
        if (teleport.getRequiredLevel() > client.getRealSkillLevel(Skill.MAGIC)) {
            return false;
        }
        if (magicLevel < teleport.getRequiredLevel()) {
            return false;
        }
        if (!hasRequiredItems(teleport)) {
            return false;
        }
            //if (!QuestState.FINISHED.equals(quest.getState(Microbot.getClient()))
        for (Quest questReq : teleport.getRequiredQuests()) {
            QuestState.FINISHED.equals(questReq.getState(Microbot.getClient()));
            //if (!Rs2Player.isQuestCompleted(quest)) {
            //    return false;
            //}
        }
        return true;
    }
    private boolean castTeleportSpell( SpellbookTeleport teleport) {
        MagicAction magicTeleportAction = teleportToMagicActionMap.get(teleport.getName());
        if (magicTeleportAction == null) {
            Microbot.showMessage("Unknown teleport spell: " + teleport.getName());
            return false;
        }
        WorldPoint playerLocationBeforeTeleport = client.getLocalPlayer().getWorldLocation();
        List<WorldPoint> teleportDestinations = teleport.getDestinations();
        assert( teleportDestinations.size()==1);
        WorldPoint targetLocation = teleportDestinations.get(0);
        Rs2Magic.cast(magicTeleportAction);
        sleepUntil(() -> !Rs2Player.isNearArea(targetLocation,1)  && !Rs2Player.isInteracting() && !Rs2Player.isAnimating(), 500);
        //Microbot.log("teleport with"+teleport.getName() +  to location {}, current player location", , client.getLocalPlayer().getWorldLocation());
        WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();
        boolean success = playerLocation.distanceTo(teleport.getDestination()) < 5;
        if (success) {
            currentTeleport = teleport;
            isTeleporting = true;
            teleportStartTick = client.getTickCount();
        }
        return success;
    }
    private boolean useItemTeleport(TeleportItem teleport) {
        // Implement jewelry teleport logic
        // This might involve finding the jewelry in the inventory and using it
        return false; // Placeholder
    }
    private boolean usePOHTeleport(POHTeleport teleport) {
        // Implement POH teleport logic
        // This might involve interacting with POH objects
        return false; // Placeholder
    }
    private static void logDebug(String message) {
        if (Rs2AntibanSettings.devDebug) {
            Microbot.log("<col=4B0082>" + message + "</col>");
        }
    }
    public void onGameTick() {
        if (isTeleporting) {
            checkTeleportCompletion();
        }
    }
    private void checkTeleportCompletion() {
        Player player = client.getLocalPlayer();
        if (player == null) return;
        if (player.getAnimation() == -1 && client.getGameState() == GameState.LOGGED_IN) {
            int ticksSinceTeleport = client.getTickCount() - teleportStartTick;
            if (ticksSinceTeleport > 5) { // Adjust this value as needed
                WorldPoint playerLocation = player.getWorldLocation();
                if (currentTeleport.getDistanceTo(playerLocation) < 1) { // Teleport successful
                    isTeleporting = false;
                    currentTeleport = null;
                    Microbot.showMessage("Teleport completed successfully");
                } else {
                    isTeleporting = false;
                    currentTeleport = null;
                    Microbot.showMessage("Teleport failed");
                }
            }
        }
    }
    private void shutdown() {
        if (currentPathfindingTask != null) {
            currentPathfindingTask.cancel(true);
        }
        saveDistanceCache();
    }
    // Add more methods as needed, such as filtering by requirements, etc.
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/teleport/TeleportItem.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.util.teleport;
import net.runelite.api.coords.WorldPoint;
import java.util.List;
public class TeleportItem extends AbstractTeleport {
    private final int itemId;
    private final List<String> locations;    // List of locations for each teleport destination
    private final boolean membersOnly;       // If the item is members-only
    private final boolean rechargeable;      // If the item is rechargeable
    private final String notes;              // Any additional notes or information
    public TeleportItem(String name, TeleportType category, int itemId, int requiredLevel, List<ItemQuantity> requiredItems, 
                        List<String> requiredQuests, List<WorldPoint> destinations, boolean isEquippable, int charges,
                        List<String> locations, boolean membersOnly, boolean rechargeable, String notes) {
        super(name, category, requiredLevel, requiredItems, requiredQuests, destinations, isEquippable, charges);
        this.itemId = itemId;
        this.locations = locations;
        this.membersOnly = membersOnly;
        this.rechargeable = rechargeable;
        this.notes = notes;
    }
    // Getter for itemId
    public int getItemId() {
        return itemId;
    }
    // Getter for locations
    public List<String> getLocations() {
        return locations;
    }
    // Getter for membersOnly
    public boolean isMembersOnly() {
        return membersOnly;
    }
    // Getter for rechargeable
    public boolean isRechargeable() {
        return rechargeable;
    }
    // Getter for notes
    public String getNotes() {
        return notes;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/teleport/TeleportType.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.util.teleport;
public enum TeleportType {
    STANDARD_SPELLBOOK,
    ANCIENT_MAGICKS,
    LUNAR_SPELLBOOK,
    ARCEUUS_SPELLBOOK,
    ENCHANTED_JEWELLERY,
    TELEPORT_TABLETS,
    TELEPORT_SCROLLS,
    ACHIEVEMENT_DIARY_ITEMS,
    OTHER_ITEMS,
    QUEST_RELATED_ITEMS,
    SKILL_CAPES,
    COMBAT_ACHIEVEMENT_ITEMS,
    FAIRY_RING,
    POH
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/VoxSylvaeInventoryAndBankManagementScript.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.util;
import net.runelite.api.InventoryID;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.Rs2InventorySetup;
import net.runelite.client.plugins.microbot.util.bank.Rs2Bank;
import net.runelite.client.plugins.microbot.util.equipment.Rs2Equipment;
import net.runelite.client.plugins.microbot.util.inventory.DropOrder;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.microbot.util.shop.Rs2Shop;
import net.runelite.client.plugins.microbot.util.walker.Rs2Walker;
import java.util.List;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.widgets.Widget;
import net.runelite.client.plugins.microbot.util.widget.Rs2Widget;
import net.runelite.client.plugins.microbot.Script;
import net.runelite.client.plugins.microbot.shortestpath.ShortestPathPlugin;
import net.runelite.client.plugins.microbot.util.dialogues.Rs2Dialogue;
import net.runelite.client.plugins.microbot.util.math.Rs2Random;
import net.runelite.client.plugins.microbot.util.menu.NewMenuEntry;
import net.runelite.client.plugins.microbot.util.npc.Rs2NpcManager;
import static net.runelite.client.plugins.microbot.util.Global.sleepUntil;
import static net.runelite.client.plugins.microbot.util.Global.sleep;
import net.runelite.api.Client;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.questhelper.runeliteobjects.extendedruneliteobjects.FaceAnimationIDs;
import java.awt.*;
import java.util.Objects;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import javax.inject.Inject;
import org.apache.commons.lang3.ObjectUtils.Null;
@Slf4j
public class VoxSylvaeInventoryAndBankManagementScript {
    @Inject
    private Client client;
    @Inject
    private ItemManager itemManager;
    public ScheduledFuture<?> mainScheduledFuture;
    public boolean isRunning() {
        return mainScheduledFuture != null && !mainScheduledFuture.isDone();
    }
    public void shutdown() {
        if (mainScheduledFuture != null && !mainScheduledFuture.isDone()) {
            mainScheduledFuture.cancel(true);
            ShortestPathPlugin.exit();
            if (Microbot.getClientThread().scheduledFuture != null)
                Microbot.getClientThread().scheduledFuture.cancel(true);
            Microbot.pauseAllScripts = false;
            Microbot.getSpecialAttackConfigs().reset();
        }
    }
    public static class BankItemInfo {
        public final int slot;
        public final int tab;
        public final int itemId;
        public final String itemName;
        public final int quantity;
        public BankItemInfo(int slot, int tab, int itemId, String itemName, int quantity) {
            this.slot = slot;
            this.tab = tab;
            this.itemId = itemId;
            this.itemName = itemName;
            this.quantity = quantity;
        }
    }
    enum InvnetoryAndBankingState{
        IDLE,
        BANKING,
        DEPOSITING,
        WITHDRAWING,
        EQUIPPING,
        DROPPING,
        COMBINING,
        CLOSING_BANK
    }
    enum BankingAction{
        DEPOSIT_INVENTORY,
        DEPOSIT_WORN_ITEMS,
        WITHDRAW,
        EQUIP,
        DROP,
        COMBINE,
        CLOSE_BANK
    }
    InvnetoryAndBankingState currentState = InvnetoryAndBankingState.IDLE;
    public void dropInventoryItems(DropOrder configuredDropOrder, String subStringItem ) {
        DropOrder dropOrder = configuredDropOrder == DropOrder.RANDOM ? DropOrder.random() : configuredDropOrder;
        Rs2Inventory.dropAll(x -> x.name.toLowerCase().contains(subStringItem), dropOrder);
    }
    private boolean retrieveAllItemsFromBank(int itemId) {
          //not open bank
          if (!Rs2Bank.isOpen()) {
            Microbot.log("<retrieveAllItemsFromBank> Bank did not open");
            return false;
        }
        if (Rs2Bank.hasItem(itemId)) {
            Rs2Bank.withdrawAll(itemId);
            sleepUntil(() -> Rs2Inventory.hasItem(itemId), (int)Rs2Random.truncatedGauss(600, 1000, 0));
            return Rs2Inventory.hasItem(itemId);
        }
        return false;
    }
    public boolean retrieveAmountItemsFromBank(int itemId, int amount) {
        //not open bank
        if (!Rs2Bank.isOpen()) {
            Microbot.log("<retrieveAmountItemsFromBank> Bank did not open");
            return false;
        }
        if (Rs2Bank.hasItem(itemId)) {
            Rs2Bank.withdrawX(itemId, amount);
            sleepUntil(() -> Rs2Inventory.hasItemAmount(itemId,amount), (int)Rs2Random.truncatedGauss(600, 1000, 0));
            return Rs2Inventory.hasItemAmount(itemId,amount);
        }
        return false;
    }
    private Widget openAndScrollToBankTab(int itemTabID, int ItemSlotId) {
        if (!Rs2Bank.isTabOpen(itemTabID)) {
            log.info("Switching to tab: {}", itemTabID);
            Rs2Bank.openTab(itemTabID);
            sleepUntil(() -> Rs2Bank.isTabOpen(itemTabID), 5000);
        }
        Rs2Bank.scrollBankToSlot(ItemSlotId);
        Rs2Random.wait(200, 500);
        return Rs2Bank.getItemWidget(ItemSlotId);
    }
    public BankItemInfo findItemInBank(int itemId) {
        if(openBank()){
            Microbot.log("<findItemInBank> Bank did not open");
            return null;
        }
        ItemContainer bank = client.getItemContainer(InventoryID.BANK);
        // throw exeption if bank is not open
        if (bank == null) {
            return null; // Bank is not open
        }
        Item[] bankItems = bank.getItems();
        int currentTab = 0;
        int currentSlot = 0;
        for (Item item : bankItems) {
            if (item.getId() == itemId) {
                ItemComposition itemComposition = itemManager.getItemComposition(itemId);
                String itemName = itemComposition.getName();
                return new BankItemInfo(currentSlot, currentTab, itemId, itemName, item.getQuantity());
            }
            currentSlot++;
            if (item.getId() == 21) { // ID 21 is the item ID for bank tab separators
                currentTab++;
                currentSlot = 0;
            }
        }
        return null; // Item not found
    }
    public BankItemInfo findItemInBank(String itemName, int minItemQuantity) {
        if(openBank()){
            Microbot.log("<findItemInBank> Bank did not open");
            return null;
        }
        ItemContainer bank = client.getItemContainer(InventoryID.BANK);
        if (bank == null) {
            return null; // Bank is not open
        }
        Item[] bankItems = bank.getItems();
        int currentTab = 0;
        int currentSlot = 0;
        for (Item item : bankItems) {
            ItemComposition itemComposition = itemManager.getItemComposition(item.getId());
            if (itemComposition.getName().equalsIgnoreCase(itemName) && item.getQuantity() >= minItemQuantity) {
                return new BankItemInfo(currentSlot, currentTab, item.getId(), itemName, item.getQuantity());
            }
            currentSlot++;
            if (item.getId() == 21) { // ID 21 is the item ID for bank tab separators
                currentTab++;
                currentSlot = 0;
            }
        }
        return null; // Item not found
    }
    private int getItemIdByName(String itemName) {
        for (int i = 0; i < client.getItemCount(); i++) {
            ItemComposition itemComposition = itemManager.getItemComposition(i);
            if (itemComposition.getName().equalsIgnoreCase(itemName)) {
                return i;
            }
        }
        return -1; // Item not found
    }
    public boolean retrieveItemsFromBankById(List<Integer> itemIDs) {
        if(openBank()){
            Microbot.log("<retrieveItemsFromBank> Bank did not open");
            return false;
        }
        for (int itemID : itemIDs) {
            if (Rs2Bank.hasItem(itemID)) {
                Rs2Bank.withdrawItem(itemID);
                sleepUntil(() -> Rs2Inventory.hasItem(itemID), 50);
                if (!Rs2Inventory.hasItem(itemID)) {
                    Microbot.log("Failed to withdraw item: " + itemID);
                    Rs2Bank.closeBank();
                    return false;
                }
            } else {
                System.out.println("Missing item in bank: " + itemID);
                Rs2Bank.closeBank();
                return false;
            }
        }
        Rs2Bank.closeBank();
        return true;
    }
    private boolean retrieveItemsFromBankbyName(List<String> items) {
        if(openBank()){
            Microbot.log("<retrieveItemsFromBank> Bank did not open to retrieve items: " + items);
            return false;
        }
        for (String item : items) {
            if (Rs2Bank.hasItem(item)) {
                Rs2Bank.withdrawItem(item);
                sleepUntil(() -> Rs2Inventory.hasItem(item), 50);
                if (!Rs2Inventory.hasItem(item)) {
                    Microbot.log("Failed to withdraw item: " + item);
                    Rs2Bank.closeBank();
                    return false;
                }
            } else {
                System.out.println("Missing item in bank: " + item);
                Rs2Bank.closeBank();
                return false;
            }
        }
        Rs2Bank.closeBank();
        return true;
    }
    public boolean loadInventoryAndEquipment(String inventorySetupName) {
        boolean hasEquipment = false;
        boolean hasInventory = false;
        if (!openBank()) {
            Microbot.log("Bank did not open");
            return false;
        }
        try {
            Rs2InventorySetup rs2InventorySetup = new Rs2InventorySetup(inventorySetupName, mainScheduledFuture);
            if (!rs2InventorySetup.hasSpellBook()) {
                Microbot.showMessage("Your spellbook is not matching "+ inventorySetupName + " the inventory setup.");
                sleep(100);
                return false;
            }
            hasEquipment = rs2InventorySetup.doesEquipmentMatch();
            hasInventory = rs2InventorySetup.doesInventoryMatch();
            if (!hasEquipment) {
                hasEquipment = rs2InventorySetup.loadEquipment();
            }
            if (!hasInventory && rs2InventorySetup.doesEquipmentMatch()) {
                hasInventory = rs2InventorySetup.loadInventory();
                sleep(1000);
            }
        } catch (Exception ignored) {            
            Microbot.pauseAllScripts = false;
            Microbot.log("Failed to "+inventorySetupName+"load inventory setup");
        }
        return hasInventory && hasEquipment;
    }
    public boolean openBank () {
        try {
            if (Rs2Bank.isOpen()) {
                return true;
            }
             int tryOpenBank = 0;
            while (!Rs2Bank.isOpen()) {
                Rs2Bank.walkToBankAndUseBank();
                sleepUntil(() -> Rs2Shop.isOpen(),(int)Rs2Random.truncatedGauss(600, 1000, 0));
                tryOpenBank++;
                if (tryOpenBank > 5) {
                    Microbot.log("<openBank> Failed to reach the bank and open it");
                    return false;
                }
            }            
            sleepUntil(Rs2Bank::isOpen, 10000);
        } catch (Exception ignored) {            
            Microbot.pauseAllScripts = true;
            Microbot.log("<openBank> Failed to open bank, with exception: " + ignored.getMessage());
        }
        return Rs2Bank.isOpen();
    }
    private boolean checkBeforeWithdrawAndEquip(int itemId) {
        try {
            if (!Rs2Equipment.isWearing(itemId)) {
                Rs2Bank.withdrawAndEquip(itemId);
            //check if it is wearing
                sleepUntil(() -> Rs2Equipment.isWearing(itemId), 5000);
                return Rs2Equipment.isWearing(itemId);
            }
            return true;
        } catch (Exception ignored) {            
            Microbot.pauseAllScripts = true;
            Microbot.log("<openBank> Failed to open bank, with exception: " + ignored.getMessage());
            return false;
        }
    }
    private boolean checkBeforeWithdrawAndEquip(String itemName) {
        if (!Rs2Equipment.isWearing(itemName)) {
            Rs2Bank.withdrawAndEquip(itemName);
            //check if it is wearing
            sleepUntil(() -> Rs2Equipment.isWearing(itemName), 5000);
            return Rs2Equipment.isWearing(itemName);
        }
        return true;
    }
    public boolean withdrawAndEquipItemWithMultipleIds(List<Integer> itemIds) {
        if (!Rs2Bank.openBank()) {
            Microbot.log("<withdrawAndEquipItemWithMultipleIds> Bank did not open, cant get any item with ids: " + itemIds);
            return false;
        }
        for (int itemId : itemIds) {
            if (Rs2Bank.hasItem(itemId)) {
                checkBeforeWithdrawAndEquip(itemId);
                return true;
            } else {
              continue;
            }
        }
        Microbot.log("<withdrawAndEquipItemWithMultipleIds> Missing all items in bank: " + itemIds);        
        return true;
    }
    public boolean withdrawAndEquip(String itemName) {
        if (!Rs2Bank.openBank()) {
            Microbot.log("<withdrawAndEquip> Bank did not open, item: " + itemName);
            return false;
        }
        if (Rs2Bank.hasItem(itemName)) {
            checkBeforeWithdrawAndEquip(itemName);
            return true;
        }
        Microbot.log("<withdrawAndEquip> Missing item in bank: " + itemName);
        return false;
    }
    public boolean withdrawAndEquip(int itemId) {
        try{
            if (!Rs2Bank.openBank()) {
                Microbot.log("<withdrawAndEquip> Bank did not open, item: " + itemId);
                return false;
            }
            if (Rs2Bank.hasItem(itemId)) {
                checkBeforeWithdrawAndEquip(itemId);
                return true;
            }
            Microbot.log("<withdrawAndEquip> Missing item in bank: " + itemId);
            return false;
        } catch (Exception ignored) {
            Microbot.pauseAllScripts = true;
            Microbot.log("<withdrawAndEquip> Failed to withdraw and equip item: " + itemId+" with exception: " + ignored.getMessage());
            return false;
        }
    }
    public <T>boolean hasAllItemsInInventory(List<T> items) {
        for (T item : items) {
            if (item.getClass() == String.class && !Rs2Inventory.hasItem((String)item)) {
                //Rs2Item invItem = Rs2Inventory.getItem((String)item);
                Microbot.log("<hasAllItemsInInventory> Missing item in inventory: " + item);
                return false;
            }
            if (item.getClass() == Integer.class && !Rs2Inventory.hasItem((Integer)item)) {
                Microbot.log("<hasAllItemsInInventory> Missing item in inventory: " + item);
                return false;                
            }
        }
        return true;
    }
    //utitlity methods
    public void equipGraceful() {
        withdrawAndEquip("GRACEFUL HOOD");
        withdrawAndEquip("GRACEFUL CAPE");
        withdrawAndEquip("GRACEFUL BOOTS");
        withdrawAndEquip("GRACEFUL GLOVES");
        withdrawAndEquip("GRACEFUL TOP");
        withdrawAndEquip("GRACEFUL LEGS");
    }
    public boolean withdrawDigsitePendant() {
        List<Integer> digsitePendants = List.of(ItemID.DIGSITE_PENDANT_1, ItemID.DIGSITE_PENDANT_2, ItemID.DIGSITE_PENDANT_3, ItemID.DIGSITE_PENDANT_4, ItemID.DIGSITE_PENDANT_5);
        return withdrawAndEquipItemWithMultipleIds(digsitePendants);     
    }
    //@Override
    //public void shutdown() {
    //    super.shutdown();
    //    Microbot.pauseAllScripts = true;
    //}
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/VoxSylvaeUitl.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.util;
import static net.runelite.client.plugins.microbot.util.Global.sleep;
import static net.runelite.client.plugins.microbot.util.Global.sleepUntil;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.microbot.util.antiban.AntibanOverlay;
import net.runelite.client.plugins.microbot.util.antiban.Rs2Antiban;
import net.runelite.client.plugins.microbot.util.antiban.Rs2AntibanSettings;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.keyboard.Rs2Keyboard;
import net.runelite.client.plugins.microbot.util.mouse.VirtualMouse;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.xptracker.XpTrackerPlugin;
import net.runelite.api.AnimationID;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Skill;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.StatChanged;
import net.runelite.api.widgets.Widget;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ProfileChanged;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.microbot.breakhandler.BreakHandlerPlugin;
import net.runelite.client.plugins.microbot.util.antiban.AntibanPlugin;
import net.runelite.client.plugins.microbot.util.antiban.enums.Activity;
import net.runelite.client.plugins.microbot.util.antiban.enums.ActivityIntensity;
import net.runelite.client.plugins.microbot.util.antiban.enums.CombatSkills;
import net.runelite.client.plugins.microbot.util.antiban.ui.MasterPanel;
import net.runelite.client.plugins.microbot.util.bank.Rs2Bank;
import net.runelite.client.plugins.PluginInstantiationException;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.HotkeyListener;
import net.runelite.client.util.ImageUtil;
import net.runelite.client.plugins.microbot.Script;
import net.runelite.client.plugins.microbot.util.security.Login;
import net.runelite.client.plugins.microbot.util.shop.Rs2Shop;
import net.runelite.client.plugins.microbot.util.widget.Rs2Widget;
import java.util.concurrent.TimeUnit;
import javax.inject.Inject;
import javax.swing.*;
import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import java.awt.image.BufferedImage;
import java.time.Duration;
import java.time.Instant;
import java.util.EnumMap;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;
import java.awt.*;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.awt.event.KeyEvent;
import static net.runelite.client.plugins.microbot.util.Global.sleepUntil;
public class VoxSylvaeUitl {
    public static void ensurePluginEnabled(Class pluginClass,  boolean devDebug){
        if (!Microbot.isPluginEnabled(pluginClass)) {
            String pluginName = pluginClass.getName();
            if (devDebug)
                Microbot.showMessage("Current plugin depend on the plugin \""+pluginName +"\", enabling it now.");
            Microbot.log("\""+pluginName +"\""+"not enabled, enabling it now.");
            Plugin PluginObject = Microbot.getPluginManager().getPlugins().stream()
                    .filter(x -> x.getClass().getName().equals(pluginName))
                    .findFirst()
                    .orElse(null);
            Microbot.startPlugin(PluginObject);
        }
    }
    public static Plugin getPluginByName(String pluginName) {
        for (Plugin plugin : Microbot.getPluginManager().getPlugins()) {
            PluginDescriptor descriptor = plugin.getClass().getAnnotation(PluginDescriptor.class);
            if (descriptor != null && descriptor.name().contains(pluginName)) {
                return plugin;
            }
        }
        return null;
    }
    public static String startPluginByName(String pluginName) {
            System.out.println("Starting startPlugin"); // Debug line
            try {
                Microbot.getPluginManager().setPluginEnabled(getPluginByName(pluginName), true);
                sleep(100);
                Microbot.getPluginManager().startPlugins();
                //if (!(currentPluginName == null))
                //    lastPluginName = currentPluginName;
                //currentPluginName = pluginName;
                //activity = "running";
                //pluginStartTime = System.currentTimeMillis();
                System.out.println("started plugin: " + pluginName);
                return pluginName;
            } catch (Exception e) {
                System.out.println("Failed to start plugin: " + e.getMessage());
                return null;
            }
        }
    public static void stopPluginByName(String pluginName) {
        try {
            Microbot.getPluginManager().setPluginEnabled(getPluginByName(pluginName), false);
            sleep(500);
            SwingUtilities.invokeLater(() -> {
                try {
                    Microbot.getPluginManager().stopPlugin(getPluginByName(pluginName));
                    System.out.println("stopped plugin: " + pluginName);
                } catch (PluginInstantiationException e) {
                    System.out.println("error stopPlugin"); // Debug line
                    throw new RuntimeException(e);
                }
            });
        } catch (Exception e) {
            System.out.println("Failed to stop plugin: " + e.getMessage());
        }
    }
     /**
     * Hops to a new world
     */
    private void hopWorld() {
        // Stock level dropped below minimum, pause or stop execution
        System.out.println("Stock level dropped below minimum threshold.");
        Rs2Shop.closeShop();
        Rs2Bank.closeBank();
        sleep(2400, 4800); // this sleep is required to avoid the message: please finish what you're doing before using the world switcher.
        // This is where we need to hop worlds.
        int world = Login.getRandomWorld(true, null);
        boolean isHopped = Microbot.hopToWorld(world);
        if (!isHopped) return;
        Rs2Widget.sleepUntilHasWidget("Switch World");
        boolean result = sleepUntil(() -> Rs2Widget.findWidget("Switch World", null, false) != null, 10);
        if (result) {
            Rs2Keyboard.keyPress(KeyEvent.VK_SPACE);
            sleepUntil(() -> Microbot.getClient().getGameState() == GameState.HOPPING);
            sleepUntil(() -> Microbot.getClient().getGameState() == GameState.LOGGED_IN);
        }
    }
    public static int getSkillLevel(Skill skill) {
        return Microbot.getClient().getRealSkillLevel(skill);
    }
}
