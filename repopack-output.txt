This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-09-25T13:02:14.388Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
runelite-client/
  src/
    main/
      java/
        net/
          runelite/
            client/
              plugins/
                microbot/
                  example/
                    ExampleConfig.java
                    ExampleOverlay.java
                    ExamplePlugin.java
                    ExampleScript.java
                  util/
                    antiban/
                      enums/
                        Activity.java
                        ActivityIntensity.java
                        Category.java
                        CombatSkills.java
                        PlaySchedule.java
                        PlayStyle.java
                      ui/
                        ActivityPanel.java
                        CardPanel.java
                        CooldownPanel.java
                        GeneralPanel.java
                        MasterPanel.java
                        MicroBreakPanel.java
                        MousePanel.java
                        NavigationPanel.java
                        ProfilePanel.java
                        UiHelper.java
                      AntibanOverlay.java
                      AntibanPlugin.java
                      AntibanSetupTemplates.java
                      FieldUtil.java
                      MouseFatigue.java
                      Rs2Antiban.java
                      Rs2AntibanSettings.java
                    bank/
                      enums/
                        BankLocation.java
                      Rs2Bank.java
                    camera/
                      NpcTracker.java
                      Rs2Camera.java
                    combat/
                      Rs2Combat.java
                    depositbox/
                      Rs2DepositBox.java
                    dialogues/
                      Rs2Dialogue.java
                    equipment/
                      JewelleryLocationEnum.java
                      Rs2Equipment.java
                    gameobject/
                      Rs2Cannon.java
                      Rs2GameObject.java
                    grandexchange/
                      GrandExchangeSlots.java
                      Rs2GrandExchange.java
                    grounditem/
                      InteractModel.java
                      LootingParameters.java
                      Rs2GroundItem.java
                    inventory/
                      DropOrder.java
                      Rs2Inventory.java
                      Rs2Item.java
                    keyboard/
                      Rs2Keyboard.java
                    magic/
                      Rs2Magic.java
                      Rs2Spells.java
                    math/
                      Random.java
                      RateCalculator.java
                      Rs2Random.java
                    menu/
                      NewMenuEntry.java
                    misc/
                      Operation.java
                      Predicates.java
                      Rs2Food.java
                      Rs2Potion.java
                      Rs2UiHelper.java
                      SpecialAttackWeaponEnum.java
                      TimeUtils.java
                    models/
                      RS2Item.java
                    mouse/
                      naturalmouse/
                        api/
                          DeviationProvider.java
                          MouseInfoAccessor.java
                          MouseMotion.java
                          MouseMotionFactory.java
                          MouseMotionObserver.java
                          NoiseProvider.java
                          OvershootManager.java
                          SpeedManager.java
                          SystemCalls.java
                        support/
                          mousemotion/
                            MouseMovement.java
                            MovementFactory.java
                          DefaultMouseInfoAccessor.java
                          DefaultMouseMotionNature.java
                          DefaultNoiseProvider.java
                          DefaultOvershootManager.java
                          DefaultSpeedManager.java
                          DefaultSystemCalls.java
                          DoublePoint.java
                          Flow.java
                          MouseMotionNature.java
                          ScreenAdjustedNature.java
                          SinusoidalDeviationProvider.java
                        tools/
                          SystemDiagnosis.java
                        util/
                          FactoryTemplates.java
                          FlowTemplates.java
                          FlowUtil.java
                          MathUtil.java
                          Pair.java
                        NaturalMouse.java
                      Mouse.java
                      VirtualMouse.java
                    npc/
                      Rs2Npc.java
                      Rs2NpcManager.java
                      Rs2NpcStats.java
                    player/
                      NameGenerator.java
                      Rs2Player.java
                      Rs2Pvp.java
                    prayer/
                      Rs2Prayer.java
                      Rs2PrayerEnum.java
                    reflection/
                      Rs2Reflection.java
                    security/
                      Encryption.java
                      Login.java
                    settings/
                      Rs2Settings.java
                    shop/
                      Actions.java
                      Rs2Shop.java
                    tabs/
                      Rs2Tab.java
                      Tab.java
                    tile/
                      Rs2Tile.java
                    walker/
                      Rs2MiniMap.java
                      Rs2Walker.java
                    widget/
                      models/
                        ItemWidget.java
                      Rs2Widget.java
                    Global.java
                    MicrobotInventorySetup.java
                    Rs2InventorySetup.java
                VoxSylvaePlugins/
                  data/
                    locationData/
                      ancientMagicksTeleports.json
                      arceuusTeleports.json
                      fairyRingTeleports.json
                      JewelryTeleport.java
                      jewelryTeleports.json
                      lunarMagicTeleports.json
                      POHTeleportOptions.json
                      teleportationSpells.json
                  skilling/
                    hunter/
                      VoxSylvaeAIOHunter/
                        data/
                          hunterCreatureData.json
                        AIOHunterConfig.java
                        AIOHunterOverlay.java
                        AIOHunterTaskManager.java
                        CreatureLocation.java
                        HunterCreatureTarget.java
                        HunterMaster.java
                        HuntersRumoursPlugin.java
                        HuntersRumoursScript.java
                  util/
                    navigation/
                      VoxSylvaeNavigationOverlay.java
                      VoxSylvaeNavigationScript.java
                    teleport/
                      AbstractTeleport.java
                      FairyRingTeleport.java
                      ItemTeleport.java
                      JewelryTeleport.java
                      POHTeleport.java
                      StandardTeleport.java
                      Teleport.java
                      TeleportType.java
                    TeleportationManager.java
                    VoxSylvaeInventoryAndBankManagementScript.java
                    VoxSylvaeUtil.java

================================================================
Repository Files
================================================================

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/example/ExampleConfig.java
================
package net.runelite.client.plugins.microbot.example;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
@ConfigGroup("example")
public interface ExampleConfig extends Config {
/*    @ConfigItem(
            keyName = "Ore",
            name = "Ore",
            description = "Choose the ore",
            position = 0
    )
    default List<String> ORE()
    {
        return Rocks.TIN;
    }*/
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/example/ExampleOverlay.java
================
package net.runelite.client.plugins.microbot.example;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import javax.inject.Inject;
import javax.inject.Named;
import java.awt.*;
public class ExampleOverlay extends OverlayPanel {
    @Inject
    ExampleOverlay(ExamplePlugin plugin)
    {
        super(plugin);
        setPosition(OverlayPosition.TOP_LEFT);
        setNaughty();
    }
    @Override
    public Dimension render(Graphics2D graphics) {
        try {
            panelComponent.setPreferredSize(new Dimension(200, 300));
            panelComponent.getChildren().add(TitleComponent.builder()
                    .text("Micro Example V1.0.0")
                    .color(Color.GREEN)
                    .build());
            panelComponent.getChildren().add(LineComponent.builder().build());
            panelComponent.getChildren().add(LineComponent.builder()
                    .left(Microbot.status)
                    .build());
        } catch(Exception ex) {
            System.out.println(ex.getMessage());
        }
        return super.render(graphics);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/example/ExamplePlugin.java
================
package net.runelite.client.plugins.microbot.example;
import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.events.GameTick;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.ui.overlay.OverlayManager;
import javax.inject.Inject;
import java.awt.*;
@PluginDescriptor(
        name = PluginDescriptor.Default + "Example",
        description = "Microbot example plugin",
        tags = {"example", "microbot"},
        enabledByDefault = false
)
@Slf4j
public class ExamplePlugin extends Plugin {
    @Inject
    private ExampleConfig config;
    @Provides
    ExampleConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(ExampleConfig.class);
    }
    @Inject
    private OverlayManager overlayManager;
    @Inject
    private ExampleOverlay exampleOverlay;
    @Inject
    ExampleScript exampleScript;
    @Override
    protected void startUp() throws AWTException {
        if (overlayManager != null) {
            overlayManager.add(exampleOverlay);
        }
        exampleScript.run(config);
    }
    protected void shutDown() {
        exampleScript.shutdown();
        overlayManager.remove(exampleOverlay);
    }
    int ticks = 10;
    @Subscribe
    public void onGameTick(GameTick tick)
    {
        //System.out.println(getName().chars().mapToObj(i -> (char)(i + 3)).map(String::valueOf).collect(Collectors.joining()));
        if (ticks > 0) {
            ticks--;
        } else {
            ticks = 10;
        }
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/example/ExampleScript.java
================
package net.runelite.client.plugins.microbot.example;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.Script;
import net.runelite.client.plugins.microbot.util.grounditem.LootingParameters;
import net.runelite.client.plugins.microbot.util.grounditem.Rs2GroundItem;
import java.util.concurrent.TimeUnit;
public class ExampleScript extends Script {
    public static boolean test = false;
    public boolean run(ExampleConfig config) {
        Microbot.enableAutoRunOn = false;
        mainScheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(() -> {
            try {
                if (!Microbot.isLoggedIn()) return;
                if (!super.run()) return;
                long startTime = System.currentTimeMillis();
                test = false;
                LootingParameters valueParams = new LootingParameters(
                        5000,
                        Integer.MAX_VALUE,
                        20,
                        1,
                        0,
                        false,
                        false
                );
                Rs2GroundItem.loot("Vorkath's head", 20);
                if (Rs2GroundItem.lootItemBasedOnValue(valueParams)) {
                    System.out.println("Looing succesfull!");
                }
                /*for (int i = 0; i < 2; i++) {
                    System.out.println("loop:= " + i);
                    Rs2Inventory.waitForInventoryChanges();
                }*/
                long endTime = System.currentTimeMillis();
                long totalTime = endTime - startTime;
                System.out.println("Total time for loop " + totalTime);
            } catch (Exception ex) {
                System.out.println(ex.getMessage());
            }
        }, 0, 1000, TimeUnit.MILLISECONDS);
        return true;
    }
    @Override
    public void shutdown() {
        super.shutdown();
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/antiban/enums/Activity.java
================
package net.runelite.client.plugins.microbot.util.antiban.enums;
import lombok.Getter;
import net.runelite.api.Skill;
/**
 * The Activity enum represents various activities that the player can perform in the game, each associated with a specific
 * category and intensity level.
 *
 * <p>
 * Activities range from general skilling and combat tasks to specific high-intensity boss fights or complex tasks. Each activity
 * is linked to a <code>Category</code> that defines the type of activity (e.g., skilling, combat), and an <code>ActivityIntensity</code>
 * that controls how aggressive or passive the bot's behavior should be during that activity.
 * </p>
 *
 * <h3>Main Features:</h3>
 * <ul>
 *   <li>Wide Range of Activities: Covers general skilling activities such as mining, cooking, and woodcutting,
 *   as well as high-intensity tasks like boss fights and combat encounters.</li>
 *   <li>Category Association: Each activity is linked to a <code>Category</code> that helps the bot identify the
 *   type of activity and how to handle it.</li>
 *   <li>Intensity Levels: Activities have different intensity levels based on their complexity and demands, which are
 *   represented by <code>ActivityIntensity</code>. For example, combat activities tend to have higher intensity, while
 *   skilling tasks may be more moderate or low intensity.</li>
 *   <li>Skill Mapping: The enum provides a method to map game skills to the appropriate general activity,
 *   ensuring that the bot behaves correctly when training a particular skill.</li>
 * </ul>
 *
 * <h3>Usage:</h3>
 * <p>
 * The <code>Activity</code> enum is used to control bot behavior based on the type of activity the player is performing.
 * Each activity informs the bot of the type of task being executed, its intensity, and the corresponding category to ensure
 * appropriate behavior, such as taking breaks or adjusting actions dynamically.
 * </p>
 *
 * <h3>Example:</h3>
 * <pre>
 * Rs2Antiban.setActivity(Activity activity);
 * Rs2Antiban.getCategory();
 * Rs2Antiban.setActivityIntensity(ActivityIntensity activityIntensity);
 * </pre>
 *
 * <h3>Skill-Based Activity Mapping:</h3>
 * <p>
 * The <code>fromSkill(Skill skill)</code> method maps in-game skills (e.g., Mining, Fishing, Combat) to general activities,
 * allowing the bot to adjust its behavior based on the skill currently being trained. This ensures that the bot
 * behaves consistently for all general activities related to a specific skill.
 * </p>
 *
 * <h3>Activity Categories and Intensities:</h3>
 * <p>
 * Each activity belongs to a <code>Category</code> that defines the overall type of the activity (e.g., skilling, combat,
 * collecting), and each is assigned an <code>ActivityIntensity</code> level, which determines the speed and aggression of
 * the bot's actions during that activity.
 * </p>
 */
public enum Activity {
    GENERAL_MINING("General Mining", Category.SKILLING_MINING, ActivityIntensity.LOW),
    GENERAL_SMITHING("General Smithing", Category.SKILLING_SMITHING, ActivityIntensity.LOW),
    GENERAL_FISHING("General Fishing", Category.SKILLING_FISHING, ActivityIntensity.LOW),
    GENERAL_COOKING("General Cooking", Category.SKILLING_COOKING, ActivityIntensity.LOW),
    GENERAL_FIREMAKING("General Firemaking", Category.SKILLING_FIREMAKING, ActivityIntensity.LOW),
    GENERAL_WOODCUTTING("General Woodcutting", Category.SKILLING_WOODCUTTING, ActivityIntensity.LOW),
    GENERAL_FLETCHING("General Fletching", Category.SKILLING_FLETCHING, ActivityIntensity.LOW),
    GENERAL_CRAFTING("General Crafting", Category.SKILLING_CRAFTING, ActivityIntensity.LOW),
    GENERAL_AGILITY("General Agility", Category.SKILLING_AGILITY, ActivityIntensity.MODERATE),
    GENERAL_THIEVING("General Thieving", Category.SKILLING_THIEVING, ActivityIntensity.MODERATE),
    GENERAL_SLAYER("General Slayer", Category.COMBAT_HIGH, ActivityIntensity.MODERATE),
    GENERAL_RUNECRAFT("General Runecraft", Category.SKILLING_RUNECRAFT, ActivityIntensity.MODERATE),
    GENERAL_HUNTER("General Hunter", Category.SKILLING_HUNTER, ActivityIntensity.MODERATE),
    GENERAL_COMBAT("General Combat", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    GENERAL_HERBLORE("General Herblore", Category.SKILLING_HERBLORE, ActivityIntensity.LOW),
    GENERAL_FARMING("General Farming", Category.SKILLING_FARMING, ActivityIntensity.MODERATE),
    GENERAL_PRAYER("General Prayer", Category.SKILLING_PRAYER, ActivityIntensity.HIGH),
    GENERAL_CONSTRUCTION("General Construction", Category.SKILLING_CONSTRUCTION, ActivityIntensity.MODERATE),
    GENERAL_COLLECTING("General Collecting", Category.COLLECTING, ActivityIntensity.MODERATE),
    COMPLETING_THE_FORTIS_COLOSSEUM_WAVE_12("Completing the Fortis Colosseum (Wave 12)", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    KILLING_NEX_DUO("Killing Nex (Duo)", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    TOMBS_OF_AMASCUT_SOLO_500_RAID_LEVEL("Tombs of Amascut (solo 500 raid level)", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    KILLING_NEX_TEAM("Killing Nex (Team)", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    THEATRE_OF_BLOOD_SCYTHE_OF_VITUR("Theatre of Blood (Scythe of vitur)", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    CHAMBERS_OF_XERIC("Chambers of Xeric", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    THEATRE_OF_BLOOD_ABYSSAL_TENTACLE("Theatre of Blood (Abyssal tentacle)", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    KILLING_KREEARRA("Killing Kreearra", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    KILLING_PHOSANIS_NIGHTMARE("Killing Phosanis Nightmare", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    KILLING_VENENATIS("Killing Venenatis", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    KILLING_VARDORVIS("Killing Vardorvis", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    TOMBS_OF_AMASCUT_EXPERT("Tombs of Amascut (Expert)", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    KILLING_COMMANDER_ZILYANA("Killing Commander Zilyana", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    KILLING_SPINDEL("Killing Spindel", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    KILLING_VETION("Killing Vetion", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    KILLING_PHANTOM_MUSPAH_TWISTED_BOW("Killing Phantom Muspah (Twisted bow)", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    KILLING_THE_ALCHEMICAL_HYDRA("Killing the Alchemical Hydra", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    COMPLETING_THE_CORRUPTED_GAUNTLET("Completing The Corrupted Gauntlet", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    KILLING_CERBERUS("Killing Cerberus", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    KILLING_GENERAL_GRAARDOR("Killing General Graardor", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    KILLING_DEMONIC_GORILLAS("Killing demonic gorillas", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    KILLING_THE_WHISPERER("Killing The Whisperer", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    KILLING_DUKE_SUCELLUS("Killing Duke Sucellus", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    KILLING_THE_NIGHTMARE("Killing The Nightmare", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    KILLING_CALVARION("Killing Calvarion", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    KILLING_THE_LEVIATHAN("Killing The Leviathan", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    PICKPOCKETING_VYRES("Pickpocketing vyres", Category.SKILLING_THIEVING, ActivityIntensity.HIGH),
    KILLING_CALLISTO("Killing Callisto", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    KILLING_REVENANTS_CRAWS_BOW("Killing revenants (Craws bow)", Category.COMBAT_MID, ActivityIntensity.HIGH),
    KILLING_ARTIO("Killing Artio", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    KILLING_VORKATH_DRAGON_HUNTER_LANCE("Killing Vorkath (Dragon hunter lance)", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    KILLING_VORKATH_DRAGON_HUNTER_CROSSBOW("Killing Vorkath (Dragon hunter crossbow)", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    KILLING_ZULRAH_MAX_EFFICIENCY("Killing Zulrah (max efficiency)", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    COMPLETING_THE_FORTIS_COLOSSEUM_WAVE_1("Completing the Fortis Colosseum (Wave 1)", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    WILDERNESS_AGILITY_COURSE("Wilderness Agility Course", Category.SKILLING_AGILITY, ActivityIntensity.HIGH),
    KILLING_KRIL_TSUTSAROTH("Killing Kril Tsutsaroth", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    KILLING_REVENANTS_MAGIC_SHORTBOW("Killing revenants (Magic shortbow)", Category.COMBAT_MID, ActivityIntensity.HIGH),
    PICKPOCKETING_ELVES("Pickpocketing elves", Category.SKILLING_THIEVING, ActivityIntensity.HIGH),
    KILLING_DAGANNOTH_KINGS_SOLO_TRIBRID("Killing Dagannoth Kings (Solo tribrid)", Category.COMBAT_HIGH, ActivityIntensity.MODERATE),
    KILLING_THE_CORPOREAL_BEAST("Killing the Corporeal Beast", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    KILLING_ZOMBIE_PIRATES("Killing zombie pirates", Category.COMBAT_LOW, ActivityIntensity.HIGH),
    OPENING_ESSENCE_IMPLING_JARS("Opening essence impling jars", Category.PROCESSING, ActivityIntensity.HIGH),
    CRAFTING_WRATH_RUNES("Crafting wrath runes", Category.SKILLING_RUNECRAFT, ActivityIntensity.HIGH),
    KILLING_THE_GIANT_MOLE_TWISTED_BOW("Killing the Giant Mole (Twisted bow)", Category.COMBAT_MID, ActivityIntensity.LOW),
    STEALING_FROM_ROGUES_CASTLE_CHESTS("Stealing from Rogues Castle chests", Category.SKILLING_THIEVING, ActivityIntensity.HIGH),
    COMPLETING_THE_GAUNTLET("Completing The Gauntlet", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    DELIVERING_FOOD_IN_GNOME_RESTAURANT("Delivering food in Gnome Restaurant", Category.COLLECTING, ActivityIntensity.HIGH),
    OPENING_GRUBBY_CHESTS("Opening grubby chests", Category.PROCESSING, ActivityIntensity.HIGH),
    MOONS_OF_PERIL("Moons of Peril", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    CRAFTING_BLOOD_RUNES("Crafting blood runes", Category.SKILLING_RUNECRAFT, ActivityIntensity.HIGH),
    KILLING_VORKATH_TOXIC_BLOWPIPE("Killing Vorkath (Toxic blowpipe)", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    HALLOWED_SEPULCHRE("Hallowed Sepulchre", Category.SKILLING_AGILITY, ActivityIntensity.HIGH),
    OPENING_SINISTER_CHESTS("Opening sinister chests", Category.PROCESSING, ActivityIntensity.HIGH),
    CRAFTING_ASTRAL_RUNES("Crafting astral runes", Category.SKILLING_RUNECRAFT, ActivityIntensity.HIGH),
    OPENING_ECLECTIC_IMPLING_JARS("Opening eclectic impling jars", Category.PROCESSING, ActivityIntensity.HIGH),
    MAKING_TOY_CATS("Making toy cats", Category.PROCESSING, ActivityIntensity.HIGH),
    CRAFTING_SUNFIRE_RUNES("Crafting sunfire runes", Category.SKILLING_RUNECRAFT, ActivityIntensity.HIGH),
    SMELTING_RUNITE_BARS_AT_BLAST_FURNACE("Smelting runite bars at Blast Furnace", Category.SKILLING_SMITHING, ActivityIntensity.HIGH),
    FILLING_BULLSEYE_LANTERN_EMPTY("Filling bullseye lantern (empty)", Category.PROCESSING, ActivityIntensity.MODERATE),
    KILLING_THE_THERMONUCLEAR_SMOKE_DEVIL("Killing the Thermonuclear smoke devil", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    BUYING_MONKEY_NUTS("Buying monkey nuts", Category.COLLECTING, ActivityIntensity.LOW),
    KILLING_ZALCANO("Killing Zalcano", Category.SKILLING, ActivityIntensity.HIGH),
    KILLING_RUNE_DRAGONS("Killing rune dragons", Category.COMBAT_HIGH, ActivityIntensity.MODERATE),
    KILLING_LIZARDMAN_SHAMANS_CANYON("Killing Lizardman Shamans (Canyon)", Category.COMBAT_HIGH, ActivityIntensity.MODERATE),
    CRAFTING_DEATH_RUNES_THROUGH_THE_ABYSS("Crafting death runes through the Abyss", Category.SKILLING_RUNECRAFT, ActivityIntensity.MODERATE),
    KILLING_ZULRAH("Killing Zulrah", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    CRAFTING_DOUBLE_LAW_RUNES_THROUGH_THE_ABYSS("Crafting double law runes through the Abyss", Category.SKILLING_RUNECRAFT, ActivityIntensity.MODERATE),
    KILLING_LAVA_DRAGONS("Killing lava dragons", Category.COMBAT_HIGH, ActivityIntensity.MODERATE),
    KILLING_DAGANNOTH_KINGS_REX_ONLY("Killing Dagannoth Kings (Rex only)", Category.COMBAT_MID, ActivityIntensity.LOW),
    OPENING_CRYSTAL_CHESTS("Opening crystal chests", Category.PROCESSING, ActivityIntensity.HIGH),
    MAKING_REDWOOD_PYRE_LOGS("Making redwood pyre logs", Category.PROCESSING, ActivityIntensity.MODERATE),
    MAKING_SACRED_OIL("Making sacred oil", Category.SKILLING_CRAFTING, ActivityIntensity.LOW),
    MAKING_DIVINE_SUPER_COMBAT_POTIONS("Making divine super combat potions", Category.SKILLING_HERBLORE, ActivityIntensity.LOW),
    KILLING_THE_ABYSSAL_SIRE("Killing the Abyssal Sire", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    KILLING_THE_GIANT_MOLE_DHAROKS("Killing the Giant Mole (Dharoks)", Category.COMBAT_MID, ActivityIntensity.LOW),
    BUYING_KEGS_OF_BEER("Buying kegs of beer", Category.COLLECTING, ActivityIntensity.MODERATE),
    MAKING_AVANTOE_POTIONS("Making avantoe potions", Category.PROCESSING, ActivityIntensity.LOW),
    PICKPOCKETING_HAM_MEMBERS("Pickpocketing H.A.M. members", Category.SKILLING_THIEVING, ActivityIntensity.HIGH),
    HUNTING_BLACK_CHINCHOMPAS("Hunting black chinchompas", Category.SKILLING_HUNTER, ActivityIntensity.MODERATE),
    MAKING_SNAPDRAGON_POTIONS("Making snapdragon potions", Category.PROCESSING, ActivityIntensity.LOW),
    CASTING_TAN_LEATHER("Casting Tan Leather", Category.SKILLING_MAGIC, ActivityIntensity.MODERATE),
    KILLING_THE_GROTESQUE_GUARDIANS("Killing the Grotesque Guardians", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    HUNTING_IMPLINGS("Hunting implings", Category.SKILLING_HUNTER, ActivityIntensity.HIGH),
    CRAFTING_BLOOD_RUNES_THROUGH_THE_ABYSS("Crafting blood runes through the Abyss", Category.SKILLING_RUNECRAFT, ActivityIntensity.HIGH),
    MAKING_MAGIC_PYRE_LOGS("Making magic pyre logs", Category.PROCESSING, ActivityIntensity.MODERATE),
    KILLING_BRUTAL_BLACK_DRAGONS("Killing brutal black dragons", Category.COMBAT_HIGH, ActivityIntensity.LOW),
    MAKING_RANARR_POTIONS("Making ranarr potions", Category.PROCESSING, ActivityIntensity.LOW),
    KILLING_HYDRAS("Killing hydras", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    ENCHANTING_DRAGONSTONE_JEWELLERY("Enchanting dragonstone jewellery", Category.SKILLING_MAGIC, ActivityIntensity.MODERATE),
    MAKING_SANFEW_SERUM4("Making sanfew serum(4)", Category.SKILLING_HERBLORE, ActivityIntensity.MODERATE),
    MAKING_DWARF_WEED_POTIONS("Making dwarf weed potions", Category.PROCESSING, ActivityIntensity.LOW),
    SMELTING_ADAMANTITE_BARS_AT_BLAST_FURNACE("Smelting adamantite bars at Blast Furnace", Category.SKILLING_SMITHING, ActivityIntensity.HIGH),
    MAKING_KWUARM_POTIONS("Making kwuarm potions", Category.PROCESSING, ActivityIntensity.LOW),
    MAKING_CADANTINE_POTIONS("Making cadantine potions", Category.PROCESSING, ActivityIntensity.LOW),
    KILLING_GREEN_DRAGONS_MYTHS_GUILD("Killing green dragons (Myths Guild)", Category.COMBAT_MID, ActivityIntensity.MODERATE),
    MAKING_RAW_WILD_PIES("Making raw wild pies", Category.PROCESSING, ActivityIntensity.HIGH),
    KILLING_VYREWATCH_SENTINELS("Killing Vyrewatch Sentinels", Category.COMBAT_HIGH, ActivityIntensity.LOW),
    KILLING_THE_KRAKEN("Killing the Kraken", Category.COMBAT_HIGH, ActivityIntensity.LOW),
    KILLING_FIYR_SHADES("Killing fiyr shades", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    MAKING_TOADFLAX_POTIONS("Making toadflax potions", Category.PROCESSING, ActivityIntensity.LOW),
    KILLING_GREEN_DRAGONS("Killing green dragons", Category.COMBAT_MID, ActivityIntensity.MODERATE),
    MAKING_LANTADYME_POTIONS("Making lantadyme potions", Category.PROCESSING, ActivityIntensity.LOW),
    BARROWS("Barrows", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    PICKPOCKETING_MASTER_FARMERS("Pickpocketing master farmers", Category.SKILLING_THIEVING, ActivityIntensity.MODERATE),
    KILLING_LIZARDMAN_SHAMANS_SETTLEMENT_OR_TEMPLE("Killing Lizardman Shamans (Settlement or Temple)", Category.COMBAT_HIGH, ActivityIntensity.MODERATE),
    COLLECTING_MORT_MYRE_FUNGI("Collecting mort myre fungi", Category.COLLECTING, ActivityIntensity.LOW),
    HUNTING_MOONLIGHT_ANTELOPES("Hunting moonlight antelopes", Category.SKILLING_HUNTER, ActivityIntensity.MODERATE),
    COMPLETING_ELITE_CLUES_URIUM_REMAINS("Completing elite clues (urium remains)", Category.SKILLING_FIREMAKING, ActivityIntensity.HIGH),
    MAKING_WEAPON_POISON_PLUS_PLUS("Making weapon poison(++)", Category.COLLECTING, ActivityIntensity.HIGH),
    KILLING_MITHRIL_DRAGONS("Killing mithril dragons", Category.COMBAT_HIGH, ActivityIntensity.MODERATE),
    KILLING_URIUM_SHADES("Killing urium shades", Category.COMBAT_HIGH, ActivityIntensity.MODERATE),
    MAKING_GUTHIX_RESTS("Making Guthix rests", Category.PROCESSING, ActivityIntensity.HIGH),
    SMELTING_STEEL_BARS_AT_BLAST_FURNACE("Smelting steel bars at Blast Furnace", Category.SKILLING_SMITHING, ActivityIntensity.HIGH),
    KILLING_SKELETAL_WYVERNS("Killing skeletal wyverns", Category.COMBAT_HIGH, ActivityIntensity.LOW),
    CRAFTING_DRIFT_NETS("Crafting drift nets", Category.SKILLING_CRAFTING, ActivityIntensity.MODERATE),
    SMITHING_RUNE_ITEMS("Smithing rune items", Category.SKILLING_SMITHING, ActivityIntensity.LOW),
    MINING_RUNITE_ORE("Mining runite ore", Category.SKILLING_MINING, ActivityIntensity.LOW),
    MAKING_IRIT_POTIONS("Making irit potions", Category.PROCESSING, ActivityIntensity.LOW),
    LAST_MAN_STANDING("Last Man Standing", Category.COMBAT_LOW, ActivityIntensity.HIGH),
    CREATING_TELEPORT_TABLETS_AT_LECTERN_LUNAR("Creating teleport tablets at Lectern (Lunar)", Category.SKILLING_MAGIC, ActivityIntensity.LOW),
    MAKING_ULTRACOMPOST("Making ultracompost", Category.PROCESSING, ActivityIntensity.LOW),
    KILLING_FEVER_SPIDERS_MAXIMUM_EFFICIENCY("Killing fever spiders (maximum efficiency)", Category.COMBAT_LOW, ActivityIntensity.HIGH),
    FLETCHING_MOONLIGHT_ANTLER_BOLTS("Fletching moonlight antler bolts", Category.PROCESSING, ActivityIntensity.LOW),
    KILLING_DISCIPLES_OF_IBAN("Killing disciples of Iban", Category.COMBAT_LOW, ActivityIntensity.MODERATE),
    KILLING_GARGOYLES("Killing gargoyles", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    FLETCHING_OGRE_ARROW_SHAFTS("Fletching ogre arrow shafts", Category.PROCESSING, ActivityIntensity.LOW),
    KILLING_ENTS("Killing ents", Category.COMBAT_MID, ActivityIntensity.MODERATE),
    GRINDING_DESERT_GOAT_HORNS("Grinding desert goat horns", Category.PROCESSING, ActivityIntensity.MODERATE),
    GRINDING_UNICORN_HORNS("Grinding unicorn horns", Category.PROCESSING, ActivityIntensity.MODERATE),
    CRAFTING_DRAGONSTONE_JEWELLERY("Crafting dragonstone jewellery", Category.SKILLING_CRAFTING, ActivityIntensity.LOW),
    CRAFTING_BLOOD_RUNES_AT_ARCEUUS_MAX("Crafting blood runes at Arceuus (max)", Category.SKILLING_RUNECRAFT, ActivityIntensity.LOW),
    HUNTING_SUNLIGHT_ANTELOPES("Hunting sunlight antelopes", Category.SKILLING_HUNTER, ActivityIntensity.MODERATE),
    PICKPOCKETING_PALADINS("Pickpocketing paladins", Category.SKILLING_THIEVING, ActivityIntensity.MODERATE),
    STEALING_CAVE_GOBLIN_WIRE("Stealing cave goblin wire", Category.COLLECTING, ActivityIntensity.HIGH),
    CRAFTING_COSMIC_RUNES_THROUGH_THE_ABYSS("Crafting cosmic runes through the Abyss", Category.SKILLING_RUNECRAFT, ActivityIntensity.MODERATE),
    MINING_BASALT("Mining basalt", Category.SKILLING_MINING, ActivityIntensity.LOW),
    TANNING_RED_DRAGONHIDE("Tanning red dragonhide", Category.PROCESSING, ActivityIntensity.LOW),
    CRAFTING_BLOOD_RUNES_AT_ARCEUUS_NO_DIARY("Crafting blood runes at Arceuus (no diary)", Category.SKILLING_RUNECRAFT, ActivityIntensity.LOW),
    MAKING_PINEAPPLE_PIZZAS("Making pineapple pizzas", Category.SKILLING_COOKING, ActivityIntensity.HIGH),
    MAKING_HARRALANDER_POTIONS("Making harralander potions", Category.PROCESSING, ActivityIntensity.LOW),
    KILLING_BLUE_DRAGONS("Killing blue dragons", Category.COMBAT_MID, ActivityIntensity.MODERATE),
    MINING_GEMSTONES("Mining gemstones", Category.SKILLING_MINING, ActivityIntensity.MODERATE),
    CRAFTING_OPAL_BRACELETS("Crafting opal bracelets", Category.SKILLING_CRAFTING, ActivityIntensity.LOW),
    ENCHANTING_TOPAZ_JEWELLERY("Enchanting topaz jewellery", Category.SKILLING_MAGIC, ActivityIntensity.MODERATE),
    KILLING_SARACHNIS("Killing Sarachnis", Category.COMBAT_MID, ActivityIntensity.MODERATE),
    BUYING_BEER_TANKARDS("Buying beer tankards", Category.PROCESSING, ActivityIntensity.MODERATE),
    CRAFTING_XERICIAN_ROBES("Crafting Xerician robes", Category.SKILLING_CRAFTING, ActivityIntensity.LOW),
    SMELTING_MITHRIL_BARS_AT_BLAST_FURNACE("Smelting mithril bars at Blast Furnace", Category.SKILLING_SMITHING, ActivityIntensity.HIGH),
    CHARGING_AND_ALCHEMISING_BRACELETS_OF_ETHEREUM("Charging and alchemising bracelets of ethereum", Category.PROCESSING, ActivityIntensity.MODERATE),
    CREATING_TELEPORT_TO_HOUSE_TABLETS("Creating teleport to house tablets", Category.PROCESSING, ActivityIntensity.LOW),
    CREATING_BARROWS_TELEPORT_TABLETS("Creating Barrows teleport tablets", Category.SKILLING_MAGIC, ActivityIntensity.LOW),
    KILLING_THE_KALPHITE_QUEEN("Killing the Kalphite Queen", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    CRAFTING_LAW_RUNES_THROUGH_THE_ABYSS("Crafting law runes through the Abyss", Category.SKILLING_RUNECRAFT, ActivityIntensity.MODERATE),
    CRAFTING_COSMIC_RUNES("Crafting cosmic runes", Category.SKILLING_RUNECRAFT, ActivityIntensity.HIGH),
    FILLING_BUCKETS_WITH_WATER("Filling buckets with water", Category.SKILLING_MAGIC, ActivityIntensity.MODERATE),
    ENCHANTING_JADE_AMULETS("Enchanting jade amulets", Category.SKILLING_MAGIC, ActivityIntensity.MODERATE),
    HUNTING_HERBIBOARS("Hunting herbiboars", Category.SKILLING_HUNTER, ActivityIntensity.LOW),
    TEMPLE_TREKKING("Temple Trekking", Category.COMBAT_LOW, ActivityIntensity.LOW),
    FLETCHING_RUBY_BOLTS("Fletching ruby bolts", Category.SKILLING_FLETCHING, ActivityIntensity.LOW),
    PLANTING_MITHRIL_SEEDS("Planting mithril seeds", Category.COLLECTING, ActivityIntensity.LOW),
    MAKING_RAW_SUMMER_PIES("Making raw summer pies", Category.PROCESSING, ActivityIntensity.MODERATE),
    CRUSHING_BIRD_NESTS("Crushing bird nests", Category.PROCESSING, ActivityIntensity.MODERATE),
    FLETCHING_FLIGHTED_OGRE_ARROWS("Fletching flighted ogre arrows", Category.PROCESSING, ActivityIntensity.LOW),
    HIGH_ALCHING_MYSTIC_EARTH_STAVES_AT_THE_FOUNTAIN_OF_RUNE("High alching mystic earth staves at the fountain of rune", Category.SKILLING_MAGIC, ActivityIntensity.LOW),
    TANNING_BLACK_DRAGONHIDE("Tanning black dragonhide", Category.PROCESSING, ActivityIntensity.LOW),
    HIGH_ALCHING_MYSTIC_WATER_STAVES_AT_THE_FOUNTAIN_OF_RUNE("High alching mystic water staves at the fountain of rune", Category.SKILLING_MAGIC, ActivityIntensity.LOW),
    BLAST_MINING("Blast mining", Category.SKILLING_MINING, ActivityIntensity.MODERATE),
    HIGH_ALCHING_MYSTIC_AIR_STAVES_AT_THE_FOUNTAIN_OF_RUNE("High alching mystic air staves at the fountain of rune", Category.SKILLING_MAGIC, ActivityIntensity.LOW),
    CRAFTING_SOUL_RUNES("Crafting soul runes", Category.SKILLING_RUNECRAFT, ActivityIntensity.HIGH),
    MAKING_TARROMIN_POTIONS("Making tarromin potions", Category.PROCESSING, ActivityIntensity.LOW),
    KILLING_FEVER_SPIDERS_ALCHING("Killing fever spiders (alching", Category.COMBAT_LOW, ActivityIntensity.HIGH),
    MAKING_ADAMANT_BRUTAL_ARROWS("Making adamant brutal arrows", Category.PROCESSING, ActivityIntensity.LOW),
    CASTING_SUPERGLASS_MAKE("Casting Superglass Make", Category.SKILLING_MAGIC, ActivityIntensity.HIGH),
    KILLING_FEVER_SPIDERS_NO_CANNON("Killing fever spiders (no cannon)", Category.COMBAT_LOW, ActivityIntensity.MODERATE),
    MAKING_RAW_ADMIRAL_PIES("Making raw admiral pies", Category.PROCESSING, ActivityIntensity.HIGH),
    CRAFTING_TOPAZ_BRACELETS("Crafting topaz bracelets", Category.SKILLING_CRAFTING, ActivityIntensity.LOW),
    MINING_RUNITE_ORE_FREE_TO_PLAY("Mining runite ore (free-to-play)", Category.SKILLING_MINING, ActivityIntensity.MODERATE),
    CREATING_VARROCK_TELEPORT_TABLETS("Creating Varrock teleport tablets", Category.PROCESSING, ActivityIntensity.LOW),
    CLEANING_GRIMY_TORSTOL("Cleaning grimy torstol", Category.SKILLING_HERBLORE, ActivityIntensity.HIGH),
    CHARGING_AIR_ORBS("Charging air orbs", Category.SKILLING_MAGIC, ActivityIntensity.MODERATE),
    KILLING_BRUTAL_RED_DRAGONS("Killing brutal red dragons", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    HUNTING_CARNIVOROUS_CHINCHOMPAS("Hunting carnivorous chinchompas", Category.SKILLING_HUNTER, ActivityIntensity.MODERATE),
    CRAFTING_NATURE_RUNES_THROUGH_THE_ABYSS("Crafting nature runes through the Abyss", Category.SKILLING_RUNECRAFT, ActivityIntensity.HIGH),
    HIGH_ALCHING_PROFITABLE_FREE_TO_PLAY_ITEMS("High alching profitable free-to-play items", Category.SKILLING_MAGIC, ActivityIntensity.LOW),
    HUMIDIFYING_CLAY("Humidifying clay", Category.SKILLING_MAGIC, ActivityIntensity.MODERATE),
    SEARCHING_A_HERBLORE_CAPE("Searching a herblore cape", Category.COLLECTING, ActivityIntensity.HIGH),
    KILLING_SKOGRES_AND_ZOGRES("Killing skogres and zogres", Category.COMBAT_MID, ActivityIntensity.MODERATE),
    CRAFTING_BLOOD_RUNES_AT_ARCEUUS_MINIMAL_REQUIREMENTS("Crafting blood runes at Arceuus (minimal requirements)", Category.SKILLING_RUNECRAFT, ActivityIntensity.LOW),
    CATCHING_DARK_CRABS("Catching dark crabs", Category.SKILLING_FISHING, ActivityIntensity.LOW),
    COOKING_RAW_SUNLIGHT_ANTELOPE("Cooking raw sunlight antelope", Category.SKILLING_COOKING, ActivityIntensity.LOW),
    KILLING_ICE_TROLL_RUNTS("Killing ice troll runts", Category.COMBAT_MID, ActivityIntensity.MODERATE),
    SMITHING_CANNONBALLS("Smithing cannonballs", Category.SKILLING_SMITHING, ActivityIntensity.LOW),
    MINING_SALTS("Mining salts", Category.SKILLING_MINING, ActivityIntensity.LOW),
    CUTTING_DIAMOND_BOLT_TIPS("Cutting diamond bolt tips", Category.PROCESSING, ActivityIntensity.LOW),
    MAKING_MARRENTILL_POTIONS("Making marrentill potions", Category.PROCESSING, ActivityIntensity.LOW),
    HIGH_ALCHING_COMBAT_BRACELETS_AT_THE_FOUNTAIN_OF_RUNE("High alching combat bracelets at the fountain of rune", Category.SKILLING_MAGIC, ActivityIntensity.LOW),
    CRAFTING_LIMESTONE_BRICKS("Crafting limestone bricks", Category.PROCESSING, ActivityIntensity.HIGH),
    TANNING_BLUE_DRAGONHIDE("Tanning blue dragonhide", Category.PROCESSING, ActivityIntensity.LOW),
    MAKING_MAHOGANY_PLANKS("Making mahogany planks", Category.PROCESSING, ActivityIntensity.HIGH),
    CRAFTING_RUBY_BRACELETS("Crafting ruby bracelets", Category.SKILLING_CRAFTING, ActivityIntensity.LOW),
    MAKING_GUAM_POTIONS("Making guam potions", Category.PROCESSING, ActivityIntensity.LOW),
    CRAFTING_DIAMOND_BRACELETS("Crafting diamond bracelets", Category.SKILLING_CRAFTING, ActivityIntensity.LOW),
    CLEANING_GRIMY_KWUARM("Cleaning grimy kwuarm", Category.SKILLING_HERBLORE, ActivityIntensity.HIGH),
    CREATING_CAMELOT_TELEPORT_TABLETS("Creating Camelot teleport tablets", Category.PROCESSING, ActivityIntensity.LOW),
    EXCHANGING_IMPLING_JARS("Exchanging impling jars", Category.PROCESSING, ActivityIntensity.MODERATE),
    HIGH_ALCHING_RUNITE_LIMBS_AT_THE_FOUNTAIN_OF_RUNE("High alching runite limbs at the fountain of rune", Category.SKILLING_MAGIC, ActivityIntensity.LOW),
    COLLECTING_CLIMBING_BOOTS("Collecting climbing boots", Category.COLLECTING, ActivityIntensity.HIGH),
    BLESSING_UNBLESSED_SYMBOLS("Blessing unblessed symbols", Category.PROCESSING, ActivityIntensity.LOW),
    CHARGING_FIRE_ORBS("Charging fire orbs", Category.SKILLING_MAGIC, ActivityIntensity.LOW),
    MINING_AMETHYST("Mining amethyst", Category.SKILLING_MINING, ActivityIntensity.LOW),
    MINING_IRON_ORE("Mining iron ore", Category.SKILLING_MINING, ActivityIntensity.MODERATE),
    MAKING_OAK_PLANKS("Making oak planks", Category.PROCESSING, ActivityIntensity.MODERATE),
    TANNING_GREEN_DRAGONHIDE("Tanning green dragonhide", Category.PROCESSING, ActivityIntensity.LOW),
    MOTHERLODE_MINE("Motherlode Mine", Category.SKILLING_MINING, ActivityIntensity.LOW),
    MAKING_MAHOGANY_PLANKS_AT_THE_WOODCUTTING_GUILD("Making mahogany planks at the Woodcutting Guild", Category.PROCESSING, ActivityIntensity.MODERATE),
    COLLECTING_SNAPE_GRASS("Collecting snape grass", Category.COLLECTING, ActivityIntensity.LOW),
    CUTTING_AMETHYST_ARROWTIPS("Cutting amethyst arrowtips", Category.PROCESSING, ActivityIntensity.LOW),
    KILLING_THE_KING_BLACK_DRAGON("Killing the King Black Dragon", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    RECHARGING_RINGS_OF_WEALTH("Recharging rings of wealth", Category.PROCESSING, ActivityIntensity.MODERATE),
    COLLECTING_MONKS_ROBES("Collecting monks robes", Category.COLLECTING, ActivityIntensity.LOW),
    LOOTING_OGRE_COFFINS("Looting ogre coffins", Category.COLLECTING, ActivityIntensity.MODERATE),
    CASTING_SPIN_FLAX("Casting Spin Flax", Category.SKILLING_MAGIC, ActivityIntensity.MODERATE),
    KILLING_JUBSTERS("Killing Jubsters", Category.COMBAT_LOW, ActivityIntensity.LOW),
    FLETCHING_HEADLESS_ARROWS("Fletching headless arrows", Category.PROCESSING, ActivityIntensity.LOW),
    CASTING_PLANK_MAKE("Casting plank make", Category.SKILLING_MAGIC, ActivityIntensity.LOW),
    MAKING_DYNAMITE("Making dynamite", Category.SKILLING_MINING, ActivityIntensity.MODERATE),
    CRAFTING_SAPPHIRE_BRACELETS("Crafting sapphire bracelets", Category.SKILLING_CRAFTING, ActivityIntensity.LOW),
    BUYING_IRON_ORE("Buying iron ore", Category.COLLECTING, ActivityIntensity.MODERATE),
    SMITHING_BRONZE_DART_TIPS("Smithing bronze dart tips", Category.SKILLING_SMITHING, ActivityIntensity.LOW),
    CLEANING_GRIMY_CADANTINE("Cleaning grimy cadantine", Category.SKILLING_HERBLORE, ActivityIntensity.HIGH),
    CRAFTING_JADE_BRACELETS("Crafting jade bracelets", Category.SKILLING_CRAFTING, ActivityIntensity.LOW),
    DEGRIMING_GRIMY_GUAM_LEAF("Degriming grimy guam leaf", Category.SKILLING_HERBLORE, ActivityIntensity.HIGH),
    CHARGING_WATER_ORBS("Charging water orbs", Category.SKILLING_MAGIC, ActivityIntensity.LOW),
    CATCHING_RAW_KARAMBWAN("Catching raw karambwan", Category.SKILLING_FISHING, ActivityIntensity.LOW),
    BUYING_TEAM_CAPES("Buying team capes", Category.COLLECTING, ActivityIntensity.LOW),
    MAKING_DYES("Making dyes", Category.PROCESSING, ActivityIntensity.HIGH),
    CHARGING_EARTH_ORBS("Charging earth orbs", Category.SKILLING_MAGIC, ActivityIntensity.MODERATE),
    CRAFTING_RUBY_JEWELLERY("Crafting ruby jewellery", Category.SKILLING_CRAFTING, ActivityIntensity.LOW),
    CRAFTING_CLOCKWORK_TELEPORT_METHOD("Crafting clockwork (teleport method)", Category.SKILLING_CRAFTING, ActivityIntensity.HIGH),
    MAKING_PIE_SHELLS("Making pie shells", Category.PROCESSING, ActivityIntensity.LOW),
    KILLING_SPIDINES("Killing spidines", Category.COMBAT_LOW, ActivityIntensity.LOW),
    CATCHING_ANGLERFISH("Catching anglerfish", Category.SKILLING_FISHING, ActivityIntensity.MODERATE),
    HUNTING_CHINCHOMPAS("Hunting chinchompas", Category.SKILLING_HUNTER, ActivityIntensity.MODERATE),
    FLETCHING_DIAMOND_BOLTS("Fletching diamond bolts", Category.SKILLING_FLETCHING, ActivityIntensity.LOW),
    CRAFTING_MUD_RUNES("Crafting mud runes", Category.SKILLING_RUNECRAFT, ActivityIntensity.MODERATE),
    CRAFTING_EMERALD_BRACELETS("Crafting emerald bracelets", Category.SKILLING_CRAFTING, ActivityIntensity.LOW),
    COLLECTING_STEEL_PLATEBODIES_HIGH_ALCHEMY("Collecting steel platebodies (High Alchemy)", Category.SKILLING_MAGIC, ActivityIntensity.MODERATE),
    CRAFTING_DIAMOND_JEWELLERY("Crafting diamond jewellery", Category.SKILLING_CRAFTING, ActivityIntensity.LOW),
    MAKING_TEAK_PLANKS("Making teak planks", Category.PROCESSING, ActivityIntensity.MODERATE),
    COOKING_RAW_SHARKS("Cooking raw sharks", Category.SKILLING_COOKING, ActivityIntensity.LOW),
    CUTTING_RUBY_BOLT_TIPS("Cutting ruby bolt tips", Category.PROCESSING, ActivityIntensity.LOW),
    CRAFTING_RUNES_AT_OURANIA_ALTAR("Crafting runes at Ourania Altar", Category.SKILLING_RUNECRAFT, ActivityIntensity.MODERATE),
    COLLECTING_BLACK_SCIMITARS_FROM_ARDOUGNE_CASTLE("Collecting black scimitars from Ardougne Castle", Category.COLLECTING, ActivityIntensity.LOW),
    MAKING_UNCOOKED_BERRY_PIES("Making uncooked berry pies", Category.PROCESSING, ActivityIntensity.LOW),
    PICKING_BANANAS("Picking bananas", Category.COLLECTING, ActivityIntensity.MODERATE),
    ENCHANTING_DIAMOND_NECKLACES("Enchanting diamond necklaces", Category.SKILLING_MAGIC, ActivityIntensity.MODERATE),
    KILLING_THE_CRAZY_ARCHAEOLOGIST("Killing the Crazy archaeologist", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    KILLING_FERAL_VAMPYRES("Killing Feral Vampyres", Category.COMBAT_MID, ActivityIntensity.LOW),
    COLLECTING_ANTI_DRAGON_SHIELDS_FREE_TO_PLAY("Collecting anti-dragon shields (free-to-play)", Category.COLLECTING, ActivityIntensity.MODERATE),
    STRINGING_MAPLE_LONGBOWS("Stringing maple longbows", Category.SKILLING_FLETCHING, ActivityIntensity.MODERATE),
    SMITHING_IRON_DART_TIPS("Smithing iron dart tips", Category.SKILLING_SMITHING, ActivityIntensity.LOW),
    HIGH_ALCHING_UNFINISHED_RUNITE_CROSSBOWS_AT_THE_FOUNTAIN_OF_RUNE("High alching unfinished runite crossbows at the fountain of rune", Category.SKILLING_MAGIC, ActivityIntensity.LOW),
    KILLING_RED_DRAGONS("Killing red dragons", Category.COMBAT_MID, ActivityIntensity.MODERATE),
    COLLECTING_JANGERBERRIES("Collecting jangerberries", Category.COLLECTING, ActivityIntensity.LOW),
    GRINDING_CHOCOLATE_BARS("Grinding chocolate bars", Category.PROCESSING, ActivityIntensity.MODERATE),
    CRAFTING_EMERALD_JEWELLERY("Crafting emerald jewellery", Category.SKILLING_CRAFTING, ActivityIntensity.LOW),
    MAKING_GLOVES_OF_SILENCE("Making gloves of silence", Category.PROCESSING_MAGIC, ActivityIntensity.MODERATE),
    CATCHING_MINNOWS("Catching minnows", Category.SKILLING_FISHING, ActivityIntensity.MODERATE),
    KILLING_BLACK_DRAGONS("Killing black dragons", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    STRINGING_MAGIC_LONGBOWS("Stringing magic longbows", Category.SKILLING_FLETCHING, ActivityIntensity.MODERATE),
    HIGH_ALCHING_ATLATL_DARTS_AT_THE_FOUNTAIN_OF_RUNE("High alching atlatl darts at the fountain of rune", Category.SKILLING_MAGIC, ActivityIntensity.LOW),
    MAKING_UNCOOKED_APPLE_PIES("Making uncooked apple pies", Category.PROCESSING, ActivityIntensity.LOW),
    KILLING_AVIANSIES("Killing aviansies", Category.COMBAT_MID, ActivityIntensity.MODERATE),
    KILLING_CAVE_HORRORS("Killing cave horrors", Category.COMBAT_MID, ActivityIntensity.MODERATE),
    COOKING_PLAIN_PIZZAS("Cooking plain pizzas", Category.SKILLING_COOKING, ActivityIntensity.LOW),
    CLEANING_GRIMY_SNAPDRAGON("Cleaning grimy snapdragon", Category.SKILLING_HERBLORE, ActivityIntensity.HIGH),
    HIGH_ALCHING_RUNE_ARROWS_AT_THE_FOUNTAIN_OF_RUNE("High alching rune arrows at the fountain of rune", Category.SKILLING_MAGIC, ActivityIntensity.LOW),
    KILLING_SPIRITUAL_MAGES("Killing spiritual mages", Category.COMBAT_HIGH, ActivityIntensity.MODERATE),
    CLEANING_GRIMY_TOADFLAX("Cleaning grimy toadflax", Category.SKILLING_HERBLORE, ActivityIntensity.HIGH),
    COLLECTING_PLANKS("Collecting planks", Category.COLLECTING, ActivityIntensity.LOW),
    COLLECTING_RED_SPIDERS_EGGS("Collecting red spiders eggs", Category.COLLECTING, ActivityIntensity.LOW),
    ENCHANTING_SAPPHIRE_RINGS("Enchanting sapphire rings", Category.SKILLING_MAGIC, ActivityIntensity.MODERATE),
    CATCHING_SACRED_EELS("Catching sacred eels", Category.SKILLING_FISHING, ActivityIntensity.LOW),
    CLIMBING_THE_AGILITY_PYRAMID("Climbing the Agility Pyramid", Category.SKILLING_AGILITY, ActivityIntensity.HIGH),
    CRAFTING_STEAM_RUNES("Crafting steam runes", Category.SKILLING_RUNECRAFT, ActivityIntensity.MODERATE),
    MAKING_ANCHOVY_PIZZAS("Making anchovy pizzas", Category.SKILLING_COOKING, ActivityIntensity.MODERATE),
    CRAFTING_GOLD_BRACELETS("Crafting gold bracelets", Category.SKILLING_CRAFTING, ActivityIntensity.LOW),
    KILLING_BRUTAL_GREEN_DRAGONS("Killing brutal green dragons", Category.COMBAT_HIGH, ActivityIntensity.HIGH),
    STRINGING_YEW_LONGBOWS("Stringing yew longbows", Category.SKILLING_FLETCHING, ActivityIntensity.MODERATE),
    KILLING_BRYOPHYTA_FREE_TO_PLAY("Killing Bryophyta (free-to-play)", Category.COMBAT_MID, ActivityIntensity.MODERATE),
    COLLECTING_WHITE_BERRIES("Collecting white berries", Category.COLLECTING, ActivityIntensity.LOW),
    COLLECTING_ANTI_DRAGON_SHIELDS("Collecting anti-dragon shields", Category.COLLECTING, ActivityIntensity.HIGH),
    CUTTING_MAHOGANY_LOGS("Cutting mahogany logs", Category.SKILLING_WOODCUTTING, ActivityIntensity.LOW),
    KILLING_CHAOS_DRUIDS("Killing chaos druids", Category.COMBAT_LOW, ActivityIntensity.LOW),
    COLLECTING_FISH_FOOD("Collecting fish food", Category.COLLECTING, ActivityIntensity.MODERATE),
    CATCHING_INFERNAL_EELS("Catching infernal eels", Category.SKILLING_FISHING, ActivityIntensity.LOW),
    MINING_VOLCANIC_ASH("Mining volcanic ash", Category.SKILLING_MINING, ActivityIntensity.LOW),
    CUTTING_YEW_LOGS_FREE_TO_PLAY("Cutting yew logs (free-to-play)", Category.SKILLING_WOODCUTTING, ActivityIntensity.LOW),
    FORGING_GIANT_SWORDS("Forging Giant swords", Category.SKILLING_SMITHING, ActivityIntensity.MODERATE),
    COOKING_RAW_MONKFISH("Cooking raw monkfish", Category.SKILLING_COOKING, ActivityIntensity.LOW),
    MINING_ADAMANTITE_ORE("Mining adamantite ore", Category.SKILLING_MINING, ActivityIntensity.LOW),
    SPINNING_FLAX_TO_BOW_STRINGS("Spinning flax to bow strings", Category.PROCESSING, ActivityIntensity.LOW),
    BUYING_PIES("Buying pies", Category.COLLECTING, ActivityIntensity.MODERATE),
    TANNING_COWHIDE("Tanning cowhide", Category.PROCESSING, ActivityIntensity.LOW),
    KILLING_BRINE_RATS("Killing brine rats", Category.COMBAT_MID, ActivityIntensity.MODERATE),
    CRAFTING_SAPPHIRE_JEWELLERY("Crafting sapphire jewellery", Category.SKILLING_CRAFTING, ActivityIntensity.LOW),
    COLLECTING_BRONZE_PICKAXES("Collecting bronze pickaxes", Category.COLLECTING, ActivityIntensity.HIGH),
    KILLING_OGRESS_SHAMANS("Killing ogress shamans", Category.COMBAT_HIGH, ActivityIntensity.MODERATE),
    SMITHING_MITHRIL_DART_TIPS("Smithing mithril dart tips", Category.SKILLING_SMITHING, ActivityIntensity.LOW),
    COLLECTING_WINE_OF_ZAMORAK("Collecting wine of zamorak", Category.COLLECTING, ActivityIntensity.MODERATE),
    MAKING_UNCOOKED_MEAT_PIES("Making uncooked meat pies", Category.PROCESSING, ActivityIntensity.LOW),
    CLEANING_GRIMY_IRIT_LEAVES("Cleaning grimy irit leaves", Category.SKILLING_HERBLORE, ActivityIntensity.HIGH),
    CLEANING_GRIMY_HARRALANDER("Cleaning grimy harralander", Category.SKILLING_HERBLORE, ActivityIntensity.HIGH),
    CREATING_BONES_TO_PEACHES_TABLETS("Creating bones to peaches tablets", Category.PROCESSING, ActivityIntensity.LOW),
    COLLECTING_CHAOS_RUNES("Collecting chaos runes", Category.COLLECTING, ActivityIntensity.MODERATE),
    CUTTING_MAGIC_LOGS("Cutting magic logs", Category.SKILLING_WOODCUTTING, ActivityIntensity.LOW),
    FILLING_WATER_CONTAINERS_HOSIDIUS_KITCHEN("Filling water containers (Hosidius kitchen)", Category.PROCESSING, ActivityIntensity.LOW),
    COLLECTING_NATURE_RUNES("Collecting nature runes", Category.SKILLING_MAGIC, ActivityIntensity.MODERATE),
    COLLECTING_RED_SPIDERS_EGGS_FREE_TO_PLAY("Collecting red spiders eggs (free-to-play)", Category.COLLECTING, ActivityIntensity.MODERATE),
    MAKING_TUNA_POTATOES("Making tuna potatoes", Category.PROCESSING, ActivityIntensity.MODERATE),
    CLEANING_GRIMY_TARROMIN("Cleaning grimy tarromin", Category.SKILLING_HERBLORE, ActivityIntensity.HIGH),
    COLLECTING_TINDERBOXES("Collecting tinderboxes", Category.COLLECTING, ActivityIntensity.HIGH),
    MAKING_PASTRY_DOUGH("Making pastry dough", Category.PROCESSING, ActivityIntensity.MODERATE),
    MINING_ADAMANTITE_ORE_FREE_TO_PLAY("Mining adamantite ore (free-to-play)", Category.SKILLING_MINING, ActivityIntensity.LOW),
    CLEANING_GRIMY_GUAM_LEAVES("Cleaning grimy guam leaves", Category.SKILLING_HERBLORE, ActivityIntensity.HIGH),
    RUNNING_LAPS_OF_THE_CANIFIS_ROOFTOP_COURSE("Running laps of the Canifis rooftop course", Category.SKILLING_AGILITY, ActivityIntensity.LOW),
    BAKING_POTATOES("Baking potatoes", Category.SKILLING_COOKING, ActivityIntensity.LOW),
    MAKING_PIZZA_BASES("Making pizza bases", Category.PROCESSING, ActivityIntensity.HIGH),
    COOKING_RAW_KARAMBWAN("Cooking raw karambwan", Category.SKILLING_COOKING, ActivityIntensity.LOW),
    CREATING_ARDOUGNE_TELEPORT_TABLETS("Creating Ardougne teleport tablets", Category.PROCESSING, ActivityIntensity.LOW),
    COLLECTING_COSMIC_RUNES("Collecting cosmic runes", Category.COLLECTING, ActivityIntensity.MODERATE),
    BUYING_BRONZE_BARS("Buying bronze bars", Category.COLLECTING, ActivityIntensity.LOW),
    FLETCHING_UNSTRUNG_MAPLE_LONGBOWS("Fletching unstrung maple longbows", Category.SKILLING_FLETCHING, ActivityIntensity.LOW),
    COOKING_RAW_SWORDFISH("Cooking raw swordfish", Category.SKILLING_COOKING, ActivityIntensity.LOW),
    SMELTING_RUNITE_BARS("Smelting runite bars", Category.SKILLING_SMITHING, ActivityIntensity.LOW),
    COLLECTING_IRON_ORE("Collecting iron ore", Category.COLLECTING, ActivityIntensity.LOW),
    CUTTING_REDWOOD_LOGS("Cutting redwood logs", Category.SKILLING_WOODCUTTING, ActivityIntensity.LOW),
    COOKING_RAW_ANGLERFISH("Cooking raw anglerfish", Category.SKILLING_COOKING, ActivityIntensity.LOW),
    MINING_IRON_ORE_FREE_TO_PLAY("Mining iron ore (free-to-play)", Category.SKILLING_MINING, ActivityIntensity.HIGH),
    MINING_CLAY_MEMBERS("Mining clay members", Category.SKILLING_MINING, ActivityIntensity.MODERATE),
    KILLING_IMPS("Killing imps", Category.COMBAT_LOW, ActivityIntensity.LOW),
    COLLECTING_BIG_BONES_FROM_THE_BONE_YARD("Collecting big bones from the Bone Yard", Category.COLLECTING, ActivityIntensity.MODERATE),
    KILLING_MONKEYS("Killing monkeys", Category.COMBAT_LOW, ActivityIntensity.LOW),
    CATCHING_SHRIMP_AND_ANCHOVIES("Catching shrimp & anchovies", Category.SKILLING_FISHING, ActivityIntensity.LOW),
    COLLECTING_ASHES("Collecting ashes", Category.COLLECTING, ActivityIntensity.LOW),
    KILLING_OGRESS_WARRIORS("Killing ogress warriors", Category.COMBAT_MID, ActivityIntensity.LOW),
    COLLECTING_AND_TANNING_COWHIDE("Collecting and tanning cowhide", Category.COLLECTING, ActivityIntensity.LOW),
    BUYING_ALE_FROM_THE_RISING_SUN_INN("Buying ale from the Rising Sun Inn", Category.COLLECTING, ActivityIntensity.HIGH),
    KILLING_HILL_GIANTS("Killing hill giants", Category.COMBAT_LOW, ActivityIntensity.MODERATE),
    COLLECTING_STEEL_PLATEBODIES("Collecting steel platebodies", Category.COLLECTING, ActivityIntensity.MODERATE),
    COOKING_RAW_LOBSTER("Cooking raw lobster", Category.SKILLING_COOKING, ActivityIntensity.LOW),
    KILLING_COWS_AND_TANNING_COWHIDE("Killing cows and tanning cowhide", Category.COMBAT_LOW, ActivityIntensity.LOW),
    BUYING_JUG_PACKS("Buying jug packs", Category.COLLECTING, ActivityIntensity.LOW),
    KILLING_CHAOS_DWARVES("Killing chaos dwarves", Category.COMBAT_MID, ActivityIntensity.LOW),
    FILLING_WATER_CONTAINERS("Filling water containers", Category.PROCESSING, ActivityIntensity.LOW),
    COLLECTING_WINE_OF_ZAMORAK_FREE_TO_PLAY("Collecting wine of zamorak (free-to-play)", Category.COLLECTING, ActivityIntensity.LOW),
    MAKING_DOUGH_AT_COOKS_GUILD("Making dough at Cooks Guild", Category.PROCESSING, ActivityIntensity.HIGH),
    SMELTING_BRONZE_BARS("Smelting bronze bars", Category.SKILLING_SMITHING, ActivityIntensity.LOW),
    MINING_CLAY("Mining clay", Category.SKILLING_MINING, ActivityIntensity.LOW),
    CRAFTING_GOLD_JEWELLERY("Crafting gold jewellery", Category.SKILLING_CRAFTING, ActivityIntensity.LOW),
    BUYING_KEBABS_IN_AL_KHARID("Buying kebabs in Al Kharid", Category.COLLECTING, ActivityIntensity.HIGH),
    STEALING_WYDINS_BANANAS("Stealing Wydins bananas", Category.COLLECTING, ActivityIntensity.HIGH),
    COLLECTING_GARLIC("Collecting garlic", Category.COLLECTING, ActivityIntensity.MODERATE),
    COOKING_RAW_TUNA("Cooking raw tuna", Category.SKILLING_COOKING, ActivityIntensity.LOW),
    COLLECTING_SPADES("Collecting spades", Category.COLLECTING, ActivityIntensity.MODERATE),
    CUTTING_WILLOW_LOGS("Cutting willow logs", Category.SKILLING_WOODCUTTING, ActivityIntensity.LOW),
    CUTTING_OAK_LOGS("Cutting oak logs", Category.SKILLING_WOODCUTTING, ActivityIntensity.LOW),
    CATCHING_TROUT_AND_SALMON("Catching trout & salmon", Category.SKILLING_FISHING, ActivityIntensity.LOW),
    KILLING_ZAMORAK_MONKS("Killing Zamorak monks", Category.COMBAT_LOW, ActivityIntensity.MODERATE),
    MINING_COAL_AND_SUPERHEATING_ADAMANTITE_BARS("Mining coal and superheating Adamantite bars", Category.SKILLING_MINING, ActivityIntensity.MODERATE),
    SMELTING_SILVER_BARS("Smelting silver bars", Category.SKILLING_SMITHING, ActivityIntensity.LOW),
    KILLING_CHICKENS("Killing chickens", Category.COMBAT_LOW, ActivityIntensity.LOW),
    SHEARING_SHEEP("Shearing sheep", Category.COLLECTING, ActivityIntensity.LOW),
    PICKING_POTATOES("Picking potatoes", Category.COLLECTING, ActivityIntensity.LOW),
    KILLING_HOBGOBLINS("Killing hobgoblins", Category.COMBAT_MID, ActivityIntensity.MODERATE),
    MINING_GOLD_ORE_CRAFTING_GUILD("Mining gold ore (Crafting Guild)", Category.SKILLING_MINING, ActivityIntensity.LOW),
    KILLING_WIZARDS("Killing wizards", Category.COMBAT_LOW, ActivityIntensity.LOW),
    KILLING_BEARS("Killing bears", Category.COMBAT_MID, ActivityIntensity.MODERATE),
    MINING_COAL_AND_SUPERHEATING_MITHRIL_BARS("Mining coal and superheating Mithril bars", Category.SKILLING_MINING, ActivityIntensity.MODERATE),
    MINING_COAL_FREE_TO_PLAY("Mining coal (free-to-play)", Category.SKILLING_MINING, ActivityIntensity.MODERATE),
    SMELTING_IRON_BARS("Smelting iron bars", Category.SKILLING_SMITHING, ActivityIntensity.LOW),
    SMELTING_STEEL_BARS("Smelting steel bars", Category.SKILLING_SMITHING, ActivityIntensity.LOW),
    KILLING_ANKOU_FREE_TO_PLAY("Killing Ankou (free-to-play)", Category.COMBAT_MID, ActivityIntensity.MODERATE),
    BUYING_FROM_WYDINS_FOOD_STORE("Buying from Wydins Food Store", Category.COLLECTING, ActivityIntensity.HIGH),
    COLLECTING_BEER_GLASSES("Collecting beer glasses", Category.COLLECTING, ActivityIntensity.LOW),
    MAKING_FLOUR("Making flour", Category.PROCESSING, ActivityIntensity.LOW),
    COLLECTING_AIR_TALISMANS("Collecting air talismans", Category.COLLECTING, ActivityIntensity.MODERATE),
    KILLING_DARK_WIZARDS("Killing dark wizards", Category.COMBAT_LOW, ActivityIntensity.LOW),
    MINING_GOLD_ORE_FREE_TO_PLAY("Mining gold ore (free-to-play)", Category.SKILLING_MINING, ActivityIntensity.LOW),
    GETTING_INFINITE_MONEY("Getting infinite money", Category.COLLECTING_NONE, ActivityIntensity.HIGH),
    SPLASHING("Splashing spells on monsters", Category.SKILLING_MAGIC, ActivityIntensity.VERY_LOW);
    @Getter
    private final String method;
    @Getter
    private final Category category;
    private final ActivityIntensity intensity;
    Activity(String method, Category category, ActivityIntensity intensity) {
        this.method = method;
        this.category = category;
        this.intensity = intensity;
    }
    public static Activity fromSkill(Skill skill) {
        switch (skill) {
            case ATTACK:
            case DEFENCE:
            case STRENGTH:
            case RANGED:
            case MAGIC:
                return GENERAL_COMBAT;
            case PRAYER:
                return GENERAL_PRAYER;
            case CONSTRUCTION:
                return GENERAL_CONSTRUCTION;
            case COOKING:
                return GENERAL_COOKING;
            case WOODCUTTING:
                return GENERAL_WOODCUTTING;
            case FLETCHING:
                return GENERAL_FLETCHING;
            case FISHING:
                return GENERAL_FISHING;
            case FIREMAKING:
                return GENERAL_FIREMAKING;
            case CRAFTING:
                return GENERAL_CRAFTING;
            case SMITHING:
                return GENERAL_SMITHING;
            case MINING:
                return GENERAL_MINING;
            case HERBLORE:
                return GENERAL_HERBLORE;
            case AGILITY:
                return GENERAL_AGILITY;
            case THIEVING:
                return GENERAL_THIEVING;
            case SLAYER:
                return GENERAL_SLAYER;
            case RUNECRAFT:
                return GENERAL_RUNECRAFT;
            case HUNTER:
                return GENERAL_HUNTER;
            case FARMING:
                return GENERAL_FARMING;
            default:
                return null;
        }
    }
    public ActivityIntensity getActivityIntensity() {
        return intensity;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/antiban/enums/ActivityIntensity.java
================
package net.runelite.client.plugins.microbot.util.antiban.enums;
import lombok.Getter;
import net.runelite.api.Skill;
/**
 * The ActivityIntensity enum represents different levels of intensity for player activities,
 * each associated with a specific play style and behavior pattern.
 *
 * <p>
 * Activity intensities are used to simulate varying levels of focus and action frequency during bot operation.
 * Each intensity level controls the frequency and amplitude of actions, which corresponds to how aggressive or passive
 * the bot's behavior is during different tasks. The intensity also determines the corresponding play style, which
 * adjusts the bot's overall behavior to better mimic human variability.
 * </p>
 *
 * <h3>Main Features:</h3>
 * <ul>
 *   <li>Intensity Levels: Ranges from "Very Low" to "Extreme," with varying levels of action frequency and amplitude.</li>
 *   <li>Play Style Association: Each intensity is linked to a <code>PlayStyle</code>, which defines the overall behavior
 *   of the bot during specific activities.</li>
 *   <li>Skill Mapping: Different skills are mapped to specific intensity levels, with combat-related skills generally
 *   assigned higher intensities, while skilling activities are mapped to lower intensities.</li>
 *   <li>Randomization: Provides a method to generate a random activity intensity, adding unpredictability to bot behavior.</li>
 * </ul>
 *
 * <h3>Usage:</h3>
 * <p>
 * The <code>ActivityIntensity</code> enum is used to dynamically adjust the bot's behavior based on the intensity of the
 * player's activity. Higher intensity levels correspond to more aggressive actions, while lower intensity levels simulate
 * slower, more deliberate behavior. This allows the bot to adapt to different types of activities, from combat to skilling.
 * </p>
 *
 * <h3>Example:</h3>
 * <pre>
 * ActivityIntensity currentIntensity = ActivityIntensity.HIGH;
 * PlayStyle associatedStyle = currentIntensity.getPlayStyle();
 * double actionFrequency = currentIntensity.getFrequency();
 * </pre>
 *
 * <h3>Skill-Based Intensity:</h3>
 * <p>
 * The <code>fromSkill(Skill skill)</code> method maps in-game skills to specific activity intensity levels. For example,
 * combat-related skills such as Attack, Defence, and Ranged are mapped to higher intensities, while skills like Cooking,
 * Fishing, and Crafting are mapped to lower intensities. This allows the bot to adjust its behavior based on the current
 * skill being trained.
 * </p>
 *
 * <h3>Random Intensity:</h3>
 * <p>
 * The <code>random()</code> method provides a way to select a random activity intensity, introducing unpredictability
 * and making the bot's actions appear more human-like by varying the intensity over time.
 * </p>
 */
public enum ActivityIntensity {
    VERY_LOW("Very Low", 0.6, 1.8, PlayStyle.PASSIVE),
    LOW("Low", 0.4, 1.5, PlayStyle.CAUTIOUS),
    MODERATE("Moderate", 0.3, 1.2, PlayStyle.AGGRESSIVE),
    HIGH("High", 0.2, 1.1, PlayStyle.EXTREME_AGGRESSIVE),
    EXTREME("Extreme", 0.1, 1.0, PlayStyle.EXTREME_AGGRESSIVE);
    @Getter
    private final String name;
    @Getter
    private final double frequency;
    @Getter
    private final double amplitude;
    @Getter
    private final PlayStyle playStyle;
    ActivityIntensity(String name, double frequency, double amplitude, PlayStyle playStyle) {
        this.name = name;
        this.frequency = frequency;
        this.amplitude = amplitude;
        this.playStyle = playStyle;
    }
    public static ActivityIntensity random() {
        return values()[(int) (Math.random() * values().length - 1)];
    }
    public static ActivityIntensity fromSkill(Skill skill) {
        switch (skill) {
            case ATTACK:
            case DEFENCE:
            case STRENGTH:
            case RANGED:
            case PRAYER:
            case MAGIC:
            case CONSTRUCTION:
                return HIGH;
            case COOKING:
            case WOODCUTTING:
            case FLETCHING:
            case FISHING:
            case FIREMAKING:
            case CRAFTING:
            case SMITHING:
            case MINING:
            case HERBLORE:
                return LOW;
            case AGILITY:
            case THIEVING:
            case SLAYER:
            case RUNECRAFT:
            case HUNTER:
            case FARMING:
                return MODERATE;
            default:
                return null;
        }
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/antiban/enums/Category.java
================
package net.runelite.client.plugins.microbot.util.antiban.enums;
import net.runelite.api.AnimationID;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.antiban.AntibanPlugin;
import net.runelite.client.plugins.microbot.util.antiban.Rs2Antiban;
import net.runelite.client.plugins.microbot.util.combat.Rs2Combat;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
/**
 * The Category enum represents different categories of player activities, such as combat, skilling, and processing.
 *
 * <p>
 * Each category is associated with a specific type of activity and contains logic to determine whether the player is "busy"
 * based on the current game state. This is used to control bot behavior and ensure it adapts to the player's activity,
 * pausing or adjusting actions when the player is engaged in a task.
 * </p>
 *
 * <h3>Main Features:</h3>
 * <ul>
 *   <li>Categories for Various Activities: Includes categories such as combat, skilling (e.g., fishing, cooking, magic),
 *   processing, and collecting, each with its own logic to determine if the player is busy.</li>
 *   <li>Custom Busy Logic: Each category overrides the <code>isBusy()</code> method, providing custom logic
 *   for determining if the player is engaged in the respective activity.</li>
 *   <li>Bot Activity Control: The bot uses these categories to manage when it should take action or pause, based
 *   on whether the player is currently busy performing an activity.</li>
 * </ul>
 *
 * <h3>Usage:</h3>
 * <p>
 * The <code>Category</code> enum is used within the bot's logic to monitor the player's activities and determine
 * if the bot should continue executing actions or wait for the player to finish their current task. Each category
 * provides specific logic to handle different types of activities such as combat, skilling, and crafting.
 * This class is used by the anti-ban system to make sure the action cooldown is not counting down while the player is busy.
 * </p>
 *
 * <h3>Example:</h3>
 * <pre>
 * Category currentCategory = Category.SKILLING_COOKING;
 * if (currentCategory.isBusy()) {
 *     // The player is busy cooking, so the bot may pause actions.
 * } else {
 *     // The player is idle, and the bot can continue with the next task.
 * }
 * </pre>
 *
 * <h3>Customization:</h3>
 * <p>
 * Each category overrides the <code>isBusy()</code> method to implement custom logic for checking if the player is engaged
 * in a specific task. For example, the <code>COMBAT_MID</code> category checks if the player is in combat, while the
 * <code>SKILLING_COOKING</code> category checks if the player is currently cooking. Some categories are not fully implemented
 * and include TODO notes for further customization based on game-specific conditions.
 * </p>
 *
 * <h3>Development Notes:</h3>
 * <p>
 * Several categories contain TODO notes indicating that additional logic may be required to accurately determine if the player is busy.
 * These categories currently rely on simple checks, such as whether the player is animating or if the inventory is full,
 * but may need further refinement based on specific interactions or game mechanics.
 * </p>
 */
public enum Category {
    COMBAT_MID("Combat/Mid") {
        @Override
        public boolean isBusy() {
            return Rs2Combat.inCombat();
        }
    },
    SKILLING_AGILITY("Skilling/Agility") {
        @Override
        public boolean isBusy() {
            return Rs2Player.isMoving();
        }
    },
    PROCESSING("Processing") {
        @Override
        public boolean isBusy() {
            return Rs2Player.isAnimating() || Microbot.isGainingExp;
        }
    },
    COLLECTING("Collecting") {
        @Override
        public boolean isBusy() {
            return Rs2Player.isMoving() || Rs2Player.isInteracting();
        }
    },
    SKILLING_CRAFTING("Skilling/Crafting") {
        @Override
        public boolean isBusy() {
            return !Rs2Antiban.isIdle();
        }
    },
    SKILLING_MAGIC("Skilling/Magic") {
        @Override
        public boolean isBusy() {
            return Rs2Player.isAnimating() || Microbot.isGainingExp;
        }
    },
    COMBAT_LOW("Combat/Low") {
        @Override
        public boolean isBusy() {
            return Rs2Combat.inCombat();
        }
    },
    SKILLING_HERBLORE("Skilling/Herblore") {
        @Override
        public boolean isBusy() {
            return !Rs2Antiban.isIdle() || Microbot.isGainingExp;
        }
    },
    SKILLING_FLETCHING("Skilling/Fletching") {
        @Override
        public boolean isBusy() {
            return !Rs2Antiban.isIdle();
        }
    },
    SKILLING_FISHING("Skilling/Fishing") {
        @Override
        public boolean isBusy() {
            return Rs2Player.isInteracting();
        }
    },
    PROCESSING_MAGIC("Processing/Magic") {
        @Override
        public boolean isBusy() {
            return Rs2Player.isAnimating() && Microbot.isGainingExp;
        }
    },
    SKILLING_COOKING("Skilling/Cooking") {
        @Override
        public boolean isBusy() {
            return AntibanPlugin.isCooking();
        }
    },
    SKILLING_FIREMAKING("Skilling/Firemaking") {
        @Override
        public boolean isBusy() {
            return Rs2Player.getPoseAnimation() == AnimationID.FIREMAKING;
        }
    },
    SKILLING_THIEVING("Skilling/Thieving") {
        @Override
        public boolean isBusy() {
            return !Rs2Player.isAnimating();
        }
    },
    SKILLING("Skilling") {
        @Override
        public boolean isBusy() {
            return !Rs2Player.isAnimating() || !Rs2Inventory.isFull();
        }
    },
    COLLECTING_NONE("Collecting/None") {
        @Override
        public boolean isBusy() {
            return Rs2Player.isMoving();
        }
    },
    COMBAT_HIGH("Combat/High") {
        @Override
        public boolean isBusy() {
            return Rs2Combat.inCombat();
        }
    },
    SKILLING_WOODCUTTING("Skilling/Woodcutting") {
        @Override
        public boolean isBusy() {
            return Rs2Antiban.isWoodcutting();
        }
    },
    SKILLING_MINING("Skilling/Mining") {
        @Override
        public boolean isBusy() {
            return AntibanPlugin.isMining();
        }
    },
    SKILLING_RUNECRAFT("Skilling/Runecraft") {
        @Override
        public boolean isBusy() {
            return Rs2Inventory.contains("pure essence", "rune essence", "Daeyalt essence", "Dark essence fragment", "blood essence");
        }
    },
    SKILLING_SMITHING("Skilling/Smithing") {
        /**
         * Checks if the player is busy.
         * <p>
         * TODO: This method has not been implemented correctly yet.
         * It currently only checks if the player is animating or if the inventory is full.
         * Additional conditions may need to be added to accurately determine if the player is busy.
         * Consider adding checks for:
         * <ul>
         *   <li>Whether the player is interacting with specific game objects.</li>
         *   <li>Other animations that might indicate a busy state.</li>
         *   <li>Game-specific conditions that represent the player being busy.</li>
         * </ul>
         *
         * @return {@code true} if the player is animating or the inventory is full; {@code false} otherwise.
         */
        @Override
        public boolean isBusy() {
            return !Rs2Antiban.isIdle();
        }
    },
    SKILLING_HUNTER("Skilling/Hunter") {
        /**
         * Checks if the player is busy.
         * <p>
         * TODO: This method has not been implemented correctly yet.
         * It currently only checks if the player is animating or if the inventory is full.
         * Additional conditions may need to be added to accurately determine if the player is busy.
         * Consider adding checks for:
         * <ul>
         *   <li>Whether the player is interacting with specific game objects.</li>
         *   <li>Other animations that might indicate a busy state.</li>
         *   <li>Game-specific conditions that represent the player being busy.</li>
         * </ul>
         *
         * @return {@code true} if the player is animating or the inventory is full; {@code false} otherwise.
         */
        @Override
        public boolean isBusy() {
            return !Rs2Antiban.isIdle();
        }
    },
    SKILLING_FARMING("Skilling/Farming") {
        /**
         * Checks if the player is busy.
         * <p>
         * TODO: This method has not been implemented correctly yet.
         * It currently only checks if the player is animating or if the inventory is full.
         * Additional conditions may need to be added to accurately determine if the player is busy.
         * Consider adding checks for:
         * <ul>
         *   <li>Whether the player is interacting with specific game objects.</li>
         *   <li>Other animations that might indicate a busy state.</li>
         *   <li>Game-specific conditions that represent the player being busy.</li>
         * </ul>
         *
         * @return {@code true} if the player is animating or the inventory is full; {@code false} otherwise.
         */
        @Override
        public boolean isBusy() {
            return Rs2Player.isAnimating() || Rs2Inventory.isFull();
        }
    },
    SKILLING_PRAYER("Skilling/Prayer") {
        /**
         * Checks if the player is busy.
         * <p>
         * TODO: This method has not been implemented correctly yet.
         * It currently only checks if the player is animating or if the inventory is full.
         * Additional conditions may need to be added to accurately determine if the player is busy.
         * Consider adding checks for:
         * <ul>
         *   <li>Whether the player is interacting with specific game objects.</li>
         *   <li>Other animations that might indicate a busy state.</li>
         *   <li>Game-specific conditions that represent the player being busy.</li>
         * </ul>
         *
         * @return {@code true} if the player is animating or the inventory is full; {@code false} otherwise.
         */
        @Override
        public boolean isBusy() {
            return Rs2Player.isAnimating() || Rs2Inventory.isFull();
        }
    },
    SKILLING_CONSTRUCTION("Skilling/Construction") {
        /**
         * Checks if the player is busy.
         * <p>
         * TODO: This method has not been implemented correctly yet.
         * It currently only checks if the player is animating or if the inventory is full.
         * Additional conditions may need to be added to accurately determine if the player is busy.
         * Consider adding checks for:
         * <ul>
         *   <li>Whether the player is interacting with specific game objects.</li>
         *   <li>Other animations that might indicate a busy state.</li>
         *   <li>Game-specific conditions that represent the player being busy.</li>
         * </ul>
         *
         * @return {@code true} if the player is animating or the inventory is full; {@code false} otherwise.
         */
        @Override
        public boolean isBusy() {
            return Rs2Player.isAnimating() || Rs2Inventory.isFull();
        }
    };
    private final String name;
    Category(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }
    public abstract boolean isBusy();
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/antiban/enums/CombatSkills.java
================
package net.runelite.client.plugins.microbot.util.antiban.enums;
import net.runelite.api.Skill;
public enum CombatSkills {
    ATTACK(Skill.ATTACK),
    STRENGTH(Skill.STRENGTH),
    DEFENCE(Skill.DEFENCE),
    HITPOINTS(Skill.HITPOINTS),
    RANGED(Skill.RANGED),
    PRAYER(Skill.PRAYER);
    CombatSkills(Skill skill) {
    }
    public static boolean isCombatSkill(Skill skill) {
        return skill == Skill.ATTACK || skill == Skill.STRENGTH || skill == Skill.DEFENCE || skill == Skill.HITPOINTS || skill == Skill.RANGED || skill == Skill.PRAYER;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/antiban/enums/PlaySchedule.java
================
package net.runelite.client.plugins.microbot.util.antiban.enums;
import java.time.Duration;
import java.time.LocalTime;
/**
 * The PlaySchedule enum represents predefined play time schedules for the bot, simulating real-life play patterns.
 *
 * <p>
 * Each schedule defines a specific time range during which the bot is active, allowing for more human-like
 * behavior by simulating different play habits throughout the day. These schedules are managed and enforced
 * by the Break Handler plugin, which controls when the bot should be active or inactive based on the selected schedule.
 * </p>
 *
 * <h3>Main Features:</h3>
 * <ul>
 *   <li>Predefined Time Ranges: Each schedule has a start and end time that corresponds to specific periods of the day
 *   (e.g., morning, afternoon, evening).</li>
 *   <li>Varied Durations: Schedules vary in length, offering short, medium, and long play periods for each time of day.</li>
 *   <li>Realistic Break Simulation: The bot automatically checks whether it is within or outside the defined play schedule,
 *   allowing for breaks and simulating a more realistic user pattern. This is managed by the Break Handler plugin.</li>
 * </ul>
 *
 * <h3>Usage:</h3>
 * <p>
 * The <code>PlaySchedule</code> enum is used to control when the bot is active during specific periods of the day.
 * By adhering to these schedules, the bot avoids continuous operation and mimics a more realistic user behavior.
 * The Break Handler plugin ensures that the bot respects the defined schedules and manages any necessary pauses.
 * </p>
 *
 * <h3>Schedule Checks:</h3>
 * <p>
 * The <code>isOutsideSchedule()</code> method determines whether the current time is outside of the defined play schedule.
 * This is useful for ensuring that the bot only runs during the specified time periods, as controlled by the Break Handler plugin.
 * The <code>timeUntilNextSchedule()</code> method calculates how long the bot must wait until the next play period starts,
 * helping to schedule breaks and restarts efficiently.
 * </p>
 */
public enum PlaySchedule {
    SHORT_MORNING(LocalTime.of(8, 0), LocalTime.of(9, 0)),
    MEDIUM_MORNING(LocalTime.of(7, 0), LocalTime.of(10, 0)),
    LONG_MORNING(LocalTime.of(6, 0), LocalTime.of(12, 0)),
    SHORT_AFTERNOON(LocalTime.of(12, 0), LocalTime.of(13, 0)),
    MEDIUM_AFTERNOON(LocalTime.of(12, 0), LocalTime.of(15, 0)),
    LONG_AFTERNOON(LocalTime.of(12, 0), LocalTime.of(18, 0)),
    SHORT_EVENING(LocalTime.of(18, 0), LocalTime.of(19, 0)),
    MEDIUM_EVENING(LocalTime.of(17, 0), LocalTime.of(20, 0)),
    LONG_EVENING(LocalTime.of(17, 0), LocalTime.of(23, 0)),
    SHORT_DAY(LocalTime.of(9, 0), LocalTime.of(17, 0)),
    MEDIUM_DAY(LocalTime.of(8, 0), LocalTime.of(18, 0)),
    LONG_DAY(LocalTime.of(6, 0), LocalTime.of(22, 0));
    private final LocalTime startTime;
    private final LocalTime endTime;
    PlaySchedule(LocalTime startTime, LocalTime endTime) {
        this.startTime = startTime;
        this.endTime = endTime;
    }
    public boolean isOutsideSchedule() {
        LocalTime currentTime = LocalTime.now();
        return currentTime.isBefore(startTime) || currentTime.isAfter(endTime);
    }
    public Duration timeUntilNextSchedule() {
        LocalTime currentTime = LocalTime.now();
        if (currentTime.isBefore(startTime)) {
            return Duration.between(currentTime, startTime);
        } else if (currentTime.isAfter(endTime)) {
            return Duration.between(currentTime, startTime).plusDays(1);
        } else {
            return Duration.ZERO;
        }
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/antiban/enums/PlayStyle.java
================
package net.runelite.client.plugins.microbot.util.antiban.enums;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.client.plugins.microbot.Microbot;
import java.time.Duration;
import java.time.Instant;
import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;
/**
 * The PlayStyle enum represents different behavioral profiles for bot activity,
 * each simulating varying levels of human-like behavior by adjusting the frequency
 * and intensity of actions over time.
 *
 * <p>
 * Each play style has its own characteristics, such as how aggressive or passive the bot's actions are,
 * the length of breaks between actions, and the overall attention span. The enum offers profiles ranging
 * from highly aggressive behavior with minimal breaks to passive styles with long pauses between actions.
 * It is used to simulate different user behavior patterns and make the bot's actions less predictable.
 * </p>
 *
 * <h3>Main Features:</h3>
 * <ul>
 *   <li>Profiles: Ranges from "Extreme Aggressive" to "Passive," with varying tick intervals and breaks.</li>
 *   <li>Dynamic Evolution: Play styles can evolve over time, adjusting action intervals using sine wave patterns
 *   to simulate natural human variability.</li>
 *   <li>Attention Span: Each play style includes a simulated attention span, after which the profile may switch
 *   to another one to mimic shifts in focus or behavior.</li>
 *   <li>Profile Switching: Play styles can switch up or down based on probability, simulating refocusing and
 *   different user habits.</li>
 *   <li>Randomization: Random play style generation for unpredictable behavior and more realistic automation.</li>
 * </ul>
 *
 * <h3>Usage:</h3>
 * <p>
 * The <code>PlayStyle</code> enum is primarily used to control how the bot behaves in different situations,
 * allowing it to alternate between aggressive, moderate, or cautious behaviors dynamically. This helps the bot
 * to avoid detection by simulating varied human actions over time.
 * </p>
 *
 * <h3>Example:</h3>
 * <pre>
 * PlayStyle currentStyle = PlayStyle.AGGRESSIVE;
 * Rs2Antiban.playStyle = currentStyle; // Set the current play style
 * Rs2Antiban.playStyle.evolvePlayStyle(); // Dynamically evolve the play style (evolve is called each time Rs2Antiban.actionCooldown() is triggered)
 * </pre>
 *
 * <h3>Attention Span Simulation:</h3>
 * <p>
 * Each play style tracks an attention span, representing the time the bot will continue with the current profile
 * before switching to a new one. This ensures that the bot does not remain in a single behavior pattern for too long,
 * helping it to mimic real human behavior.
 * </p>
 */
@Slf4j
public enum PlayStyle {
    EXTREME_AGGRESSIVE("Extreme Aggressive", 1, 3, 2, 0.00), // Almost no break between inputs
    AGGRESSIVE("Aggressive", 2, 5, 5, 0.01),                // Very short breaks
    MODERATE("Moderate", 3, 9, 10, 0.08),                    // Short breaks
    BALANCED("Balanced", 7, 15, 14, 0.12),                   // Moderate breaks
    CAREFUL("Careful", 12, 21, 14, 0.17),                    // Longer breaks
    CAUTIOUS("Cautious", 17, 30, 14, 0.23),                  // Very long breaks
    PASSIVE("Passive", 20, 35, 14, 0.4),                    // Minimal actions
    RANDOM("Random", 1, 35, 25, 0.00);                       // Random actions
    @Getter
    private final String name;
    private final int originalPrimaryTickInterval;
    private final int originalSecondaryTickInterval;
    private final int baseDuration; // Base duration for the attention span
    private final double refocusProbability; // Probability of refocusing
    @Getter
    @Setter
    public double frequency;
    @Getter
    @Setter
    public double amplitude;
    @Setter
    public Instant startTime; // Start time for the current playstyle
    @Getter
    private int primaryTickInterval;
    @Getter
    private int secondaryTickInterval;
    private double phase; // Phase angle for the sine function
    private int attentionSpan; // Attention span for the current playstyle
    PlayStyle(String name, int primaryTickInterval, int secondaryTickInterval, int baseDuration, double refocusProbability) {
        this.name = name;
        this.originalPrimaryTickInterval = primaryTickInterval;
        this.originalSecondaryTickInterval = secondaryTickInterval;
        this.primaryTickInterval = primaryTickInterval;
        this.secondaryTickInterval = secondaryTickInterval;
        this.refocusProbability = refocusProbability;
        this.phase = 0.0;
        this.frequency = 0.2;
        this.amplitude = 2.0;
        this.startTime = Instant.now();
        this.baseDuration = baseDuration;
        this.attentionSpan = generateAttentionSpan(baseDuration);
    }
    // Return a random PlayStyle
    public static PlayStyle random() {
        return values()[(int) (Math.random() * values().length)];
    }
    public int getRandomTickInterval() {
        return ThreadLocalRandom.current().nextInt(primaryTickInterval, secondaryTickInterval + 1);
    }
    // Method to evolve the play style over time using a sine function
    public void evolvePlayStyle() {
        phase += frequency;
        primaryTickInterval = adjustInterval(primaryTickInterval, amplitude);
        log.info("Primary tick interval: {}", primaryTickInterval);
        secondaryTickInterval = adjustInterval(secondaryTickInterval, amplitude);
        log.info("Secondary tick interval: {}", secondaryTickInterval);
        Microbot.log("Slightly adjusting playStyle intervals.");
    }
    // Helper method to adjust intervals using the sine of the phase
    private int adjustInterval(int interval, double amplitude) {
        int change = (int) (amplitude * Math.sin(phase));
        interval += change;
        // Ensure intervals remain within logical boundaries
        return Math.max(1, interval);
    }
    // Method to reset the intervals to their original values
    public void resetPlayStyle() {
        this.primaryTickInterval = originalPrimaryTickInterval;
        this.secondaryTickInterval = originalSecondaryTickInterval;
        this.phase = 0.0; // Reset the phase as well
        this.startTime = Instant.now(); // Reset start time
        this.attentionSpan = generateAttentionSpan(this.baseDuration); // Generate new attention span
    }
    // Switch profile to a new play style either one step up or down
    public PlayStyle switchProfile() {
        boolean up = Math.random() < 0.5;
        boolean refocus = Math.random() < refocusProbability;
        if (refocus) {
            PlayStyle newProfile = values()[0];
            Microbot.log("Refocusing, switching to: " + newProfile.getName());
            return newProfile;
        }
        int index = this.ordinal();
        if (up) {
            index++;
        } else {
            index--;
        }
        // Check if index is out of bounds and invert the direction if necessary
        if (index < 0 || index >= values().length - 1) {
            // Invert the direction
            up = !up;
            // Reset index to the current ordinal value
            index = this.ordinal();
            // Update the index again with the inverted direction
            if (up) {
                index = Math.min(values().length - 1, index + 1);
            } else {
                index = Math.max(0, index - 1);
            }
        }
        PlayStyle newProfile = values()[index];
        Microbot.log("Switched profile to: " + newProfile.getName());
        return newProfile;
    }
    // Switch profile based on simulated attention span
    public boolean shouldSwitchProfileBasedOnAttention() {
        Instant currentTime = Instant.now();
        long elapsedTime = java.time.Duration.between(this.startTime, currentTime).getSeconds(); // elapsed time in seconds
        return elapsedTime >= this.attentionSpan;
    }
    // Time left in the current play style
    public String getTimeLeftUntilNextSwitch() {
        Instant currentTime = Instant.now();
        long elapsedTime = Duration.between(this.startTime, currentTime).getSeconds(); // elapsed time in seconds
        long timeLeft = (this.attentionSpan) - elapsedTime;
        if (timeLeft <= 0) {
            return "00:00"; // switch should occur immediately
        }
        long minutes = timeLeft / 60;
        long seconds = timeLeft % 60;
        return String.format("%02d:%02d", minutes, seconds);
    }
    // Generate attention span using normal and Poisson distributions
    private int generateAttentionSpan(int baseDuration) {
        // Define parameters for normal and Poisson distributions
        double normalMean = baseDuration * 60; // mean of the normal distribution
        double normalStdDev = normalMean * 0.2; // standard deviation of the normal distribution (20% of mean)
        double poissonLambda = normalMean * 0.1; // lambda parameter for the Poisson distribution (10% of mean)
        // Generate random values from normal and Poisson distributions
        Random random = new Random();
        double normalSample = random.nextGaussian() * normalStdDev + normalMean;
        double poissonSample = nextPoisson(poissonLambda);
        // Combine the values to get the attention span
        return (int) Math.max(1, normalSample + poissonSample);
    }
    // Helper method to generate a Poisson-distributed random value
    private int nextPoisson(double lambda) {
        Random random = new Random();
        double l = Math.exp(-lambda);
        int k = 0;
        double p = 1.0;
        do {
            k++;
            p *= random.nextDouble();
        } while (p > l);
        return k - 1;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/antiban/ui/ActivityPanel.java
================
package net.runelite.client.plugins.microbot.util.antiban.ui;
import net.runelite.client.plugins.microbot.util.antiban.Rs2AntibanSettings;
import net.runelite.client.ui.ColorScheme;
import javax.swing.*;
import java.awt.*;
public class ActivityPanel extends JPanel {
    private final JCheckBox usePlayStyle = new JCheckBox("Use Play Style");
    private final JCheckBox useRandomIntervals = new JCheckBox("Use Random Intervals");
    private final JCheckBox simulateFatigue = new JCheckBox("Simulate Fatigue");
    private final JCheckBox simulateAttentionSpan = new JCheckBox("Simulate Attention Span");
    private final JCheckBox useBehavioralVariability = new JCheckBox("Use Behavioral Variability");
    private final JCheckBox useNonLinearIntervals = new JCheckBox("Use Non-Linear Intervals");
    private final JCheckBox dynamicActivityIntensity = new JCheckBox("Dynamic Activity Intensity");
    private final JCheckBox dynamicActivity = new JCheckBox("Dynamic Activity");
    public ActivityPanel() {
        setLayout(new GridBagLayout());
        setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = GridBagConstraints.RELATIVE;
        gbc.anchor = GridBagConstraints.WEST;
        gbc.insets = new Insets(5, 5, 5, 5);
        add(usePlayStyle, gbc);
        add(useRandomIntervals, gbc);
        add(simulateFatigue, gbc);
        add(simulateAttentionSpan, gbc);
        add(useBehavioralVariability, gbc);
        add(useNonLinearIntervals, gbc);
        add(dynamicActivityIntensity, gbc);
        add(dynamicActivity, gbc);
        setupActionListeners();
    }
    private void setupActionListeners() {
        usePlayStyle.addActionListener(e -> Rs2AntibanSettings.usePlayStyle = usePlayStyle.isSelected());
        useRandomIntervals.addActionListener(e -> Rs2AntibanSettings.randomIntervals = useRandomIntervals.isSelected());
        simulateFatigue.addActionListener(e -> Rs2AntibanSettings.simulateFatigue = simulateFatigue.isSelected());
        simulateAttentionSpan.addActionListener(e -> Rs2AntibanSettings.simulateAttentionSpan = simulateAttentionSpan.isSelected());
        useBehavioralVariability.addActionListener(e -> Rs2AntibanSettings.behavioralVariability = useBehavioralVariability.isSelected());
        useNonLinearIntervals.addActionListener(e -> Rs2AntibanSettings.nonLinearIntervals = useNonLinearIntervals.isSelected());
        dynamicActivityIntensity.addActionListener(e -> Rs2AntibanSettings.dynamicIntensity = dynamicActivityIntensity.isSelected());
        dynamicActivity.addActionListener(e -> Rs2AntibanSettings.dynamicActivity = dynamicActivity.isSelected());
    }
    public void updateValues() {
        usePlayStyle.setSelected(Rs2AntibanSettings.usePlayStyle);
        useRandomIntervals.setSelected(Rs2AntibanSettings.randomIntervals);
        simulateFatigue.setSelected(Rs2AntibanSettings.simulateFatigue);
        simulateAttentionSpan.setSelected(Rs2AntibanSettings.simulateAttentionSpan);
        useBehavioralVariability.setSelected(Rs2AntibanSettings.behavioralVariability);
        useNonLinearIntervals.setSelected(Rs2AntibanSettings.nonLinearIntervals);
        dynamicActivityIntensity.setSelected(Rs2AntibanSettings.dynamicIntensity);
        dynamicActivity.setSelected(Rs2AntibanSettings.dynamicActivity);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/antiban/ui/CardPanel.java
================
package net.runelite.client.plugins.microbot.util.antiban.ui;
import net.runelite.client.ui.ColorScheme;
import javax.swing.*;
import java.awt.*;
public class CardPanel extends JPanel {
    public CardPanel() {
        setLayout(new CardLayout());
        setBorder(BorderFactory.createCompoundBorder(
                BorderFactory.createMatteBorder(2, 2, 2, 2, ColorScheme.DARKER_GRAY_COLOR.darker()),
                BorderFactory.createEmptyBorder(0, 0, 5, 0)));
        setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
    }
    public void addPanel(JPanel panel, String name) {
        add(panel, name);
    }
    public void showPanel(String name) {
        CardLayout cardLayout = (CardLayout) getLayout();
        cardLayout.show(this, name);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/antiban/ui/CooldownPanel.java
================
package net.runelite.client.plugins.microbot.util.antiban.ui;
import net.runelite.client.plugins.microbot.util.antiban.Rs2Antiban;
import net.runelite.client.plugins.microbot.util.antiban.Rs2AntibanSettings;
import net.runelite.client.ui.ColorScheme;
import javax.swing.*;
import java.awt.*;
import static net.runelite.client.plugins.microbot.util.antiban.ui.UiHelper.setupSlider;
public class CooldownPanel extends JPanel {
    private final JCheckBox isActionCooldownActive = new JCheckBox("Action Cooldown Active");
    private final JSlider actionCooldownChance = new JSlider(0, 100, (int) (Rs2AntibanSettings.actionCooldownChance * 100));
    private final JSlider timeout = new JSlider(0, 60, Rs2Antiban.getTIMEOUT());
    private final JLabel actionCooldownChanceLabel = new JLabel("Action Cooldown Chance (%): " + (int) (Rs2AntibanSettings.actionCooldownChance * 100));
    private final JLabel timeoutLabel = new JLabel("Timeout (ticks): " + Rs2Antiban.getTIMEOUT());
    public CooldownPanel() {
        // Set the layout manager for the panel to GridBagLayout
        setLayout(new GridBagLayout());
        setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
        setupSlider(actionCooldownChance, 20, 100, 10);
        setupSlider(timeout, 10, 60, 5);
        // Create a GridBagConstraints object to define the layout settings for each component
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(5, 5, 5, 5); // Padding around components
        gbc.anchor = GridBagConstraints.WEST; // Align components to the left
        gbc.gridx = 0; // All components will be in column 0
        gbc.gridy = GridBagConstraints.RELATIVE; // Components will be placed in consecutive rows
        // Add the "Action Cooldown Active" checkbox
        add(isActionCooldownActive, gbc);
        // Add the "Action Cooldown Chance" label
        add(actionCooldownChanceLabel, gbc);
        gbc.fill = GridBagConstraints.HORIZONTAL;
        // Add the "Action Cooldown Chance" slider
        add(actionCooldownChance, gbc);
        gbc.fill = GridBagConstraints.NONE;
        // Add the "Timeout" label
        add(timeoutLabel, gbc);
        gbc.fill = GridBagConstraints.HORIZONTAL;
        // Add the "Timeout" slider
        add(timeout, gbc);
        setupActionListeners();
    }
    private void setupActionListeners() {
        isActionCooldownActive.addActionListener(e -> Rs2AntibanSettings.actionCooldownActive = isActionCooldownActive.isSelected());
        actionCooldownChance.addChangeListener(e -> {
            Rs2AntibanSettings.actionCooldownChance = actionCooldownChance.getValue() / 100.0;
            actionCooldownChanceLabel.setText("Action Cooldown Chance (%): " + actionCooldownChance.getValue());
        });
        timeout.addChangeListener(e -> {
            Rs2Antiban.setTIMEOUT(timeout.getValue());
            timeoutLabel.setText("Timeout (ticks): " + timeout.getValue());
        });
    }
    public void updateValues() {
        isActionCooldownActive.setSelected(Rs2AntibanSettings.actionCooldownActive);
        isActionCooldownActive.setEnabled(false);
        actionCooldownChance.setValue((int) (Rs2AntibanSettings.actionCooldownChance * 100));
        actionCooldownChanceLabel.setText("Action Cooldown Chance (%): " + actionCooldownChance.getValue());
        timeout.setValue(Rs2Antiban.getTIMEOUT());
        timeoutLabel.setText("Timeout (ticks): " + timeout.getValue());
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/antiban/ui/GeneralPanel.java
================
package net.runelite.client.plugins.microbot.util.antiban.ui;
import net.runelite.client.plugins.microbot.util.antiban.Rs2AntibanSettings;
import net.runelite.client.ui.ColorScheme;
import javax.swing.*;
import java.awt.*;
public class GeneralPanel extends JPanel {
    private final JCheckBox isEnabled = new JCheckBox("Enabled");
    private final JCheckBox universalAntiban = new JCheckBox("Universal Antiban");
    private final JCheckBox useContextualVariability = new JCheckBox("Use Contextual Variability");
    private final JCheckBox devDebug = new JCheckBox("Dev Debug");
    public GeneralPanel() {
        // Set the layout manager for the panel to GridBagLayout
        setLayout(new GridBagLayout());
        setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
        // Create a GridBagConstraints object to define the layout settings for each component
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(5, 5, 5, 5); // Padding around components
        gbc.anchor = GridBagConstraints.WEST; // Align components to the left
        gbc.gridx = 0; // All components will be in column 0
        gbc.gridy = GridBagConstraints.RELATIVE; // Components will be placed in consecutive rows
        // Add the "Enabled" checkbox
        add(isEnabled, gbc);
        // Add the "Universal Antiban" checkbox
        add(universalAntiban, gbc);
        // Add the "Use Contextual Variability" checkbox
        add(useContextualVariability, gbc);
        // Add the "Dev Debug" checkbox
        add(devDebug, gbc);
        setupActionListeners();
    }
    private void setupActionListeners() {
        isEnabled.addActionListener(e -> Rs2AntibanSettings.antibanEnabled = isEnabled.isSelected());
        universalAntiban.addActionListener(e -> Rs2AntibanSettings.universalAntiban = universalAntiban.isSelected());
        useContextualVariability.addActionListener(e -> Rs2AntibanSettings.contextualVariability = useContextualVariability.isSelected());
        devDebug.addActionListener(e -> Rs2AntibanSettings.devDebug = devDebug.isSelected());
    }
    public void updateValues() {
        isEnabled.setSelected(Rs2AntibanSettings.antibanEnabled);
        universalAntiban.setSelected(Rs2AntibanSettings.universalAntiban);
        useContextualVariability.setSelected(Rs2AntibanSettings.contextualVariability);
        devDebug.setSelected(Rs2AntibanSettings.devDebug);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/antiban/ui/MasterPanel.java
================
package net.runelite.client.plugins.microbot.util.antiban.ui;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.antiban.Rs2Antiban;
import net.runelite.client.ui.FontManager;
import net.runelite.client.ui.PluginPanel;
import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.geom.AffineTransform;
/**
 * The MasterPanel is a user interface panel for configuring anti-ban settings.
 *
 * <p>
 * This panel allows users to adjust settings related to the anti-ban system, such as enabling micro-breaks,
 * adjusting action cooldown probabilities, and configuring behavioral simulations like fatigue or attention span.
 * The panel is divided into different categories, each focusing on specific aspects of anti-ban behavior,
 * including activity settings, mouse behavior, and cooldown management.
 * </p>
 *
 * <p>
 * Users can interact with various checkboxes and sliders to tailor the bot's anti-ban features to their preferences,
 * making it behave more like a human player during automated tasks.
 * </p>
 *
 * <h3>Main Features:</h3>
 * <ul>
 *   <li>Enable or disable anti-ban features like action cooldowns and micro-breaks.</li>
 *   <li>Customize the bot's behavior with random intervals, dynamic activity, and simulated fatigue.</li>
 *   <li>Adjust the duration and probability of micro-breaks and action cooldowns.</li>
 *   <li>Fine-tune mouse behavior, including natural movements and random actions.</li>
 *   <li>View real-time information about the current play style, activity, and bot status.</li>
 * </ul>
 *
 * <p>
 * This panel is automatically integrated into the bot's user interface and does not require manual initialization by the user.
 * </p>
 */
public class MasterPanel extends PluginPanel {
    private static final int BOUNDARY_RIGHT = 150; // Adjust for how far you want the GIF to move
    private static final int BOUNDARY_LEFT = 0;
    // Additional Info Panel
    private final JLabel playStyleLabel = new JLabel("Play Style: " + (Rs2Antiban.getPlayStyle() != null ? Rs2Antiban.getPlayStyle().getName() : "null"));
    private final JLabel playStyleChangeLabel = new JLabel("Play Style Change: " + (Rs2Antiban.getPlayStyle() != null ? Rs2Antiban.getPlayStyle().getTimeLeftUntilNextSwitch() : "null"));
    private final JLabel profileLabel = new JLabel("Category: " + (Rs2Antiban.getCategory() != null ? Rs2Antiban.getCategory().getName() : "null"));
    private final JLabel activityLabel = new JLabel("Activity: " + (Rs2Antiban.getActivity() != null ? Rs2Antiban.getActivity().getMethod() : "null"));
    private final JLabel activityIntensityLabel = new JLabel("Activity Intensity: " + (Rs2Antiban.getActivityIntensity() != null ? Rs2Antiban.getActivityIntensity().getName() : "null"));
    private final JLabel busyLabel = new JLabel("Busy: " + (Rs2Antiban.getCategory() != null ? Rs2Antiban.getCategory().isBusy() : "null"));
    private final boolean isFlipped = false; // Track if the image is flipped
    private final FlippableLabel label;
    private final JLayeredPane layeredPane; // Use a layered pane for positioning the GIF
    GeneralPanel generalPanel = new GeneralPanel();
    ActivityPanel activityPanel = new ActivityPanel();
    ProfilePanel profilePanel = new ProfilePanel();
    MousePanel mousePanel = new MousePanel();
    MicroBreakPanel microBreakPanel = new MicroBreakPanel();
    CooldownPanel cooldownPanel = new CooldownPanel();
    JButton resetButton = new JButton("Reset");
    private int xPosition = 0;
    private int xVelocity = 1; // Change this value to control the speed of movement
    public MasterPanel() {
        setLayout(new BorderLayout());
        // Create the CardPanel (which contains the CardLayout)
        CardPanel cardPanel = new CardPanel();
        // Add panels to the CardPanel with unique names
        cardPanel.addPanel(generalPanel, "General");
        cardPanel.addPanel(activityPanel, "Activity");
        cardPanel.addPanel(profilePanel, "Profile");
        cardPanel.addPanel(mousePanel, "Mouse");
        cardPanel.addPanel(microBreakPanel, "MicroBreak");
        cardPanel.addPanel(cooldownPanel, "Cooldown");
        // Create the NavigationPanel and pass the CardPanel to it
        NavigationPanel navigationPanel = new NavigationPanel(cardPanel);
        JPanel headerPanel = createHeaderPanel(navigationPanel);
        JPanel mainDisplayPanel = new JPanel();
        mainDisplayPanel.add(cardPanel);
        mainDisplayPanel.setLayout(new BoxLayout(mainDisplayPanel, BoxLayout.Y_AXIS));
        mainDisplayPanel.add(createInfoPanel());
        mainDisplayPanel.add(Box.createVerticalStrut(100));
        mainDisplayPanel.add(new Box(BoxLayout.Y_AXIS));
        layeredPane = new JLayeredPane();
        layeredPane.setPreferredSize(new Dimension(250, 32));
        // Create and position the GIF JLabel
        ImageIcon icon = new ImageIcon(Rs2Antiban.class.getResource("walkingduckdark.gif"));
        label = new FlippableLabel(icon);
        label.setBounds(xPosition, 0, icon.getIconWidth(), icon.getIconHeight()); // Initial position
        layeredPane.add(label, JLayeredPane.DEFAULT_LAYER); // Add label to the default layer
        mainDisplayPanel.add(layeredPane);
        // Timer to move the GIF back and forth
        Timer timer = new Timer(80, new ActionListener() { // Update every 20ms (50fps)
            @Override
            public void actionPerformed(ActionEvent e) {
                // Update the position
                xPosition += xVelocity;
                // Check boundaries and reverse direction if needed
                if (xPosition >= 250 || xPosition <= BOUNDARY_LEFT) {
                    xVelocity = -xVelocity; // Reverse direction
                    label.flip(); // Flip the image when direction changes
                }
                // Update the label's position
                label.updatePosition(xPosition);
            }
        });
        timer.start(); // Start the movement timer
        add(headerPanel, BorderLayout.NORTH);
        add(mainDisplayPanel, BorderLayout.CENTER);
        add(resetButton, BorderLayout.SOUTH);
        cardPanel.showPanel("General");
        setupResetButton();
    }
    private JPanel createHeaderPanel(NavigationPanel navigationPanel) {
        JPanel headerPanel = new JPanel();
        headerPanel.setLayout(new BorderLayout());
        headerPanel.setBackground(new Color(27, 27, 27));
//        JLabel headerLabel = new JLabel("<html><font color=#ffff1a>\uD83E\uDD86</font> ANTIBAN <font color=#ffff1a>\uD83E\uDD86</font></html>");
        JLabel headerLabel = new JLabel("ANTIBAN");
        headerLabel.setFont(FontManager.getRunescapeBoldFont().deriveFont(24.0F));
        headerLabel.setBorder(BorderFactory.createEmptyBorder(10, 0, 10, 0));
        headerLabel.setHorizontalAlignment(SwingConstants.CENTER);
        headerPanel.add(headerLabel, BorderLayout.NORTH);
        headerPanel.add(navigationPanel, BorderLayout.CENTER);
        return headerPanel;
    }
    //set up the reset button to reset all settings
    public void setupResetButton() {
        resetButton.addActionListener(e -> {
            Rs2Antiban.resetAntibanSettings();
            loadSettings();
        });
    }
    public void loadSettings() {
        // Load settings from the settings object and set the checkboxes accordingly
        generalPanel.updateValues();
        activityPanel.updateValues();
        profilePanel.updateValues();
        mousePanel.updateValues();
        microBreakPanel.updateValues();
        cooldownPanel.updateValues();
        if (!Microbot.isLoggedIn())
            return;
        playStyleLabel.setText("Play Style: " + (Rs2Antiban.getPlayStyle() != null ? Rs2Antiban.getPlayStyle().getName() : "null"));
        playStyleChangeLabel.setText("Play Style Change: " + (Rs2Antiban.getPlayStyle() != null ? Rs2Antiban.getPlayStyle().getTimeLeftUntilNextSwitch() : "null"));
        profileLabel.setText("Category: " + (Rs2Antiban.getCategory() != null ? Rs2Antiban.getCategory().getName() : "null"));
        activityLabel.setText("Activity: " + (Rs2Antiban.getActivity() != null ? Rs2Antiban.getActivity().getMethod() : "null"));
        activityIntensityLabel.setText("Activity Intensity: " + (Rs2Antiban.getActivityIntensity() != null ? Rs2Antiban.getActivityIntensity().getName() : "null"));
        busyLabel.setText("Busy: " + (Rs2Antiban.getCategory() != null ? Rs2Antiban.getCategory().isBusy() : "null"));
    }
    private JPanel createInfoPanel() {
        JPanel panel = new JPanel(new GridBagLayout());
        panel.setBorder(BorderFactory.createTitledBorder("Additional Info"));
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.gridx = 0;
        gbc.gridy = GridBagConstraints.RELATIVE;
        gbc.anchor = GridBagConstraints.WEST;
        gbc.insets = new Insets(5, 5, 5, 5);
        panel.add(playStyleLabel, gbc);
        panel.add(playStyleChangeLabel, gbc);
        panel.add(profileLabel, gbc);
        panel.add(activityLabel, gbc);
        panel.add(activityIntensityLabel, gbc);
        panel.add(busyLabel, gbc);
        return panel;
    }
    // Custom JLabel class that supports flipping the image
    private class FlippableLabel extends JLabel {
        private boolean isFlipped = false;
        public FlippableLabel(ImageIcon icon) {
            super(icon);
            setDoubleBuffered(true); // Enable double buffering to prevent flickering
        }
        public void flip() {
            isFlipped = !isFlipped;
            repaint(); // Request a repaint to apply the flip
        }
        public void updatePosition(int x) {
            // Safely update the label position without interfering with other UI events
            SwingUtilities.invokeLater(() -> setBounds(x, getY(), getWidth(), getHeight()));
        }
        @Override
        protected void paintComponent(Graphics g) {
            Graphics2D g2d = (Graphics2D) g.create(); // Create a copy of Graphics2D to avoid modifying the original
            if (isFlipped) {
                // Apply horizontal flip by flipping the x-axis
                AffineTransform transform = AffineTransform.getScaleInstance(-1, 1);
                transform.translate(-getWidth(), 0);
                g2d.setTransform(transform);
            }
            super.paintComponent(g2d); // Let JLabel handle the image rendering
            g2d.dispose(); // Dispose of the copy to release resources
        }
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/antiban/ui/MicroBreakPanel.java
================
package net.runelite.client.plugins.microbot.util.antiban.ui;
import net.runelite.client.plugins.microbot.util.antiban.Rs2AntibanSettings;
import net.runelite.client.ui.ColorScheme;
import javax.swing.*;
import java.awt.*;
import static net.runelite.client.plugins.microbot.util.antiban.ui.UiHelper.setupSlider;
public class MicroBreakPanel extends JPanel {
    private final JCheckBox isMicroBreakActive = new JCheckBox("Micro Break Active");
    private final JCheckBox takeMicroBreaks = new JCheckBox("Take Micro Breaks");
    private final JSlider microBreakDurationLow = new JSlider(1, 10, Rs2AntibanSettings.microBreakDurationLow);
    private final JSlider microBreakDurationHigh = new JSlider(1, 30, Rs2AntibanSettings.microBreakDurationHigh);
    private final JSlider microBreakChance = new JSlider(0, 100, (int) (Rs2AntibanSettings.microBreakChance * 100));
    private final JLabel microBreakDurationLowLabel = new JLabel("Micro Break Duration Low (min): " + Rs2AntibanSettings.microBreakDurationLow);
    private final JLabel microBreakDurationHighLabel = new JLabel("Micro Break Duration High (min): " + Rs2AntibanSettings.microBreakDurationHigh);
    private final JLabel microBreakChanceLabel = new JLabel("Micro Break Chance (%): " + (int) (Rs2AntibanSettings.microBreakChance * 100));
    public MicroBreakPanel() {
        // Set the layout manager for the panel to GridBagLayout
        setLayout(new GridBagLayout());
        setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
        setupSlider(microBreakDurationLow, 1, 5, 1);
        setupSlider(microBreakDurationHigh, 5, 15, 1);
        setupSlider(microBreakChance, 20, 100, 10);
        // Create a GridBagConstraints object to define the layout settings for each component
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(5, 5, 5, 5); // Padding around components
        gbc.anchor = GridBagConstraints.WEST; // Align components to the left
        gbc.gridx = 0; // All components will be in column 0
        gbc.gridy = GridBagConstraints.RELATIVE; // Components will be placed in consecutive rows
        // Add the "Micro Break Active" checkbox
        add(isMicroBreakActive, gbc);
        // Add the "Take Micro Breaks" checkbox
        add(takeMicroBreaks, gbc);
        // Add the "Micro Break Duration Low" label
        add(microBreakDurationLowLabel, gbc);
        gbc.fill = GridBagConstraints.HORIZONTAL;
        // Add the "Micro Break Duration Low" slider
        add(microBreakDurationLow, gbc);
        gbc.fill = GridBagConstraints.NONE;
        // Add the "Micro Break Duration High" label
        add(microBreakDurationHighLabel, gbc);
        gbc.fill = GridBagConstraints.HORIZONTAL;
        // Add the "Micro Break Duration High" slider
        add(microBreakDurationHigh, gbc);
        gbc.fill = GridBagConstraints.NONE;
        // Add the "Micro Break Chance" label
        add(microBreakChanceLabel, gbc);
        gbc.fill = GridBagConstraints.HORIZONTAL;
        // Add the "Micro Break Chance" slider
        add(microBreakChance, gbc);
        setupActionListeners();
    }
    private void setupActionListeners() {
        isMicroBreakActive.addActionListener(e -> Rs2AntibanSettings.microBreakActive = isMicroBreakActive.isSelected());
        takeMicroBreaks.addActionListener(e -> Rs2AntibanSettings.takeMicroBreaks = takeMicroBreaks.isSelected());
        microBreakDurationLow.addChangeListener(e -> {
            Rs2AntibanSettings.microBreakDurationLow = microBreakDurationLow.getValue();
            microBreakDurationLowLabel.setText("Micro Break Duration Low (min): " + microBreakDurationLow.getValue());
        });
        microBreakDurationHigh.addChangeListener(e -> {
            Rs2AntibanSettings.microBreakDurationHigh = microBreakDurationHigh.getValue();
            microBreakDurationHighLabel.setText("Micro Break Duration High (min): " + microBreakDurationHigh.getValue());
        });
        microBreakChance.addChangeListener(e -> {
            Rs2AntibanSettings.microBreakChance = microBreakChance.getValue() / 100.0;
            microBreakChanceLabel.setText("Micro Break Chance (%): " + microBreakChance.getValue());
        });
    }
    public void updateValues() {
        isMicroBreakActive.setSelected(Rs2AntibanSettings.microBreakActive);
        isMicroBreakActive.setEnabled(false);
        takeMicroBreaks.setSelected(Rs2AntibanSettings.takeMicroBreaks);
        microBreakDurationLow.setValue(Rs2AntibanSettings.microBreakDurationLow);
        microBreakDurationLowLabel.setText("Micro Break Duration Low (min): " + microBreakDurationLow.getValue());
        microBreakDurationHigh.setValue(Rs2AntibanSettings.microBreakDurationHigh);
        microBreakDurationHighLabel.setText("Micro Break Duration High (min): " + microBreakDurationHigh.getValue());
        microBreakChance.setValue((int) (Rs2AntibanSettings.microBreakChance * 100));
        microBreakChanceLabel.setText("Micro Break Chance (%): " + microBreakChance.getValue());
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/antiban/ui/MousePanel.java
================
package net.runelite.client.plugins.microbot.util.antiban.ui;
import net.runelite.client.plugins.microbot.util.antiban.Rs2AntibanSettings;
import net.runelite.client.ui.ColorScheme;
import javax.swing.*;
import java.awt.*;
import static net.runelite.client.plugins.microbot.util.antiban.ui.UiHelper.setupSlider;
public class MousePanel extends JPanel {
    private final JCheckBox useNaturalMouse = new JCheckBox("Use Natural Mouse");
    private final JCheckBox simulateMistakes = new JCheckBox("Simulate Mistakes");
    private final JCheckBox moveMouseOffScreen = new JCheckBox("Move Mouse Off Screen");
    private final JCheckBox moveMouseRandomly = new JCheckBox("Move Mouse Randomly");
    private final JSlider moveMouseRandomlyChance = new JSlider(0, 100, (int) (Rs2AntibanSettings.moveMouseRandomlyChance * 100));
    private final JLabel moveMouseRandomlyChanceLabel = new JLabel("Random Mouse Movement (%): " + (int) (Rs2AntibanSettings.moveMouseRandomlyChance * 100));
    public MousePanel() {
        // Set the layout manager for the panel to GridBagLayout
        setLayout(new GridBagLayout());
        setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
        setupSlider(moveMouseRandomlyChance, 20, 100, 10);
        // Create a GridBagConstraints object to define the layout settings for each component
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(5, 5, 5, 5); // Padding around components
        gbc.anchor = GridBagConstraints.WEST; // Align components to the left
        gbc.gridx = 0; // All components will be in column 0
        gbc.gridy = GridBagConstraints.RELATIVE; // Components will be placed in consecutive rows
        // Add the "Use Natural Mouse" checkbox
        add(useNaturalMouse, gbc);
        // Add a gap between "Use Natural Mouse" and the rest of the settings
        gbc.insets = new Insets(20, 5, 5, 5); // Increase the top padding to create a larger gap
        add(Box.createVerticalStrut(15), gbc); // Add a vertical gap of 15 pixels
        // Add the "Simulate Mistakes" checkbox
        gbc.insets = new Insets(5, 5, 5, 5); // Reset padding for normal spacing
        add(simulateMistakes, gbc);
        // Add the "Move Mouse Off Screen" checkbox
        add(moveMouseOffScreen, gbc);
        // Add the "Move Mouse Randomly" checkbox
        add(moveMouseRandomly, gbc);
        // Add the "Random Mouse Movement" label
        add(moveMouseRandomlyChanceLabel, gbc);
        gbc.fill = GridBagConstraints.HORIZONTAL;
        // Add the "Random Mouse Movement" slider
        add(moveMouseRandomlyChance, gbc);
        setupActionListeners();
    }
    private void setupActionListeners() {
        useNaturalMouse.addActionListener(e -> Rs2AntibanSettings.naturalMouse = useNaturalMouse.isSelected());
        simulateMistakes.addActionListener(e -> Rs2AntibanSettings.simulateMistakes = simulateMistakes.isSelected());
        moveMouseOffScreen.addActionListener(e -> Rs2AntibanSettings.moveMouseOffScreen = moveMouseOffScreen.isSelected());
        moveMouseRandomly.addActionListener(e -> Rs2AntibanSettings.moveMouseRandomly = moveMouseRandomly.isSelected());
        moveMouseRandomlyChance.addChangeListener(e -> {
            Rs2AntibanSettings.moveMouseRandomlyChance = moveMouseRandomlyChance.getValue() / 100.0;
            moveMouseRandomlyChanceLabel.setText("Random Mouse Movement (%): " + moveMouseRandomlyChance.getValue());
        });
    }
    public void updateValues() {
        useNaturalMouse.setSelected(Rs2AntibanSettings.naturalMouse);
        simulateMistakes.setSelected(Rs2AntibanSettings.simulateMistakes);
        moveMouseOffScreen.setSelected(Rs2AntibanSettings.moveMouseOffScreen);
        moveMouseRandomly.setSelected(Rs2AntibanSettings.moveMouseRandomly);
        moveMouseRandomlyChance.setValue((int) (Rs2AntibanSettings.moveMouseRandomlyChance * 100));
        moveMouseRandomlyChanceLabel.setText("Random Mouse Movement (%): " + moveMouseRandomlyChance.getValue());
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/antiban/ui/NavigationPanel.java
================
package net.runelite.client.plugins.microbot.util.antiban.ui;
import net.runelite.client.plugins.microbot.util.antiban.Rs2Antiban;
import javax.swing.*;
import java.awt.*;
import java.util.Objects;
public class NavigationPanel extends JPanel {
    public NavigationPanel(CardPanel cardPanel) {
        setLayout(new BorderLayout());
        // Create a navigation panel for the buttons
        JPanel navPanel = new JPanel();
        navPanel.setLayout(new GridLayout(1, 6)); // 1 rows, 6 column
        // Create buttons with icons
        JButton generalButton = createIconButton("general.png", "General");
        JButton activityButton = createIconButton("activity.png", "Activity");
        JButton profileButton = createIconButton("profile.png", "Profile");
        JButton mouseButton = createIconButton("mouse.png", "Mouse");
        JButton microBreakButton = createIconButton("microbreak.png", "MicroBreak");
        JButton cooldownButton = createIconButton("cooldown.png", "Cooldown");
        // Add buttons to the navigation panel
        navPanel.add(generalButton);
        navPanel.add(activityButton);
        navPanel.add(profileButton);
        navPanel.add(mouseButton);
        navPanel.add(microBreakButton);
        navPanel.add(cooldownButton);
        // Add navigation panel to the NavigationPanel
        add(navPanel, BorderLayout.CENTER);
        // Add action listeners to switch panels on button click
        generalButton.addActionListener(e -> cardPanel.showPanel("General"));
        activityButton.addActionListener(e -> cardPanel.showPanel("Activity"));
        profileButton.addActionListener(e -> cardPanel.showPanel("Profile"));
        mouseButton.addActionListener(e -> cardPanel.showPanel("Mouse"));
        microBreakButton.addActionListener(e -> cardPanel.showPanel("MicroBreak"));
        cooldownButton.addActionListener(e -> cardPanel.showPanel("Cooldown"));
    }
    private JButton createIconButton(String iconPath, String altText) {
        ImageIcon icon = new ImageIcon(Objects.requireNonNull(Rs2Antiban.class.getResource(iconPath)));
        JButton button = new JButton(icon);
        button.setToolTipText(altText); // Set alt text for accessibility
        return button;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/antiban/ui/ProfilePanel.java
================
package net.runelite.client.plugins.microbot.util.antiban.ui;
import net.runelite.client.plugins.microbot.util.antiban.Rs2AntibanSettings;
import net.runelite.client.ui.ColorScheme;
import javax.swing.*;
import java.awt.*;
public class ProfilePanel extends JPanel {
    private final JCheckBox enableProfileSwitching = new JCheckBox("Enable Profile Switching");
    private final JCheckBox adjustForTimeOfDay = new JCheckBox("Adjust For Time Of Day");
    private final JCheckBox simulatePlaySchedule = new JCheckBox("Simulate Play Schedule");
    public ProfilePanel() {
        // Set the layout manager for the panel to GridBagLayout
        setLayout(new GridBagLayout());
        setBackground(ColorScheme.DARK_GRAY_HOVER_COLOR);
        // Create a GridBagConstraints object to define the layout settings for each component
        GridBagConstraints gbc = new GridBagConstraints();
        gbc.insets = new Insets(5, 5, 5, 5); // Padding around components
        gbc.anchor = GridBagConstraints.WEST; // Align components to the left
        gbc.gridx = 0; // All components will be in column 0
        gbc.gridy = GridBagConstraints.RELATIVE; // Components will be placed in consecutive rows
        // Add the "Enable Profile Switching" checkbox
        add(enableProfileSwitching, gbc);
        // Add the "Adjust For Time Of Day" checkbox
        add(adjustForTimeOfDay, gbc);
        // Add the "Simulate Play Schedule" checkbox
        add(simulatePlaySchedule, gbc);
        setupActionListeners();
    }
    private void setupActionListeners() {
        enableProfileSwitching.addActionListener(e -> Rs2AntibanSettings.profileSwitching = enableProfileSwitching.isSelected());
        adjustForTimeOfDay.addActionListener(e -> Rs2AntibanSettings.timeOfDayAdjust = adjustForTimeOfDay.isSelected());
        simulatePlaySchedule.addActionListener(e -> Rs2AntibanSettings.playSchedule = simulatePlaySchedule.isSelected());
    }
    public void updateValues() {
        enableProfileSwitching.setSelected(Rs2AntibanSettings.profileSwitching);
        adjustForTimeOfDay.setSelected(Rs2AntibanSettings.timeOfDayAdjust);
        simulatePlaySchedule.setSelected(Rs2AntibanSettings.playSchedule);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/antiban/ui/UiHelper.java
================
package net.runelite.client.plugins.microbot.util.antiban.ui;
import javax.swing.*;
public class UiHelper {
    public static void setupSlider(JSlider slider, int majorTickSpacing, int max, int minorTickSpacing) {
        slider.setMajorTickSpacing(majorTickSpacing);
        slider.setMinorTickSpacing(minorTickSpacing);
        slider.setPaintTicks(true);
        slider.setPaintLabels(true);
        slider.setMinimum(0);
        slider.setMaximum(max);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/antiban/AntibanOverlay.java
================
package net.runelite.client.plugins.microbot.util.antiban;
import net.runelite.api.Actor;
import net.runelite.api.Point;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.ProgressPieComponent;
import javax.inject.Inject;
import java.awt.*;
import java.awt.image.BufferedImage;
/**
 * The {@code AntibanOverlay} class provides a visual representation of the anti-ban system through
 * an overlay component on the game screen. This overlay uses a progress pie to display the remaining
 * time for the current action cooldown, simulating a human-like delay or pause in gameplay. The overlay
 * dynamically follows the player's location and updates in real-time as the cooldown progresses.
 *
 * <p>
 * This class extends the {@code Overlay} class from RuneLite's API and leverages {@code ProgressPieComponent}
 * to render a circular timer. The timer visually decreases over time, providing an indication of when the
 * next action will be performed. It is designed to be unobtrusive and provides important feedback for
 * antiban behaviors.
 * </p>
 *
 * <h3>Features:</h3>
 * <ul>
 *   <li>Dynamic positioning: The overlay automatically adjusts its position to follow the player's location on the screen.</li>
 *   <li>Visual feedback: A progress pie that gradually depletes, showing the remaining time before the next action is triggered.</li>
 *   <li>Integration with Anti-ban system: The overlay is displayed only when the anti-ban cooldown is active,
 *       providing clear feedback during specific bot behaviors.</li>
 * </ul>
 *
 * <h3>Usage:</h3>
 * <p>
 * The {@code AntibanOverlay} class does not need to be explicitly initialized or called.
 * It is automatically integrated into the overlay system and activated when the anti-ban action cooldown
 * is active, as determined by the {@code Rs2AntibanSettings}.
 * </p>
 *
 * <p>
 * This class works in conjunction with {@code Rs2Antiban} to monitor the player's activity and to display the
 * appropriate overlay based on the current status of the anti-ban system. It draws a circular timer around the
 * player character, providing a visual cue for the current cooldown.
 * </p>
 *
 * <h3>Example Flow:</h3>
 * <pre>
 * // This class is automatically invoked by the overlay system when the action cooldown is active.
 * // The following example describes its integration in the larger system:
 *
 * // 1. The anti-ban system detects an action cooldown.
 * Rs2Antiban.actionCooldown();
 *
 * // 2. If the cooldown is active, the overlay renders the progress pie around the player.
 * AntibanOverlay.render(graphics);
 * </pre>
 *
 * <h3>Primary Methods:</h3>
 * <ul>
 *   <li><code>getCanvasTextLocation(Graphics2D graphics, Actor actor)</code>: Calculates the screen location of the player,
 *       used for positioning the overlay relative to the player's character.</li>
 *   <li><code>drawTimerPieOverlay(Graphics2D graphics)</code>: Renders the progress pie overlay, representing the remaining
 *       cooldown time as a gradually decreasing pie chart.</li>
 *   <li><code>render(Graphics2D graphics)</code>: The main render loop that checks if an action cooldown is active and draws
 *       the overlay if necessary.</li>
 * </ul>
 *
 * <h3>Rendering Logic:</h3>
 * <p>
 * The rendering process begins with checking if the anti-ban cooldown is active. If active, the overlay retrieves
 * the player's screen location and calculates the remaining cooldown time. The progress pie is then drawn at the
 * calculated location, visually indicating the time left until the next action.
 * </p>
 *
 * <h3>Customization:</h3>
 * <p>
 * The color of the overlay and the size of the timer can be customized by adjusting the constants
 * {@code PUBLIC_TIMER_COLOR}, and {@code TIMER_OVERLAY_DIAMETER}.
 * </p>
 *
 * <h3>Dependencies:</h3>
 * <ul>
 *   <li>Requires integration with the {@code Rs2Antiban} system for cooldown tracking and updates.</li>
 *   <li>Relies on {@code ProgressPieComponent} for rendering the progress pie as the visual indicator of time remaining.</li>
 *   <li>Uses the RuneLite API's {@code Overlay} class for managing the visual overlay within the game.</li>
 * </ul>
 *
 * <h3>Limitations:</h3>
 * <ul>
 *   <li>The overlay will only render if {@code Rs2AntibanSettings.actionCooldownActive} is set to true, meaning it is dependent on the
 *       anti-ban system being active and configured properly.</li>
 *   <li>The overlay is tied to the player's screen position, so if the player is off-screen, the overlay may not be visible.</li>
 * </ul>
 */
public class AntibanOverlay extends Overlay {
    public static Color PUBLIC_TIMER_COLOR = Color.YELLOW;
    public static int TIMER_OVERLAY_DIAMETER = 20;
    private final ProgressPieComponent progressPieComponent = new ProgressPieComponent();
    @Inject
    public AntibanOverlay() {
        setPosition(OverlayPosition.DYNAMIC);
    }
    private Point getCanvasTextLocation(Graphics2D graphics, Actor actor) {
        int zOffset = Math.min(actor.getLogicalHeight(), 140);
        // create blank buffered image
        BufferedImage bufferedImage = new BufferedImage(TIMER_OVERLAY_DIAMETER, TIMER_OVERLAY_DIAMETER, BufferedImage.TYPE_INT_ARGB);
        return actor.getCanvasImageLocation(bufferedImage, zOffset);
    }
    private void drawTimerPieOverlay(Graphics2D graphics) {
        // Calculate the remaining time as a fraction of the total time
        int totalTime = Rs2Antiban.getPlayStyle().getSecondaryTickInterval();
        int timeLeft = Rs2Antiban.getTIMEOUT();
        float percent = (float) timeLeft / totalTime;
        // Get the player's screen location
        Point playerLocation = getCanvasTextLocation(graphics, Microbot.getClient().getLocalPlayer());
        progressPieComponent.setDiameter(TIMER_OVERLAY_DIAMETER);
        // Shift over to not be on top of the text
        int x = playerLocation.getX() + (TIMER_OVERLAY_DIAMETER / 2);
        int y = playerLocation.getY() - (15 + (Microbot.getClient().getScale() / 30));
        progressPieComponent.setPosition(new Point(x, y));
        progressPieComponent.setFill(PUBLIC_TIMER_COLOR);
        progressPieComponent.setBorderColor(PUBLIC_TIMER_COLOR);
        progressPieComponent.setProgress(percent); // inverse so pie drains over time
        progressPieComponent.render(graphics);
    }
    @Override
    public Dimension render(Graphics2D graphics) {
        if (Rs2AntibanSettings.actionCooldownActive) {
            drawTimerPieOverlay(graphics);
        }
        return null;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/antiban/AntibanPlugin.java
================
package net.runelite.client.plugins.microbot.util.antiban;
import net.runelite.api.AnimationID;
import net.runelite.api.GameState;
import net.runelite.api.Skill;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.StatChanged;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ProfileChanged;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.breakhandler.BreakHandlerPlugin;
import net.runelite.client.plugins.microbot.util.antiban.enums.Activity;
import net.runelite.client.plugins.microbot.util.antiban.enums.ActivityIntensity;
import net.runelite.client.plugins.microbot.util.antiban.enums.CombatSkills;
import net.runelite.client.plugins.microbot.util.antiban.ui.MasterPanel;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.util.ImageUtil;
import javax.inject.Inject;
import javax.swing.*;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.time.Duration;
import java.time.Instant;
import java.util.EnumMap;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;
/**
 * The AntibanPlugin is responsible for managing anti-ban behaviors during bot operation.
 *
 * <p>
 * This plugin ensures that the bot behaves in a more human-like manner to avoid detection by using various
 * anti-ban strategies. These strategies include simulating breaks, adjusting activity levels, and mimicking
 * attention span variations. The plugin tracks user activity and game state to dynamically adjust bot behavior.
 * </p>
 *
 * <h3>Main Features:</h3>
 * <ul>
 *   <li>Simulates action cooldowns and micro-breaks based on the bot's current activities.</li>
 *   <li>Dynamically adjusts activity intensity and behavior depending on the bot's in-game actions, such as mining or cooking.</li>
 *   <li>Tracks user skill changes and updates the anti-ban settings accordingly.</li>
 *   <li>Supports attention span simulation, profile switching, and periodic breaks to ensure realistic play styles.</li>
 *   <li>Automatically enables the BreakHandlerPlugin when needed for managing breaks.</li>
 * </ul>
 *
 * <h3>Usage:</h3>
 * <p>
 * The <code>AntibanPlugin</code> works silently in the background to adjust the bot's behavior during runtime.
 * Users do not need to manually interact with this plugin, as it is automatically integrated into the bot framework.
 * </p>
 *
 * <p>
 * The plugin monitors in-game actions, such as cooking, mining, and skill changes, to adjust its anti-ban strategy
 * accordingly. It also manages the simulation of breaks, cooldowns, and play style variations to mimic human behavior
 * and avoid detection.
 * </p>
 *
 * <h3>Additional Details:</h3>
 * <ul>
 *   <li>Automatic tracking of idle time to determine if the bot should take a break.</li>
 *   <li>Real-time updates to anti-ban settings based on player activities and game state changes.</li>
 *   <li>Hidden from the user interface to avoid unnecessary distractions, while always being active in the background.</li>
 * </ul>
 */
@PluginDescriptor(
        name = PluginDescriptor.See1Duck + "Antiban",
        description = "Antiban for microbot",
        tags = {"main", "microbot", "antiban parent"},
        alwaysOn = true,
        hidden = true
)
public class AntibanPlugin extends Plugin {
    private static final int COOK_TIMEOUT = 3;
    private static final int MINING_TIMEOUT = 3;
    private static final int IDLE_TIMEOUT = 1;
    public static int ticksSinceLogin;
    private static Instant lastCookingAction = Instant.MIN;
    private static Instant lastMiningAction = Instant.MIN;
    private static int idleTicks = 0;
    private final Map<Skill, Integer> skillExp = new EnumMap<>(Skill.class);
    private boolean ready;
    private Skill lastSkillChanged;
    private NavigationButton navButton;
    @Inject
    private OverlayManager overlayManager;
    @Inject
    private ClientToolbar clientToolbar;
    public static boolean isCooking() {
        return Rs2Player.getAnimation() == AnimationID.COOKING_FIRE
                || Rs2Player.getAnimation() == AnimationID.COOKING_RANGE
                || Duration.between(lastCookingAction, Instant.now()).getSeconds() < COOK_TIMEOUT;
    }
    public static boolean isMining() {
        return Rs2Antiban.isMining()
                || Duration.between(lastMiningAction, Instant.now()).getSeconds() < MINING_TIMEOUT;
    }
    public static boolean isIdle() {
        return idleTicks > IDLE_TIMEOUT;
    }
    private static void updateIdleTicks() {
        idleTicks++;
    }
    private static void updateLastCookingAction() {
        lastCookingAction = Instant.now();
    }
    private static void updateLastMiningAction() {
        lastMiningAction = Instant.now();
    }
    public static void performActionBreak() {
        if (Rs2AntibanSettings.actionCooldownActive) {
            if (Rs2Antiban.getTIMEOUT() > 0) {
                if (!Rs2Antiban.getCategory().isBusy()) {
                    Rs2Antiban.TIMEOUT--;
                }
            } else {
                Rs2AntibanSettings.actionCooldownActive = false;
                if (Rs2AntibanSettings.universalAntiban && !Rs2AntibanSettings.microBreakActive)
                    Microbot.pauseAllScripts = false;
            }
        }
    }
    @Override
    protected void startUp() throws AWTException {
        final MasterPanel panel = injector.getInstance(MasterPanel.class);
        final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "antiban.png");
        navButton = NavigationButton.builder()
                .tooltip("Antiban")
                .icon(icon)
                .priority(1)
                .panel(panel)
                .build();
        Timer timer = new Timer();
        timer.scheduleAtFixedRate(new TimerTask() {
            @Override
            public void run() {
                SwingUtilities.invokeLater(panel::loadSettings);
            }
        }, 0, 600);
        clientToolbar.addNavigation(navButton);
        overlayManager.add(new AntibanOverlay());
    }
    @Override
    protected void shutDown() {
        overlayManager.removeIf(overlay -> overlay instanceof AntibanOverlay);
        clientToolbar.removeNavigation(navButton);
    }
    @Subscribe
    public void onChatMessage(ChatMessage event) {
        if (Rs2Antiban.checkForCookingEvent(event)) {
            updateLastCookingAction();
        }
    }
    @Subscribe
    public void onProfileChanged(ProfileChanged event) {
        Rs2Antiban.resetAntibanSettings();
    }
    @Subscribe
    public void onGameStateChanged(GameStateChanged event) {
        GameState state = event.getGameState();
        switch (state) {
            case LOGGING_IN:
            case HOPPING:
                ready = true;
                break;
            case LOGGED_IN:
                if (ready) {
                    ticksSinceLogin = 0;
                    ready = false;
                }
                break;
        }
    }
    // method to check if we have been idle for too long, indicating some issue with the script, use this to reset or reinitialize your script
    public static boolean isIdleTooLong(int timeout) {
        return idleTicks > timeout && !Rs2AntibanSettings.actionCooldownActive && !Rs2AntibanSettings.takeMicroBreaks;
    }
    @Subscribe
    public void onGameTick(GameTick event) {
        ticksSinceLogin++;
        if (!Rs2AntibanSettings.antibanEnabled) {
            return;
        }
        if (!Rs2Player.isAnimating()) {
            updateIdleTicks();
        } else {
            if (Rs2AntibanSettings.simulateFatigue) {
                ticksSinceLogin -= idleTicks;
            }
            idleTicks = 0;
        }
        if (Rs2AntibanSettings.takeMicroBreaks && !Microbot.isPluginEnabled(BreakHandlerPlugin.class)) {
            if (Rs2AntibanSettings.devDebug)
                Microbot.showMessage("Micro breaks depend on the BreakHandlerPlugin, enabling it now.");
            Microbot.log("BreakHandlerPlugin not enabled, enabling it now.");
            String name = BreakHandlerPlugin.class.getName();
            Plugin breakHandlerPlugin = Microbot.getPluginManager().getPlugins().stream()
                    .filter(x -> x.getClass().getName().equals(name))
                    .findFirst()
                    .orElse(null);
            Microbot.startPlugin(breakHandlerPlugin);
        }
        if (Rs2Antiban.isMining()) {
            updateLastMiningAction();
        }
        if (Rs2AntibanSettings.actionCooldownActive) {
            performActionBreak();
        }
        if (Rs2AntibanSettings.usePlayStyle) {
            if (Rs2Antiban.getPlayStyle() == null)
                return;
            if (Rs2AntibanSettings.simulateAttentionSpan && Rs2AntibanSettings.profileSwitching &&
                    Rs2Antiban.getPlayStyle().shouldSwitchProfileBasedOnAttention()) {
                Rs2Antiban.setPlayStyle(Rs2Antiban.getPlayStyle().switchProfile());
                Rs2Antiban.getPlayStyle().resetPlayStyle();
            }
        }
    }
    @Subscribe
    public void onStatChanged(StatChanged statChanged) {
        if (!Rs2AntibanSettings.antibanEnabled) {
            return;
        }
        final Skill skill = statChanged.getSkill();
        final int exp = statChanged.getXp();
        final Integer previous = skillExp.put(skill, exp);
        if (lastSkillChanged != null && (lastSkillChanged.equals(skill) || (CombatSkills.isCombatSkill(lastSkillChanged) && CombatSkills.isCombatSkill(skill)))) {
            if (Rs2AntibanSettings.universalAntiban && !Rs2AntibanSettings.actionCooldownActive && Rs2Antiban.getActivity() != null) {
                Rs2Antiban.actionCooldown();
                Rs2Antiban.takeMicroBreakByChance();
            }
            if (Rs2Antiban.getActivity() == null)
                updateAntibanSettings(skill);
            return;
        }
        lastSkillChanged = skill;
        if (previous == null || previous >= exp) {
            return;
        }
        updateAntibanSettings(skill);
    }
    private void updateAntibanSettings(Skill skill) {
        final ActivityIntensity activityIntensity = ActivityIntensity.fromSkill(skill);
        final Activity activity = Activity.fromSkill(skill);
        if (activity != null && Rs2AntibanSettings.dynamicActivity) {
            Rs2Antiban.setActivity(activity);
            Microbot.log("Activity changed, new activity: " + activity);
            if (Rs2AntibanSettings.universalAntiban) {
                Rs2Antiban.actionCooldown();
                Rs2Antiban.takeMicroBreakByChance();
            }
        }
        if (activityIntensity != null && Rs2AntibanSettings.dynamicIntensity) {
            Rs2Antiban.setActivityIntensity(activityIntensity);
            Microbot.log("Activity changed, new activity intensity: " + activityIntensity);
        }
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/antiban/AntibanSetupTemplates.java
================
package net.runelite.client.plugins.microbot.util.antiban;
import net.runelite.client.plugins.microbot.util.antiban.enums.Activity;
/**
 * The {@code AntibanSetupTemplates} class provides predefined antiban setup configurations tailored to specific
 * in-game activities. These configurations are designed to mimic human-like behaviors such as fatigue simulation,
 * attention span, and behavioral variability, with the goal of reducing detection risks by anti-cheat systems.
 *
 * <p>
 * Each method in this class corresponds to a specific activity (e.g., combat, runecrafting, construction) and
 * adjusts various settings to create a more realistic and undetectable experience for the bot.
 * These setups adjust mouse movement patterns, simulate breaks, introduce variability, and more.
 * </p>
 *
 * <h3>Main Features:</h3>
 * <ul>
 *   <li>Activity-Specific Setups: Methods are provided to apply antiban configurations for a wide range of activities,
 *       including skilling, combat, and more specialized tasks like runecrafting and herblore.</li>
 *   <li>Human-Like Behavior Simulation: The setups simulate human-like behaviors to avoid detection, including fatigue,
 *       attention span, micro breaks, mouse movement patterns, and random intervals.</li>
 *   <li>Flexible Configurations: Each setup method customizes settings such as action cooldowns, behavioral variability,
 *       and micro breaks to tailor the antiban behavior to the specific activity.</li>
 *   <li>Basic Setup: A general setup method is included for cases where simpler antiban measures are needed without
 *       advanced features like attention span or micro breaks.</li>
 * </ul>
 *
 * <h3>Usage:</h3>
 * <p>
 * These methods are intended to be called before executing specific game activities to ensure that the antiban measures
 * are properly configured for the task. The configurations can be adjusted to suit different activities or playstyles
 * by enabling or disabling certain features like profile switching or dynamic intensity.
 * </p>
 *
 * <h3>Example:</h3>
 * <p>Inside your plugin script class, execute the initialization outside the main loop.</p>
 * <pre>
 * private void initialize() {
 *         Rs2Antiban.antibanSetupTemplates.applyMiningSetup();
 *     }
 * </pre>
 *
 * <h3>Available Setup Methods:</h3>
 * <ul>
 *   <li><code>applyCombatSetup()</code>: Configures antiban settings for combat activities.</li>
 *   <li><code>applyRunecraftingSetup()</code>: Configures antiban settings for runecrafting activities.</li>
 *   <li><code>applyConstructionSetup()</code>: Configures antiban settings for construction activities.</li>
 *   <li><code>applyAgilitySetup()</code>: Configures antiban settings for agility tasks.</li>
 *   <li><code>applyHerbloreSetup()</code>: Configures antiban settings for herblore tasks.</li>
 *   <li><code>applyThievingSetup()</code>: Configures antiban settings for thieving tasks.</li>
 *   <li><code>applyCraftingSetup()</code>: Configures antiban settings for crafting tasks.</li>
 *   <li><code>applyFletchingSetup()</code>: Configures antiban settings for fletching tasks.</li>
 *   <li><code>applyHunterSetup()</code>: Configures antiban settings for hunter tasks.</li>
 *   <li><code>applyMiningSetup()</code>: Configures antiban settings for mining tasks.</li>
 *   <li><code>applySmithingSetup()</code>: Configures antiban settings for smithing tasks.</li>
 *   <li><code>applyFishingSetup()</code>: Configures antiban settings for fishing tasks.</li>
 *   <li><code>applyCookingSetup()</code>: Configures antiban settings for cooking tasks.</li>
 *   <li><code>applyFiremakingSetup()</code>: Configures antiban settings for firemaking tasks.</li>
 *   <li><code>applyWoodcuttingSetup()</code>: Configures antiban settings for woodcutting tasks.</li>
 *   <li><code>applyFarmingSetup()</code>: Configures antiban settings for farming tasks.</li>
 *   <li><code>applyGeneralBasicSetup()</code>: Applies a basic antiban configuration without advanced features.</li>
 * </ul>
 */
public class AntibanSetupTemplates {
    /**
     * Applies the antiban setup tailored for general combat activities.
     * This setup enables various human-like behaviors such as fatigue simulation, attention span,
     * and mouse movement variability to reduce detection risk.
     */
    public void applyCombatSetup() {
        Rs2AntibanSettings.antibanEnabled = true;
        Rs2AntibanSettings.usePlayStyle = true;
        Rs2AntibanSettings.randomIntervals = false;
        Rs2AntibanSettings.simulateFatigue = true;
        Rs2AntibanSettings.simulateAttentionSpan = true;
        Rs2AntibanSettings.behavioralVariability = true;
        Rs2AntibanSettings.nonLinearIntervals = true;
        Rs2AntibanSettings.profileSwitching = true;
        Rs2AntibanSettings.timeOfDayAdjust = false;
        Rs2AntibanSettings.simulateMistakes = false;
        Rs2AntibanSettings.naturalMouse = true;
        Rs2AntibanSettings.contextualVariability = true;
        Rs2AntibanSettings.dynamicIntensity = false;
        Rs2AntibanSettings.dynamicActivity = false;
        Rs2AntibanSettings.devDebug = false;
        Rs2AntibanSettings.takeMicroBreaks = true;
        Rs2AntibanSettings.playSchedule = true;
        Rs2AntibanSettings.universalAntiban = false;
        Rs2AntibanSettings.microBreakDurationLow = 3;
        Rs2AntibanSettings.microBreakDurationHigh = 8;
        Rs2AntibanSettings.actionCooldownChance = 1.00;
        Rs2AntibanSettings.microBreakChance = 0.05;
        Rs2Antiban.setActivity(Activity.GENERAL_COMBAT);
    }
    /**
     * Applies the antiban setup tailored for runecrafting activities.
     * This setup adjusts settings to simulate human-like behaviors during runecrafting tasks.
     */
    public void applyRunecraftingSetup() {
        // Implementation for Runecrafting setup
        Rs2AntibanSettings.antibanEnabled = true;
        Rs2AntibanSettings.usePlayStyle = true;
        Rs2AntibanSettings.randomIntervals = false;
        Rs2AntibanSettings.simulateFatigue = true;
        Rs2AntibanSettings.simulateAttentionSpan = true;
        Rs2AntibanSettings.behavioralVariability = true;
        Rs2AntibanSettings.nonLinearIntervals = true;
        Rs2AntibanSettings.profileSwitching = true;
        Rs2AntibanSettings.timeOfDayAdjust = false;
        Rs2AntibanSettings.simulateMistakes = false;
        Rs2AntibanSettings.naturalMouse = true;
        Rs2AntibanSettings.contextualVariability = true;
        Rs2AntibanSettings.dynamicIntensity = false;
        Rs2AntibanSettings.dynamicActivity = false;
        Rs2AntibanSettings.devDebug = false;
        Rs2AntibanSettings.takeMicroBreaks = true;
        Rs2AntibanSettings.playSchedule = true;
        Rs2AntibanSettings.universalAntiban = false;
        Rs2AntibanSettings.microBreakDurationLow = 3;
        Rs2AntibanSettings.microBreakDurationHigh = 8;
        Rs2AntibanSettings.actionCooldownChance = 1.00;
        Rs2AntibanSettings.microBreakChance = 0.05;
        Rs2Antiban.setActivity(Activity.GENERAL_RUNECRAFT);
    }
    /**
     * Applies the antiban setup tailored for construction activities.
     * This setup focuses on mimicking human-like behaviors during construction tasks.
     */
    public void applyConstructionSetup() {
        // Implementation for Construction setup
        Rs2AntibanSettings.antibanEnabled = true;
        Rs2AntibanSettings.usePlayStyle = true;
        Rs2AntibanSettings.randomIntervals = false;
        Rs2AntibanSettings.simulateFatigue = true;
        Rs2AntibanSettings.simulateAttentionSpan = true;
        Rs2AntibanSettings.behavioralVariability = true;
        Rs2AntibanSettings.nonLinearIntervals = true;
        Rs2AntibanSettings.profileSwitching = true;
        Rs2AntibanSettings.timeOfDayAdjust = false;
        Rs2AntibanSettings.simulateMistakes = false;
        Rs2AntibanSettings.naturalMouse = true;
        Rs2AntibanSettings.contextualVariability = true;
        Rs2AntibanSettings.dynamicIntensity = false;
        Rs2AntibanSettings.dynamicActivity = false;
        Rs2AntibanSettings.devDebug = false;
        Rs2AntibanSettings.takeMicroBreaks = true;
        Rs2AntibanSettings.playSchedule = true;
        Rs2AntibanSettings.universalAntiban = false;
        Rs2AntibanSettings.microBreakDurationLow = 3;
        Rs2AntibanSettings.microBreakDurationHigh = 8;
        Rs2AntibanSettings.actionCooldownChance = 1.00;
        Rs2AntibanSettings.microBreakChance = 0.05;
        Rs2Antiban.setActivity(Activity.GENERAL_CONSTRUCTION);
    }
    /**
     * Applies the antiban setup tailored for agility activities.
     * This setup includes adjustments to simulate human-like behaviors during agility tasks.
     */
    public void applyAgilitySetup() {
        // Implementation for Agility setup
        Rs2AntibanSettings.antibanEnabled = true;
        Rs2AntibanSettings.usePlayStyle = true;
        Rs2AntibanSettings.randomIntervals = false;
        Rs2AntibanSettings.simulateFatigue = true;
        Rs2AntibanSettings.simulateAttentionSpan = true;
        Rs2AntibanSettings.behavioralVariability = true;
        Rs2AntibanSettings.nonLinearIntervals = true;
        Rs2AntibanSettings.profileSwitching = true;
        Rs2AntibanSettings.timeOfDayAdjust = false;
        Rs2AntibanSettings.simulateMistakes = false;
        Rs2AntibanSettings.naturalMouse = true;
        Rs2AntibanSettings.contextualVariability = true;
        Rs2AntibanSettings.dynamicIntensity = false;
        Rs2AntibanSettings.dynamicActivity = false;
        Rs2AntibanSettings.devDebug = false;
        Rs2AntibanSettings.takeMicroBreaks = true;
        Rs2AntibanSettings.playSchedule = true;
        Rs2AntibanSettings.universalAntiban = false;
        Rs2AntibanSettings.microBreakDurationLow = 3;
        Rs2AntibanSettings.microBreakDurationHigh = 8;
        Rs2AntibanSettings.actionCooldownChance = 1.00;
        Rs2AntibanSettings.microBreakChance = 0.05;
        Rs2Antiban.setActivity(Activity.GENERAL_AGILITY);
    }
    /**
     * Applies the antiban setup tailored for herblore activities.
     * This setup configures settings to mimic human-like behaviors during herblore tasks.
     */
    public void applyHerbloreSetup() {
        // Implementation for Herblore setup
        Rs2AntibanSettings.antibanEnabled = true;
        Rs2AntibanSettings.usePlayStyle = true;
        Rs2AntibanSettings.randomIntervals = false;
        Rs2AntibanSettings.simulateFatigue = true;
        Rs2AntibanSettings.simulateAttentionSpan = true;
        Rs2AntibanSettings.behavioralVariability = true;
        Rs2AntibanSettings.nonLinearIntervals = true;
        Rs2AntibanSettings.profileSwitching = true;
        Rs2AntibanSettings.timeOfDayAdjust = false;
        Rs2AntibanSettings.simulateMistakes = false;
        Rs2AntibanSettings.naturalMouse = true;
        Rs2AntibanSettings.contextualVariability = true;
        Rs2AntibanSettings.dynamicIntensity = false;
        Rs2AntibanSettings.dynamicActivity = false;
        Rs2AntibanSettings.devDebug = false;
        Rs2AntibanSettings.takeMicroBreaks = true;
        Rs2AntibanSettings.playSchedule = true;
        Rs2AntibanSettings.universalAntiban = false;
        Rs2AntibanSettings.microBreakDurationLow = 3;
        Rs2AntibanSettings.microBreakDurationHigh = 8;
        Rs2AntibanSettings.actionCooldownChance = 1.00;
        Rs2AntibanSettings.microBreakChance = 0.05;
        Rs2Antiban.setActivity(Activity.GENERAL_HERBLORE);
    }
    /**
     * Applies the antiban setup tailored for thieving activities.
     * This setup simulates human-like behaviors during thieving tasks to reduce detection risk.
     */
    public void applyThievingSetup() {
        // Implementation for Thieving setup
        Rs2AntibanSettings.antibanEnabled = true;
        Rs2AntibanSettings.usePlayStyle = true;
        Rs2AntibanSettings.randomIntervals = false;
        Rs2AntibanSettings.simulateFatigue = true;
        Rs2AntibanSettings.simulateAttentionSpan = true;
        Rs2AntibanSettings.behavioralVariability = true;
        Rs2AntibanSettings.nonLinearIntervals = true;
        Rs2AntibanSettings.profileSwitching = true;
        Rs2AntibanSettings.timeOfDayAdjust = false;
        Rs2AntibanSettings.simulateMistakes = false;
        Rs2AntibanSettings.naturalMouse = true;
        Rs2AntibanSettings.contextualVariability = true;
        Rs2AntibanSettings.dynamicIntensity = false;
        Rs2AntibanSettings.dynamicActivity = false;
        Rs2AntibanSettings.devDebug = false;
        Rs2AntibanSettings.takeMicroBreaks = true;
        Rs2AntibanSettings.playSchedule = true;
        Rs2AntibanSettings.universalAntiban = false;
        Rs2AntibanSettings.microBreakDurationLow = 3;
        Rs2AntibanSettings.microBreakDurationHigh = 8;
        Rs2AntibanSettings.actionCooldownChance = 1.00;
        Rs2AntibanSettings.microBreakChance = 0.05;
        Rs2Antiban.setActivity(Activity.GENERAL_THIEVING);
    }
    /**
     * Applies the antiban setup tailored for crafting activities.
     * This setup focuses on human-like behavior simulation during crafting tasks.
     */
    public void applyCraftingSetup() {
        // Implementation for Crafting setup
        Rs2AntibanSettings.antibanEnabled = true;
        Rs2AntibanSettings.usePlayStyle = true;
        Rs2AntibanSettings.randomIntervals = false;
        Rs2AntibanSettings.simulateFatigue = true;
        Rs2AntibanSettings.simulateAttentionSpan = true;
        Rs2AntibanSettings.behavioralVariability = true;
        Rs2AntibanSettings.nonLinearIntervals = true;
        Rs2AntibanSettings.profileSwitching = true;
        Rs2AntibanSettings.timeOfDayAdjust = false;
        Rs2AntibanSettings.simulateMistakes = false;
        Rs2AntibanSettings.naturalMouse = true;
        Rs2AntibanSettings.contextualVariability = true;
        Rs2AntibanSettings.dynamicIntensity = false;
        Rs2AntibanSettings.dynamicActivity = false;
        Rs2AntibanSettings.devDebug = false;
        Rs2AntibanSettings.takeMicroBreaks = true;
        Rs2AntibanSettings.playSchedule = true;
        Rs2AntibanSettings.universalAntiban = false;
        Rs2AntibanSettings.microBreakDurationLow = 3;
        Rs2AntibanSettings.microBreakDurationHigh = 8;
        Rs2AntibanSettings.actionCooldownChance = 1.00;
        Rs2AntibanSettings.microBreakChance = 0.05;
        Rs2Antiban.setActivity(Activity.GENERAL_CRAFTING);
    }
    /**
     * Applies the antiban setup tailored for fletching activities.
     * This setup adjusts settings to mimic human behavior during fletching tasks.
     */
    public void applyFletchingSetup() {
        // Implementation for Fletching setup
        Rs2AntibanSettings.antibanEnabled = true;
        Rs2AntibanSettings.usePlayStyle = true;
        Rs2AntibanSettings.randomIntervals = false;
        Rs2AntibanSettings.simulateFatigue = true;
        Rs2AntibanSettings.simulateAttentionSpan = true;
        Rs2AntibanSettings.behavioralVariability = true;
        Rs2AntibanSettings.nonLinearIntervals = true;
        Rs2AntibanSettings.profileSwitching = true;
        Rs2AntibanSettings.timeOfDayAdjust = false;
        Rs2AntibanSettings.simulateMistakes = false;
        Rs2AntibanSettings.naturalMouse = true;
        Rs2AntibanSettings.contextualVariability = true;
        Rs2AntibanSettings.dynamicIntensity = false;
        Rs2AntibanSettings.dynamicActivity = false;
        Rs2AntibanSettings.devDebug = false;
        Rs2AntibanSettings.takeMicroBreaks = true;
        Rs2AntibanSettings.playSchedule = true;
        Rs2AntibanSettings.universalAntiban = false;
        Rs2AntibanSettings.microBreakDurationLow = 3;
        Rs2AntibanSettings.microBreakDurationHigh = 8;
        Rs2AntibanSettings.actionCooldownChance = 1.00;
        Rs2AntibanSettings.microBreakChance = 0.05;
        Rs2Antiban.setActivity(Activity.GENERAL_FLETCHING);
    }
    public void applySlayerSetup() {
        // Implementation for Slayer setup
    }
    /**
     * Applies the antiban setup tailored for hunter activities.
     * This setup simulates human-like behaviors during hunting tasks.
     */
    public void applyHunterSetup() {
        // Implementation for Hunter setup
        Rs2AntibanSettings.antibanEnabled = true;
        Rs2AntibanSettings.usePlayStyle = true;
        Rs2AntibanSettings.randomIntervals = false;
        Rs2AntibanSettings.simulateFatigue = true;
        Rs2AntibanSettings.simulateAttentionSpan = true;
        Rs2AntibanSettings.behavioralVariability = true;
        Rs2AntibanSettings.nonLinearIntervals = true;
        Rs2AntibanSettings.profileSwitching = true;
        Rs2AntibanSettings.timeOfDayAdjust = false;
        Rs2AntibanSettings.simulateMistakes = false;
        Rs2AntibanSettings.naturalMouse = true;
        Rs2AntibanSettings.contextualVariability = true;
        Rs2AntibanSettings.dynamicIntensity = false;
        Rs2AntibanSettings.dynamicActivity = false;
        Rs2AntibanSettings.devDebug = false;
        Rs2AntibanSettings.takeMicroBreaks = true;
        Rs2AntibanSettings.playSchedule = true;
        Rs2AntibanSettings.universalAntiban = false;
        Rs2AntibanSettings.microBreakDurationLow = 3;
        Rs2AntibanSettings.microBreakDurationHigh = 8;
        Rs2AntibanSettings.actionCooldownChance = 1.00;
        Rs2AntibanSettings.microBreakChance = 0.05;
        Rs2Antiban.setActivity(Activity.GENERAL_HUNTER);
    }
    /**
     * Applies the antiban setup tailored for mining activities.
     * This setup includes adjustments to mimic human behaviors during mining tasks.
     */
    public void applyMiningSetup() {
        // Implementation for Mining setup
        Rs2AntibanSettings.antibanEnabled = true;
        Rs2AntibanSettings.usePlayStyle = true;
        Rs2AntibanSettings.randomIntervals = false;
        Rs2AntibanSettings.simulateFatigue = true;
        Rs2AntibanSettings.simulateAttentionSpan = true;
        Rs2AntibanSettings.behavioralVariability = true;
        Rs2AntibanSettings.nonLinearIntervals = true;
        Rs2AntibanSettings.profileSwitching = true;
        Rs2AntibanSettings.timeOfDayAdjust = false;
        Rs2AntibanSettings.simulateMistakes = true;
        Rs2AntibanSettings.naturalMouse = true;
        Rs2AntibanSettings.contextualVariability = false;
        Rs2AntibanSettings.dynamicIntensity = false;
        Rs2AntibanSettings.dynamicActivity = false;
        Rs2AntibanSettings.devDebug = false;
        Rs2AntibanSettings.takeMicroBreaks = true;
        Rs2AntibanSettings.playSchedule = true;
        Rs2AntibanSettings.universalAntiban = false;
        Rs2AntibanSettings.microBreakDurationLow = 1;
        Rs2AntibanSettings.microBreakDurationHigh = 4;
        Rs2AntibanSettings.actionCooldownChance = 1.00;
        Rs2AntibanSettings.microBreakChance = 0.05;
        Rs2Antiban.setActivity(Activity.GENERAL_MINING);
    }
    /**
     * Applies the antiban setup tailored for smithing activities.
     * This setup configures settings to simulate human-like behaviors during smithing tasks.
     */
    public void applySmithingSetup() {
        // Implementation for Smithing setup
        Rs2AntibanSettings.antibanEnabled = true;
        Rs2AntibanSettings.usePlayStyle = true;
        Rs2AntibanSettings.randomIntervals = false;
        Rs2AntibanSettings.simulateFatigue = true;
        Rs2AntibanSettings.simulateAttentionSpan = true;
        Rs2AntibanSettings.behavioralVariability = true;
        Rs2AntibanSettings.nonLinearIntervals = true;
        Rs2AntibanSettings.profileSwitching = true;
        Rs2AntibanSettings.timeOfDayAdjust = false;
        Rs2AntibanSettings.simulateMistakes = false;
        Rs2AntibanSettings.naturalMouse = true;
        Rs2AntibanSettings.contextualVariability = true;
        Rs2AntibanSettings.dynamicIntensity = false;
        Rs2AntibanSettings.dynamicActivity = false;
        Rs2AntibanSettings.devDebug = false;
        Rs2AntibanSettings.takeMicroBreaks = true;
        Rs2AntibanSettings.playSchedule = true;
        Rs2AntibanSettings.universalAntiban = false;
        Rs2AntibanSettings.microBreakDurationLow = 3;
        Rs2AntibanSettings.microBreakDurationHigh = 8;
        Rs2AntibanSettings.actionCooldownChance = 1.00;
        Rs2AntibanSettings.microBreakChance = 0.05;
        Rs2Antiban.setActivity(Activity.GENERAL_SMITHING);
    }
    /**
     * Applies the antiban setup tailored for fishing activities.
     * This setup focuses on mimicking human-like behaviors during fishing tasks.
     */
    public void applyFishingSetup() {
        // Implementation for Fishing setup
        Rs2AntibanSettings.antibanEnabled = true;
        Rs2AntibanSettings.usePlayStyle = true;
        Rs2AntibanSettings.randomIntervals = false;
        Rs2AntibanSettings.simulateFatigue = true;
        Rs2AntibanSettings.simulateAttentionSpan = true;
        Rs2AntibanSettings.behavioralVariability = true;
        Rs2AntibanSettings.nonLinearIntervals = true;
        Rs2AntibanSettings.profileSwitching = true;
        Rs2AntibanSettings.timeOfDayAdjust = false;
        Rs2AntibanSettings.simulateMistakes = false;
        Rs2AntibanSettings.naturalMouse = true;
        Rs2AntibanSettings.contextualVariability = true;
        Rs2AntibanSettings.dynamicIntensity = false;
        Rs2AntibanSettings.dynamicActivity = false;
        Rs2AntibanSettings.devDebug = false;
        Rs2AntibanSettings.takeMicroBreaks = true;
        Rs2AntibanSettings.playSchedule = true;
        Rs2AntibanSettings.universalAntiban = false;
        Rs2AntibanSettings.microBreakDurationLow = 3;
        Rs2AntibanSettings.microBreakDurationHigh = 8;
        Rs2AntibanSettings.actionCooldownChance = 1.00;
        Rs2AntibanSettings.microBreakChance = 0.05;
        Rs2Antiban.setActivity(Activity.GENERAL_FISHING);
    }
    /**
     * Applies the antiban setup tailored for cooking activities.
     * This setup simulates human-like behaviors during cooking tasks to reduce detection risk.
     */
    public void applyCookingSetup() {
        // Implementation for Cooking setup
        Rs2AntibanSettings.antibanEnabled = true;
        Rs2AntibanSettings.usePlayStyle = true;
        Rs2AntibanSettings.randomIntervals = false;
        Rs2AntibanSettings.simulateFatigue = true;
        Rs2AntibanSettings.simulateAttentionSpan = true;
        Rs2AntibanSettings.behavioralVariability = true;
        Rs2AntibanSettings.nonLinearIntervals = true;
        Rs2AntibanSettings.profileSwitching = true;
        Rs2AntibanSettings.timeOfDayAdjust = false;
        Rs2AntibanSettings.simulateMistakes = false;
        Rs2AntibanSettings.naturalMouse = true;
        Rs2AntibanSettings.contextualVariability = true;
        Rs2AntibanSettings.dynamicIntensity = false;
        Rs2AntibanSettings.dynamicActivity = false;
        Rs2AntibanSettings.devDebug = false;
        Rs2AntibanSettings.takeMicroBreaks = true;
        Rs2AntibanSettings.playSchedule = true;
        Rs2AntibanSettings.universalAntiban = false;
        Rs2AntibanSettings.microBreakDurationLow = 3;
        Rs2AntibanSettings.microBreakDurationHigh = 8;
        Rs2AntibanSettings.actionCooldownChance = 1.00;
        Rs2AntibanSettings.microBreakChance = 0.05;
        Rs2Antiban.setActivity(Activity.GENERAL_COOKING);
    }
    /**
     * Applies the antiban setup tailored for firemaking activities.
     * This setup is designed to simulate human behavior during firemaking tasks.
     */
    public void applyFiremakingSetup() {
        // Implementation for Firemaking setup
        Rs2AntibanSettings.antibanEnabled = true;
        Rs2AntibanSettings.usePlayStyle = true;
        Rs2AntibanSettings.randomIntervals = false;
        Rs2AntibanSettings.simulateFatigue = true;
        Rs2AntibanSettings.simulateAttentionSpan = true;
        Rs2AntibanSettings.behavioralVariability = true;
        Rs2AntibanSettings.nonLinearIntervals = true;
        Rs2AntibanSettings.profileSwitching = true;
        Rs2AntibanSettings.timeOfDayAdjust = false;
        Rs2AntibanSettings.simulateMistakes = false;
        Rs2AntibanSettings.naturalMouse = true;
        Rs2AntibanSettings.contextualVariability = true;
        Rs2AntibanSettings.dynamicIntensity = false;
        Rs2AntibanSettings.dynamicActivity = false;
        Rs2AntibanSettings.devDebug = false;
        Rs2AntibanSettings.takeMicroBreaks = true;
        Rs2AntibanSettings.playSchedule = true;
        Rs2AntibanSettings.universalAntiban = false;
        Rs2AntibanSettings.microBreakDurationLow = 3;
        Rs2AntibanSettings.microBreakDurationHigh = 8;
        Rs2AntibanSettings.actionCooldownChance = 1.00;
        Rs2AntibanSettings.microBreakChance = 0.05;
        Rs2Antiban.setActivity(Activity.GENERAL_FIREMAKING);
    }
    /**
     * Applies the antiban setup tailored for woodcutting activities.
     * This setup mimics human-like behaviors during woodcutting tasks to reduce detection risk.
     */
    public void applyWoodcuttingSetup() {
        // Implementation for Woodcutting setup
        Rs2AntibanSettings.antibanEnabled = true;
        Rs2AntibanSettings.usePlayStyle = true;
        Rs2AntibanSettings.randomIntervals = false;
        Rs2AntibanSettings.simulateFatigue = true;
        Rs2AntibanSettings.simulateAttentionSpan = true;
        Rs2AntibanSettings.behavioralVariability = true;
        Rs2AntibanSettings.nonLinearIntervals = true;
        Rs2AntibanSettings.profileSwitching = true;
        Rs2AntibanSettings.timeOfDayAdjust = false;
        Rs2AntibanSettings.simulateMistakes = false;
        Rs2AntibanSettings.naturalMouse = true;
        Rs2AntibanSettings.contextualVariability = true;
        Rs2AntibanSettings.dynamicIntensity = false;
        Rs2AntibanSettings.dynamicActivity = false;
        Rs2AntibanSettings.devDebug = false;
        Rs2AntibanSettings.takeMicroBreaks = true;
        Rs2AntibanSettings.playSchedule = true;
        Rs2AntibanSettings.universalAntiban = false;
        Rs2AntibanSettings.microBreakDurationLow = 3;
        Rs2AntibanSettings.microBreakDurationHigh = 8;
        Rs2AntibanSettings.actionCooldownChance = 1.00;
        Rs2AntibanSettings.microBreakChance = 0.05;
        Rs2Antiban.setActivity(Activity.GENERAL_WOODCUTTING);
    }
    /**
     * Applies the antiban setup tailored for farming activities.
     * This setup configures settings to simulate human-like behaviors during farming tasks.
     */
    public void applyFarmingSetup() {
        // Implementation for Farming setup
        Rs2AntibanSettings.antibanEnabled = true;
        Rs2AntibanSettings.usePlayStyle = true;
        Rs2AntibanSettings.randomIntervals = false;
        Rs2AntibanSettings.simulateFatigue = true;
        Rs2AntibanSettings.simulateAttentionSpan = true;
        Rs2AntibanSettings.behavioralVariability = true;
        Rs2AntibanSettings.nonLinearIntervals = true;
        Rs2AntibanSettings.profileSwitching = true;
        Rs2AntibanSettings.timeOfDayAdjust = false;
        Rs2AntibanSettings.simulateMistakes = false;
        Rs2AntibanSettings.naturalMouse = true;
        Rs2AntibanSettings.contextualVariability = false;
        Rs2AntibanSettings.dynamicIntensity = false;
        Rs2AntibanSettings.dynamicActivity = false;
        Rs2AntibanSettings.devDebug = false;
        Rs2AntibanSettings.takeMicroBreaks = true;
        Rs2AntibanSettings.playSchedule = true;
        Rs2AntibanSettings.universalAntiban = false;
        Rs2AntibanSettings.microBreakDurationLow = 3;
        Rs2AntibanSettings.microBreakDurationHigh = 8;
        Rs2AntibanSettings.actionCooldownChance = 1.00;
        Rs2AntibanSettings.microBreakChance = 0.05;
        Rs2Antiban.setActivity(Activity.GENERAL_FARMING);
    }
    /**
     * Applies the basic antiban setup.
     * This setup configures settings to simulate human-like mouse movement and reduce detection risk.
     * This setup does not include advanced features such as action cooldown, attention span or micro breaks.
     */
    public void applyGeneralBasicSetup() {
        // Implementation for General Basic setup
        Rs2AntibanSettings.antibanEnabled = true;
        Rs2AntibanSettings.usePlayStyle = false;
        Rs2AntibanSettings.randomIntervals = false;
        Rs2AntibanSettings.simulateFatigue = true;
        Rs2AntibanSettings.simulateAttentionSpan = false;
        Rs2AntibanSettings.behavioralVariability = false;
        Rs2AntibanSettings.nonLinearIntervals = false;
        Rs2AntibanSettings.profileSwitching = false;
        Rs2AntibanSettings.timeOfDayAdjust = false;
        Rs2AntibanSettings.simulateMistakes = true;
        Rs2AntibanSettings.naturalMouse = true;
        Rs2AntibanSettings.contextualVariability = false;
        Rs2AntibanSettings.dynamicIntensity = false;
        Rs2AntibanSettings.dynamicActivity = false;
        Rs2AntibanSettings.devDebug = false;
        Rs2AntibanSettings.takeMicroBreaks = false;
        Rs2AntibanSettings.playSchedule = false;
        Rs2AntibanSettings.universalAntiban = false;
        Rs2AntibanSettings.microBreakDurationLow = 3;
        Rs2AntibanSettings.microBreakDurationHigh = 8;
        Rs2AntibanSettings.actionCooldownChance = 1.00;
        Rs2AntibanSettings.microBreakChance = 0.05;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/antiban/FieldUtil.java
================
package net.runelite.client.plugins.microbot.util.antiban;
import sun.misc.Unsafe;
import java.lang.reflect.Field;
public class FieldUtil {
    private static Unsafe unsafe;
    static {
        try {
            final Field unsafeField = Unsafe.class.getDeclaredField("theUnsafe");
            unsafeField.setAccessible(true);
            unsafe = (Unsafe) unsafeField.get(null);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
    public static void setFinalStatic(Field field, Object value) throws Exception {
        Object fieldBase = unsafe.staticFieldBase(field);
        long fieldOffset = unsafe.staticFieldOffset(field);
        unsafe.putObject(fieldBase, fieldOffset, value);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/antiban/MouseFatigue.java
================
package net.runelite.client.plugins.microbot.util.antiban;
import java.util.Random;
public class MouseFatigue {
    private final Random random = new Random();
    public double increaseRate = 0.005;
    public double noiseAmplitude = 5.0;
    // Method to calculate the base time with noise
    public int calculateBaseTimeWithNoise(int initialBaseTimeMs, int maxBaseTimeMs) {
        double noise = random.nextGaussian() * noiseAmplitude;
        int newBaseTimeMs = (int) (initialBaseTimeMs + AntibanPlugin.ticksSinceLogin * increaseRate + noise);
        return Math.min(newBaseTimeMs, maxBaseTimeMs);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/antiban/Rs2Antiban.java
================
package net.runelite.client.plugins.microbot.util.antiban;
import com.google.common.collect.ImmutableSet;
import lombok.Getter;
import lombok.Setter;
import net.runelite.api.ChatMessageType;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.breakhandler.BreakHandlerScript;
import net.runelite.client.plugins.microbot.util.antiban.enums.Activity;
import net.runelite.client.plugins.microbot.util.antiban.enums.ActivityIntensity;
import net.runelite.client.plugins.microbot.util.antiban.enums.Category;
import net.runelite.client.plugins.microbot.util.antiban.enums.PlayStyle;
import net.runelite.client.plugins.microbot.util.math.Random;
import net.runelite.client.plugins.microbot.util.math.Rs2Random;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.ui.overlay.components.*;
import net.runelite.client.util.ColorUtil;
import org.jetbrains.annotations.NotNull;
import java.awt.*;
import java.util.Set;
import static net.runelite.api.AnimationID.*;
/**
 * The {@code Rs2Antiban} class provides a comprehensive anti-ban system that simulates human-like behavior
 * during various in-game activities. This system includes features such as mouse fatigue, random intervals,
 * micro-breaks, action cooldowns, and contextually aware mouse movements, all aimed at reducing the risk
 * of detection by anti-cheat systems.
 *
 * <p>
 * The class uses configurations set in {@code Rs2AntibanSettings} to determine the behavior of the bot
 * during activities like woodcutting, mining, cooking, and more. It leverages various methods to simulate
 * natural player behaviors, such as random mouse movements and taking breaks. It also integrates with
 * specific activity configurations like play style, activity intensity, and categories, which are adjusted
 * based on the activity being performed.
 * </p>
 *
 * <h3>Main Features:</h3>
 * <ul>
 *   <li>Human-Like Behavior Simulation: Simulates actions such as moving the mouse randomly, taking micro-breaks,
 *       and varying the intervals between actions to mimic natural gameplay.</li>
 *   <li>Activity-Based Configurations: Allows setting activity-specific antiban configurations through
 *       the {@code setActivity()} and {@code setActivityIntensity()} methods, ensuring that the antiban
 *       behavior is appropriate for the current task.</li>
 *   <li>Mouse Fatigue Simulation: Integrates with a mouse fatigue system to simulate the effects of fatigue
 *       on mouse movement over time.</li>
 *   <li>Overlay Rendering: Provides methods to render an overlay that displays current antiban status,
 *       including activity, play style, and action cooldown progress.</li>
 *   <li>Micro-Breaks and Cooldowns: Supports taking breaks based on a random chance or specific intervals
 *       to simulate a player taking short pauses during gameplay.</li>
 * </ul>
 *
 * <h3>Usage:</h3>
 * <p>
 * The methods provided in this class are designed to be called during in-game activities to ensure the antiban
 * system is engaged and functioning according to the activity being performed. The configurations can be customized
 * through {@code Rs2AntibanSettings} to adjust behaviors such as action cooldowns, break chances, and mouse movements.
 * </p>
 *
 * <h3>Example:</h3>
 * <pre>
 * // Setting the antiban activity to woodcutting
 * Rs2Antiban.setActivity(Activity.GENERAL_WOODCUTTING);
 *
 * // Triggering an action cooldown based on current settings
 * Rs2Antiban.actionCooldown();
 *
 * // Rendering the antiban overlay in a panel
 * Rs2Antiban.renderAntibanOverlayComponents(panelComponent);
 * </pre>
 *
 * <h3>Available Methods:</h3>
 * <ul>
 *   <li><code>setActivity(Activity activity)</code>: Sets the current activity and adjusts antiban settings based on the activity type.</li>
 *   <li><code>setActivityIntensity(ActivityIntensity intensity)</code>: Sets the intensity level of the current activity.</li>
 *   <li><code>actionCooldown()</code>: Triggers an action cooldown, potentially adjusting play style and performing random mouse movements.</li>
 *   <li><code>takeMicroBreakByChance()</code>: Attempts to trigger a micro-break based on a random chance.</li>
 *   <li><code>isWoodcutting()</code>: Checks if the player is currently performing a woodcutting animation.</li>
 *   <li><code>isMining()</code>: Checks if the player is currently performing a mining animation.</li>
 *   <li><code>isIdle()</code>: Checks if the player is currently idle (not performing any animation).</li>
 *   <li><code>renderAntibanOverlayComponents(PanelComponent panelComponent)</code>: Renders an overlay showing the current antiban status and action cooldown progress.</li>
 *   <li><code>moveMouseOffScreen()</code>: Moves the mouse off-screen to simulate taking a break.</li>
 *   <li><code>moveMouseRandomly()</code>: Moves the mouse randomly to simulate natural behavior during gameplay.</li>
 *   <li><code>activateAntiban()</code>: Activates the antiban system.</li>
 *   <li><code>deactivateAntiban()</code>: Deactivates the antiban system.</li>
 *   <li><code>resetAntibanSettings()</code>: Resets all antiban settings to their default values.</li>
 * </ul>
 */
@Getter
@Setter
public class Rs2Antiban {
    public static final ImmutableSet<Integer> MINING_ANIMATION_IDS = ImmutableSet.of(
            MINING_BRONZE_PICKAXE, MINING_MOTHERLODE_BRONZE, MINING_CRASHEDSTAR_BRONZE,
            MINING_IRON_PICKAXE, MINING_MOTHERLODE_IRON, MINING_CRASHEDSTAR_IRON,
            MINING_STEEL_PICKAXE, MINING_MOTHERLODE_STEEL, MINING_CRASHEDSTAR_STEEL,
            MINING_BLACK_PICKAXE, MINING_MOTHERLODE_BLACK, MINING_CRASHEDSTAR_BLACK,
            MINING_MITHRIL_PICKAXE, MINING_MOTHERLODE_MITHRIL, MINING_CRASHEDSTAR_MITHRIL,
            MINING_ADAMANT_PICKAXE, MINING_MOTHERLODE_ADAMANT, MINING_CRASHEDSTAR_ADAMANT,
            MINING_RUNE_PICKAXE, MINING_MOTHERLODE_RUNE, MINING_CRASHEDSTAR_RUNE,
            MINING_GILDED_PICKAXE, MINING_MOTHERLODE_GILDED, MINING_CRASHEDSTAR_GILDED,
            MINING_DRAGON_PICKAXE, MINING_MOTHERLODE_DRAGON, MINING_CRASHEDSTAR_DRAGON,
            MINING_DRAGON_PICKAXE_OR, MINING_MOTHERLODE_DRAGON_OR, MINING_CRASHEDSTAR_DRAGON_OR,
            MINING_DRAGON_PICKAXE_OR_TRAILBLAZER, MINING_MOTHERLODE_DRAGON_OR_TRAILBLAZER, MINING_CRASHEDSTAR_DRAGON_OR_TRAILBLAZER,
            MINING_DRAGON_PICKAXE_UPGRADED, MINING_MOTHERLODE_DRAGON_UPGRADED, MINING_CRASHEDSTAR_DRAGON_UPGRADED,
            MINING_INFERNAL_PICKAXE, MINING_MOTHERLODE_INFERNAL, MINING_CRASHEDSTAR_INFERNAL,
            MINING_3A_PICKAXE, MINING_MOTHERLODE_3A, MINING_CRASHEDSTAR_3A,
            MINING_CRYSTAL_PICKAXE, MINING_MOTHERLODE_CRYSTAL, MINING_CRASHEDSTAR_CRYSTAL,
            MINING_TRAILBLAZER_PICKAXE, MINING_TRAILBLAZER_PICKAXE_2, MINING_TRAILBLAZER_PICKAXE_3, MINING_MOTHERLODE_TRAILBLAZER
    );
    private static final Set<Integer> WOODCUTTING_ANIMS = ImmutableSet.of(
            WOODCUTTING_BRONZE, WOODCUTTING_IRON, WOODCUTTING_STEEL, WOODCUTTING_BLACK, WOODCUTTING_MITHRIL,
            WOODCUTTING_ADAMANT, WOODCUTTING_RUNE, WOODCUTTING_GILDED, WOODCUTTING_DRAGON, WOODCUTTING_DRAGON_OR,
            WOODCUTTING_INFERNAL, WOODCUTTING_3A_AXE, WOODCUTTING_CRYSTAL, WOODCUTTING_TRAILBLAZER,
            WOODCUTTING_2H_BRONZE, WOODCUTTING_2H_IRON, WOODCUTTING_2H_STEEL, WOODCUTTING_2H_BLACK,
            WOODCUTTING_2H_MITHRIL, WOODCUTTING_2H_ADAMANT, WOODCUTTING_2H_RUNE, WOODCUTTING_2H_DRAGON,
            WOODCUTTING_2H_CRYSTAL, WOODCUTTING_2H_CRYSTAL_INACTIVE, WOODCUTTING_2H_3A
    );
    // Mouse fatigue class
    public static MouseFatigue mouseFatigue = new MouseFatigue();
    // Antiban setup class
    public static AntibanSetupTemplates antibanSetupTemplates = new AntibanSetupTemplates();
    @Getter
    @Setter
    public static int TIMEOUT = 0;
    @Getter
    private static Activity activity;
    @Getter
    private static ActivityIntensity activityIntensity;
    @Getter
    @Setter
    private static Category category;
    @Getter
    @Setter
    private static PlayStyle playStyle;
    public static void setActivity(@NotNull Activity activity) {
        Rs2Antiban.activity = activity;
        Rs2Antiban.category = activity.getCategory();
        Rs2Antiban.activityIntensity = activity.getActivityIntensity();
        if (Rs2AntibanSettings.simulateAttentionSpan) {
            Rs2Antiban.playStyle = PlayStyle.EXTREME_AGGRESSIVE;
            //Rs2Antiban.playStyle = activityIntensity.getPlayStyle();
        } else {
            if (Rs2Antiban.playStyle == null)
                Rs2Antiban.playStyle = activityIntensity.getPlayStyle();
        }
        if (Rs2AntibanSettings.randomIntervals) {
            Rs2Antiban.playStyle = PlayStyle.RANDOM;
        }
        playStyle.frequency = activityIntensity.getFrequency();
        playStyle.amplitude = activityIntensity.getAmplitude();
        Rs2Antiban.playStyle.resetPlayStyle();
    }
    public static void setActivityIntensity(ActivityIntensity activityIntensity) {
        Rs2AntibanSettings.dynamicIntensity = false;
        Rs2Antiban.activityIntensity = activityIntensity;
    }
    public static boolean checkForCookingEvent(ChatMessage event) {
        if (event.getType() != ChatMessageType.SPAM) {
            return false;
        }
        final String message = event.getMessage();
        return message.startsWith("You successfully cook")
                || message.startsWith("You successfully bake")
                || message.startsWith("You successfully fry")
                || message.startsWith("You manage to cook")
                || message.startsWith("You roast a")
                || message.startsWith("You spit-roast")
                || message.startsWith("You cook")
                || message.startsWith("Eventually the Jubbly")
                || message.startsWith("You half-cook")
                || message.startsWith("The undead meat is now cooked")
                || message.startsWith("The undead chicken is now cooked")
                || message.startsWith("You successfully scramble")
                || message.startsWith("You dry a piece of meat")
                || message.startsWith("You accidentally burn")
                || message.equals("You burn the mushroom in the fire.")
                || message.startsWith("Unfortunately the Jubbly")
                || message.startsWith("You accidentally spoil");
    }
    /**
     * Checks if the player is currently performing a woodcutting animation.
     *
     * @return true if the player is performing a woodcutting animation, false otherwise.
     */
    public static boolean isWoodcutting() {
        return WOODCUTTING_ANIMS.contains(Rs2Player.getAnimation());
    }
    /**
     * Checks if the player is currently performing a mining animation.
     *
     * @return true if the player is performing a mining animation, false otherwise.
     */
    public static boolean isMining() {
        return MINING_ANIMATION_IDS.contains(Rs2Player.getAnimation());
    }
    /**
     * Checks if the player is currently idle.
     *
     * @return true if the player is idle, false otherwise.
     */
    public static boolean isIdle() {
        return AntibanPlugin.isIdle();
    }
    /**
     * <h2>Handles the Execution of an Action Cooldown Based on Anti-Ban Behaviors</h2>
     * <p>
     * This method controls the flow for activating the cooldown either with certainty or based on a chance.
     * It includes logic to adjust behaviors such as non-linear intervals, behavioral variability, and random mouse movements
     * to simulate more human-like actions.
     * </p>
     * <p>
     * Execute this method at any point in your script where you want to trigger an action cooldown.
     * </p>
     * <p>
     * The cooldown can be triggered directly if <code>actionCooldownChance</code> is 1.00 (100%),
     * or by chance if <code>actionCooldownChance</code> is less than 1.00 (100%). Several features like universal antiban,
     * non-linear intervals, and play style evolution are configurable through <code>Rs2AntibanSettings</code>.
     * </p>
     *
     * <h3>Primary Actions Handled:</h3>
     * <ul>
     *   <li>Pausing all scripts if the universal antiban is enabled.</li>
     *   <li>Evolving play style if non-linear intervals are enabled.</li>
     *   <li>Setting a timeout based on behavioral variability settings.</li>
     *   <li>Optionally moving the mouse randomly or off-screen based on respective settings.</li>
     * </ul>
     *
     * <h3>Preconditions:</h3>
     * <ul>
     *   <li>If <code>Rs2AntibanSettings.usePlayStyle</code> is disabled, the cooldown will not be performed.</li>
     * </ul>
     *
     * <h3>Main Flow:</h3>
     * <ul>
     *   <li>If <code>actionCooldownChance</code> &lt; 1.00 (100%), the cooldown is triggered based on the result of a random dice roll.</li>
     *   <li>If <code>actionCooldownChance</code> is 1.00 (100%) or greater, the cooldown is triggered unconditionally.</li>
     * </ul>
     *
     * <h3>Helper Methods:</h3>
     * <p>
     * <code>performActionCooldown()</code> encapsulates the shared logic for performing the cooldown,
     * adjusting the play style, and invoking other anti-ban actions like moving the mouse randomly or off-screen.
     * </p>
     */
    public static void actionCooldown() {
        if (!Rs2AntibanSettings.usePlayStyle) {
            logDebug("PlayStyle not enabled, cannot perform action cooldown");
            return;
        }
        if (Rs2AntibanSettings.actionCooldownChance == 1.0) {
            performActionCooldown();
            return;
        }
        if (Rs2AntibanSettings.actionCooldownChance <= 0.0) {
            logDebug("Action cooldown chance is 0%, cannot perform action cooldown");
            return;
        }
        if (Rs2AntibanSettings.actionCooldownChance <= 0.99 && Rs2Random.diceFractional(Rs2AntibanSettings.actionCooldownChance)) {
            performActionCooldown();
        }
    }
    private static void logDebug(String message) {
        if (Rs2AntibanSettings.devDebug) {
            Microbot.log("<col=f44336>" + message + "</col>");
        }
    }
    private static void performActionCooldown() {
        if (Rs2AntibanSettings.universalAntiban)
            Microbot.pauseAllScripts = true;
        if (Rs2AntibanSettings.nonLinearIntervals)
            playStyle.evolvePlayStyle();
        if (Rs2AntibanSettings.behavioralVariability)
            TIMEOUT = playStyle.getRandomTickInterval();
        else
            TIMEOUT = playStyle.getPrimaryTickInterval();
        Rs2AntibanSettings.actionCooldownActive = true;
        if (Rs2AntibanSettings.moveMouseRandomly && Rs2Random.diceFractional(Rs2AntibanSettings.moveMouseRandomlyChance)) {
            Rs2Random.wait(100, 200);
            moveMouseRandomly();
        }
        if (Rs2AntibanSettings.moveMouseOffScreen)
            moveMouseOffScreen();
    }
    /**
     * Attempts to trigger a micro-break based on a random chance, as configured in Rs2AntibanSettings.
     *
     * <p>
     * This method simulates human-like pauses in the bot's behavior by invoking a micro-break if a randomly generated
     * value is less than the configured <code>microBreakChance</code>. When triggered, the break duration is determined
     * randomly within a specified range and the mouse may be optionally moved off-screen.
     * </p>
     *
     * <h3>Behavior:</h3>
     * <ul>
     *   <li>If a random value is less than <code>Rs2AntibanSettings.microBreakChance</code>, the micro-break is activated.</li>
     *   <li>The break duration is randomly set between <code>Rs2AntibanSettings.microBreakDurationLow</code> and
     *   <code>Rs2AntibanSettings.microBreakDurationHigh</code>, in seconds.</li>
     *   <li>If <code>Rs2AntibanSettings.moveMouseOffScreen</code> is enabled, the mouse is moved off-screen during the break.</li>
     * </ul>
     *
     * <h3>Preconditions:</h3>
     * <ul>
     *   <li>The configuration in <code>Rs2AntibanSettings</code> must define valid break chance and duration values.</li>
     * </ul>
     *
     * <h3>Postconditions:</h3>
     * <ul>
     *   <li><code>Rs2AntibanSettings.microBreakActive</code> is set to <code>true</code> if the break is triggered.</li>
     *   <li><code>BreakHandlerScript.breakDuration</code> is set to a randomly determined value in seconds.</li>
     * </ul>
     *
     * @return true if a micro-break is triggered, false otherwise.
     */
    public static boolean takeMicroBreakByChance() {
        if (!Rs2AntibanSettings.takeMicroBreaks && Rs2AntibanSettings.microBreakChance > 0.0) {
            logDebug("MICRO BREAKS ARE DISABLED, cannot take micro break");
            return false;
        }
        if (Math.random() < Rs2AntibanSettings.microBreakChance) {
            Rs2AntibanSettings.microBreakActive = true;
            BreakHandlerScript.breakDuration = Random.random(Rs2AntibanSettings.microBreakDurationLow * 60, Rs2AntibanSettings.microBreakDurationHigh * 60);
            if (Rs2AntibanSettings.moveMouseOffScreen)
                moveMouseOffScreen();
            return true;
        }
        return false;
    }
    /**
     * Renders an overlay component that displays various anti-ban settings and information within a panel.
     *
     * <p>
     * This method populates a <code>PanelComponent</code> with details regarding the current anti-ban system's state,
     * activity levels, play styles, and other related information. It is intended for use in providing a visual representation
     * of the anti-ban system's status during runtime, with debug information shown when enabled.
     * </p>
     *
     * <h3>Overlay Components:</h3>
     * <ul>
     *   <li>A title component labeled " Humanizer " with orange coloring.</li>
     *   <li>Details about the current activity, including method name, category, and intensity.</li>
     *   <li>If <code>Rs2AntibanSettings.devDebug</code> is enabled, several debug lines will show key anti-ban settings,
     *       such as action cooldown, random intervals, and behavioral variability.</li>
     *   <li>If a play style is active, the panel displays the current play style name and the time remaining until the next switch
     *       if attention span simulation is enabled.</li>
     *   <li>A progress bar representing the current action cooldown based on a tick interval, providing a visual cue for
     *       the remaining time.</li>
     *   <li>Status updates on whether the bot is busy or idle, indicating potential upcoming breaks.</li>
     * </ul>
     *
     * <h3>Behavior:</h3>
     * <ul>
     *   <li>The method dynamically updates the panel with current information based on settings in <code>Rs2AntibanSettings</code>
     *       and <code>playStyle</code>.</li>
     *   <li>If debug mode is enabled, additional lines provide detailed state information, such as whether action cooldown,
     *       fatigue simulation, and natural mouse movements are active.</li>
     *   <li>The progress bar visually indicates the current state of the action cooldown timer.</li>
     * </ul>
     *
     * <h3>Preconditions:</h3>
     * <ul>
     *   <li><code>playStyle</code> and <code>Rs2AntibanSettings</code> must be properly initialized.</li>
     *   <li>The <code>panelComponent</code> must be passed as a valid and non-null component to receive overlay data.</li>
     * </ul>
     *
     * <h3>Where to Use:</h3>
     * <p>
     * This method should be used within overlay rendering methods, typically in custom overlay classes that extend
     * <code>OverlayPanel</code>. For example, in the <code>MotherloadMineOverlay</code> class, this method is used to
     * display anti-ban information in the mining overlay. It is invoked within the <code>render(Graphics2D graphics)</code>
     * method to ensure that the anti-ban status is updated every time the overlay is drawn.
     * </p>
     *
     * <p>
     * To integrate this method into a custom overlay:
     * </p>
     * <ol>
     *   <li>Ensure that your overlay class extends <code>OverlayPanel</code> or a similar class that supports adding components.</li>
     *   <li>Invoke <code>Rs2Antiban.renderAntibanOverlayComponents(panelComponent);</code> within the overlay's
     *       <code>render</code> method, before or after other components are added, depending on the desired layout.</li>
     *   <li>Ensure that the appropriate <code>Rs2AntibanSettings</code> are configured before invoking the method.</li>
     * </ol>
     *
     * <h3>Example Usage:</h3>
     * <pre>
     * {@code
     * @Override
     * public Dimension render(Graphics2D graphics) {
     *     try {
     *         panelComponent.setPreferredSize(new Dimension(275, 900));
     *         panelComponent.getChildren().add(TitleComponent.builder()
     *                 .text("\uD83E\uDD86 Motherlode Mine \uD83E\uDD86")
     *                 .color(Color.ORANGE)
     *                 .build());
     *
     *         Rs2Antiban.renderAntibanOverlayComponents(panelComponent);
     *         addEmptyLine();
     *
     *         panelComponent.getChildren().add(LineComponent.builder()
     *                 .left("Mining Location: " + MotherloadMineScript.miningSpot.name())
     *                 .build());
     *
     *         addEmptyLine();
     *
     *         panelComponent.getChildren().add(LineComponent.builder()
     *                 .left(status.toString())
     *                 .right("Version: " + MotherloadMineScript.version)
     *                 .build());
     *     } catch (Exception ex) {
     *         System.out.println(ex.getMessage());
     *     }
     *     return super.render(graphics);
     * }
     * }
     * </pre>
     */
    public static void renderAntibanOverlayComponents(PanelComponent panelComponent) {
        final ProgressBarComponent progressBarComponent = new ProgressBarComponent();
        progressBarComponent.setBackgroundColor(Color.DARK_GRAY);
        progressBarComponent.setForegroundColor(ColorUtil.fromHex("#cc8400"));
        progressBarComponent.setMaximum(0);
        progressBarComponent.setMaximum(playStyle.getSecondaryTickInterval());
        progressBarComponent.setValue(TIMEOUT);
        progressBarComponent.setLabelDisplayMode(ProgressBarComponent.LabelDisplayMode.TEXT_ONLY);
        progressBarComponent.setLeftLabel("0");
        progressBarComponent.setRightLabel(String.valueOf(playStyle.getSecondaryTickInterval()));
        progressBarComponent.setCenterLabel(String.valueOf(TIMEOUT));
        panelComponent.getChildren().add(TitleComponent.builder().text("\uD83E\uDD86 Humanizer \uD83E\uDD86")
                .color(Color.ORANGE).build());
        panelComponent.getChildren().add(LineComponent.builder().build());
        panelComponent.getChildren().add(SplitComponent.builder()
                .first(LineComponent.builder().left("Activity: " + activity.getMethod()).right(Rs2AntibanSettings.devDebug ? "Dynamic: " + (Rs2AntibanSettings.dynamicActivity ? "" : "") : "").build())
                .second(LineComponent.builder().left("Category: " + category.getName()).build()).build());
        panelComponent.getChildren().add(LineComponent.builder().build());
        panelComponent.getChildren().add(LineComponent.builder().left("Activity Intensity: " + activityIntensity.getName()).right(Rs2AntibanSettings.devDebug ? "Dynamic: " + (Rs2AntibanSettings.dynamicIntensity ? "" : "") : "").build());
        if (Rs2AntibanSettings.devDebug) {
            panelComponent.getChildren().add(LineComponent.builder().left("isActionCooldownActive: " + (Rs2AntibanSettings.actionCooldownActive ? "" : "")).build());
            panelComponent.getChildren().add(LineComponent.builder().left("isEnabled: " + (Rs2AntibanSettings.antibanEnabled ? "" : "")).build());
            panelComponent.getChildren().add(LineComponent.builder().left("useRandomIntervals: " + (Rs2AntibanSettings.randomIntervals ? "" : "")).build());
            panelComponent.getChildren().add(LineComponent.builder().left("simulateFatigue: " + (Rs2AntibanSettings.simulateFatigue ? "" : "")).build());
            panelComponent.getChildren().add(LineComponent.builder().left("simulateAttentionSpan: " + (Rs2AntibanSettings.simulateAttentionSpan ? "" : "")).build());
            panelComponent.getChildren().add(LineComponent.builder().left("useBehavioralVariability: " + (Rs2AntibanSettings.behavioralVariability ? "" : "")).build());
            panelComponent.getChildren().add(LineComponent.builder().left("useNonLinearIntervals: " + (Rs2AntibanSettings.nonLinearIntervals ? "" : "")).build());
            panelComponent.getChildren().add(LineComponent.builder().left("enableProfileSwitching: " + (Rs2AntibanSettings.profileSwitching ? "" : "")).build());
            panelComponent.getChildren().add(LineComponent.builder().left("adjustForTimeOfDay: " + (Rs2AntibanSettings.timeOfDayAdjust ? "" : "")).build());
            panelComponent.getChildren().add(LineComponent.builder().left("simulateMistakes: " + (Rs2AntibanSettings.simulateMistakes ? "" : "")).build());
            panelComponent.getChildren().add(LineComponent.builder().left("useNaturalMouse: " + (Rs2AntibanSettings.naturalMouse ? "" : "")).build());
            panelComponent.getChildren().add(LineComponent.builder().left("useContextualVariability: " + (Rs2AntibanSettings.contextualVariability ? "" : "")).build());
        }
        if (playStyle != null) {
            panelComponent.getChildren().add(LineComponent.builder().left("Play Style: " + playStyle.getName()).build());
            if (Rs2AntibanSettings.simulateAttentionSpan) {
                panelComponent.getChildren().add(LineComponent.builder().left("Play style change in: " + playStyle.getTimeLeftUntilNextSwitch()).build());
            }
            panelComponent.getChildren().add(LineComponent.builder().build());
            if (Rs2Antiban.getCategory().isBusy()) {
                panelComponent.getChildren().add(LineComponent.builder().left("We are busy").build());
            } else {
                panelComponent.getChildren().add(LineComponent.builder().left("Not busy anymore, breaking").build());
            }
            panelComponent.getChildren().add(LineComponent.builder().build());
            panelComponent.getChildren().add(TitleComponent.builder().text("Action cooldown(Tick)").color(Color.WHITE).build());
            panelComponent.getChildren().add(progressBarComponent);
        }
    }
    /**
     * <h1>Move Mouse Off Screen</h1>
     * This method moves the mouse off the screen with a 1/4 chance to trigger.
     * This is used to simulate a user moving the mouse off the screen to take a break.
     */
    public static void moveMouseOffScreen() {
        Microbot.naturalMouse.moveOffScreen();
    }
    /**
     * <h1>Move Mouse Randomly</h1>
     * This method moves the mouse randomly based on the given chance in settings.
     * This is used to simulate a user moving the mouse randomly to take a break.
     */
    public static void moveMouseRandomly() {
        Microbot.naturalMouse.moveRandom();
    }
    public static void activateAntiban() {
        Rs2AntibanSettings.antibanEnabled = true;
    }
    public static void deactivateAntiban() {
        Rs2AntibanSettings.antibanEnabled = false;
    }
    public static boolean isIdleTooLong(int timeoutTicks) {
        return AntibanPlugin.isIdleTooLong(timeoutTicks);
    }
    // reset all the variables
    public static void resetAntibanSettings() {
        Rs2AntibanSettings.reset();
        Rs2Antiban.playStyle = null;
        Rs2Antiban.activity = null;
        Rs2Antiban.activityIntensity = null;
        Rs2Antiban.category = null;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/antiban/Rs2AntibanSettings.java
================
package net.runelite.client.plugins.microbot.util.antiban;
/**
 * Provides configuration settings for the anti-ban system used by various plugins within the bot framework.
 *
 * <p>
 * The <code>Rs2AntibanSettings</code> class contains a collection of static fields that define behaviors
 * and settings related to anti-ban mechanisms. These settings control how the bot simulates human-like
 * behavior to avoid detection during automated tasks. Each setting adjusts a specific aspect of the
 * anti-ban system, including break patterns, mouse movements, play style variability, and other behaviors
 * designed to mimic natural human interaction with the game.
 * </p>
 *
 * <h3>Main Features:</h3>
 * <ul>
 *   <li><strong>Action Cooldowns:</strong> Controls the cooldown behavior of actions, including random intervals
 *   and non-linear patterns.</li>
 *   <li><strong>Micro Breaks:</strong> Defines settings for taking small breaks at random intervals to simulate human pauses.</li>
 *   <li><strong>Play Style Simulation:</strong> Includes variables to simulate different play styles, attention span,
 *   and behavioral variability to create a more realistic user profile.</li>
 *   <li><strong>Mouse Movements:</strong> Settings to control mouse behavior, such as moving off-screen or randomly,
 *   mimicking natural user actions.</li>
 *   <li><strong>Dynamic Behaviors:</strong> Provides options to dynamically adjust activity intensity and behavior
 *   based on context and time of day.</li>
 * </ul>
 *
 * <h3>Fields:</h3>
 * <ul>
 *   <li><code>actionCooldownActive</code>: Tracks whether action cooldowns are currently active.</li>
 *   <li><code>microBreakActive</code>: Indicates if a micro break is currently active.</li>
 *   <li><code>antibanEnabled</code>: Globally enables or disables the anti-ban system.</li>
 *   <li><code>usePlayStyle</code>: Determines whether play style simulation is active.</li>
 *   <li><code>randomIntervals</code>: Enables random intervals between actions to avoid detection.</li>
 *   <li><code>simulateFatigue</code>: Simulates user fatigue by introducing delays or slower actions.</li>
 *   <li><code>simulateAttentionSpan</code>: Simulates varying levels of user attention over time.</li>
 *   <li><code>behavioralVariability</code>: Adds variability to actions to simulate a human's inconsistency.</li>
 *   <li><code>nonLinearIntervals</code>: Activates non-linear time intervals between actions.</li>
 *   <li><code>profileSwitching</code>: Simulates user behavior switching profiles at intervals.</li>
 *   <li><code>timeOfDayAdjust</code>: (TODO) Adjusts behaviors based on the time of day.</li>
 *   <li><code>simulateMistakes</code>: Simulates user mistakes, often controlled by natural mouse movements.</li>
 *   <li><code>naturalMouse</code>: Enables natural-looking mouse movements.</li>
 *   <li><code>moveMouseOffScreen</code>: Moves the mouse off-screen during breaks to simulate user behavior.</li>
 *   <li><code>moveMouseRandomly</code>: Moves the mouse randomly to simulate human inconsistency.</li>
 *   <li><code>contextualVariability</code>: Adjusts behaviors based on the context of the user's actions.</li>
 *   <li><code>dynamicIntensity</code>: Dynamically adjusts the intensity of user actions based on context.</li>
 *   <li><code>dynamicActivity</code>: Adjusts activities dynamically based on the user's behavior profile.</li>
 *   <li><code>devDebug</code>: Enables debug mode for developers to inspect the anti-ban system's state.</li>
 *   <li><code>takeMicroBreaks</code>: Controls whether the bot takes micro breaks at random intervals.</li>
 *   <li><code>playSchedule</code>: (TODO) Allows scheduling of playtime based on specific conditions.</li>
 *   <li><code>universalAntiban</code>: Applies the same anti-ban settings across all plugins.</li>
 *   <li><code>microBreakDurationLow</code>: Minimum duration for micro breaks, in minutes.</li>
 *   <li><code>microBreakDurationHigh</code>: Maximum duration for micro breaks, in minutes.</li>
 *   <li><code>actionCooldownChance</code>: Probability of triggering an action cooldown.</li>
 *   <li><code>microBreakChance</code>: Probability of taking a micro break.</li>
 *   <li><code>moveMouseRandomlyChance</code>: Probability of moving the mouse randomly.</li>
 * </ul>
 *
 * <h3>Usage:</h3>
 * <p>
 * These settings are typically used by anti-ban mechanisms within various plugins to adjust their behavior
 * dynamically based on the user's preferences or to simulate human-like play styles. Developers can adjust
 * these fields based on the needs of their specific automation scripts.
 * </p>
 *
 * <h3>Example:</h3>
 * <pre>
 * // Enable fatigue simulation and random intervals
 * Rs2AntibanSettings.simulateFatigue = true;
 * Rs2AntibanSettings.randomIntervals = true;
 *
 * // Set the micro break chance to 20%
 * Rs2AntibanSettings.microBreakChance = 0.2;
 * </pre>
 */
public class Rs2AntibanSettings {
    public static boolean actionCooldownActive = false;
    public static boolean microBreakActive = false;
    public static boolean antibanEnabled = true;
    public static boolean usePlayStyle = false;
    public static boolean randomIntervals = false;
    public static boolean simulateFatigue = false;
    public static boolean simulateAttentionSpan = false;
    public static boolean behavioralVariability = false;
    public static boolean nonLinearIntervals = false;
    public static boolean profileSwitching = false;
    public static boolean timeOfDayAdjust = false; //TODO: Implement this
    public static boolean simulateMistakes = false; //Handled by the natural mouse
    public static boolean naturalMouse = false;
    public static boolean moveMouseOffScreen = false;
    public static boolean moveMouseRandomly = false;
    public static boolean contextualVariability = false;
    public static boolean dynamicIntensity = false;
    public static boolean dynamicActivity = false;
    public static boolean devDebug = false;
    public static boolean takeMicroBreaks = false; // will take micro breaks lasting 3-15 minutes at random intervals by default.
    public static boolean playSchedule = false; //TODO: Implement this
    public static boolean universalAntiban = false; // Will attempt to use the same antiban settings for all plugins that has not yet implemented their own antiban settings.
    public static int microBreakDurationLow = 3; // 3 minutes
    public static int microBreakDurationHigh = 15; // 15 minutes
    public static double actionCooldownChance = 0.1; // 10% chance of activating the action cooldown by default
    public static double microBreakChance = 0.1; // 10% chance of taking a micro break by default
    public static double moveMouseRandomlyChance = 0.1; // 10% chance of moving the mouse randomly by default
    // reset method to reset all settings to default values
    public static void reset() {
        actionCooldownActive = false;
        microBreakActive = false;
        antibanEnabled = true;
        usePlayStyle = false;
        randomIntervals = false;
        simulateFatigue = false;
        simulateAttentionSpan = false;
        behavioralVariability = false;
        nonLinearIntervals = false;
        profileSwitching = false;
        timeOfDayAdjust = false;
        simulateMistakes = false;
        naturalMouse = false;
        moveMouseOffScreen = false;
        moveMouseRandomly = false;
        contextualVariability = false;
        dynamicIntensity = false;
        dynamicActivity = false;
        devDebug = false;
        takeMicroBreaks = false;
        playSchedule = false;
        universalAntiban = false;
        microBreakDurationLow = 3;
        microBreakDurationHigh = 15;
        actionCooldownChance = 0.1;
        microBreakChance = 0.1;
        moveMouseRandomlyChance = 0.1;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/bank/enums/BankLocation.java
================
package net.runelite.client.plugins.microbot.util.bank.enums;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.Quest;
import net.runelite.api.QuestState;
import net.runelite.api.Skill;
import net.runelite.api.Varbits;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.equipment.Rs2Equipment;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
@Getter
@RequiredArgsConstructor
public enum BankLocation {
    AL_KHARID(new WorldPoint(3270, 3166, 0)),
    ARCEUUS(new WorldPoint(1624, 3745, 0)),
    ARDOUGNE_NORTH(new WorldPoint(2616, 3332, 0)),
    ARDOUGNE_SOUTH(new WorldPoint(2655, 3283, 0)),
    BARBARIAN_OUTPOST(new WorldPoint(2536, 3574, 0)),
    BLAST_FURNACE_BANK(new WorldPoint(1948, 4957, 0)),
    BLAST_MINE(new WorldPoint(1502, 3856, 0)),
    BURGH_DE_ROTT(new WorldPoint(3495, 3212, 0)),
    CAMELOT(new WorldPoint(2725, 3493, 0)),
    CAMODZAAL(new WorldPoint(2979, 5798, 0)),
    CAM_TORUM(new WorldPoint(1450, 9557, 1)),
    CANIFIS(new WorldPoint(3512, 3480, 0)),
    CASTLE_WARS(new WorldPoint(2443, 3083, 0)),
    CATHERBY(new WorldPoint(2808, 3441, 0)),
    COOKS_GUILD(new WorldPoint(3147,3450,0)),
    CRAFTING_GUILD(new WorldPoint(2936, 3281, 0)),
    DIHN_BANK(new WorldPoint(1640, 3944, 0)),
    DRAYNOR(new WorldPoint(3092, 3243, 0)),
    DRAYNOR_VILLAGE(new WorldPoint(3093, 3245, 0)),
    DUEL_ARENA(new WorldPoint(3381, 3268, 0)),
    DWARF_MINE_BANK(new WorldPoint(2837, 10207, 0)),
    EAST_ARDOUGNE_NORTH(new WorldPoint(2618, 3332, 0)),
    EAST_ARDOUGNE_SOUTH(new WorldPoint(2652, 3283, 0)),
    EDGEVILLE(new WorldPoint(3094, 3492, 0)),
    FALADOR_EAST(new WorldPoint(3014, 3355, 0)),
    FALADOR_WEST(new WorldPoint(2945, 3369, 0)),
    FARMING_GUILD(new WorldPoint(1253, 3741, 0)),
    FEROX_ENCLAVE(new WorldPoint(3130, 3631, 0)),
    FISHING_GUILD(new WorldPoint(2586, 3420, 0)),
    FOSSIL_ISLAND(new WorldPoint(3739, 3804, 0)),
    FOSSIL_ISLAND_WRECK(new WorldPoint(3771, 3898, 0)),
    GNOME_BANK(new WorldPoint(2445, 3425, 1)),
    GNOME_TREE_BANK_SOUTH(new WorldPoint(2449, 3482, 1)),
    GNOME_TREE_BANK_WEST(new WorldPoint(2442, 3488, 1)),
    GRAND_EXCHANGE(new WorldPoint(3166, 3485, 0)),
    GREAT_KOUREND_CASTLE(new WorldPoint(1612, 3681, 2)),
    HALLOWED_SEPULCHRE(new WorldPoint(2400, 5983, 0)),
    HOSIDIUS(new WorldPoint(1749, 3599, 0)),
    HOSIDIUS_KITCHEN(new WorldPoint(1676, 3617, 0)),
    HUNTERS_GUILD(new WorldPoint(1542, 3041, 0)),
    ISLE_OF_SOULS(new WorldPoint(2212, 2859, 0)),
    JATIZSO(new WorldPoint(2416, 3801, 0)),
    LANDS_END(new WorldPoint(1512, 3421, 0)),
    LEGENDS_GUILD(new WorldPoint(2732, 3379, 2)),
    LOVAKENGJ(new WorldPoint(1526, 3739, 0)),
    LUMBRIDGE_BASEMENT(new WorldPoint(3218, 9623, 0)),
    LUMBRIDGE_TOP(new WorldPoint(3209, 3220, 2)),
    LUNAR_ISLE(new WorldPoint(2099, 3919, 0)),
    MAGE_TRAINING_ARENA(new WorldPoint(3366, 3318, 1)),
    MINING_GUILD(new WorldPoint(3013, 9718, 0)),
    MOR_UL_REK(new WorldPoint(2541, 5140, 0)),
    MOTHERLOAD(new WorldPoint(3760, 5666, 0)),
    MOUNT_KARUULM(new WorldPoint(1324, 3824, 0)),
    NARDAH(new WorldPoint(3428, 2892, 0)),
    NEITIZNOT(new WorldPoint(2337, 3807, 0)),
    PEST_CONTROL(new WorldPoint(2667, 2653, 0)),
    PISCARILIUS(new WorldPoint(1803, 3790, 0)),
    PORT_KHAZARD(new WorldPoint(2664, 3161, 0)),
    PRIFDDINAS(new WorldPoint(3257, 6106, 0)),
    ROGUES_DEN_EMERALD_BENEDICT(new WorldPoint(3043, 4973, 1)),
    ROGUES_DEN_CHEST(new WorldPoint(3040, 4969, 1)),
    RUINS_OF_UNKAH(new WorldPoint(3156, 2835, 0)),
    SHANTY_PASS(new WorldPoint(3308, 3120, 0)),
    SHAYZIEN_BANK(new WorldPoint(1488, 3592, 0)),
    SHAYZIEN_CHEST(new WorldPoint(1486, 3646, 0)),
    SHILO_VILLAGE(new WorldPoint(2852, 2954, 0)),
    SOPHANEM(new WorldPoint(2799, 5169, 0)),
    SULPHUR_MINE(new WorldPoint(1453, 3858, 0)),
    TREE_GNOME_STRONGHOLD_NIEVE(new WorldPoint(2445, 3424, 1)),
    TZHAAR(new WorldPoint(2446, 5178, 0)),
    VARLAMORE_EAST(new WorldPoint(1780, 3094, 0)),
    VARLAMORE_WEST(new WorldPoint(1647, 3118, 0)),
    VARROCK_EAST(new WorldPoint(3253, 3422, 0)),
    VARROCK_WEST(new WorldPoint(3183, 3441, 0)),
    VINERY(new WorldPoint(1808, 3570, 0)),
    VINERY_BANK(new WorldPoint(1809, 3566, 0)),
    VOLCANO_BANK(new WorldPoint(3819, 3809, 0)),
    WINTERTODT(new WorldPoint(1640, 3944, 0)),
    WARRIORS_GUILD(new WorldPoint(2843, 3542, 0)),
    WOODCUTTING_GUILD(new WorldPoint(1591, 3479, 0)),
    YANILLE(new WorldPoint(2613, 3093, 0)),
    ZANARIS(new WorldPoint(2383, 4458, 0)),
    ZEAH_SAND_BANK(new WorldPoint(1719, 3465, 0)),
    MINING_GUILD_BANK(new WorldPoint(3012, 9718, 0));
    private final WorldPoint worldPoint;
    public boolean hasRequirements() {
        boolean hasLineOfSight = Microbot.getClient().getLocalPlayer().getWorldArea().hasLineOfSightTo(Microbot.getClient().getTopLevelWorldView(), worldPoint);
        switch (this) {
            case CRAFTING_GUILD:
                boolean hasFaladorHardDiary = Microbot.getVarbitValue(Varbits.DIARY_FALADOR_HARD) == 1;
                boolean hasMaxedCrafting = Rs2Player.getSkillRequirement(Skill.CRAFTING, 99, false);
                boolean isWearingCraftingGuild = (Rs2Equipment.isWearing("brown apron") || Rs2Equipment.isWearing("golden apron")) ||
                        (Rs2Equipment.isWearing("max cape") || Rs2Equipment.isWearing("max hood")) ||
                        (Rs2Equipment.isWearing("crafting cape") || Rs2Equipment.isWearing("crafting hood"));
                if (hasLineOfSight && Rs2Player.isMember() && (hasMaxedCrafting || hasFaladorHardDiary)) return true;
                return Rs2Player.isMember() && isWearingCraftingGuild &&
                        (hasMaxedCrafting || hasFaladorHardDiary);
            case LUMBRIDGE_BASEMENT:
                return Rs2Player.isMember() && Rs2Player.getQuestState(Quest.RECIPE_FOR_DISASTER__ANOTHER_COOKS_QUEST) == QuestState.FINISHED;
            case COOKS_GUILD:
                boolean hasVarrockHardDiary = Microbot.getVarbitValue(Varbits.DIARY_VARROCK_HARD) == 1;
                boolean hasMaxedCooking = Rs2Player.getSkillRequirement(Skill.COOKING, 99, false);
                boolean isWearingCooksGuild = Rs2Equipment.isWearing("chef's hat") ||
                        (Rs2Equipment.isWearing("cooking cape") || Rs2Equipment.isWearing("cooking hood")) ||
                        (Rs2Equipment.isWearing("max cape") || Rs2Equipment.isWearing("max hood")) ||
                        (Rs2Equipment.isWearing("varrock armour 3") || Rs2Equipment.isWearing("varrock armour 4"));
                if (hasLineOfSight && Rs2Player.isMember() && (hasMaxedCooking || hasVarrockHardDiary)) return true;
                return Rs2Player.isMember() && isWearingCooksGuild &&
                        (hasVarrockHardDiary || hasMaxedCooking);
            case WARRIORS_GUILD:
                if (hasLineOfSight && Rs2Player.isMember()) return true;
                return Rs2Player.isMember() &&
                        (Rs2Player.getSkillRequirement(Skill.ATTACK, 99, false) || Rs2Player.getSkillRequirement(Skill.STRENGTH, 99, false)) ||
                        (Rs2Player.getRealSkillLevel(Skill.ATTACK) + Rs2Player.getRealSkillLevel(Skill.STRENGTH) >= 130);
            case WOODCUTTING_GUILD:
                if (hasLineOfSight && Rs2Player.isMember()) return true;
                return Rs2Player.isMember() && Rs2Player.getSkillRequirement(Skill.WOODCUTTING, 60, true);
            case FARMING_GUILD:
                if (hasLineOfSight && Rs2Player.isMember()) return true;
                return Rs2Player.isMember() && Rs2Player.getSkillRequirement(Skill.FARMING, 45, true);
            case MINING_GUILD:
                if (hasLineOfSight && Rs2Player.isMember()) return true;
                return Rs2Player.isMember() && Rs2Player.getSkillRequirement(Skill.MINING, 60, true);
            case FISHING_GUILD:
                if (hasLineOfSight && Rs2Player.isMember()) return true;
                return Rs2Player.isMember() && Rs2Player.getSkillRequirement(Skill.FISHING, 68, true);
            case HUNTERS_GUILD:
                if (hasLineOfSight && Rs2Player.isMember()) return true;
                return Rs2Player.isMember() && Rs2Player.getSkillRequirement(Skill.HUNTER, 46, false);
            case LEGENDS_GUILD:
                if (hasLineOfSight && Rs2Player.isMember()) return true;
                return Rs2Player.isMember() && Rs2Player.getQuestState(Quest.LEGENDS_QUEST) == QuestState.FINISHED;
            case MINING_GUILD_BANK:
                if (hasLineOfSight && Rs2Player.isMember()) return true;
                return Rs2Player.isMember() && Rs2Player.getSkillRequirement(Skill.MINING, 60);
            default:
                return true;
        }
    }
    public boolean hasException() {
        switch (this) {
            case MINING_GUILD_BANK:
                boolean inRegion = Microbot.getClient().getLocalPlayer().getWorldLocation().getRegionID() == 12183 || Microbot.getClient().getLocalPlayer().getWorldLocation().getRegionID() == 12184;
                return inRegion;
            default:
                return false;
        }
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/bank/Rs2Bank.java
================
package net.runelite.client.plugins.microbot.util.bank;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.plugins.loottracker.LootTrackerItem;
import net.runelite.client.plugins.loottracker.LootTrackerRecord;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.antiban.Rs2AntibanSettings;
import net.runelite.client.plugins.microbot.util.bank.enums.BankLocation;
import net.runelite.client.plugins.microbot.util.equipment.Rs2Equipment;
import net.runelite.client.plugins.microbot.util.gameobject.Rs2GameObject;
import net.runelite.client.plugins.microbot.util.grandexchange.Rs2GrandExchange;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Item;
import net.runelite.client.plugins.microbot.util.keyboard.Rs2Keyboard;
import net.runelite.client.plugins.microbot.util.math.Rs2Random;
import net.runelite.client.plugins.microbot.util.menu.NewMenuEntry;
import net.runelite.client.plugins.microbot.util.misc.Predicates;
import net.runelite.client.plugins.microbot.util.npc.Rs2Npc;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.microbot.util.security.Encryption;
import net.runelite.client.plugins.microbot.util.security.Login;
import net.runelite.client.plugins.microbot.util.walker.Rs2Walker;
import net.runelite.client.plugins.microbot.util.widget.Rs2Widget;
import java.awt.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import static net.runelite.api.Varbits.*;
import static net.runelite.api.widgets.ComponentID.BANK_INVENTORY_ITEM_CONTAINER;
import static net.runelite.api.widgets.ComponentID.BANK_ITEM_CONTAINER;
import static net.runelite.client.plugins.microbot.Microbot.updateItemContainer;
import static net.runelite.client.plugins.microbot.util.Global.*;
import static net.runelite.client.plugins.microbot.util.gameobject.Rs2GameObject.hoverOverObject;
import static net.runelite.client.plugins.microbot.util.npc.Rs2Npc.hoverOverActor;
@SuppressWarnings("unused")
@Slf4j
public class Rs2Bank {
    public static final int BANK_ITEM_WIDTH = 36;
    public static final int BANK_ITEM_HEIGHT = 32;
    public static final int BANK_ITEM_Y_PADDING = 4;
    public static final int BANK_ITEMS_PER_ROW = 8;
    private static final int X_AMOUNT_VARBIT = 3960;
    private static final int SELECTED_OPTION_VARBIT = 6590;
    private static final int HANDLE_X_SET = 5;
    private static final int HANDLE_X_UNSET = 6;
    private static final int HANDLE_ALL = 7;
    private static final int WITHDRAW_AS_NOTE_VARBIT = 3958;
    public static List<Rs2Item> bankItems = new ArrayList<Rs2Item>();
    /**
     * Container describes from what interface the action happens
     * eg: withdraw means the contailer will be the bank container
     * eg: deposit means that the container will be the inventory container
     * and so on...
     */
    private static int container = -1;
    // Array to store the counts of items in each tab
    private static final int[] bankTabCounts = new int[9];
    /**
     * Executes menu swapping for a specific rs2Item and entry index.
     *
     * @param entryIndex The index of the entry to swap.
     * @param rs2Item    The ItemWidget associated with the menu swap.
     */
    public static void invokeMenu(int entryIndex, Rs2Item rs2Item) {
        int identifier = entryIndex;
        Rectangle itemBoundingBox = null;
        if (container == BANK_INVENTORY_ITEM_CONTAINER) {
            identifier = identifier + 1;
            itemBoundingBox = Rs2Inventory.itemBounds(rs2Item);
        }
        if (container == BANK_ITEM_CONTAINER) {
            int itemTab = getItemTabForBankItem(rs2Item.slot);
            if (!isTabOpen(itemTab))
                openTab(itemTab);
            scrollBankToSlot(rs2Item.slot);
            itemBoundingBox = itemBounds(rs2Item);
        }
        Microbot.doInvoke(new NewMenuEntry(rs2Item.slot, container, MenuAction.CC_OP.getId(), identifier, rs2Item.id, rs2Item.name), (itemBoundingBox == null) ? new Rectangle(1, 1) : itemBoundingBox);
        // MenuEntryImpl(getOption=Wear, getTarget=<col=ff9040>Amulet of glory(4)</col>, getIdentifier=9, getType=CC_OP_LOW_PRIORITY, getParam0=1, getParam1=983043, getItemId=1712, isForceLeftClick=false, isDeprioritized=false)
        // Rs2Reflection.invokeMenu(rs2Item.slot, container, MenuAction.CC_OP.getId(), identifier, rs2Item.id, "Withdraw-1", rs2Item.name, -1, -1);
    }
    /**
     * Gets the bounding rectangle for the slot of the specified item in the bank container.
     *
     * @param rs2Item The item to get the bounds for.
     *
     * @return The bounding rectangle for the item's slot, or null if the item is not found.
     */
    public static Rectangle itemBounds(Rs2Item rs2Item) {
        Widget itemWidget = getItemWidget(rs2Item.slot);
        if (itemWidget == null) return null;
        return itemWidget.getBounds();
    }
    /**
     * Closes the bank interface if it is open.
     *
     * @return true if the bank interface was open and successfully closed, false otherwise.
     */
    public static boolean isOpen() {
        if (Rs2Widget.hasWidget("Please enter your PIN")) {
            try {
                if (Login.activeProfile.getBankPin().isEmpty()) {
                    Microbot.showMessage("Your bankpin is empty. Please fill this field in your runelite profile.");
                    return false;
                }
                handleBankPin(Encryption.decrypt(Login.activeProfile.getBankPin()));
            } catch (Exception e) {
                System.out.println("Something went wrong handling bankpin");
            }
            return false;
        }
        return Rs2Widget.findWidget("Rearrange mode", null) != null;
    }
    public static List<Rs2Item> bankItems() {
        return bankItems;
    }
    /**
     * Closes the bank interface if it is open.
     *
     * @return true if the bank interface was open and successfully closed, false otherwise.
     */
    public static boolean closeBank() {
        if (!isOpen()) return false;
        Rs2Widget.clickChildWidget(786434, 11);
        sleepUntilOnClientThread(() -> !isOpen());
        return true;
    }
    /**
     * Finds a bank item widget in the bank interface by its partial name match.
     *
     * @param name The name of the item to find.
     *
     * @return The bank item widget if found, or null if not found.
     */
    public static Rs2Item findBankItem(String name) {
        return findBankItem(name, false);
    }
    /**
     * check if the player has a bank item identified by id
     *
     * @param id the item id
     *
     * @return boolean
     */
    public static boolean hasItem(int id) {
        return findBankItem(id) != null;
    }
    /**
     * check if the player has a bank item identified by contains name
     *
     * @param name the item name
     *
     * @return boolean
     */
    public static boolean hasItem(String name) {
        return hasItem(name, false);
    }
    /**
     * @param name
     * @param exact
     *
     * @return
     */
    public static boolean hasItem(String name, boolean exact) {
        return findBankItem(name, exact) != null;
    }
    /**
     * check if the player has a bank item identified by exact name.
     *
     * @param name the item name
     *
     * @return boolean
     */
    public static boolean hasBankItem(String name) {
        return findBankItem(name, false, 1) != null;
    }
    /**
     * check if the player has a bank item identified by exact name.
     *
     * @param name the item name
     *
     * @return boolean
     */
    public static boolean hasBankItem(String name, int amount) {
        return hasBankItem(name, amount, false);
    }
    /**
     * check if the player has a bank item identified by exact name.
     *
     * @param name the item name
     *
     * @return boolean
     */
    public static boolean hasBankItem(String name, int amount, boolean exact) {
        return findBankItem(name, exact, amount) != null;
    }
    /**
     * check if the player has a bank item identified by exact name.
     *
     * @param name  the item name
     * @param exact exact search based on equalsIgnoreCase
     *
     * @return boolean
     */
    public static boolean hasBankItem(String name, boolean exact) {
        return findBankItem(name, exact) != null;
    }
    //hasBankItem overload to check with id and amount
    public static boolean hasBankItem(int id, int amount) {
        Rs2Item rs2Item = findBankItem(id);
        if (rs2Item == null) return false;
        log.info("Item: " + rs2Item.name + " Amount: " + rs2Item.quantity);
        return findBankItem(Objects.requireNonNull(rs2Item).name, true, amount) != null;
    }
    /**
     * Query count of item inside of bank
     */
    public static int count(String name, boolean exact) {
        Rs2Item bankItem = findBankItem(name, exact);
        if (bankItem == null) return 0;
        return bankItem.quantity;
    }
    /**
     * Query count of item inside of bank
     */
    public static int count(String name) {
        return count(name, false);
    }
    /**
     * Deposits all equipped items into the bank.
     * This method finds and clicks the "Deposit Equipment" button in the bank interface.
     */
    public static void depositEquipment() {
        Widget widget = Rs2Widget.findWidget(SpriteID.BANK_DEPOSIT_EQUIPMENT, null);
        if (widget == null) return;
        Microbot.getMouse().click(widget.getBounds());
    }
    /**
     * Deposits one item quickly into the bank by its ItemWidget.
     *
     * @param rs2Item The ItemWidget representing the item to deposit.
     */
    private static void depositOne(Rs2Item rs2Item) {
        if (!isOpen()) return;
        if (rs2Item == null) return;
        if (!Rs2Inventory.hasItem(rs2Item.id)) return;
        container = BANK_INVENTORY_ITEM_CONTAINER;
        if (Microbot.getVarbitValue(SELECTED_OPTION_VARBIT) == 0) {
            invokeMenu(1, rs2Item);
        } else {
            invokeMenu(2, rs2Item);
        }
    }
    /**
     * Deposits one item quickly by its ID.
     *
     * @param id The ID of the item to deposit.
     */
    public static void depositOne(int id) {
        Rs2Item rs2Item = Rs2Inventory.get(id);
        if (rs2Item == null) return;
        depositOne(rs2Item);
    }
    /**
     * Deposits one item quickly by its name with a partial name match.
     *
     * @param name The name of the item to deposit.
     */
    public static void depositOne(String name, boolean exact) {
        Rs2Item rs2Item = Rs2Inventory.get(name, exact);
        if (rs2Item == null) return;
        depositOne(rs2Item);
    }
    /**
     * Deposits one item quickly by its name with a partial name match.
     *
     * @param name The name of the item to deposit.
     */
    public static void depositOne(String name) {
        depositOne(name, false);
    }
    /**
     * Deposits a specified amount of an item into the inventory.
     * This method checks if the bank window is open, if the provided ItemWidget is valid and
     * if the player has the item in their inventory. If all conditions are met, it calls the
     * 'handleAmount' method to deposit the specified amount of the item into the inventory.
     *
     * @param rs2Item item to handle
     * @param amount  amount to deposit
     */
    private static void depositX(Rs2Item rs2Item, int amount) {
        if (!isOpen()) return;
        if (rs2Item == null) return;
        if (!Rs2Inventory.hasItem(rs2Item.id)) return;
        container = BANK_INVENTORY_ITEM_CONTAINER;
        handleAmount(rs2Item, amount);
    }
    /**
     * Handles the amount for an item widget.
     * <p>
     * This method checks if the current varbit value matches the specified amount.
     * If it does, it executes the menu swapper with the HANDLE_X_SET option.
     * If it doesn't match, it executes the menu swapper with the HANDLE_X_UNSET option,
     * enters the specified amount using the VirtualKeyboard, and presses Enter.
     *
     * @param rs2Item The item to handle.
     * @param amount  The desired amount to set.
     */
    private static void handleAmount(Rs2Item rs2Item, int amount) {
        handleAmount(rs2Item, amount, false);
    }
    /**
     * Handles the amount for an item widget.
     * <p>
     * This method checks if the current varbit value matches the specified amount.
     * If it does, it executes the menu swapper with the HANDLE_X_SET option.
     * If it doesn't match, it executes the menu swapper with the HANDLE_X_UNSET option,
     * enters the specified amount using the VirtualKeyboard, and presses Enter.
     *
     * @param rs2Item The item to handle.
     * @param amount  The desired amount to set.
     * @param safe    will wait for item to appear in inventory before continuing if set to true
     */
    private static void handleAmount(Rs2Item rs2Item, int amount, boolean safe) {
        int inventorySize = Rs2Inventory.size();
        if (Microbot.getVarbitValue(X_AMOUNT_VARBIT) == amount) {
            invokeMenu(HANDLE_X_SET, rs2Item);
            if (safe)
                sleepUntil(() -> inventorySize != Rs2Inventory.size(), 2500);
        } else {
            invokeMenu(HANDLE_X_UNSET, rs2Item);
            sleep(1200);
            Rs2Keyboard.typeString(String.valueOf(amount));
            Rs2Keyboard.enter();
            sleepUntil(() -> Rs2Inventory.hasItem(rs2Item.id), 2500);
        }
    }
    /**
     * deposit x amount of items identified by its name
     * set exact to true if you want to identify by its exact name
     *
     * @param id param amount
     */
    public static void depositX(int id, int amount) {
        Rs2Item rs2Item = Rs2Inventory.get(id);
        if (rs2Item == null) return;
        depositX(rs2Item, amount);
    }
    /**
     * deposit x amount of items identified by its name
     * set exact to true if you want to identify by its exact name
     *
     * @param name param amount
     *             param exact
     */
    private static void depositX(String name, int amount, boolean exact) {
        Rs2Item rs2Item = Rs2Inventory.get(name, exact);
        if (rs2Item == null) return;
        depositX(rs2Item, amount);
    }
    /**
     * deposit x amount of items identified by its name
     *
     * @param name param amount
     */
    public static void depositX(String name, int amount) {
        Rs2Item rs2Item = Rs2Inventory.get(name);
        if (rs2Item == null) return;
        depositX(rs2Item, amount);
    }
    /**
     * deposit all items identified by its ItemWidget
     *
     * @param rs2Item item to deposit
     *
     * @returns did deposit anything
     */
    private static boolean depositAll(Rs2Item rs2Item) {
        if (!isOpen()) return false;
        if (rs2Item == null) return false;
        if (!Rs2Inventory.hasItem(rs2Item.id)) return false;
        container = BANK_INVENTORY_ITEM_CONTAINER;
        invokeMenu(HANDLE_ALL, rs2Item);
        return true;
    }
    /**
     * deposit all items identified by its id
     *
     * @param id searches based on the id
     *
     * @return true if anything deposited
     */
    public static boolean depositAll(int id) {
        Rs2Item rs2Item = Rs2Inventory.get(id);
        if (rs2Item == null) return false;
        return depositAll(rs2Item);
    }
    public static boolean depositAll(Predicate<Rs2Item> predicate) {
        boolean result = false;
        List<Rs2Item> items = Rs2Inventory.items().stream().filter(predicate).distinct().collect(Collectors.toList());
        for (Rs2Item item : items) {
            if (item == null) continue;
            depositAll(item);
            sleep(300, 600);
            result = true;
        }
        return result;
    }
    // boolean to determine if we still have items to deposit
    private static boolean isDepositing(Predicate<Rs2Item> filter) {
        List<Rs2Item> itemsToDeposit = Rs2Inventory.all(filter)
                .stream()
                .filter(Objects::nonNull)
                .filter(Predicates.distinctByProperty(Rs2Item::getName))
                .collect(Collectors.toList());
        return !itemsToDeposit.isEmpty();
    }
    /**
     * deposit all items identified by its name
     * set exact to true if you want to be identified by its exact name
     *
     * @param name  name to search
     * @param exact does an exact search equalsIgnoreCase
     */
    public static void depositAll(String name, boolean exact) {
        Rs2Item rs2Item = Rs2Inventory.get(name);
        if (rs2Item == null) return;
        depositAll(rs2Item);
    }
    /**
     * deposit all items identified by its name
     *
     * @param name item name to search
     */
    public static void depositAll(String name) {
        depositAll(name, false);
    }
    /**
     * deposit all items
     */
    public static void depositAll() {
        Microbot.status = "Deposit all";
        if (Rs2Inventory.isEmpty()) return;
        if (!Rs2Bank.isOpen()) return;
        Widget widget = Rs2Widget.findWidget(SpriteID.BANK_DEPOSIT_INVENTORY, null);
        if (widget == null) return;
        Microbot.getMouse().click(widget.getBounds());
        sleepUntil(Rs2Inventory::isEmpty);
    }
    /**
     * Deposits all items in the player's inventory into the bank, except for the items with the specified IDs.
     * This method uses a lambda function to filter out the items with the specified IDs from the deposit operation.
     *
     * @param ids The IDs of the items to be excluded from the deposit.
     *
     * @return true if any items were deposited, false otherwise.
     */
    public static boolean depositAllExcept(Integer... ids) {
        return depositAll(x -> Arrays.stream(ids).noneMatch(id -> id == x.id));
    }
    /**
     * Deposits all items in the player's inventory into the bank, except for the items with the specified names.
     * This method uses a lambda function to filter out the items with the specified names from the deposit operation.
     *
     * @param names The names of the items to be excluded from the deposit.
     *
     * @return true if any items were deposited, false otherwise.
     */
    public static boolean depositAllExcept(String... names) {
        return depositAll(x -> Arrays.stream(names).noneMatch(name -> name.equalsIgnoreCase(x.name)));
    }
    /**
     * Deposits all items in the player's inventory into the bank, except for the items with the specified names.
     * This method uses a lambda function to filter out the items with the specified names from the deposit operation.
     *
     * @param names The names of the items to be excluded from the deposit.
     *
     * @return true if any items were deposited, false otherwise.
     */
    public static boolean depositAllExcept(List<String> names) {
        return depositAll(x -> names.stream().noneMatch(name -> name.equalsIgnoreCase(x.name)));
    }
    /**
     * Deposits all items in the player's inventory into the bank, except for the items with the specified names.
     * This method uses a lambda function to filter out the items with the specified names from the deposit operation.
     * It also allows for a delay between deposit operations.
     *
     * @param names The names of the items to be excluded from the deposit.
     *
     * @return true if any items were deposited, false otherwise.
     */
    public static boolean depositAllExcept(boolean exact, String... names) {
        if (!exact)
            return depositAll(x -> Arrays.stream(names).noneMatch(name -> x.name.contains(name.toLowerCase())));
        else
            return depositAll(x -> Arrays.stream(names).noneMatch(name -> name.equalsIgnoreCase(x.name)));
    }
    /**
     * withdraw one item identified by its ItemWidget.
     *
     * @param rs2Item item to withdraw
     */
    private static void withdrawOne(Rs2Item rs2Item) {
        if (!isOpen()) return;
        if (rs2Item == null) return;
        if (Rs2Inventory.isFull()) return;
        container = BANK_ITEM_CONTAINER;
        if (Microbot.getVarbitValue(SELECTED_OPTION_VARBIT) == 0) {
            invokeMenu(1, rs2Item);
        } else {
            invokeMenu(2, rs2Item);
        }
    }
    /**
     * withdraw one item identified by its id.
     *
     * @param id the item id
     */
    public static void withdrawOne(int id) {
        withdrawOne(findBankItem(id));
    }
    public static void withdrawItem(String name) {
        withdrawOne(name);
    }
    public static void withdrawItem(int id) {
        withdrawOne(id);
    }
    public static void withdrawItem(boolean checkInv, int id) {
        if (checkInv && Rs2Inventory.hasItem(id)) return;
        withdrawOne(id);
    }
    public static void withdrawItem(boolean checkInv, String name) {
        if (checkInv && Rs2Inventory.hasItem(name)) return;
        withdrawOne(name);
    }
    /**
     * withdraw one item identified by its name.
     * set exact to true if you want to identify by the exact name.
     *
     * @param name  the item name
     * @param exact boolean
     */
    public static void withdrawOne(String name, boolean exact) {
        withdrawOne(findBankItem(name, exact));
    }
    /**
     * withdraw one item identified by its name
     *
     * @param name the item name
     */
    public static void withdrawOne(String name) {
        withdrawOne(name, false);
    }
    public static void withdrawOne(String name, int sleepTime) {
        withdrawOne(name, false);
        sleep(sleepTime);
    }
    /**
     * withdraw x amount of items identified by its ItemWidget.
     *
     * @param rs2Item Item to handle
     * @param amount  int
     */
    private static void withdrawXItem(Rs2Item rs2Item, int amount) {
        if (!isOpen()) return;
        if (rs2Item == null) return;
        if (Rs2Inventory.isFull() && !Rs2Inventory.hasItem(rs2Item.id) && !rs2Item.isStackable()) return;
        container = BANK_ITEM_CONTAINER;
        handleAmount(rs2Item, amount);
    }
    /**
     * Checks inventory before withdrawing item
     *
     * @param checkInv check inventory before withdrawing item
     * @param id       item id
     * @param amount   amount to withdraw
     */
    public static void withdrawX(boolean checkInv, int id, int amount) {
        if (checkInv && !Rs2Bank.hasItem(id)) return;
        withdrawX(id, amount);
    }
    /**
     * Checks inventory before withdrawing item
     *
     * @param checkInv check inventory before withdrawing item
     * @param name     item name
     * @param amount   amount to withdraw
     */
    public static void withdrawX(boolean checkInv, String name, int amount) {
        withdrawX(checkInv, name, amount, false);
    }
    /**
     * Checks inventory before withdrawing item
     *
     * @param checkInv check inventory before withdrawing item
     * @param name     item name
     * @param amount   amount to withdraw
     * @param exact    exact search based on equalsIgnoreCase
     */
    public static void withdrawX(boolean checkInv, String name, int amount, boolean exact) {
        if (checkInv && Rs2Inventory.hasItem(name)) return;
        withdrawX(name, amount, exact);
    }
    /**
     * withdraw x amount of items identified by its id.
     *
     * @param id     item id to search
     * @param amount amount to withdraw
     */
    public static void withdrawX(int id, int amount) {
        withdrawXItem(findBankItem(id), amount);
    }
    /**
     * withdraw x amount of items identified by its name.
     * set exact to true if you want to identify an item by its exact name.
     *
     * @param name   item name to search
     * @param amount amount to withdraw
     * @param exact  exact search based on equalsIgnoreCase
     */
    private static void withdrawX(String name, int amount, boolean exact) {
        withdrawXItem(findBankItem(name, exact), amount);
    }
    /**
     * withdraw x amount of items identified by its name
     *
     * @param name   item name to search
     * @param amount amount to withdraw
     */
    public static void withdrawX(String name, int amount) {
        withdrawXItem(findBankItem(name, false), amount);
    }
    /**
     * withdraw all items identified by its ItemWidget.
     *
     * @param rs2Item Item to withdraw
     *
     * @return
     */
    private static boolean withdrawAll(Rs2Item rs2Item) {
        if (!isOpen()) return false;
        if (rs2Item == null) return false;
        if (Rs2Inventory.isFull()) return false;
        container = BANK_ITEM_CONTAINER;
        invokeMenu(HANDLE_ALL, rs2Item);
        return true;
    }
    public static void withdrawAll(boolean checkInv, String name) {
        withdrawAll(checkInv, name, false);
    }
    /**
     * withdraw all items identified by its name.
     *
     * @param checkInv check if item is already in inventory
     * @param name     item name
     * @param exact    name
     */
    public static void withdrawAll(boolean checkInv, String name, boolean exact) {
        if (checkInv && !Rs2Bank.hasItem(name, exact)) return;
        Rs2Item item = findBankItem(name, exact);
        withdrawAll(item);
    }
    /**
     * @param name
     */
    public static void withdrawAll(String name) {
        withdrawAll(false, name, false);
    }
    /**
     * withdraw all items identified by its id.
     *
     * @param id item id to search
     *
     * @return
     */
    public static boolean withdrawAll(int id) {
        return withdrawAll(findBankItem(id));
    }
    /**
     * withdraw all items identified by its name
     * set the boolean exact to true if you want to identify the item by the exact name
     *
     * @param name  item name to search
     * @param exact exact search based on equalsIgnoreCase
     */
    public static void withdrawAll(String name, boolean exact) {
        withdrawAll(findBankItem(name, exact));
    }
    /**
     * wear an item identified by its ItemWidget.
     *
     * @param rs2Item item to wear
     */
    private static void wearItem(Rs2Item rs2Item) {
        if (!isOpen()) return;
        if (rs2Item == null) return;
        container = BANK_INVENTORY_ITEM_CONTAINER;
        invokeMenu(8, rs2Item);
    }
    /**
     * wear an item identified by the name contains
     *
     * @param name item name to search based on contains(string)
     */
    public static void wearItem(String name) {
        wearItem(Rs2Inventory.get(name, false));
    }
    /**
     * wear an item identified by its exact name.
     *
     * @param name  item name to search
     * @param exact exact search based on equalsIgnoreCase
     */
    public static void wearItem(String name, boolean exact) {
        wearItem(Rs2Inventory.get(name, exact));
    }
    /**
     * withdraw all and equip item identified by its id.
     *
     * @param id item id
     */
    public static void withdrawXAndEquip(int id, int amount) {
        if (Rs2Equipment.isWearing(id)) return;
        withdrawX(id, amount);
        sleepUntil(() -> Rs2Inventory.hasItem(id));
        wearItem(id);
    }
    /**
     * withdraw all and equip item identified by its id.
     *
     * @param name item name
     */
    public static void withdrawAllAndEquip(String name) {
        if (Rs2Equipment.isWearing(name)) return;
        withdrawAll(name);
        sleepUntil(() -> Rs2Inventory.hasItem(name));
        wearItem(name);
    }
    /**
     * withdraw all and equip item identified by its id.
     *
     * @param id item id
     */
    public static void withdrawAllAndEquip(int id) {
        if (Rs2Equipment.hasEquipped(id)) return;
        withdrawAll(id);
        sleepUntil(() -> Rs2Inventory.hasItem(id));
        wearItem(id);
    }
    /**
     * withdraw and equip item identified by its id.
     *
     * @param name item name
     */
    public static void withdrawAndEquip(String name) {
        if (Rs2Equipment.isWearing(name)) return;
        withdrawOne(name);
        sleepUntil(() -> Rs2Inventory.hasItem(name), 1800);
        wearItem(name);
    }
    /**
     * withdraw and equip item identified by its id.
     *
     * @param id item id
     */
    public static void withdrawAndEquip(int id) {
        if (Rs2Equipment.hasEquipped(id)) return;
        withdrawOne(id);
        sleepUntil(() -> Rs2Inventory.hasItem(id));
        wearItem(id);
    }
    /**
     * withdraw items identified by one or more ids
     *
     * @param ids item ids
     */
    public static void withdrawItems(int... ids) {
        for (int id : ids) {
            withdrawOne(id);
        }
    }
    /**
     * Deposit items identified by one or more ids
     *
     * @param ids item ids
     */
    public static void depositItems(int... ids) {
        for (int id : ids) {
            depositOne(id);
        }
    }
    /**
     * Opens the bank searching for bank booth first, then chest and lastly npc
     *
     * @return True if bank was successfully opened, otherwise false.
     */
    public static boolean openBank() {
        Microbot.status = "Opening bank";
        try {
            if (Microbot.getClient().isWidgetSelected())
                Microbot.getMouse().click();
            if (isOpen()) return true;
            boolean action = false;
            GameObject bank = Rs2GameObject.findBank();
            if (bank == null) {
                GameObject chest = Rs2GameObject.findChest();
                if (chest == null) {
                    NPC npc = Rs2Npc.getBankerNPC();
                    if (npc == null) return false;
                    action = Rs2Npc.interact(npc, "bank");
                } else {
                    action = Rs2GameObject.interact(chest, "use");
                }
            } else {
                action = Rs2GameObject.interact(bank, "bank");
            }
            if (action) {
                sleepUntil(() -> isOpen() || Rs2Widget.hasWidget("Please enter your PIN"), 2500);
                sleep(600, 1000);
            }
            return action;
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
        return false;
    }
    public static boolean openBank(NPC npc) {
        Microbot.status = "Opening bank";
        try {
            if (isOpen()) return true;
            if (Rs2Inventory.isItemSelected()) Microbot.getMouse().click();
            if (npc == null) return false;
            boolean interactResult = Rs2Npc.interact(npc, "bank");
            if (!interactResult) {
                return false;
            }
            sleepUntil(Rs2Bank::isOpen);
            sleep(600, 1000);
            return true;
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
        return false;
    }
    /**
     * open bank identified by tile object.
     *
     * @param object TileObject
     *
     * @return true if bank is open
     */
    public static boolean openBank(TileObject object) {
        Microbot.status = "Opening bank";
        try {
            if (isOpen()) return true;
            if (Rs2Inventory.isItemSelected()) Microbot.getMouse().click();
            if (object == null) return false;
            boolean interactResult = Rs2GameObject.interact(object, "bank");
            if (!interactResult) {
                return false;
            }
            sleepUntil(Rs2Bank::isOpen);
            sleep(600, 1000);
            return true;
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
        return false;
    }
    /**
     * Sets the values of the inventoryWidget
     *
     * @param id item id
     */
    private static void handleWearItem(int id) {
        Rs2Item rs2Item = Rs2Inventory.get(id);
        if (rs2Item == null) return;
        container = BANK_INVENTORY_ITEM_CONTAINER;
        invokeMenu(8, rs2Item);
    }
    /**
     * Tries to wear an item identified by its id.
     *
     * @param id item id
     */
    public static void wearItem(int id) {
        handleWearItem(id);
    }
    /**
     * find an item in the bank identified by its id.
     *
     * @param id item id to find
     *
     * @return bankItem
     */
    @SuppressWarnings("UnnecessaryLocalVariable")
    private static Rs2Item findBankItem(int id) {
        if (bankItems == null) return null;
        if (bankItems.stream().findAny().isEmpty()) return null;
        Rs2Item bankItem = bankItems.stream().filter(x -> x.id == id).findFirst().orElse(null);
        return bankItem;
    }
    /**
     * Finds an item in the bank based on its name.
     *
     * @param name  The name of the item.
     * @param exact If true, requires an exact name match.
     *
     * @return The item widget, or null if the item isn't found.
     */
    @SuppressWarnings("UnnecessaryLocalVariable")
    private static Rs2Item findBankItem(String name, boolean exact) {
        return findBankItem(name, exact, 1);
    }
    /**
     * Finds an item in the bank based on its name.
     *
     * @param name   The name of the item.
     * @param exact  If true, requires an exact name match.
     * @param amount the amount needed to find in the bank
     *
     * @return The item widget, or null if the item isn't found.
     */
    @SuppressWarnings("UnnecessaryLocalVariable")
    private static Rs2Item findBankItem(String name, boolean exact, int amount) {
        if (bankItems == null) return null;
        if (bankItems.stream().findAny().isEmpty()) return null;
        final String lowerCaseName = name.toLowerCase();
        Rs2Item bankItem = bankItems.stream().filter(x -> exact
                ? x.name.equalsIgnoreCase(lowerCaseName)
                : x.name.toLowerCase().contains(lowerCaseName)).findFirst().orElse(null);
        if (bankItem == null || bankItem.quantity < amount)
            return null;
        return bankItem;
    }
    /**
     * Get the nearest bank
     *
     * @return BankLocation
     */
    public static BankLocation getNearestBank() {
        BankLocation nearest = null;
        double dist = Double.MAX_VALUE;
        int y = Microbot.getClient().getLocalPlayer().getWorldLocation().getY();
        boolean isInCave = y > 9000;
        if (isInCave) {
            y -= 6300; //minus -6300 to set y to the surface
        }
        WorldPoint local = new WorldPoint(Microbot.getClient().getLocalPlayer().getWorldLocation().getX(), y, Microbot.getClient().getPlane());
        for (BankLocation bankLocation : BankLocation.values()) {
            if (!bankLocation.hasRequirements()) continue;
            if (bankLocation.hasException()) {
                nearest = bankLocation;
                break;
            }
            double currDist = local.distanceTo2D(bankLocation.getWorldPoint());
            if (nearest == null || currDist < dist) {
                dist = currDist;
                nearest = bankLocation;
            }
        }
        return nearest;
    }
    /**
     * Walk to the closest bank
     *
     * @return true if player location is less than 4 tiles away from the bank location
     */
    public static boolean walkToBank() {
        return walkToBank(getNearestBank());
    }
    /**
     * Walk to bank location
     * 
     * @param bankLocation 
     * @return true if player location is less than 4 tiles away from the bank location
     */
    public static boolean walkToBank(BankLocation bankLocation) {
        if (Rs2Bank.isOpen()) return true;
        Rs2Player.toggleRunEnergy(true);
        Microbot.status = "Walking to nearest bank " + bankLocation.toString();
        Rs2Walker.walkTo(bankLocation.getWorldPoint(), 4);
        return bankLocation.getWorldPoint().distanceTo2D(Microbot.getClient().getLocalPlayer().getWorldLocation()) <= 4;
    }
    /**
     * Distance from the nearest bank location
     * 
     * @param distance 
     * @return true if player location is less than distance away from the bank location
     */
    public static boolean isNearBank(int distance) {
        return isNearBank(getNearestBank(), distance);
    }
    /**
     * Distance from bank location
     * 
     * @param bankLocation 
     * @param distance 
     * @return true if player location is less than distance away from the bank location
     */
    public static boolean isNearBank(BankLocation bankLocation, int distance) {
        int distanceToBank = Microbot.getClient().getLocalPlayer().getWorldLocation().distanceTo(bankLocation.getWorldPoint());
        return distanceToBank <= distance;
    }
    /**
     * Walk to the closest bank
     *
     * @return true if bank interface is open
     */
    public static boolean walkToBankAndUseBank() {
        return walkToBankAndUseBank(getNearestBank());
    }
    /**
     * Walk to bank location & use bank
     *
     * @param bankLocation 
     * @return true if bank interface is open
     */
    public static boolean walkToBankAndUseBank(BankLocation bankLocation) {
        if (Rs2Bank.isOpen()) return true;
        Rs2Player.toggleRunEnergy(true);
        if (Rs2Bank.useBank()) return true;
        Microbot.status = "Walking to nearest bank " + bankLocation.toString();
        boolean result = bankLocation.getWorldPoint().distanceTo(Microbot.getClient().getLocalPlayer().getWorldLocation()) <= 8;
        if (result) {
            return Rs2Bank.useBank();
        } else {
            Rs2Walker.walkTo(bankLocation.getWorldPoint());
        }
        return false;
    }
    /**
     * Use bank or chest
     *
     * @return true if bank is opened
     */
    public static boolean useBank() {
        return openBank();
    }
    /**
     * Updates the bank items in memory based on the provided event.
     *
     * @param e The event containing the latest bank items.
     */
    public static void storeBankItemsInMemory(ItemContainerChanged e) {
        List<Rs2Item> list = updateItemContainer(InventoryID.BANK.getId(), e);
        if (list != null)
            bankItems = list;
    }
    public static boolean handleBankPin(String pin) {
        Widget bankPinWidget = Rs2Widget.getWidget(ComponentID.BANK_PIN_CONTAINER);
        boolean isBankPinVisible = Microbot.getClientThread().runOnClientThread(() -> bankPinWidget != null && !bankPinWidget.isHidden());
        if (isBankPinVisible) {
            Rs2Keyboard.typeString(pin);
            sleep(50, 350);
            Rs2Keyboard.enter();
            return true;
        }
        return false;
    }
    /**
     * Banks items if your inventory does not have enough emptyslots (0 emptyslots being full). Will walk back to the initialplayerlocation passed as param
     *
     * @param itemNames
     * @param initialPlayerLocation
     * @param emptySlotCount
     * @return
     */
    public static boolean bankItemsAndWalkBackToOriginalPosition(List<String> itemNames, WorldPoint initialPlayerLocation, int emptySlotCount) {
        return bankItemsAndWalkBackToOriginalPosition(itemNames, getNearestBank(), initialPlayerLocation, emptySlotCount, 4);
    }
    /**
     * Banks items if your inventory is full. Will walk back to the initialplayerlocation passed as param
     *
     * @param itemNames
     * @param initialPlayerLocation
     * @return
     */
    public static boolean bankItemsAndWalkBackToOriginalPosition(List<String> itemNames, WorldPoint initialPlayerLocation) {
        return bankItemsAndWalkBackToOriginalPosition(itemNames, getNearestBank(), initialPlayerLocation, 0, 4);
    }
    /**
     * Banks at specific bank location if your inventory does not have enough emptyslots (0 emptyslots being full). Will walk back to the initialplayerlocation passed as param
     *
     * @param itemNames
     * @param initialPlayerLocation
     * @param bankLocation
     * @param emptySlotCount
     * @param distance
     * @return
     */
    public static boolean bankItemsAndWalkBackToOriginalPosition(List<String> itemNames, BankLocation bankLocation, WorldPoint initialPlayerLocation, int emptySlotCount, int distance) {
        if (Rs2Inventory.getEmptySlots() <= emptySlotCount) {
            boolean isBankOpen = Rs2Bank.walkToBankAndUseBank(bankLocation);
            if (isBankOpen) {
                for (String itemName : itemNames) {
                    Rs2Bank.depositAll(x -> x.name.toLowerCase().contains(itemName));
                }
            }
            return false;
        }
        if (distance > 10)
            distance = 10;
        if (initialPlayerLocation.distanceTo(Rs2Player.getWorldLocation()) > distance) {
            Rs2Walker.walkTo(initialPlayerLocation, distance);
        } else {
            Rs2Walker.walkFastCanvas(initialPlayerLocation);
        }
        return !(Rs2Inventory.getEmptySlots() <= emptySlotCount) && initialPlayerLocation.distanceTo(Rs2Player.getWorldLocation()) <= distance;
    }
    /**
     * Banks items if your inventory does not have enough emptyslots (0 emptyslots being full). Will walk back to the initialplayerlocation passed as param
     *
     * @param itemNames
     * @param initialPlayerLocation
     * @param emptySlotCount
     * @param distance
     *
     * @return
     */
    public static boolean bankItemsAndWalkBackToOriginalPosition(List<String> itemNames, WorldPoint initialPlayerLocation, int emptySlotCount, int distance) {
        return bankItemsAndWalkBackToOriginalPosition(itemNames, getNearestBank(), initialPlayerLocation, emptySlotCount, distance);
    }
    /**
     * Check if "noted" button is toggled on
     *
     * @return
     */
    public static boolean hasWithdrawAsNote() {
        return Microbot.getVarbitValue(WITHDRAW_AS_NOTE_VARBIT) == 1;
    }
    /**
     * enable withdraw noted in your bank
     *
     * @return
     */
    public static boolean setWithdrawAsNote() {
        if (hasWithdrawAsNote()) return true;
        Rs2Widget.clickWidget(786456);
        sleep(600);
        return hasWithdrawAsNote();
    }
    /**
     * Withdraw items from the lootTrackerPlugin
     *
     * @param npcName
     *
     * @return
     */
    public static boolean withdrawLootItems(String npcName, List<String> itemsToNotSell) {
        boolean isAtGe = Rs2GrandExchange.walkToGrandExchange();
        if (isAtGe) {
            boolean isBankOpen = Rs2Bank.useBank();
            if (!isBankOpen) return false;
        }
        Rs2Bank.depositAll();
        boolean itemFound = false;
        boolean hasWithdrawAsNote = Rs2Bank.setWithdrawAsNote();
        if (!hasWithdrawAsNote) return false;
        for (LootTrackerRecord lootTrackerRecord : Microbot.getAggregateLootRecords()) {
            if (!lootTrackerRecord.getTitle().equalsIgnoreCase(npcName)) continue;
            for (LootTrackerItem lootTrackerItem : lootTrackerRecord.getItems()) {
                if (itemsToNotSell.stream().anyMatch(x -> x.trim().equalsIgnoreCase(lootTrackerItem.getName())))
                    continue;
                int itemId = lootTrackerItem.getId();
                ItemComposition itemComposition = Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getItemDefinition(lootTrackerItem.getId()));
                if (Arrays.stream(itemComposition.getInventoryActions()).anyMatch(x -> x != null && x.equalsIgnoreCase("eat")))
                    continue;
                final boolean isNoted = itemComposition.getNote() == 799;
                if (!itemComposition.isTradeable() && !isNoted) continue;
                if (isNoted) {
                    final int unnotedItemId = lootTrackerItem.getId() - 1; //get the unnoted id of the item
                    itemComposition = Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getItemDefinition(unnotedItemId));
                    if (!itemComposition.isTradeable()) continue;
                    itemId = unnotedItemId;
                }
                boolean didWithdraw = Rs2Bank.withdrawAll(itemId);
                if (didWithdraw) {
                    itemFound = true;
                }
            }
        }
        Rs2Bank.closeBank();
        return itemFound;
    }
    private static Widget getBankSizeWidget() {
        return Microbot.getClientThread().runOnClientThread(() -> {
            Widget bankContainerWidget = Microbot.getClient().getWidget(ComponentID.BANK_ITEM_COUNT_TOP);
            return bankContainerWidget;
        });
    }
    /**
     * Retrieves the total number of items in the bank.
     * <p>
     * This method fetches the bank size widget and parses its text to determine
     * the total number of items currently stored in the bank.
     *
     * @return The total number of items in the bank. Returns 0 if the bank widget is not found.
     */
    public static int getBankItemCount() {
        Widget bank = getBankSizeWidget();
        if (bank == null) return 0;
        return Integer.parseInt(bank.getText());
    }
    /**
     * Retrieves the list of bank tab widgets.
     * <p>
     * This method runs on the client thread to fetch the bank tab container widget
     * and then retrieves its dynamic children, which represent the tabs in the bank.
     * </p>
     *
     * @return A list of bank tab widgets, or null if the bank tab container widget is not found.
     */
    public static List<Widget> getTabs() {
        return Microbot.getClientThread().runOnClientThread(() -> {
            Widget bankContainerWidget = Microbot.getClient().getWidget(ComponentID.BANK_TAB_CONTAINER);
            if (bankContainerWidget != null) {
                // get children and filter out the tabs that don't have the Action Collapse tab
                return Arrays.asList(bankContainerWidget.getDynamicChildren());
            }
            return null;
        });
    }
    /**
     * Retrieves the list of item widgets in the bank container.
     * <p>
     * This method runs on the client thread to fetch the bank container widget
     * and then retrieves its dynamic children, which represent the items in the bank.
     * </p>
     *
     * @return A list of item widgets in the bank container, or null if the bank container widget is not found.
     */
    public static List<Widget> getItems() {
        return Microbot.getClientThread().runOnClientThread(() -> {
            Widget bankContainerWidget = Microbot.getClient().getWidget(BANK_ITEM_CONTAINER);
            if (bankContainerWidget != null) {
                // Get children and filter out the tabs that don't have the Action Collapse tab
                return Arrays.asList(bankContainerWidget.getDynamicChildren());
            }
            return null;
        });
    }
    /**
     * Retrieves the widget of an item based on the given slot ID.
     *
     * @param slotId the ID of the slot to retrieve the widget from
     *
     * @return the Widget associated with the specified slot ID, or null if the slot ID is out of range or if the items list is null
     */
    public static Widget getItemWidget(int slotId) {
        List<Widget> items = getItems();
        if (items == null) return null;
        if (slotId < 0 || slotId >= items.size()) return null;
        return items.get(slotId);
    }
    /**
     * Retrieves the bounding rectangle of an item widget based on the given slot ID.
     *
     * @param slotId the ID of the slot to retrieve the widget bounds from
     *
     * @return the bounds of the item widget as a Rectangle, or null if the widget is not found
     */
    public static Rectangle getItemBounds(int slotId) {
        Widget itemWidget = getItemWidget(slotId);
        if (itemWidget == null) return null;
        return itemWidget.getBounds();
    }
    /**
     * Gets the current tab index of the user's interface.
     *
     * @return the index of the currently selected tab
     */
    public static int getCurrentTab() {
        return Microbot.getVarbitValue(CURRENT_BANK_TAB);
    }
    /**
     * Checks if the main tab (index 0) is currently open.
     *
     * @return true if the main tab is open, false otherwise
     */
    public static boolean isMainTabOpen() {
        return isTabOpen(0);
    }
    /**
     * Checks if a tab with the given index is currently open.
     *
     * @param index the index of the tab to check
     *
     * @return true if the specified tab is open, false otherwise
     */
    public static boolean isTabOpen(int index) {
        return getCurrentTab() == index;
    }
    /**
     * Opens the main tab (index 0) in the user's interface.
     */
    public static void openMainTab() {
        openTab(0);
    }
    /**
     * Opens a tab based on the given index.
     *
     * @param index the index of the tab to open
     *              If the index is invalid or the tabs list is null, no action will be taken.
     */
    public static void openTab(int index) {
        List<Widget> tabs = getTabs();
        if (tabs == null) return;
        if (index < 0 || index > tabs.size()) return;
        Rs2Widget.clickWidgetFast(tabs.get(index + 10), 10 + index);
        Rs2Random.wait(100, 200);
    }
    /**
     * Updates the item counts for each bank tab by retrieving values from corresponding variables.
     * This method fetches the item counts for each tab (1-9) and stores them in the bankTabCounts array.
     */
    private static void updateTabCounts() {
        bankTabCounts[0] = Microbot.getVarbitValue(BANK_TAB_ONE_COUNT);
        bankTabCounts[1] = Microbot.getVarbitValue(BANK_TAB_TWO_COUNT);
        bankTabCounts[2] = Microbot.getVarbitValue(BANK_TAB_THREE_COUNT);
        bankTabCounts[3] = Microbot.getVarbitValue(BANK_TAB_FOUR_COUNT);
        bankTabCounts[4] = Microbot.getVarbitValue(BANK_TAB_FIVE_COUNT);
        bankTabCounts[5] = Microbot.getVarbitValue(BANK_TAB_SIX_COUNT);
        bankTabCounts[6] = Microbot.getVarbitValue(BANK_TAB_SEVEN_COUNT);
        bankTabCounts[7] = Microbot.getVarbitValue(BANK_TAB_EIGHT_COUNT);
        bankTabCounts[8] = Microbot.getVarbitValue(BANK_TAB_NINE_COUNT);
    }
    /**
     * Determines the tab number that contains the item based on its slot ID.
     *
     * @param itemSlotId the slot ID of the item
     *
     * @return the 1-indexed tab number containing the item, or 0 if the item is in the main tab
     */
    private static int getItemTab(int itemSlotId) {
        int totalSlots = 0;
        // Loop through each tab's count and determine the tab for the item
        for (int i = 0; i < bankTabCounts.length; i++) {
            totalSlots += bankTabCounts[i];
            if (itemSlotId < totalSlots) {
                return i + 1; // Return tab number (1-indexed)
            }
        }
        // If itemSlotId is above all the tabs, it is in tab 0
        return 0;
    }
    /**
     * Retrieves the tab number of a bank item based on its slot ID.
     * Updates the tab counts before determining which tab the item belongs to.
     *
     * @param itemSlotId the slot ID of the bank item
     *
     * @return the tab number containing the item, or -1 if the slot ID is invalid
     */
    public static int getItemTabForBankItem(int itemSlotId) {
        // Update tab counts before checking which tab the item is in
        updateTabCounts();
        // Get the total number of items in the bank
        int totalItemsInBank = getBankItemCount();
        // Ensure the slot ID is within valid range
        if (itemSlotId < 0 || itemSlotId >= totalItemsInBank) {
            return -1;  // Invalid slot ID
        }
        // Determine which tab the item is in
        return getItemTab(itemSlotId);
    }
    /**
     * Counts the partial rows present in each tab based on the number of items in each tab.
     * A partial row is considered if a tab does not have enough items to fully fill a row.
     *
     * @return an array of integers where each element is 1 if the tab has a partial row, 0 otherwise
     */
    private static int[] countPartialRowsInTabs() {
        int[] partialRowCounts = new int[bankTabCounts.length];
        for (int i = 0; i < bankTabCounts.length; i++) {
            int totalItemsInTab = bankTabCounts[i];
            // If there's a remainder, then there is a partially filled row
            if (totalItemsInTab % BANK_ITEMS_PER_ROW != 0) {
                partialRowCounts[i] = 1;
            } else {
                partialRowCounts[i] = 0;
            }
        }
        return partialRowCounts;
    }
    /**
     * Calculates the total number of partial rows in the bank across all specified tabs.
     *
     * @param numberOfTabs the number of tabs to consider when calculating partial rows
     *
     * @return the total number of partial rows in the specified tabs
     */
    private static int calculatePartialRowsInBank(int numberOfTabs) {
        int totalPartialRows = 0;
        // Get the partial row counts for each tab
        int[] partialRowCounts = countPartialRowsInTabs();
        // Calculate the total number of partial rows
        for (int i = 0; i < numberOfTabs; i++) {
            totalPartialRows += partialRowCounts[i];
        }
        return totalPartialRows;
    }
    /**
     * Calculates the vertical scroll position (scrollY) required to make a specific item visible in the bank view.
     *
     * @param slotId the slot ID of the item to scroll to
     *
     * @return the calculated scrollY value needed to display the item at the top of the bank view
     */
    private static int calculateScrollYFromSlotId(int slotId) {
        int row;
        int scrollY;
        // Get total items in tabs 1-9
        int totalItemsInTabs1To9 = bankTabCounts[0] + bankTabCounts[1] + bankTabCounts[2] + bankTabCounts[3] +
                bankTabCounts[4] + bankTabCounts[5] + bankTabCounts[6] + bankTabCounts[7] +
                bankTabCounts[8];
        // Get the current tab selected
        int currentTab = getCurrentTab();
        // Calculate the rows only within the selected tab
        if (currentTab == 0) {
            // Determine if the slotId belongs to tab 0 or one of the other tabs
            if (slotId >= totalItemsInTabs1To9) {
                // The item belongs to tab 0
                int tab0SlotId = slotId - totalItemsInTabs1To9;
                row = tab0SlotId / BANK_ITEMS_PER_ROW;
            } else {
                // The item belongs to tabs 1-9
                int totalItemsInBank = getBankItemCount();
                int tab0SlotId = slotId + (totalItemsInBank - totalItemsInTabs1To9);
                row = tab0SlotId / BANK_ITEMS_PER_ROW;
                row += calculatePartialRowsInBank(getItemTab(slotId));
            }
        } else {
            // If a tab from 1-9 is selected, calculate rows within that tab
            int itemsBeforeSelectedTab = 0;
            for (int i = 0; i < currentTab - 1; i++) {
                itemsBeforeSelectedTab += bankTabCounts[i];  // Sum items from previous tabs
            }
            // Calculate the position relative to the selected tab
            int tabSlotId = slotId - itemsBeforeSelectedTab;
            // Only calculate rows within the selected tab
            row = tabSlotId / BANK_ITEMS_PER_ROW;
        }
        // Calculate the scrollY based on the row within the selected tab
        scrollY = row * (BANK_ITEM_HEIGHT + BANK_ITEM_Y_PADDING);
        // Get the widget that displays the bank items
        Widget w = Microbot.getClient().getWidget(BANK_ITEM_CONTAINER);
        // Check the height of the bank window to adjust scrolling if necessary
        assert w != null;
        int bankHeight = w.getHeight() / (BANK_ITEM_HEIGHT + BANK_ITEM_Y_PADDING);
        // Calculate the minimum scrollY to ensure the item is visible at the top of the window
        // This would be the scrollY that places the item's row at the very top of the visible area
        int minScrollY = scrollY - (bankHeight) * (BANK_ITEM_HEIGHT + BANK_ITEM_Y_PADDING);
        // Ensure that minScrollY is non-negative, since scrollY cannot be negative
        if (minScrollY < 0) {
            minScrollY = 0;
        }
        // check if the item is already visible by checking if currentScrollY is a value between minScrollY and scrollY
        int currentScrollY = w.getScrollY();
        if (currentScrollY >= minScrollY && currentScrollY <= scrollY) {
            return currentScrollY;
        }
        if (minScrollY == 0)
            return minScrollY;
        // return a value that is within the bounds of the scroll bar
        return Rs2Random.nextInt(minScrollY, scrollY, 0.5, true);
    }
    /**
     * Scrolls the bank view to make a specified item slot visible.
     *
     * @param slotId the slot ID of the item to scroll to
     */
    public static void scrollBankToSlot(int slotId) {
        int scrollY = calculateScrollYFromSlotId(slotId);
        Widget w = Microbot.getClient().getWidget(BANK_ITEM_CONTAINER);
        if (w != null) {
            Microbot.getClientThread().invokeLater(() -> {
                Microbot.getClient().setVarcIntValue(VarClientInt.BANK_SCROLL, scrollY);
                Microbot.getClient().runScript(ScriptID.UPDATE_SCROLLBAR, ComponentID.BANK_SCROLLBAR, BANK_ITEM_CONTAINER, scrollY);
            });
            w.setScrollY(scrollY);
            Microbot.getClient().setVarcIntValue(VarClientInt.BANK_SCROLL, scrollY);
            Microbot.getClientThread().invokeLater(() ->
                    Microbot.getClient().runScript(ScriptID.UPDATE_SCROLLBAR,
                            ComponentID.BANK_SCROLLBAR,
                            BANK_ITEM_CONTAINER,
                            scrollY));
        }
    }
    /**
     * Tries to hover the mouse over the bank object or bank NPC.
     *
     * @return True if bank was successfully hovered over, otherwise false.
     */
    public static boolean preHover() {
        if (!Rs2AntibanSettings.naturalMouse) {
            Microbot.log("Natural mouse is not enabled, can't hover");
            return false;
        }
        if (isOpen()) {
            return false;
        }
        Microbot.status = "Hovering over bank";
        try {
            GameObject bank = Rs2GameObject.findBank();
            if (bank != null) {
                return hoverOverObject(bank);
            }
            GameObject chest = Rs2GameObject.findChest();
            if (chest != null) {
                return hoverOverObject(chest);
            }
            NPC npc = Rs2Npc.getBankerNPC();
            if (npc != null) {
                return hoverOverActor(npc);
            }
            Microbot.log("No bank objects or NPC found to hover over.");
        } catch (Exception ex) {
            Microbot.log("An error occurred while hovering over the bank: " + ex.getMessage());
        }
        return false;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/camera/NpcTracker.java
================
package net.runelite.client.plugins.microbot.util.camera;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Actor;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.npc.Rs2Npc;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
@Slf4j
public class NpcTracker {
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1); // Single-threaded scheduler
    private ScheduledFuture<?> trackingTask; // Future to manage the scheduled task
    // The original method to track the actor
    private static void trackNpc(int npcId) {
        if (!Microbot.isLoggedIn()) {
            return;
        }
        Actor actor = Rs2Npc.getNpc(npcId); // Get the actor
        if (actor == null) {
            return; // Actor not found, do nothing
        }
        Microbot.getClient().setCameraYawTarget(Rs2Camera.calculateCameraYaw(Rs2Camera.angleToTile(actor)));
    }
    /**
     * Method to start tracking the NPC
     *
     * @param npcId the ID of the NPC to track
     */
    public void startTracking(int npcId) {
        if (trackingTask != null && !trackingTask.isCancelled()) {
            Microbot.log("Already tracking an NPC");
            return; // Already tracking, do nothing
        }
        // Schedule the trackActor method to run every 50 milliseconds
        trackingTask = scheduler.scheduleAtFixedRate(() -> trackNpc(npcId), 0, 200, TimeUnit.MILLISECONDS);
        Microbot.log("Started tracking NPC with ID: " + npcId);
    }
    /**
     * Method to stop tracking the NPC
     */
    public void stopTracking() {
        if (trackingTask != null) {
            trackingTask.cancel(true); // Cancel the scheduled task
            trackingTask = null;
            Microbot.log("Stopped tracking NPC");
        }
    }
    /**
     * Method to check if a NPC is being tracked
     *
     * @return true if a NPC is being tracked, false otherwise
     */
    public boolean isTracking() {
        return trackingTask != null;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/camera/Rs2Camera.java
================
package net.runelite.client.plugins.microbot.util.camera;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.RuneLite;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.plugins.camera.CameraPlugin;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.Global;
import net.runelite.client.plugins.microbot.util.keyboard.Rs2Keyboard;
import java.awt.*;
import java.awt.event.KeyEvent;
public class Rs2Camera {
    private static final NpcTracker NPC_TRACKER = new NpcTracker();
    public static int angleToTile(Actor t) {
        int angle = (int) Math.toDegrees(Math.atan2(t.getWorldLocation().getY() - Microbot.getClient().getLocalPlayer().getWorldLocation().getY(),
                t.getWorldLocation().getX() - Microbot.getClient().getLocalPlayer().getWorldLocation().getX()));
        return angle >= 0 ? angle : 360 + angle;
    }
    public static int angleToTile(TileObject t) {
        int angle = (int) Math.toDegrees(Math.atan2(t.getWorldLocation().getY() - Microbot.getClient().getLocalPlayer().getWorldLocation().getY(),
                t.getWorldLocation().getX() - Microbot.getClient().getLocalPlayer().getWorldLocation().getX()));
        return angle >= 0 ? angle : 360 + angle;
    }
    public static int angleToTile(LocalPoint localPoint) {
        int angle = (int) Math.toDegrees(Math.atan2(localPoint.getY() - Microbot.getClient().getLocalPlayer().getWorldLocation().getY(),
                localPoint.getX() - Microbot.getClient().getLocalPlayer().getWorldLocation().getX()));
        return angle >= 0 ? angle : 360 + angle;
    }
    public static void turnTo(final Actor actor) {
        int angle = getCharacterAngle(actor);
        setAngle(angle, 40);
    }
    public static void turnTo(final Actor actor, int maxAngle) {
        int angle = getCharacterAngle(actor);
        setAngle(angle, maxAngle);
    }
    public static void turnTo(final TileObject tileObject) {
        int angle = getObjectAngle(tileObject);
        setAngle(angle, 40);
    }
    public static void turnTo(final TileObject tileObject, int maxAngle) {
        int angle = getObjectAngle(tileObject);
        setAngle(angle, maxAngle);
    }
    public static void turnTo(final LocalPoint localPoint) {
        int angle = angleToTile(localPoint);
        setAngle(angle, 40);
    }
    public static void turnTo(final LocalPoint localPoint, int maxAngle) {
        int angle = angleToTile(localPoint);
        setAngle(angle, maxAngle);
    }
    public static int getCharacterAngle(Actor actor) {
        return getTileAngle(actor);
    }
    public static int getObjectAngle(TileObject tileObject) {
        return getTileAngle(tileObject);
    }
    public static int getTileAngle(Actor actor) {
        int a = (angleToTile(actor) - 90) % 360;
        return a < 0 ? a + 360 : a;
    }
    public static int getTileAngle(TileObject tileObject) {
        int a = (angleToTile(tileObject) - 90) % 360;
        return a < 0 ? a + 360 : a;
    }
    /**
     * <h1> Checks if the angle to the target is within the desired max angle </h1>
     * <p>
     * The desired max angle should not go over 80-90 degrees as the target will be out of view
     *
     * @param targetAngle     the angle to the target
     * @param desiredMaxAngle the maximum angle to the target (Should be a positive number)
     *
     * @return true if the angle to the target is within the desired max angle
     */
    public static boolean isAngleGood(int targetAngle, int desiredMaxAngle) {
        return Math.abs(getAngleTo(targetAngle)) <= desiredMaxAngle;
    }
    public static void setAngle(int targetDegrees, int maxAngle) {
        // Default camera speed is 1
        double defaultCameraSpeed = 1f;
        // If the camera plugin is enabled, get the camera speed from the config in case it has been changed
        if (Microbot.isPluginEnabled(CameraPlugin.class)) {
            String configGroup = "zoom";
            String configKey = "cameraSpeed";
            defaultCameraSpeed = RuneLite.getInjector().getInstance(ConfigManager.class).getConfiguration(configGroup, configKey, double.class);
        }
        // Set the camera speed to 3 to make the camera move faster
        Microbot.getClient().setCameraSpeed(3f);
        if (getAngleTo(targetDegrees) > maxAngle) {
            Rs2Keyboard.keyHold(KeyEvent.VK_LEFT);
            Global.sleepUntilTrue(() -> Math.abs(getAngleTo(targetDegrees)) <= maxAngle, 50, 5000);
            Rs2Keyboard.keyRelease(KeyEvent.VK_LEFT);
        } else if (getAngleTo(targetDegrees) < -maxAngle) {
            Rs2Keyboard.keyHold(KeyEvent.VK_RIGHT);
            Global.sleepUntilTrue(() -> Math.abs(getAngleTo(targetDegrees)) <= maxAngle, 50, 5000);
            Rs2Keyboard.keyRelease(KeyEvent.VK_RIGHT);
        }
        Microbot.getClient().setCameraSpeed((float) defaultCameraSpeed);
    }
//    todo: These methods are not working as intended, do more testing with the method above and see if its enough
//    public static void setAngle(int degrees, Actor actor) {
//        if (getAngleTo(degrees) > 5) {
//            Rs2Keyboard.keyHold(KeyEvent.VK_LEFT);
//            Global.awaitExecutionUntil(() -> Rs2Keyboard.keyRelease((char) KeyEvent.VK_LEFT),
//                    () -> Perspective.localToCanvas(Microbot.getClient(), actor.getLocalLocation(), Microbot.getClient().getPlane()) != null, 10);
//        } else if (getAngleTo(degrees) < -5) {
//            Rs2Keyboard.keyHold(KeyEvent.VK_RIGHT);
//            Global.awaitExecutionUntil(() -> Rs2Keyboard.keyRelease((char) KeyEvent.VK_RIGHT),
//                    () -> Perspective.localToCanvas(Microbot.getClient(), actor.getLocalLocation(), Microbot.getClient().getPlane()) != null, 10);
//        }
//    }
//
//    public static void setAngle(int degrees, TileObject tileObject) {
//        if (getAngleTo(degrees) > 5) {
//            Rs2Keyboard.keyHold(KeyEvent.VK_LEFT);
//            Global.awaitExecutionUntil(() -> Rs2Keyboard.keyRelease((char) KeyEvent.VK_LEFT),
//                    () -> Perspective.localToCanvas(Microbot.getClient(), tileObject.getLocalLocation(), Microbot.getClient().getPlane()) != null, 600);
//        } else if (getAngleTo(degrees) < -5) {
//            Rs2Keyboard.keyHold(KeyEvent.VK_RIGHT);
//            Global.awaitExecutionUntil(() -> Rs2Keyboard.keyRelease((char) KeyEvent.VK_RIGHT),
//                    () -> Perspective.localToCanvas(Microbot.getClient(), tileObject.getLocalLocation(), Microbot.getClient().getPlane()) != null, 600);
//        }
//    }
//
//    public static void setAngle(int degrees, LocalPoint localPoint) {
//        if (getAngleTo(degrees) > 5) {
//            Rs2Keyboard.keyHold(KeyEvent.VK_LEFT);
//            Global.awaitExecutionUntil(() -> Rs2Keyboard.keyRelease((char) KeyEvent.VK_LEFT),
//                    () -> Perspective.localToCanvas(Microbot.getClient(), localPoint, Microbot.getClient().getPlane()) != null, 600);
//        } else if (getAngleTo(degrees) < -5) {
//            Rs2Keyboard.keyHold(KeyEvent.VK_RIGHT);
//            Global.awaitExecutionUntil(() -> Rs2Keyboard.keyRelease((char) KeyEvent.VK_RIGHT),
//                    () -> Perspective.localToCanvas(Microbot.getClient(), localPoint, Microbot.getClient().getPlane()) != null, 600);
//        }
//    }
    public static void adjustPitch(float percentage) {
        float currentPitchPercentage = cameraPitchPercentage();
        if (currentPitchPercentage < percentage) {
            Rs2Keyboard.keyHold(KeyEvent.VK_UP);
            Global.sleepUntilTrue(() -> cameraPitchPercentage() >= percentage, 50, 5000);
            Rs2Keyboard.keyRelease(KeyEvent.VK_UP);
        } else {
            Rs2Keyboard.keyHold(KeyEvent.VK_DOWN);
            Global.sleepUntilTrue(() -> cameraPitchPercentage() <= percentage, 50, 5000);
            Rs2Keyboard.keyRelease(KeyEvent.VK_DOWN);
        }
    }
    public static int getPitch() {
        return Microbot.getClient().getCameraPitch();
    }
    // set camera pitch
    public static void setPitch(int pitch) {
        int minPitch = 128;
        int maxPitch = 383;
        // clamp pitch to avoid out of bounds
        pitch = Math.max(minPitch, Math.min(maxPitch, pitch));
        Microbot.getClient().setCameraPitchTarget(pitch);
    }
    public static float cameraPitchPercentage() {
        int minPitch = 128;
        int maxPitch = 383;
        int currentPitch = Microbot.getClient().getCameraPitch();
        int adjustedPitch = currentPitch - minPitch;
        int adjustedMaxPitch = maxPitch - minPitch;
        return (float) adjustedPitch / (float) adjustedMaxPitch;
    }
    public static int getAngleTo(int degrees) {
        int ca = getAngle();
        if (ca < degrees) {
            ca += 360;
        }
        int da = ca - degrees;
        if (da > 180) {
            da -= 360;
        }
        return da;
    }
    public static int getAngle() {
        // the client uses fixed point radians 0 - 2^14
        // degrees = yaw * 360 / 2^14 = yaw / 45.5111...
        // This leaves it on a scale of 45 versus a scale of 360 so we multiply it by 8 to fix that.
        return (int) Math.abs(Microbot.getClient().getCameraYaw() / 45.51 * 8);
    }
    /**
     * Calculates the CameraYaw based on the given NPC or object angle.
     *
     * @param npcAngle the angle of the NPC or object relative to the player (0-359 degrees)
     *
     * @return the calculated CameraYaw (0-2047)
     */
    public static int calculateCameraYaw(int npcAngle) {
        // Convert the NPC angle to CameraYaw using the derived formula
        return (1536 + (int) Math.round(npcAngle * (2048.0 / 360.0))) % 2048;
    }
    /**
     * Track the NPC with the camera
     *
     * @param npcId the ID of the NPC to track
     */
    public static void trackNpc(int npcId) {
        NPC_TRACKER.startTracking(npcId);
    }
    /**
     * Stop tracking the NPC with the camera
     */
    public static void stopTrackingNpc() {
        NPC_TRACKER.stopTracking();
    }
    /**
     * Checks if a NPC is being tracked
     *
     * @return true if a NPC is being tracked, false otherwise
     */
    public static boolean isTrackingNpc() {
        return NPC_TRACKER.isTracking();
    }
    public static boolean isTileOnScreen(TileObject tileObject) {
        int viewportHeight = Microbot.getClient().getViewportHeight();
        int viewportWidth = Microbot.getClient().getViewportWidth();
        Polygon poly = Perspective.getCanvasTilePoly(Microbot.getClient(), tileObject.getLocalLocation());
        if (poly == null) return false;
        return poly.getBounds2D().getX() <= viewportWidth && poly.getBounds2D().getY() <= viewportHeight;
    }
    public static boolean isTileOnScreen(LocalPoint localPoint) {
        int viewportHeight = Microbot.getClient().getViewportHeight();
        int viewportWidth = Microbot.getClient().getViewportWidth();
        Polygon poly = Perspective.getCanvasTilePoly(Microbot.getClient(), localPoint);
        if (poly == null) return false;
        return poly.getBounds2D().getX() <= viewportWidth && poly.getBounds2D().getY() <= viewportHeight;
    }
    // get the camera zoom
    public static int getZoom() {
        return Microbot.getClient().getVarcIntValue(VarClientInt.CAMERA_ZOOM_RESIZABLE_VIEWPORT);
    }
    public static void setZoom(int zoom) {
        Microbot.getClientThread().invokeLater(() -> {
            Microbot.getClient().runScript(ScriptID.CAMERA_DO_ZOOM, zoom, zoom);
        });
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/combat/Rs2Combat.java
================
package net.runelite.client.plugins.microbot.util.combat;
import net.runelite.api.VarPlayer;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.globval.enums.InterfaceTab;
import net.runelite.client.plugins.microbot.util.Global;
import net.runelite.client.plugins.microbot.util.tabs.Rs2Tab;
import net.runelite.client.plugins.microbot.util.widget.Rs2Widget;
import static net.runelite.client.plugins.microbot.Microbot.log;
import static net.runelite.client.plugins.microbot.util.Global.sleepUntil;
public class Rs2Combat {
    /**
     * Sets the attack style
     *
     * @param style WidgetInfo. ex. COMBAT_STYLE_ONE
     * @return boolean, whether the action succeeded
     */
    public static boolean setAttackStyle(WidgetInfo style) {
        Widget widget = Microbot.getClient().getWidget(style);
        if (widget == null) return false;
        if (isSelected(widget.getId() + 1)) {
            return true;
        }
        Microbot.getMouse().click(widget.getBounds());
        return true;
    }
    /**
     * Sets the auto retaliate state
     *
     * @param state boolean, true for enabled, false for disabled
     * @return boolean, whether the action succeeded
     */
    public static boolean setAutoRetaliate(boolean state) {
        Widget widget = Microbot.getClient().getWidget(WidgetInfo.COMBAT_AUTO_RETALIATE);
        if (widget == null) return false;
        if (state == isSelected(widget.getId() + 2)) return true;
        Microbot.getMouse().click(widget.getBounds());
        Global.sleep(600, 1000);
        return true;
    }
    /**
     * Sets the special attack state if currentSpecEnergy >= specialAttackEnergyRequired
     *
     * @param state                       boolean, true for enabled, false for disabled
     * @param specialAttackEnergyRequired int, 1000 = 100%
     * @return boolean, whether the action succeeded
     */
    public static boolean setSpecState(boolean state, int specialAttackEnergyRequired) {
        int currentSpecEnergy = Microbot.getClient().getVarpValue(VarPlayer.SPECIAL_ATTACK_PERCENT);
        if (Rs2Widget.isHidden(10485795)) return false;
        if (currentSpecEnergy < specialAttackEnergyRequired) return false;
        if (state == getSpecState()) return true;
        Microbot.getMouse().click(Rs2Widget.getWidget(10485795).getBounds());
        log("Used special attack");
       //  Microbot.doInvoke(new NewMenuEntry(-1, 10485795, MenuAction.CC_OP.getId(), 1, -1, "Special Attack"), new Rectangle(1, 1, Microbot.getClient().getCanvasWidth(), Microbot.getClient().getCanvasHeight()));
        //Rs2Reflection.invokeMenu(-1, 10485795, MenuAction.CC_OP.getId(), 1, -1, "Use", "Special Attack", -1, -1);
        return true;
    }
    /**
     * get special attack energy (1000 is full spec bar)
     *
     * @return
     */
    public static int getSpecEnergy() {
        int currentSpecEnergy = Microbot.getClient().getVarpValue(VarPlayer.SPECIAL_ATTACK_PERCENT);
        return currentSpecEnergy;
    }
    /**
     * Sets the special attack state
     *
     * @param state boolean, true for enabled, false for disabled
     * @return boolean, whether the action succeeded
     */
    public static boolean setSpecState(boolean state) {
        return setSpecState(state, -1);
    }
    /**
     * Checks the state of the spec widget
     *
     * @return boolean, whether the spec is enabled
     */
    public static boolean getSpecState() {
        Widget widget = Microbot.getClient().getWidget(WidgetInfo.MINIMAP_SPEC_ORB.getId() + 4);
        if (widget == null) throw new RuntimeException("Somehow the spec orb is null!");
        return widget.getSpriteId() == 1608;
    }
    /**
     * Checks if the widget is selected (based on the red background)
     *
     * @param widgetId int, the widget id
     * @return boolean, whether the widget is selected
     */
    private static boolean isSelected(int widgetId) {
        return Rs2Widget.getChildWidgetSpriteID(widgetId, 0) == 1150;
    }
    public static boolean enableAutoRetialiate() {
        if (Microbot.getVarbitPlayerValue(172) == 1) {
            Rs2Tab.switchToCombatOptionsTab();
            sleepUntil(() -> Rs2Tab.getCurrentTab() == InterfaceTab.COMBAT, 2000);
            Rs2Widget.clickWidget(38862878);
        }
        return Microbot.getVarbitPlayerValue(172) == 0;
    }
    public static boolean inCombat() {
        if (!Microbot.isLoggedIn()) return false;
        if (Microbot.getClient().getLocalPlayer().getInteracting() == null) return false;
        if (Microbot.getClient().getLocalPlayer().getInteracting().getCombatLevel() < 1) return false;
        return Microbot.getClient().getLocalPlayer().isInteracting() || Microbot.getClient().getLocalPlayer().getAnimation() != -1;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/depositbox/Rs2DepositBox.java
================
package net.runelite.client.plugins.microbot.util.depositbox;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.GameObject;
import net.runelite.api.SpriteID;
import net.runelite.api.widgets.Widget;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.gameobject.Rs2GameObject;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Item;
import net.runelite.client.plugins.microbot.util.widget.Rs2Widget;
import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import static net.runelite.api.widgets.ComponentID.DEPOSIT_BOX_INVENTORY_ITEM_CONTAINER;
import static net.runelite.client.plugins.microbot.util.Global.*;
@Slf4j
public class Rs2DepositBox {
    private static final int DEPOSIT_ALL_BUTTON_ID = 1920;
    private static final int DEPOSIT_INVENTORY_ID = 1921;
    private static final int DEPOSIT_EQUIPMENT_ID = 1922;
    private static final int CLOSE_BUTTON_PARENT_ID = DEPOSIT_BOX_INVENTORY_ITEM_CONTAINER - 1;
    /**
     * Checks if the deposit box interface is open.
     *
     * @return true if the deposit box interface is open, false otherwise.
     */
    public static boolean isOpen() {
        return Rs2Widget.isDepositBoxWidgetOpen();
    }
    /**
     * Closes the deposit box interface.
     *
     * @return true if the deposit box interface was successfully closed, false otherwise.
     */
    public static boolean closeDepositBox() {
        if (!isOpen()) return false;
        Rs2Widget.clickChildWidget(CLOSE_BUTTON_PARENT_ID, 11); // Assuming close button ID is 11
        sleepUntilOnClientThread(() -> !isOpen());
        return true;
    }
    /**
     * Opens the deposit box interface by interacting with a nearby deposit box.
     *
     * @return true if the deposit box was successfully opened, false otherwise.
     */
    public static boolean openDepositBox() {
        Microbot.status = "Opening deposit box";
        try {
            if (Microbot.getClient().isWidgetSelected())
                Microbot.getMouse().click();
            // Assuming interaction logic with a nearby deposit box
            if (isOpen()) return true;
            GameObject depositBox = Rs2GameObject.findDepositBox();
            boolean action = false;
            if (depositBox != null) {
                action = Rs2GameObject.interact(depositBox, "Deposit");
            }
            if (action) {
                sleepUntil(Rs2DepositBox::isOpen, 2500);
            }
            return action;
        } catch (Exception e) {
            Microbot.log("Error opening deposit box: " + e.getMessage());
        }
        return false;
    }
    /**
     * Deposits all items in the inventory into the deposit box.
     */
    public static void depositAll() {
        Microbot.status = "Depositing all items";
        if (Rs2Inventory.isEmpty()) return;
        if (!isOpen()) return;
        Widget depositAllWidget = Rs2Widget.findWidget(SpriteID.BANK_DEPOSIT_INVENTORY, null);
        if (depositAllWidget == null) return;
        Microbot.getMouse().click(depositAllWidget.getBounds());
        sleepUntil(Rs2Inventory::isEmpty);
    }
    public static boolean depositAll(Predicate<Rs2Item> predicate, boolean fastDeposit) {
        boolean result = false;
        List<Rs2Item> items = Rs2Inventory.items().stream().filter(predicate).distinct().collect(Collectors.toList());
        for (Rs2Item item : items) {
            if (item == null) continue;
            depositItem(item);
            if (!fastDeposit)
                sleep(100, 300);
            result = true;
        }
        return result;
    }
    public static boolean depositAll(Predicate<Rs2Item> predicate) {
        return depositAll(predicate, false);
    }
    /**
     * Deposits all items in the player's inventory into the bank, except for the items with the specified IDs.
     * This method uses a lambda function to filter out the items with the specified IDs from the deposit operation.
     *
     * @param ids The IDs of the items to be excluded from the deposit.
     *
     * @return true if any items were deposited, false otherwise.
     */
    public static boolean depositAllExcept(Integer... ids) {
        return depositAll(x -> Arrays.stream(ids).noneMatch(id -> id == x.id));
    }
    public static boolean depositAllExcept(boolean fastDeposit, Integer... ids) {
        return depositAll(x -> Arrays.stream(ids).noneMatch(id -> id == x.id), fastDeposit);
    }
    /**
     * Deposits all items in the player's inventory into the bank, except for the items with the specified names.
     * This method uses a lambda function to filter out the items with the specified names from the deposit operation.
     *
     * @param names The names of the items to be excluded from the deposit.
     *
     * @return true if any items were deposited, false otherwise.
     */
    public static boolean depositAllExcept(String... names) {
        return depositAll(x -> Arrays.stream(names).noneMatch(name -> name.equalsIgnoreCase(x.name)));
    }
    public static boolean depositAllExcept(boolean fastDeposit, String... names) {
        return depositAll(x -> Arrays.stream(names).noneMatch(name -> name.equalsIgnoreCase(x.name)), fastDeposit);
    }
    /**
     * Deposits all items in the player's inventory into the bank, except for the items with the specified names.
     * This method uses a lambda function to filter out the items with the specified names from the deposit operation.
     *
     * @param names The names of the items to be excluded from the deposit.
     *
     * @return true if any items were deposited, false otherwise.
     */
    public static boolean depositAllExcept(List<String> names) {
        return depositAll(x -> names.stream().noneMatch(name -> name.equalsIgnoreCase(x.name)));
    }
    public static boolean depositAllExcept(boolean fastDeposit, List<String> names) {
        return depositAll(x -> names.stream().noneMatch(name -> name.equalsIgnoreCase(x.name)), fastDeposit);
    }
    /**
     * Deposits all items in the player's inventory into the bank, except for the items with the specified names.
     * This method uses a lambda function to filter out the items with the specified names from the deposit operation.
     * It also allows for a delay between deposit operations.
     *
     * @param names The names of the items to be excluded from the deposit.
     *
     * @return true if any items were deposited, false otherwise.
     */
    public static boolean depositAllExcept(boolean exact, boolean fastDeposit, String... names) {
        if (!exact)
            return depositAll(x -> Arrays.stream(names).noneMatch(name -> x.name.contains(name.toLowerCase())), fastDeposit);
        else
            return depositAll(x -> Arrays.stream(names).noneMatch(name -> name.equalsIgnoreCase(x.name)), fastDeposit);
    }
    /**
     * Deposits a specific item by its name.
     *
     * @param itemName the name of the item to deposit.
     */
    public static void depositItem(String itemName) {
        Rs2Item item = Rs2Inventory.get(itemName);
        if (item == null) return;
        depositItem(item);
    }
    /**
     * Deposits a specific item by its ID.
     *
     * @param itemId the ID of the item to deposit.
     */
    public static void depositItem(int itemId) {
        Rs2Item item = Rs2Inventory.get(itemId);
        if (item == null) return;
        depositItem(item);
    }
    /**
     * Deposits a item quickly by its name with a partial or exact name match.
     * Name and a boolean to determine if the name should be an exact match.
     *
     * @param itemName   the name of the item to deposit.
     * @param exactMatch true if the name should be an exact match, false otherwise.
     */
    public static void depositItem(String itemName, boolean exactMatch) {
        Rs2Item item = Rs2Inventory.get(itemName, exactMatch);
        if (item == null) return;
        depositItem(item);
    }
    /**
     * Deposits a specific item by its Rs2Item reference.
     *
     * @param rs2Item the Rs2Item to deposit.
     */
    public static void depositItem(Rs2Item rs2Item) {
        if (rs2Item == null || !isOpen()) return;
        if (!Rs2Inventory.hasItem(rs2Item.id)) return;
        Rs2Inventory.interact(rs2Item, "Deposit-All");
    }
    /**
     * Deposits all equipment into the deposit box.
     */
    public static void depositEquipment() {
        Widget widget = Rs2Widget.findWidget(SpriteID.BANK_DEPOSIT_EQUIPMENT, null);
        if (widget == null) return;
        Microbot.getMouse().click(widget.getBounds());
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/dialogues/Rs2Dialogue.java
================
package net.runelite.client.plugins.microbot.util.dialogues;
import net.runelite.client.plugins.microbot.util.keyboard.Rs2Keyboard;
import net.runelite.client.plugins.microbot.util.widget.Rs2Widget;
import java.awt.event.KeyEvent;
public class Rs2Dialogue {
    public static boolean isInDialogue() {
        return Rs2Widget.isWidgetVisible(231, 5)
                || Rs2Widget.isWidgetVisible(229, 0)
                || Rs2Widget.isWidgetVisible(229, 2)
                || Rs2Widget.isWidgetVisible(219, 1)
                || Rs2Widget.isWidgetVisible(217, 5)
                || Rs2Widget.isWidgetVisible(193, 0)
                || Rs2Widget.isWidgetVisible(11, 4)
                || hasContinue();
    }
    public static void clickContinue() {
        if (Rs2Widget.hasWidget("Click here to continue"))
            Rs2Keyboard.keyPress(KeyEvent.VK_SPACE);
    }
    public static boolean hasContinue(){
        return Rs2Widget.hasWidget("Click here to continue");
    }
    public static boolean hasSelectAnOption() {
        return Rs2Widget.hasWidget("Select an Option");
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/equipment/JewelleryLocationEnum.java
================
package net.runelite.client.plugins.microbot.util.equipment;
import lombok.AllArgsConstructor;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.worldmap.TeleportType;
@AllArgsConstructor
@Getter
public enum JewelleryLocationEnum {
    // Jewellery
    BARBARIAN_ASSAULT(TeleportType.JEWELLERY, "Games Necklace" , "Barbarian Assault", new WorldPoint(2520, 3571, 0), "games_necklace_teleport_icon.png", 3),
    BURTHORPE_GAMES_ROOM(TeleportType.JEWELLERY, "Games Necklace" , "Burthorpe Games Room", new WorldPoint(2898, 3554, 0), "games_necklace_teleport_icon.png", 2),
    TEARS_OF_GUTHIX(TeleportType.JEWELLERY, "Games Necklace" , "Tears of Guthix", new WorldPoint(3245, 9500, 0), "games_necklace_teleport_icon.png", 5),
    CORPOREAL_BEAST(TeleportType.JEWELLERY, "Games Necklace" , "Corporeal Beast", new WorldPoint(2967, 4384, 0), "games_necklace_teleport_icon.png", 4),
    WINTERTODT_CAMP(TeleportType.JEWELLERY, "Games Necklace" , "Wintertodt Camp", new WorldPoint(1624, 3938, 0), "games_necklace_teleport_icon.png", 6),
    PVP_ARENA(TeleportType.JEWELLERY, "Ring of Dueling" , "Al Kharid PvP Arena", new WorldPoint(3315, 3235, 0), "ring_of_dueling_teleport_icon.png", 2),
    FEROX_ENCLAVE(TeleportType.JEWELLERY, "Ring of Dueling" , "Ferox Enclave", new WorldPoint(3151, 3636, 0), "ring_of_dueling_teleport_icon.png", 4),
    CASTLE_WARS(TeleportType.JEWELLERY, "Ring of Dueling" , "Castle Wars", new WorldPoint(2441, 3091, 0), "ring_of_dueling_teleport_icon.png", 3),
    WARRIORS_GUILD(TeleportType.JEWELLERY, "Combat Bracelet" , "Warriors' Guild", new WorldPoint(2883, 3549, 0), "combat_bracelet_teleport_icon.png", 2),
    CHAMPIONS_GUILD(TeleportType.JEWELLERY, "Combat Bracelet" , "Champions' Guild", new WorldPoint(3189, 3368, 0), "combat_bracelet_teleport_icon.png", 3),
    EDGEVILLE_MONASTERY(TeleportType.JEWELLERY, "Combat Bracelet" , "Edgeville Monastery", new WorldPoint(3053, 3487, 0), "combat_bracelet_teleport_icon.png", 4),
    RANGING_GUILD(TeleportType.JEWELLERY, "Combat Bracelet" , "Ranging Guild", new WorldPoint(2654, 3441, 0), "combat_bracelet_teleport_icon.png", 5),
    FISHING_GUILD_NECK(TeleportType.JEWELLERY, "Skills Necklace" , "Fishing Guild", new WorldPoint(2613, 3390, 0), "skills_necklace_teleport_icon.png", 2),
    MINING_GUILD(TeleportType.JEWELLERY, "Skills Necklace" , "Mining Guild", new WorldPoint(3049, 9762, 0), "skills_necklace_teleport_icon.png", 3),
    CRAFTING_GUILD(TeleportType.JEWELLERY, "Skills Necklace" , "Crafting Guild", new WorldPoint(2934, 3294, 0), "skills_necklace_teleport_icon.png", 4),
    COOKING_GUILD(TeleportType.JEWELLERY, "Skills Necklace" , "Cooking Guild", new WorldPoint(3145, 3438, 0), "skills_necklace_teleport_icon.png", 5),
    WOODCUTTING_GUILD(TeleportType.JEWELLERY, "Skills Necklace" , "Woodcutting Guild", new WorldPoint(1662, 3505, 0), "skills_necklace_teleport_icon.png", 6),
    FARMING_GUILD(TeleportType.JEWELLERY, "Skills Necklace" , "Farming Guild", new WorldPoint(1249, 3717, 0), "skills_necklace_teleport_icon.png", 7),
    EDGEVILLE(TeleportType.JEWELLERY, "Amulet of Glory" , "Edgeville", new WorldPoint(3087, 3496, 0), "amulet_of_glory_teleport_icon.png", 2),
    KARAMJA(TeleportType.JEWELLERY, "Amulet of Glory" , "Karamja", new WorldPoint(2918, 3176, 0), "amulet_of_glory_teleport_icon.png", 3),
    DRAYNOR_VILLAGE(TeleportType.JEWELLERY, "Amulet of Glory" , "Draynor Village", new WorldPoint(3105, 3251, 0), "amulet_of_glory_teleport_icon.png", 4),
    AL_KHARID(TeleportType.JEWELLERY, "Amulet of Glory" , "Al-Kharid", new WorldPoint(3293, 3163, 0), "amulet_of_glory_teleport_icon.png", 5),
    MISCELLANIA(TeleportType.JEWELLERY, "Ring of Wealth" , "Miscellania", new WorldPoint(2535, 3862, 0), "ring_of_wealth_teleport_icon.png", 2),
    GRAND_EXCHANGE(TeleportType.JEWELLERY, "Ring of Wealth" , "Grand Exchange", new WorldPoint(3162, 3480, 0), "ring_of_wealth_teleport_icon.png", 3),
    FALADOR_PARK(TeleportType.JEWELLERY, "Ring of Wealth" , "Falador Park", new WorldPoint(2995, 3375, 0), "ring_of_wealth_teleport_icon.png", 4),
    DONDAKAN(TeleportType.JEWELLERY, "Ring of Wealth" , "Dondakan", new WorldPoint(2831, 10165, 0), "ring_of_wealth_teleport_icon.png", 5);
//    SLAYER_TOWER(TeleportType.JEWELLERY, "Slayer Ring" , "Slayer Tower", new WorldPoint(3423, 3536, 0), "slayer_ring_teleport_icon.png"),
//    FREMENNIK_SLAYER_DUNGEON(TeleportType.JEWELLERY, "Slayer Ring" , "Fremennik Slayer Dungeon", new WorldPoint(2800, 9998, 0), "slayer_ring_teleport_icon.png"),
//    FREMENNIK_SLAYER_DUNGEON_OUTSIDE(TeleportType.JEWELLERY, "Slayer Ring" , "Fremennik Slayer Dungeon (inside)", new WorldPoint(2800, 3615, 0), "slayer_ring_teleport_icon.png"),
//    TARNS_LAIR(TeleportType.JEWELLERY, "Slayer Ring" , "Tarn's Lair", new WorldPoint(3187, 4601, 0), "slayer_ring_teleport_icon.png"),
//    STRONGHOLD_SLAYER_CAVE(TeleportType.JEWELLERY, "Slayer Ring" , "Stronghold Slayer Cave", new WorldPoint(2433, 3421, 0), "slayer_ring_teleport_icon.png"),
//    DARK_BEASTS(TeleportType.JEWELLERY, "Slayer Ring" , "Dark Beasts", new WorldPoint(2028, 4638, 0), "slayer_ring_teleport_icon.png"),
//    DIGSITE(TeleportType.JEWELLERY, "Digsite Pendant" , "Digsite", new WorldPoint(3339, 3445, 0), "digsite_pendant_teleport_icon.png"),
//    HOUSE_ON_THE_HILL(TeleportType.JEWELLERY, "Digsite Pendant" , "House on the Hill", new WorldPoint(3763, 3869, 0), "digsite_pendant_teleport_icon.png"),
//    LITHKREN(TeleportType.JEWELLERY, "Digsite Pendant" , "Lithkren", new WorldPoint(3547, 10456, 0), "digsite_pendant_teleport_icon.png"),
//    WIZARDS_TOWER(TeleportType.JEWELLERY, "Necklace of Passage" , "Wizards' Tower", new WorldPoint(3114, 3181, 0), "necklace_of_passage_teleport_icon.png"),
//    JORRALS_OUTPOST(TeleportType.JEWELLERY, "Necklace of Passage" , "Jorral's Outpost", new WorldPoint(2431, 3348, 0), "necklace_of_passage_teleport_icon.png"),
//    DESERT_EAGLE_STATION(TeleportType.JEWELLERY, "Necklace of Passage" , "Desert eagle station of the eagle transport system", new WorldPoint(3406, 3157, 0), "necklace_of_passage_teleport_icon.png"),
//    CHAOS_TEMPLE(TeleportType.JEWELLERY, "Burning Amulet" , "Chaos Temple (lvl 15)", new WorldPoint(3234, 3637, 0), "burning_amulet_teleport_icon.png"),
//    BANDIT_CAMP(TeleportType.JEWELLERY, "Burning Amulet" , "Bandit Camp (lvl 17)", new WorldPoint(3038, 3651, 0), "burning_amulet_teleport_icon.png"),
//    LAVA_MAZE(TeleportType.JEWELLERY, "Burning Amulet" , "Lava Maze (lvl 41)", new WorldPoint(3028, 3840, 0), "burning_amulet_teleport_icon.png");
    private final TeleportType type;
    private final String tooltip;
    private final String destination;
    private final WorldPoint location;
    private final String iconPath;
    private final int identifier;
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/equipment/Rs2Equipment.java
================
package net.runelite.client.plugins.microbot.util.equipment;
import net.runelite.api.*;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Item;
import net.runelite.client.plugins.microbot.util.menu.NewMenuEntry;
import net.runelite.client.plugins.microbot.util.tabs.Rs2Tab;
import java.awt.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
public class Rs2Equipment {
    public static ItemContainer equipment() {
        return Microbot.getClient().getItemContainer(InventoryID.EQUIPMENT);
    }
    public static List<Rs2Item> equipmentItems = new ArrayList<>();
    public static List<Rs2Item> items() {
        return equipmentItems;
    }
    public static void storeEquipmentItemsInMemory(ItemContainerChanged e) {
        if (e.getContainerId() == InventoryID.EQUIPMENT.getId() && e.getItemContainer() != null) {
            List<Rs2Item> _equipmentItems = new ArrayList<>();
            for (int i = 0; i < e.getItemContainer().getItems().length; i++) {
                Item item = equipment().getItems()[i];
                if (item.getId() == -1) continue;
                int finalI = i;
                Optional<EquipmentInventorySlot> equipmentSlot = Arrays.stream(EquipmentInventorySlot.values()).filter(x -> x.getSlotIdx() == finalI).findFirst();
                if (equipmentSlot.isEmpty()) continue;
                int slot = equipmentSlot.get().getSlotIdx();
                ItemComposition itemComposition = Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getItemDefinition(item.getId()));
                _equipmentItems.add(new Rs2Item(item, itemComposition, slot));
            }
            equipmentItems = _equipmentItems;
        }
    }
    public static void useRingAction(JewelleryLocationEnum jewelleryLocationEnum) {
        if (!hasEquippedSlot(EquipmentInventorySlot.RING)) {
            Microbot.status = "Amulet is missing in the equipment slot";
            return;
        }
        Microbot.doInvoke(new NewMenuEntry(-1, 25362456, MenuAction.CC_OP.getId(), jewelleryLocationEnum.getIdentifier(), -1, "Equip"),
                new Rectangle(1, 1, Microbot.getClient().getCanvasWidth(), Microbot.getClient().getCanvasHeight()));
        //Rs2Reflection.invokeMenu(-1, 25362456, MenuAction.CC_OP.getId(), jewelleryLocationEnum.getIdentifier(), -1, "Equip", "", -1, -1);
    }
    public static void useAmuletAction(JewelleryLocationEnum jewelleryLocationEnum) {
        if (!hasEquippedSlot(EquipmentInventorySlot.AMULET) || !hasEquippedContains(jewelleryLocationEnum.getTooltip())) {
            Microbot.status = "Amulet is missing in the equipment slot";
            return;
        }
        Microbot.doInvoke(new NewMenuEntry(-1, 25362449, MenuAction.CC_OP.getId(), jewelleryLocationEnum.getIdentifier(), -1, "Equip"),
                new Rectangle(1, 1, Microbot.getClient().getCanvasWidth(), Microbot.getClient().getCanvasHeight()));
        //Rs2Reflection.invokeMenu(-1, 25362449, MenuAction.CC_OP.getId(), jewelleryLocationEnum.getIdentifier(), -1, "Equip", "", -1, -1);
    }
    public static Rs2Item get(EquipmentInventorySlot slot) {
        return equipmentItems.stream().filter(x -> x.slot == slot.getSlotIdx()).findFirst().orElse(null);
    }
    public static Rs2Item get(int id) {
        return equipmentItems.stream().filter(x -> x.id == id).findFirst().orElse(null);
    }
    public static Rs2Item get(String name, boolean exact) {
        if (exact) {
            return equipmentItems.stream().filter(x -> x.name.equalsIgnoreCase(name))
                    .findFirst()
                    .orElse(null);
        }
        return equipmentItems.stream().filter(x -> x.name.toLowerCase().contains(name.toLowerCase()))
                .findFirst()
                .orElse(null);
    }
    public static Rs2Item get(String name) {
        return get(name, false);
    }
    @Deprecated(since = "Use isWearing", forRemoval = true)
    public static boolean hasEquipped(String itemName) {
        return Microbot.getClientThread().runOnClientThread(() -> {
            for (EquipmentInventorySlot value : EquipmentInventorySlot.values()) {
                Rs2Item item = get(value);
                if (item == null) continue;
                if (item.name.equalsIgnoreCase(itemName)) {
                    return true;
                }
            }
            return false;
        });
    }
    public static boolean hasEquippedContains(String itemName) {
        return Microbot.getClientThread().runOnClientThread(() -> {
            for (EquipmentInventorySlot value : EquipmentInventorySlot.values()) {
                Rs2Item item = get(value);
                if (item == null) continue;
                if (item.name.toLowerCase().contains(itemName.toLowerCase())) {
                    return true;
                }
            }
            return false;
        });
    }
    public static boolean hasEquipped(int id) {
        return Microbot.getClientThread().runOnClientThread(() -> {
            final ItemContainer container = Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getItemContainer(InventoryID.EQUIPMENT));
            if (container == null) return false;
            for (EquipmentInventorySlot value : EquipmentInventorySlot.values()) {
                Item itemSlot = container.getItem(value.getSlotIdx());
                if (itemSlot == null) continue;
                if (itemSlot.getId() == id) {
                    return true;
                }
            }
            return false;
        });
    }
    public static boolean hasEquippedSlot(EquipmentInventorySlot slot) {
        return Microbot.getClientThread().runOnClientThread(() -> {
            final ItemContainer container = Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getItemContainer(InventoryID.EQUIPMENT));
            if (container == null) return false;
            Item itemSlot = container.getItem(slot.getSlotIdx());
            return itemSlot != null;
        });
    }
    public static boolean isEquipped(String name, EquipmentInventorySlot slot) {
        return isEquipped(name, slot, false);
    }
    public static boolean isEquipped(int id, EquipmentInventorySlot slot) {
        final Rs2Item item = get(slot);
        return item != null && item.id == id;
    }
    public static boolean isEquipped(String name, EquipmentInventorySlot slot, boolean exact) {
        final Rs2Item item = get(slot);
        if (exact) {
            return item != null && item.name.equalsIgnoreCase(name);
        } else {
            return item != null && item.name.toLowerCase().contains(name.toLowerCase());
        }
    }
    public static boolean hasGuthanWeaponEquiped() {
        return isEquipped("guthan's warspear", EquipmentInventorySlot.WEAPON);
    }
    public static boolean hasGuthanBodyEquiped() {
        return isEquipped("guthan's platebody", EquipmentInventorySlot.BODY);
    }
    public static boolean hasGuthanLegsEquiped() {
        return isEquipped("guthan's chainskirt", EquipmentInventorySlot.LEGS);
    }
    public static boolean hasGuthanHelmEquiped() {
        return isEquipped("guthan's helm", EquipmentInventorySlot.HEAD);
    }
    public static boolean isWearingFullGuthan() {
        return hasGuthanBodyEquiped() && hasGuthanWeaponEquiped() &&
                hasGuthanHelmEquiped() && hasGuthanLegsEquiped();
    }
    public static boolean isWearing(String name) {
        return isWearing(name, false);
    }
    public static boolean isWearing(int id) {
        for (EquipmentInventorySlot slot : EquipmentInventorySlot.values()
        ) {
            if (isEquipped(id, slot)) {
                return true;
            }
        }
        return false;
    }
    public static boolean isWearing(String name, boolean exact) {
        for (EquipmentInventorySlot slot : EquipmentInventorySlot.values()
        ) {
            if (isEquipped(name, slot, exact)) {
                return true;
            }
        }
        return false;
    }
    public static boolean isWearing(List<String> names, boolean exact, List<EquipmentInventorySlot> ignoreSlots) {
        for (String name : names) {
            for (EquipmentInventorySlot slot : EquipmentInventorySlot.values()) {
                if (ignoreSlots.stream().anyMatch(x -> x.getSlotIdx() == slot.getSlotIdx()))
                    continue;
                if (!isEquipped(name, slot, exact)) {
                    return false;
                }
            }
        }
        return true;
    }
    public static boolean interact(int id, String action) {
        Rs2Item item = get(id);
        if (item != null) {
            invokeMenu(item, action);
            return true;
        }
        return false;
    }
    public static boolean interact(String name, String action) {
        Rs2Item item = get(name);
        if (item != null) {
            invokeMenu(item, action);
            return true;
        }
        return false;
    }
    /**
     * @param name
     * @param action
     * @param exact  name of the item
     * @return
     */
    public static boolean interact(String name, String action, boolean exact) {
        Rs2Item item = get(name, exact);
        if (item != null) {
            invokeMenu(item, action);
            return true;
        }
        return false;
    }
    public static boolean isWearingShield() {
        return equipmentItems.stream().anyMatch(x -> x.getSlot() == EquipmentInventorySlot.SHIELD.getSlotIdx());
    }
    private static void invokeMenu(Rs2Item rs2Item, String action) {
        if (rs2Item == null) return;
        Rs2Tab.switchToEquipmentTab();
        Microbot.status = action + " " + rs2Item.name;
        int param0 = -1;
        int param1 = -1;
        int identifier = 0;
        MenuAction menuAction = MenuAction.CC_OP;
        if (!action.isEmpty()) {
            List<String> actions = rs2Item.getEquipmentActions();
            for (int i = 0; i < actions.size(); i++) {
                if (action.equalsIgnoreCase(actions.get(i))) {
                    identifier = i + 2;
                    break;
                }
            }
        }
        if (rs2Item.getSlot() == EquipmentInventorySlot.CAPE.getSlotIdx()) {
            param1 = 25362448;
        } else if (rs2Item.getSlot() == EquipmentInventorySlot.HEAD.getSlotIdx()) {
            param1 = 25362447;
        } else if (rs2Item.getSlot() == EquipmentInventorySlot.AMMO.getSlotIdx()) {
            param1 = 25362457;
        } else if (rs2Item.getSlot() == EquipmentInventorySlot.AMULET.getSlotIdx()) {
            param1 = 25362449;
        } else if (rs2Item.getSlot() == EquipmentInventorySlot.WEAPON.getSlotIdx()) {
            param1 = 25362450;
        } else if (rs2Item.getSlot() == EquipmentInventorySlot.BODY.getSlotIdx()) {
            param1 = 25362451;
        } else if (rs2Item.getSlot() == EquipmentInventorySlot.SHIELD.getSlotIdx()) {
            param1 = 25362452;
        } else if (rs2Item.getSlot() == EquipmentInventorySlot.LEGS.getSlotIdx()) {
            param1 = 25362453;
        } else if (rs2Item.getSlot() == EquipmentInventorySlot.GLOVES.getSlotIdx()) {
            param1 = 25362454;
        } else if (rs2Item.getSlot() == EquipmentInventorySlot.BOOTS.getSlotIdx()) {
            param1 = 25362455;
        } else if (rs2Item.getSlot() == EquipmentInventorySlot.RING.getSlotIdx()) {
            param1 = 25362456;
        }
        Microbot.doInvoke(new NewMenuEntry(param0, param1, menuAction.getId(), identifier, -1, rs2Item.name), new Rectangle(0, 0, 1, 1));
        //Rs2Reflection.invokeMenu(param0, param1, menuAction.getId(), identifier, rs2Item.id, action, target, -1, -1);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/gameobject/Rs2Cannon.java
================
package net.runelite.client.plugins.microbot.util.gameobject;
import net.runelite.api.TileObject;
import net.runelite.api.VarPlayer;
import net.runelite.api.coords.WorldArea;
import net.runelite.client.plugins.cannon.CannonPlugin;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.math.Random;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import static net.runelite.client.plugins.microbot.util.Global.sleep;
import static net.runelite.client.plugins.microbot.util.Global.sleepUntil;
public class Rs2Cannon {
    public static boolean repair() {
        TileObject brokenCannon = Rs2GameObject.findObjectById(14916);
        if (brokenCannon == null) return false;
        Microbot.status = "Repairing Cannon";
        Rs2GameObject.interact(brokenCannon, "Repair");
        return true;
    }
    public static boolean refill() {
        return refill(Random.random(10, 15));
    }
    public static boolean refill(int cannonRefillAmount) {
        if (!Rs2Inventory.hasItemAmount("cannonball", 15, true)) {
            System.out.println("Not enough cannonballs!");
            return false;
        }
        int cannonBallsLeft = Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getVarpValue(VarPlayer.CANNON_AMMO));
        if (cannonBallsLeft > cannonRefillAmount) return false;
        Microbot.status = "Refilling Cannon";
        TileObject cannon = Rs2GameObject.findObjectById(6);
        if (cannon == null) return false;
        WorldArea cannonLocation = new WorldArea(cannon.getWorldLocation().getX() - 1, cannon.getWorldLocation().getY() - 1, 3, 3, cannon.getWorldLocation().getPlane());
        if (!cannonLocation.toWorldPoint().equals(CannonPlugin.getCannonPosition().toWorldPoint())) return false;
        Microbot.pauseAllScripts = true;
        Rs2GameObject.interact(cannon, "Fire");
        Rs2Player.waitForWalking();
        sleep(1200);
        Rs2GameObject.interact(cannon, "Fire");
        sleepUntil(() -> Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getVarpValue(VarPlayer.CANNON_AMMO)) > Random.random(10, 15));
        Microbot.pauseAllScripts = false;
        return true;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/gameobject/Rs2GameObject.java
================
package net.runelite.client.plugins.microbot.util.gameobject;
import lombok.SneakyThrows;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.antiban.Rs2AntibanSettings;
import net.runelite.client.plugins.microbot.util.camera.Rs2Camera;
import net.runelite.client.plugins.microbot.util.menu.NewMenuEntry;
import net.runelite.client.plugins.microbot.util.misc.Rs2UiHelper;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.microbot.util.reflection.Rs2Reflection;
import net.runelite.client.plugins.microbot.util.tile.Rs2Tile;
import net.runelite.client.plugins.microbot.util.walker.Rs2Walker;
import javax.annotation.Nullable;
import java.lang.reflect.Field;
import java.util.*;
import java.util.stream.Collectors;
import static net.runelite.api.NullObjectID.NULL_34810;
/**
 * TODO: This class should be cleaned up, less methods by passing filters instead of multiple parameters
 */
public class Rs2GameObject {
    public static boolean interact(WorldPoint worldPoint) {
        return interact(worldPoint, "");
    }
    public static boolean interact(WorldPoint worldPoint, String action) {
        TileObject gameObject = findObjectByLocation(worldPoint);
        return clickObject(gameObject, action);
    }
    public static boolean interact(GameObject gameObject) {
        return clickObject(gameObject);
    }
    public static boolean interact(TileObject tileObject) {
        return clickObject(tileObject, null);
    }
    public static boolean interact(TileObject tileObject, String action) {
        return clickObject(tileObject, action);
    }
    public static boolean interact(GameObject gameObject, String action) {
        return clickObject(gameObject, action);
    }
    public static boolean interact(int id) {
        TileObject object = findObjectById(id);
        return clickObject(object);
    }
    public static int interact(List<Integer> ids) {
        for (int objectId : ids) {
            if (interact(objectId)) return objectId;
        }
        return -1;
    }
    public static boolean interact(TileObject tileObject, String action, boolean checkCanReach) {
        if (tileObject == null) return false;
        if (!checkCanReach) return clickObject(tileObject, action);
        if (checkCanReach && Rs2GameObject.hasLineOfSight(tileObject))
            return clickObject(tileObject, action);
        Rs2Walker.walkFastCanvas(tileObject.getWorldLocation());
        return false;
    }
    public static boolean interact(TileObject tileObject, boolean checkCanReach) {
        return interact(tileObject, "", checkCanReach);
    }
    public static boolean interact(int id, boolean checkCanReach) {
        TileObject object = findObjectById(id);
        return interact(object, checkCanReach);
    }
    public static boolean interact(int id, String action) {
        TileObject object = findObjectById(id);
        return clickObject(object, action);
    }
    public static boolean interact(int id, String action, int distance) {
        TileObject object = findObjectByIdAndDistance(id, distance);
        return clickObject(object, action);
    }
    public static boolean interact(String name, String action) {
        TileObject object = get(name);
        return clickObject(object, action);
    }
    public static boolean interact(int[] objectIds, String action) {
        for (int objectId : objectIds) {
            if (interact(objectId, action)) return true;
        }
        return false;
    }
    public static boolean interact(String name) {
        GameObject object = get(name, true);
        return clickObject(object);
    }
    public static boolean interact(String name, boolean exact) {
        GameObject object = get(name, exact);
        return clickObject(object);
    }
    public static boolean interact(String name, String action, boolean exact) {
        GameObject object = get(name, exact);
        return clickObject(object, action);
    }
    @Deprecated(since = "Use findObjectById", forRemoval = true)
    public static ObjectComposition findObject(int id) {
        return Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getObjectDefinition(id));
    }
    public static boolean exists(int id) {
        return findObjectById(id) != null;
    }
    public static TileObject findObjectByName(String name) {
        Scene scene = Microbot.getClient().getScene();
        Tile[][][] tiles = scene.getTiles();
        for (int z = 0; z < Constants.MAX_Z; z++) {
            for (int x = 0; x < Constants.SCENE_SIZE; x++) {
                for (int y = 0; y < Constants.SCENE_SIZE; y++) {
                    Tile tile = tiles[z][x][y];
                    if (tile == null) {
                        continue;
                    }
                    for (TileObject object : tile.getGameObjects()) {
                        if (object == null) {
                            continue;
                        }
                        ObjectComposition objComp = getObjectComposition(object);
                        if (objComp != null && objComp.getName().equalsIgnoreCase(name)) {
                            return object;
                        }
                    }
                    WallObject wallObject = tile.getWallObject();
                    if (wallObject != null) {
                        ObjectComposition objComp = getObjectComposition(wallObject);
                        if (objComp != null && objComp.getName().equalsIgnoreCase(name)) {
                            return wallObject;
                        }
                    }
                    DecorativeObject decorativeObject = tile.getDecorativeObject();
                    if (decorativeObject != null) {
                        ObjectComposition objComp = getObjectComposition(decorativeObject);
                        if (objComp != null && objComp.getName().equalsIgnoreCase(name)) {
                            return decorativeObject;
                        }
                    }
                    GroundObject groundObject = tile.getGroundObject();
                    if (groundObject != null) {
                        ObjectComposition objComp = getObjectComposition(groundObject);
                        if (objComp != null && objComp.getName().equalsIgnoreCase(name)) {
                            return groundObject;
                        }
                    }
                }
            }
        }
        return null;
    }
    private static ObjectComposition getObjectComposition(TileObject object) {
        int id = object.getId();
        return Microbot.getClient().getObjectDefinition(id);
    }
    public static TileObject findObjectById(int id) {
        List<GameObject> gameObjects = getGameObjects();
        if (gameObjects == null) return null;
        for (net.runelite.api.GameObject gameObject : gameObjects) {
            if (gameObject.getId() == id)
                return gameObject;
        }
        List<GroundObject> groundObjects = getGroundObjects();
        for (GroundObject groundObject : groundObjects) {
            if (groundObject.getId() == id)
                return groundObject;
        }
        List<WallObject> wallObjects = getWallObjects();
        for (WallObject wallObject : wallObjects) {
            if (wallObject.getId() == id)
                return wallObject;
        }
        List<DecorativeObject> decorationObjects = getDecorationObjects();
        for (DecorativeObject decorativeObject : decorationObjects) {
            if (decorativeObject.getId() == id)
                return decorativeObject;
        }
        return null;
    }
    public static TileObject findObjectByLocation(WorldPoint worldPoint) {
        List<GameObject> gameObjects = getGameObjects();
        if (gameObjects == null) return null;
        for (net.runelite.api.GameObject gameObject : gameObjects) {
            if (gameObject.getWorldLocation().equals(worldPoint))
                return gameObject;
        }
        List<GroundObject> groundObjects = getGroundObjects();
        for (GroundObject groundObject : groundObjects) {
            if (groundObject.getWorldLocation().equals(worldPoint))
                return groundObject;
        }
        List<WallObject> wallObjects = getWallObjects();
        for (WallObject wallObject : wallObjects) {
            if (wallObject.getWorldLocation().equals(worldPoint))
                return wallObject;
        }
        List<DecorativeObject> decorationObjects = getDecorationObjects();
        for (DecorativeObject decorativeObject : decorationObjects) {
            if (decorativeObject.getWorldLocation().equals(worldPoint))
                return decorativeObject;
        }
        return null;
    }
    public static TileObject findGameObjectByLocation(WorldPoint worldPoint) {
        List<GameObject> gameObjects = getGameObjects();
        if (gameObjects == null) return null;
        for (net.runelite.api.GameObject gameObject : gameObjects) {
            if (gameObject.getWorldLocation().equals(worldPoint))
                return gameObject;
        }
        return null;
    }
    public static TileObject findObjectByIdAndDistance(int id, int distance) {
        List<GameObject> gameObjects = getGameObjectsWithinDistance(distance);
        for (net.runelite.api.GameObject gameObject : gameObjects) {
            if (gameObject.getId() == id)
                return gameObject;
        }
        List<GroundObject> groundObjects = getGroundObjects();
        groundObjects = groundObjects.stream().filter(x -> Microbot.getClient().getLocalPlayer().getWorldLocation().distanceTo(x.getWorldLocation()) < distance).collect(Collectors.toList());
        for (GroundObject groundObject : groundObjects) {
            if (groundObject.getId() == id)
                return groundObject;
        }
        List<WallObject> wallObjects = getWallObjects();
        wallObjects = wallObjects.stream().filter(x -> Microbot.getClient().getLocalPlayer().getWorldLocation().distanceTo(x.getWorldLocation()) < distance).collect(Collectors.toList());
        for (WallObject wallObject : wallObjects) {
            if (wallObject.getId() == id)
                return wallObject;
        }
        List<DecorativeObject> decorationObjects = getDecorationObjects();
        decorationObjects = decorationObjects.stream().filter(x -> Microbot.getClient().getLocalPlayer().getWorldLocation().distanceTo(x.getWorldLocation()) < distance).collect(Collectors.toList());
        for (DecorativeObject decorativeObject : decorationObjects) {
            if (decorativeObject.getId() == id)
                return decorativeObject;
        }
        return null;
    }
    public static List<DecorativeObject> getDecorationObjects() {
        Scene scene = Microbot.getClient().getScene();
        Tile[][][] tiles = scene.getTiles();
        if (tiles == null) return new ArrayList<>();
        int z = Microbot.getClient().getPlane();
        List<DecorativeObject> tileObjects = new ArrayList<>();
        for (int x = 0; x < Constants.SCENE_SIZE; ++x) {
            for (int y = 0; y < Constants.SCENE_SIZE; ++y) {
                Tile tile = tiles[z][x][y];
                if (tile == null) {
                    continue;
                }
                tileObjects.add(tile.getDecorativeObject());
            }
        }
        return Arrays.stream(tileObjects.toArray(new DecorativeObject[0]))
                .filter(Objects::nonNull)
                .sorted(Comparator.comparingInt(value -> value.getLocalLocation().distanceTo(Microbot.getClient().getLocalPlayer().getLocalLocation())))
                .collect(Collectors.toList());
    }
    public static GameObject findObjectById(int id, int x) {
        List<GameObject> gameObjects = getGameObjects();
        if (gameObjects == null) return null;
        for (net.runelite.api.GameObject gameObject : gameObjects) {
            if (gameObject.getId() == id && gameObject.getWorldLocation().getX() == x)
                return gameObject;
        }
        return null;
    }
    public static GameObject findObject(int id, WorldPoint worldPoint) {
        List<GameObject> gameObjects = getGameObjects();
        if (gameObjects == null) return null;
        for (net.runelite.api.GameObject gameObject : gameObjects) {
            if (gameObject.getId() == id && gameObject.getWorldLocation().equals(worldPoint))
                return gameObject;
        }
        return null;
    }
    public static ObjectComposition findObjectComposition(int id) {
        List<GameObject> gameObjects = getGameObjects();
        if (gameObjects == null) return null;
        for (net.runelite.api.GameObject gameObject : gameObjects) {
            if (gameObject.getId() == id) {
                return convertGameObjectToObjectComposition(gameObject);
            }
        }
        return null;
    }
    public static GameObject get(String name) {
        return get(name, false);
    }
    public static GameObject get(String name, boolean exact) {
        name = name.toLowerCase();
        // add underscore because the OBJECTID static list contains _ instead of spaces
        List<Integer> ids = getObjectIdsByName(name.replace(" ", "_"));
        List<GameObject> gameObjects = getGameObjects();
        if (gameObjects == null) {
            return null;
        }
        GameObject gameObject = gameObjects.stream()
                .filter(x -> ids.stream().anyMatch(id -> id == x.getId()))
                .min(Comparator.comparingInt(tile -> tile.getWorldLocation().distanceTo(Rs2Player.getWorldLocation())))
                .orElse(null);
        if (gameObject == null) return null;
        ObjectComposition objComp = convertGameObjectToObjectComposition(gameObject.getId());
        if (objComp == null) {
            return null;
        }
        String compName = null;
        try {
            compName = !objComp.getName().equals("null") ? objComp.getName() : (objComp.getImpostor() != null ? objComp.getImpostor().getName() : null);
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
        if (compName != null) {
            if (!exact && compName.toLowerCase().contains(name)) {
                return gameObject;
            } else if (exact && compName.equalsIgnoreCase(name)) {
                return gameObject;
            }
        }
        return null;
    }
    public static GameObject findObject(String objectName, boolean exact, int distance, boolean hasLineOfSight, WorldPoint anchorPoint) {
        List<GameObject> gameObjects = getGameObjectsWithinDistance(distance, anchorPoint);
        if (gameObjects == null) {
            return null;
        }
        for (GameObject gameObject : gameObjects) {
            if (!Rs2Tile.areSurroundingTilesWalkable(gameObject.getWorldLocation(), gameObject.sizeX(), gameObject.sizeY()))
                continue;
            if (hasLineOfSight && !hasLineOfSight(gameObject))
                continue;
            ObjectComposition objComp = convertGameObjectToObjectComposition(gameObject);
            if (objComp == null) {
                continue;
            }
            String compName;
            try {
                compName = !objComp.getName().equals("null") ? objComp.getName() : (objComp.getImpostor() != null ? objComp.getImpostor().getName() : null);
            } catch (Exception e) {
                continue;
            }
            if (compName != null) {
                if (!exact && compName.toLowerCase().contains(objectName.toLowerCase())) {
                    return gameObject;
                } else if (exact && compName.equalsIgnoreCase(objectName)) {
                    return gameObject;
                }
            }
        }
        return null;
    }
    public static boolean hasAction(ObjectComposition objComp, String action) {
        boolean result;
        if (objComp == null) return false;
        result = Arrays.stream(objComp.getActions()).anyMatch(x -> x != null && x.equalsIgnoreCase(action.toLowerCase()));
        if (!result) {
            try {
                result = Arrays.stream(objComp.getImpostor().getActions()).anyMatch(x -> x != null && x.equalsIgnoreCase(action.toLowerCase()));
            } catch (Exception ex) {
                //do nothing
            }
        }
        return result;
    }
    /**
     * Imposter objects are objects that have their menu action changed but still remain the same object.
     * for example: farming patches
     */
    public static GameObject findObjectByImposter(int id, String action) {
        return findObjectByImposter(id, action, true);
    }
    public static GameObject findObjectByImposter(int id, String optionName, boolean exact) {
        List<GameObject> gameObjects = getGameObjects();
        if (gameObjects == null) return null;
        for (net.runelite.api.GameObject gameObject : gameObjects) {
            if (gameObject.getId() != id) continue;
            ObjectComposition objComp = convertGameObjectToObjectComposition(gameObject);
            if (objComp == null) continue;
            try {
                if (objComp.getImpostor() == null) continue;
                if (exact) {
                    if (Arrays.stream(objComp.getImpostor().getActions()).filter(Objects::nonNull)
                            .anyMatch((action) -> action.equalsIgnoreCase(optionName))) {
                        return gameObject;
                    }
                } else {
                    if (Arrays.stream(objComp.getImpostor().getActions()).filter(Objects::nonNull)
                            .anyMatch((action) -> action.toLowerCase().contains(optionName.toLowerCase()))) {
                        return gameObject;
                    }
                }
            } catch (Exception ex) {
                // do nothing
            }
        }
        return null;
    }
    public static GameObject findBank() {
        List<GameObject> gameObjects = getGameObjects();
        ArrayList<Integer> possibleBankIds = Rs2Reflection.getObjectByName(new String[]{"bank_booth"}, false);
        possibleBankIds.add(NULL_34810);
        for (GameObject gameObject : gameObjects) {
            if (possibleBankIds.stream().noneMatch(x -> x == gameObject.getId())) continue;
            ObjectComposition objectComposition = convertGameObjectToObjectComposition(gameObject);
            if (objectComposition == null) continue;
            if (Arrays.stream(objectComposition.getActions())
                    .noneMatch(action ->
                            action != null && (
                                    action.toLowerCase().contains("bank") ||
                                            action.toLowerCase().contains("collect"))))
                continue;
            return gameObject;
        }
        return null;
    }
    public static GameObject findChest() {
        List<GameObject> gameObjects = getGameObjects();
        ArrayList<Integer> possibleBankIds = Rs2Reflection.getObjectByName(new String[]{"chest"}, false);
        possibleBankIds.add(12308); // RFD chest lumbridge basement
        possibleBankIds.add(31427); // Fossil island chest
        for (GameObject gameObject : gameObjects) {
            if (possibleBankIds.stream().noneMatch(x -> x == gameObject.getId())) continue;
            ObjectComposition objectComposition = convertGameObjectToObjectComposition(gameObject);
            if (objectComposition == null) continue;
            if (objectComposition.getImpostorIds() != null && objectComposition.getImpostorIds().length > 0) {
                if (Arrays.stream(objectComposition.getImpostor().getActions())
                        .anyMatch(action -> action != null && (
                                action.toLowerCase().contains("bank") ||
                                        action.toLowerCase().contains("collect"))))
                    return gameObject;
            }
            if (Arrays.stream(objectComposition.getActions())
                    .anyMatch(action -> action != null && (
                            action.toLowerCase().contains("bank") ||
                                    action.toLowerCase().contains("collect"))))
                return gameObject;
        }
        return null;
    }
    /**
     * Find nearest Deposit box
     *
     * @return GameObject
     */
    public static GameObject findDepositBox() {
        List<GameObject> gameObjects = getGameObjects();
        ArrayList<Integer> possibleBankIds = Rs2Reflection.getObjectByName(new String[]{"bank"}, false);
//        possibleBankIds.add(ObjectID.BANK_DEPOSIT_BOX);
//        possibleBankIds.add(ObjectID.BANK_DEPOSIT_CHEST);
        for (GameObject gameObject : gameObjects) {
            if (possibleBankIds.stream().noneMatch(x -> x == gameObject.getId())) continue;
            ObjectComposition objectComposition = convertGameObjectToObjectComposition(gameObject);
            if (objectComposition == null) continue;
            if (objectComposition.getImpostorIds() != null && objectComposition.getImpostorIds().length > 0) {
                if (Arrays.stream(objectComposition.getImpostor().getActions())
                        .anyMatch(action -> action != null && (
                                action.toLowerCase().contains("deposit"))))
                    return gameObject;
            }
            if (Arrays.stream(objectComposition.getActions())
                    .anyMatch(action -> action != null && (
                            action.toLowerCase().contains("deposit"))))
                return gameObject;
        }
        return null;
    }
    public static TileObject findObject(List<Integer> ids) {
        int distance = 17; // render distance seems to be around 17
        for (int id : ids) {
            TileObject object = findObjectById(id);
            if (object == null) continue;
            if (Rs2Player.getWorldLocation().distanceTo(object.getWorldLocation()) < distance) {
                if (Rs2Player.getWorldLocation().getPlane() != object.getPlane()) continue;
                if (object instanceof GroundObject && !Rs2Walker.canReach(object.getWorldLocation()))
                    continue;
                //exceptions if the pathsize needs to be bigger
                if (object.getId() == ObjectID.MARKET_STALL_14936) {
                    if (object instanceof GameObject && !Rs2Walker.canReach(object.getWorldLocation(), ((GameObject) object).sizeX(), ((GameObject) object).sizeY(), 4, 4))
                        continue;
                } else {
                    if (object instanceof GameObject && !Rs2Walker.canReach(object.getWorldLocation(), ((GameObject) object).sizeX(), ((GameObject) object).sizeY()))
                        continue;
                }
                return object;
            }
        }
        return null;
    }
    public static TileObject findObject(int[] ids) {
        int distance = 0;
        TileObject tileObject = null;
        for (int id :
                ids) {
            TileObject object = findObjectById(id);
            if (object == null) continue;
            if (Rs2Player.getWorldLocation().distanceTo(object.getWorldLocation()) < distance || tileObject == null) {
                tileObject = object;
                distance = Rs2Player.getWorldLocation().distanceTo(object.getWorldLocation());
            }
        }
        return tileObject;
    }
    public static ObjectComposition convertGameObjectToObjectComposition(TileObject tileObject) {
        Player player = Microbot.getClient().getLocalPlayer();
        if (player.getLocalLocation().distanceTo(tileObject.getLocalLocation()) > 4800) return null;
        return Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getObjectDefinition(tileObject.getId()));
    }
    public static ObjectComposition convertGameObjectToObjectComposition(int objectId) {
        return Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getObjectDefinition(objectId));
    }
    public static WallObject findDoor(int id) {
        Scene scene = Microbot.getClient().getScene();
        Tile[][][] tiles = scene.getTiles();
        int z = Microbot.getClient().getPlane();
        for (int x = 0; x < Constants.SCENE_SIZE; ++x) {
            for (int y = 0; y < Constants.SCENE_SIZE; ++y) {
                Tile tile = tiles[z][x][y];
                if (tile == null) {
                    continue;
                }
                WallObject wall = tile.getWallObject();
                if (wall != null && wall.getId() == id)
                    return wall;
            }
        }
        return null;
    }
    public static List<Tile> getTiles(int maxTileDistance) {
        int maxDistance = Math.max(2400, maxTileDistance * 128);
        Player player = Microbot.getClient().getLocalPlayer();
        Scene scene = Microbot.getClient().getScene();
        Tile[][][] tiles = scene.getTiles();
        int z = Microbot.getClient().getPlane();
        List<Tile> tileObjects = new ArrayList<>();
        for (int x = 0; x < Constants.SCENE_SIZE; ++x) {
            for (int y = 0; y < Constants.SCENE_SIZE; ++y) {
                Tile tile = tiles[z][x][y];
                if (tile == null) {
                    continue;
                }
                if (player.getLocalLocation().distanceTo(tile.getLocalLocation()) <= maxDistance) {
                    tileObjects.add(tile);
                }
            }
        }
        return tileObjects;
    }
    public static List<Tile> getTiles() {
        return getTiles(2400);
    }
    public static GameObject getGameObject(WorldPoint worldPoint) {
        LocalPoint localPoint = LocalPoint.fromWorld(Microbot.getClient(), worldPoint);
        Scene scene = Microbot.getClient().getScene();
        Tile[][][] tiles = scene.getTiles();
        int z = Microbot.getClient().getPlane();
        Tile tile = null;
        if (localPoint != null) {
            tile = tiles[z][localPoint.getSceneX()][localPoint.getSceneY()];
        }
        if (tile != null) {
            return Arrays.stream(tile.getGameObjects()).filter(Objects::nonNull).findFirst().orElse(null);
        }
        return null;
    }
    public static GameObject getGameObject(LocalPoint localPoint) {
        Scene scene = Microbot.getClient().getScene();
        Tile[][][] tiles = scene.getTiles();
        int z = Microbot.getClient().getPlane();
        Tile tile = tiles[z][localPoint.getSceneX()][localPoint.getSceneY()];
        return Arrays.stream(tile.getGameObjects()).filter(Objects::nonNull).findFirst().orElse(null);
    }
    public static List<GroundObject> getGroundObjects(int id, WorldPoint anchorPoint) {
        Scene scene = Microbot.getClient().getScene();
        Tile[][][] tiles = scene.getTiles();
        if (tiles == null) return new ArrayList<>();
        int z = Microbot.getClient().getPlane();
        List<GroundObject> tileObjects = new ArrayList<>();
        for (int x = 0; x < Constants.SCENE_SIZE; ++x) {
            for (int y = 0; y < Constants.SCENE_SIZE; ++y) {
                Tile tile = tiles[z][x][y];
                if (tile == null || tile.getGroundObject() == null) {
                    continue;
                }
                if (tile.getGroundObject().getId() == id) {
                    tileObjects.add(tile.getGroundObject());
                }
            }
        }
        return tileObjects.stream()
                .filter(Objects::nonNull)
                .sorted(Comparator.comparingInt(tile -> tile.getWorldLocation().distanceTo(anchorPoint)))
                .collect(Collectors.toList());
    }
    /**
     * TODO remove this method, maybe use find or get(int id)
     *
     * @param id
     *
     * @return
     */
    public static List<GameObject> getGameObjects(int id) {
        return getGameObjects(id, Rs2Player.getWorldLocation());
    }
    public static List<GameObject> getGameObjects(int id, WorldPoint anchorPoint) {
        Scene scene = Microbot.getClient().getScene();
        Tile[][][] tiles = scene.getTiles();
        if (tiles == null) return new ArrayList<>();
        int z = Microbot.getClient().getPlane();
        List<GameObject> tileObjects = new ArrayList<>();
        for (int x = 0; x < Constants.SCENE_SIZE; ++x) {
            for (int y = 0; y < Constants.SCENE_SIZE; ++y) {
                Tile tile = tiles[z][x][y];
                if (tile == null) {
                    continue;
                }
                for (GameObject tileObject : tile.getGameObjects()) {
                    if (tileObject != null
                            && tileObject.getSceneMinLocation().equals(tile.getSceneLocation()) && tileObject.getId() == id)
                        tileObjects.add(tileObject);
                }
            }
        }
        return tileObjects.stream()
                .filter(Objects::nonNull)
                .sorted(Comparator.comparingInt(tile -> tile.getWorldLocation().distanceTo(anchorPoint)))
                .collect(Collectors.toList());
    }
    public static TileObject getTileObject(int id) {
        return getTileObjects(id, Rs2Player.getWorldLocation()).stream().findFirst().orElse(null);
    }
    public static List<TileObject> getTileObjects(int id) {
        return getTileObjects(id, Rs2Player.getWorldLocation());
    }
    public static List<TileObject> getTileObjects(int id, WorldPoint anchorPoint) {
        return getTileObjects().stream()
                .filter(x -> Objects.nonNull(x) && x.getId() == id)
                .sorted(Comparator.comparingInt(tile -> tile.getWorldLocation().distanceTo(anchorPoint)))
                .collect(Collectors.toList());
    }
    public static List<TileObject> getTileObjects() {
        Scene scene = Microbot.getClient().getScene();
        Tile[][][] tiles = scene.getTiles();
        if (tiles == null) return new ArrayList<>();
        int z = Microbot.getClient().getPlane();
        List<TileObject> tileObjects = new ArrayList<>();
        for (int x = 0; x < Constants.SCENE_SIZE; ++x) {
            for (int y = 0; y < Constants.SCENE_SIZE; ++y) {
                Tile tile = tiles[z][x][y];
                if (tile == null) {
                    continue;
                }
                if (tile.getDecorativeObject() != null
                        && tile.getDecorativeObject().getWorldLocation().equals(tile.getWorldLocation()))
                    tileObjects.add(tile.getDecorativeObject());
                if (tile.getGroundObject() != null
                        && tile.getGroundObject().getWorldLocation().equals(tile.getWorldLocation()))
                    tileObjects.add(tile.getGroundObject());
                if (tile.getWallObject() != null
                        && tile.getWallObject().getWorldLocation().equals(tile.getWorldLocation()))
                    tileObjects.add(tile.getWallObject());
            }
        }
        return tileObjects.stream()
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
    }
    public static List<GameObject> getGameObjects() {
        Scene scene = Microbot.getClient().getScene();
        Tile[][][] tiles = scene.getTiles();
        int z = Microbot.getClient().getPlane();
        List<GameObject> tileObjects = new ArrayList<>();
        for (int x = 0; x < Constants.SCENE_SIZE; ++x) {
            for (int y = 0; y < Constants.SCENE_SIZE; ++y) {
                Tile tile = tiles[z][x][y];
                if (tile == null) {
                    continue;
                }
                for (GameObject tileObject : tile.getGameObjects()) {
                    if (tileObject != null
                            && tileObject.getSceneMinLocation().equals(tile.getSceneLocation()))
                        tileObjects.add(tileObject);
                }
            }
        }
        return tileObjects.stream()
                .filter(Objects::nonNull)
                .sorted(Comparator.comparingInt(tile -> tile.getWorldLocation().distanceTo(Microbot.getClient().getLocalPlayer().getWorldLocation())))
                .collect(Collectors.toList());
    }
    public static List<GameObject> getGameObjectsWithinDistance(int distance) {
        return getGameObjectsWithinDistance(distance, Rs2Player.getWorldLocation());
    }
    public static List<GameObject> getGameObjectsWithinDistance(int distance, WorldPoint anchorPoint) {
        Scene scene = Microbot.getClient().getScene();
        Tile[][][] tiles = scene.getTiles();
        int z = Microbot.getClient().getPlane();
        List<GameObject> tileObjects = new ArrayList<>();
        for (int x = 0; x < Constants.SCENE_SIZE; ++x) {
            for (int y = 0; y < Constants.SCENE_SIZE; ++y) {
                Tile tile = tiles[z][x][y];
                if (tile == null) {
                    continue;
                }
                for (GameObject tileObject : tile.getGameObjects()) {
                    if (tileObject != null
                            && tileObject.getSceneMinLocation().equals(tile.getSceneLocation())) {
                        int distanceToAnchor = anchorPoint.distanceTo(tileObject.getWorldLocation());
                        if (distance == 0) {
                            // Check in a cross pattern if distance is 0
                            WorldPoint objectLocation = tileObject.getWorldLocation();
                            if ((Math.abs(anchorPoint.getX() - objectLocation.getX()) == 1 && anchorPoint.getY() == objectLocation.getY())
                                    || (Math.abs(anchorPoint.getY() - objectLocation.getY()) == 1 && anchorPoint.getX() == objectLocation.getX())) {
                                tileObjects.add(tileObject);
                            }
                        } else {
                            // Default behavior for distances greater than 0
                            if (distanceToAnchor <= distance) {
                                tileObjects.add(tileObject);
                            }
                        }
                    }
                }
            }
        }
        return tileObjects.stream()
                .filter(Objects::nonNull)
                .sorted(Comparator.comparingInt(tile -> tile.getWorldLocation().distanceTo(Microbot.getClient().getLocalPlayer().getWorldLocation())))
                .collect(Collectors.toList());
    }
    public static List<TileObject> getAll() {
        List<TileObject> tileObjects = new ArrayList<>();
        tileObjects.addAll(getGameObjects());
        tileObjects.addAll(getGroundObjects());
        tileObjects.addAll(getWallObjects());
        return tileObjects;
    }
    public static List<GroundObject> getGroundObjects() {
        return getGroundObjects(Constants.SCENE_SIZE);
    }
    public static List<GroundObject> getGroundObjects(int distance) {
        Scene scene = Microbot.getClient().getScene();
        Tile[][][] tiles = scene.getTiles();
        if (tiles == null) return new ArrayList<>();
        int z = Microbot.getClient().getPlane();
        List<GroundObject> tileObjects = new ArrayList<>();
        for (int x = 0; x < Constants.SCENE_SIZE; ++x) {
            for (int y = 0; y < Constants.SCENE_SIZE; ++y) {
                Tile tile = tiles[z][x][y];
                if (tile == null) {
                    continue;
                }
                if (tile.getWorldLocation().distanceTo(Microbot.getClient().getLocalPlayer().getWorldLocation()) > distance)
                    continue;
                tileObjects.add(tile.getGroundObject());
            }
        }
        return tileObjects.stream()
                .filter(Objects::nonNull)
                .sorted(Comparator.comparingInt(tile -> tile.getWorldLocation().distanceTo(Microbot.getClient().getLocalPlayer().getWorldLocation())))
                .collect(Collectors.toList());
    }
    public static List<WallObject> getWallObjects() {
        return getWallObjects(Constants.SCENE_SIZE);
    }
    public static List<WallObject> getWallObjects(int distance) {
        Scene scene = Microbot.getClient().getScene();
        Tile[][][] tiles = scene.getTiles();
        if (tiles == null) return new ArrayList<>();
        int z = Microbot.getClient().getPlane();
        List<WallObject> tileObjects = new ArrayList<>();
        for (int x = 0; x < distance; ++x) {
            for (int y = 0; y < distance; ++y) {
                Tile tile = tiles[z][x][y];
                if (tile == null) {
                    continue;
                }
                tileObjects.add(tile.getWallObject());
            }
        }
        return tileObjects.stream()
                .filter(Objects::nonNull)
                .sorted(Comparator.comparingInt(tile -> tile.getWorldLocation().distanceTo(Microbot.getClient().getLocalPlayer().getWorldLocation())))
                .collect(Collectors.toList());
    }
    public static List<WallObject> getWallObjects(int id, WorldPoint anchorPoint) {
        Scene scene = Microbot.getClient().getScene();
        Tile[][][] tiles = scene.getTiles();
        if (tiles == null) return new ArrayList<>();
        int z = Microbot.getClient().getPlane();
        List<WallObject> tileObjects = new ArrayList<>();
        for (int x = 0; x < Constants.SCENE_SIZE; ++x) {
            for (int y = 0; y < Constants.SCENE_SIZE; ++y) {
                Tile tile = tiles[z][x][y];
                if (tile == null) {
                    continue;
                }
                if (tile.getWallObject() != null
                        && tile.getWallObject().getId() == id)
                    tileObjects.add(tile.getWallObject());
            }
        }
        return tileObjects.stream()
                .filter(Objects::nonNull)
                .sorted(Comparator.comparingInt(tile -> tile.getWorldLocation().distanceTo(anchorPoint)))
                .collect(Collectors.toList());
    }
    // private methods
    private static boolean clickObject(TileObject object) {
        return clickObject(object, "");
    }
    private static boolean clickObject(TileObject object, String action) {
        if (object == null) return false;
        if (Microbot.getClient().getLocalPlayer().getWorldLocation().distanceTo2D(object.getWorldLocation()) > 30) {
            Rs2Walker.walkTo(object.getWorldLocation());
            return false;
        }
        try {
            int param0;
            int param1;
            MenuAction menuAction = MenuAction.WALK;
            ObjectComposition objComp = convertGameObjectToObjectComposition(object);
            if (objComp == null) return false;
            Microbot.status = action + " " + objComp.getName();
            if (object instanceof GameObject) {
                GameObject obj = (GameObject) object;
                if (obj.sizeX() > 1) {
                    param0 = obj.getLocalLocation().getSceneX() - obj.sizeX() / 2;
                } else {
                    param0 = obj.getLocalLocation().getSceneX();
                }
                if (obj.sizeY() > 1) {
                    param1 = obj.getLocalLocation().getSceneY() - obj.sizeY() / 2;
                } else {
                    param1 = obj.getLocalLocation().getSceneY();
                }
            } else {
                // Default objects like walls, groundobjects, decorationobjects etc...
                param0 = object.getLocalLocation().getSceneX();
                param1 = object.getLocalLocation().getSceneY();
            }
            int index = 0;
            if (action != null) {
                String[] actions;
                if (objComp.getImpostorIds() != null) {
                    actions = objComp.getImpostor().getActions();
                } else {
                    actions = objComp.getActions();
                }
                for (int i = 0; i < actions.length; i++) {
                    if (action.equalsIgnoreCase(actions[i])) {
                        index = i;
                        break;
                    }
                }
                if (index == actions.length)
                    index = 0;
            }
            if (index == -1) {
                Microbot.log("Failed to interact with object " + object.getId() + " " + action);
            }
            if (Microbot.getClient().isWidgetSelected()) {
                menuAction = MenuAction.WIDGET_TARGET_ON_GAME_OBJECT;
            } else if (index == 0) {
                menuAction = MenuAction.GAME_OBJECT_FIRST_OPTION;
            } else if (index == 1) {
                menuAction = MenuAction.GAME_OBJECT_SECOND_OPTION;
            } else if (index == 2) {
                menuAction = MenuAction.GAME_OBJECT_THIRD_OPTION;
            } else if (index == 3) {
                menuAction = MenuAction.GAME_OBJECT_FOURTH_OPTION;
            } else if (index == 4) {
                menuAction = MenuAction.GAME_OBJECT_FIFTH_OPTION;
            }
            if (!Rs2Camera.isTileOnScreen(object.getLocalLocation())) {
                Rs2Camera.turnTo(object);
            }
            Microbot.doInvoke(new NewMenuEntry(param0, param1, menuAction.getId(), object.getId(), -1, action, objComp.getName(), object), Rs2UiHelper.getObjectClickbox(object));
// MenuEntryImpl(getOption=Use, getTarget=Barrier, getIdentifier=43700, getType=GAME_OBJECT_THIRD_OPTION, getParam0=53, getParam1=51, getItemId=-1, isForceLeftClick=true, getWorldViewId=-1, isDeprioritized=false)
            //Rs2Reflection.invokeMenu(param0, param1, menuAction.getId(), object.getId(),-1, "", "", -1, -1);
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
        return true;
    }
    public static boolean hasLineOfSight(TileObject tileObject) {
        return hasLineOfSight(Rs2Player.getWorldLocation(), tileObject);
    }
    public static boolean hasLineOfSight(WorldPoint point, TileObject tileObject) {
        if (tileObject == null) return false;
        if (tileObject instanceof GameObject) {
            GameObject gameObject = (GameObject) tileObject;
            WorldPoint worldPoint = WorldPoint.fromScene(Microbot.getClient(), gameObject.getSceneMinLocation().getX(), gameObject.getSceneMinLocation().getY(), gameObject.getPlane());
            return new WorldArea(
                    worldPoint,
                    gameObject.sizeX(),
                    gameObject.sizeY())
                    .hasLineOfSightTo(Microbot.getClient().getTopLevelWorldView(), point.toWorldArea());
        } else {
            return new WorldArea(
                    tileObject.getWorldLocation(),
                    2,
                    2)
                    .hasLineOfSightTo(Microbot.getClient().getTopLevelWorldView(), new WorldArea(point.getX(),
                            point.getY(), 2, 2, point.getPlane()));
        }
    }
    @SneakyThrows
    public static List<Integer> getObjectIdsByName(String name) {
        List<Integer> ids = new ArrayList<>();
        ObjectID objectID = new ObjectID();
        Class<?> objectIDClass = ObjectID.class;
        // Loop through all declared fields of the class
        for (Field field : objectIDClass.getDeclaredFields()) {
            // Get the name of the current field
            String fieldName = field.getName();
            // Check if the current field's name matches the desired property name
            if (fieldName.toLowerCase().contains(name)) {
                field.setAccessible(true);
                int propertyValue = (int) field.get(objectID);
                ids.add(propertyValue);
            }
        }
        return ids;
    }
    @Nullable
    public static ObjectComposition getObjectComposition(int id) {
        ObjectComposition objectComposition = Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getObjectDefinition(id));
        return objectComposition.getImpostorIds() == null ? objectComposition : objectComposition.getImpostor();
    }
    public static boolean canWalkTo(TileObject tileObject, int distance) {
        if (tileObject == null) return false;
        WorldArea objectArea;
        if (tileObject instanceof GameObject) {
            GameObject gameObject = (GameObject) tileObject;
            WorldPoint worldPoint = WorldPoint.fromScene(Microbot.getClient(), gameObject.getSceneMinLocation().getX(), gameObject.getSceneMinLocation().getY(), gameObject.getPlane());
            if (Microbot.getClient().isInInstancedRegion()) {
                var localPoint = LocalPoint.fromWorld(Microbot.getClient(), worldPoint);
                worldPoint = WorldPoint.fromLocalInstance(Microbot.getClient(), localPoint);
            }
            objectArea = new WorldArea(
                    worldPoint,
                    gameObject.sizeX(),
                    gameObject.sizeY());
        } else {
            objectArea = new WorldArea(
                    tileObject.getWorldLocation(),
                    2,
                    2);
        }
        var tiles = Rs2Tile.getReachableTilesFromTile(Rs2Player.getWorldLocation(), distance);
        for (var tile : tiles.keySet()) {
            if (tile.distanceTo(objectArea) < 2)
                return true;
        }
        return false;
    }
    /**
     * Hovers over the given game object using the natural mouse.
     *
     * @param object The game object to hover over.
     *
     * @return True if successfully hovered, otherwise false.
     */
    public static boolean hoverOverObject(TileObject object) {
        if (!Rs2AntibanSettings.naturalMouse) {
            Microbot.log("Natural mouse is not enabled, can't hover");
            return false;
        }
        Point point = Rs2UiHelper.getClickingPoint(Rs2UiHelper.getObjectClickbox(object), true);
        // if the point is 1,1 then the object is not on screen and we should return false
        if (point.getX() == 1 && point.getY() == 1) {
            return false;
        }
        Microbot.getNaturalMouse().moveTo(point.getX(), point.getY());
        return true;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/grandexchange/GrandExchangeSlots.java
================
package net.runelite.client.plugins.microbot.util.grandexchange;
public enum GrandExchangeSlots {
    ONE,
    TWO,
    THREE,
    FOUR,
    FIVE,
    SIX,
    SEVEN,
    EIGHT
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/grandexchange/Rs2GrandExchange.java
================
package net.runelite.client.plugins.microbot.util.grandexchange;
import net.runelite.api.GrandExchangeOfferState;
import net.runelite.api.NPC;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.bank.Rs2Bank;
import net.runelite.client.plugins.microbot.util.bank.enums.BankLocation;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Item;
import net.runelite.client.plugins.microbot.util.keyboard.Rs2Keyboard;
import net.runelite.client.plugins.microbot.util.npc.Rs2Npc;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.microbot.util.walker.Rs2Walker;
import net.runelite.client.plugins.microbot.util.widget.Rs2Widget;
import org.apache.commons.lang3.tuple.Pair;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import static net.runelite.client.plugins.microbot.util.Global.*;
public class Rs2GrandExchange {
    public static final int GRAND_EXCHANGE_OFFER_CONTAINER_QTY_10 = 30474265;
    public static final int GRAND_EXCHANGE_OFFER_CONTAINER_QTY_100 = 30474265;
    public static final int GRAND_EXCHANGE_OFFER_CONTAINER_QTY_1000 = 30474265;
    public static final int GRAND_EXCHANGE_OFFER_CONTAINER_QTY_X = 30474265;
    public static final int GRAND_EXCHANGE_OFFER_CONTAINER_QTY_1 = 30474265;
    public static final int COLLECT_BUTTON = 30474246;
    /**
     * close the grand exchange interface
     */
    public static void closeExchange() {
        Microbot.status = "Closing Grand Exchange";
        if (!isOpen()) return;
        Rs2Widget.clickChildWidget(30474242, 11);
        sleepUntilOnClientThread(() -> Rs2Widget.getWidget(30474242) == null);
    }
    /**
     * check if the grand exchange screen is open
     *
     * @return
     */
    public static boolean isOpen() {
        Microbot.status = "Checking if Grand Exchange is open";
        return !Microbot.getClientThread().runOnClientThread(() -> Rs2Widget.getWidget(WidgetInfo.GRAND_EXCHANGE_WINDOW_CONTAINER) == null
                || Rs2Widget.getWidget(WidgetInfo.GRAND_EXCHANGE_WINDOW_CONTAINER).isHidden());
    }
    /**
     * check if the ge offerscreen is open
     *
     * @return
     */
    public static boolean isOfferScreenOpen() {
        Microbot.status = "Checking if Offer is open";
        return Rs2Widget.getWidget(WidgetInfo.GRAND_EXCHANGE_OFFER_CONTAINER) != null;
    }
    /**
     * Opens the grand exchange
     *
     * @return
     */
    public static boolean openExchange() {
        Microbot.status = "Opening Grand Exchange";
        try {
            if (Rs2Inventory.isItemSelected())
                Microbot.getMouse().click();
            if (isOpen()) return true;
            NPC npc = Rs2Npc.getNpc("Grand Exchange Clerk");
            if (npc == null) return false;
            Rs2Npc.interact(npc, "exchange");
            sleepUntil(Rs2GrandExchange::isOpen, 5000);
            return false;
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
        return false;
    }
    /**
     * @param itemName
     * @param price
     * @param quantity
     * @return true if item has been bought succesfully
     */
    public static boolean buyItem(String itemName, int price, int quantity) {
        return buyItem(itemName, itemName, price, quantity);
    }
    /**
     * @param itemName   name of the item
     * @param searchTerm search term
     * @param price      price of the item to buy
     * @param quantity   quantity of item to buy
     * @return true if item has been bought succesfully
     */
    public static boolean buyItem(String itemName, String searchTerm, int price, int quantity) {
        try {
            if (useGrandExchange()) return false;
            Pair<GrandExchangeSlots, Integer> slot = getAvailableSlot();
            if (slot.getLeft() == null) {
                if (hasBoughtOffer()) {
                    collectToBank();
                }
                return false;
            }
            Widget buyOffer = getOfferBuyButton(slot.getLeft());
            if (buyOffer == null) return false;
            Rs2Widget.clickWidgetFast(buyOffer);
            sleepUntil(Rs2GrandExchange::isOfferTextVisible, 5000);
            sleepUntil(() -> Rs2Widget.hasWidget("What would you like to buy?"));
            Rs2Keyboard.typeString(searchTerm);
            sleepUntil(() -> !Rs2Widget.hasWidget("Start typing the name"), 5000); //GE Search Results
            sleep(1200);
            Pair<Widget, Integer> itemResult = getSearchResultWidget(itemName);
            if (itemResult != null) {
                Rs2Widget.clickWidgetFast(itemResult.getLeft(), itemResult.getRight(), 1);
                sleepUntil(() -> getPricePerItemButton_X() != null);
            }
            Widget pricePerItemButtonX = getPricePerItemButton_X();
            if (pricePerItemButtonX != null) {
                System.out.println("tried to click widget");
                sleep(2000);
                Microbot.getMouse().click(pricePerItemButtonX.getBounds());
                Microbot.getMouse().click(pricePerItemButtonX.getBounds());
                sleepUntil(() -> Rs2Widget.getWidget(162, 41) != null, 5000); //GE Enter Price
                sleep(1000);
                Rs2Keyboard.typeString(Integer.toString(price));
                Rs2Keyboard.enter();
                sleep(2000);
                setQuantity(quantity);
                confirm();
                return true;
            } else {
                System.out.println("unable to find widget setprice.");
            }
            return false;
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
        return false;
    }
    private static void confirm() {
        Microbot.getMouse().click(getConfirm().getBounds());
        sleepUntil(() -> Rs2Widget.hasWidget("Your offer is much higher"), 2000);
        if (Rs2Widget.hasWidget("Your offer is much higher")) {
            Rs2Widget.clickWidget("Yes");
        }
    }
    private static void setQuantity(int quantity) {
        if (quantity > 1) {
            Widget quantityButtonX = getQuantityButton_X();
            Microbot.getMouse().click(quantityButtonX.getBounds());
            sleepUntil(() -> Rs2Widget.getWidget(162, 41) != null); //GE Enter Price/Quantity
            sleep(600, 1000);
            Rs2Keyboard.typeString(Integer.toString(quantity));
            sleep(500, 750);
            Rs2Keyboard.enter();
            sleep(1000);
        }
    }
    /**
     * TODO: test this method
     * Buys item from the grandexchange 5% above the average priec
     * @param itemName
     * @param quantity
     * @return
     */
    public static boolean buyItemAbove5Percent(String itemName, int quantity) {
        try {
            if (!isOpen()) {
                openExchange();
            }
            Pair<GrandExchangeSlots, Integer> slot = getAvailableSlot();
            Widget buyOffer = getOfferBuyButton(slot.getLeft());
            if (buyOffer == null) return false;
            Microbot.getMouse().click(buyOffer.getBounds());
            sleepUntil(Rs2GrandExchange::isOfferTextVisible);
            sleepUntil(() -> Rs2Widget.hasWidget("What would you like to buy?"));
            if (Rs2Widget.hasWidget("What would you like to buy?"))
                Rs2Keyboard.typeString(itemName);
            sleepUntil(() -> Rs2Widget.hasWidget(itemName)); //GE Search Results
            sleep(1200, 1600);
            Pair<Widget, Integer> itemResult = getSearchResultWidget(itemName);
            if (itemResult != null) {
                Rs2Widget.clickWidgetFast(itemResult.getLeft(), itemResult.getRight(), 1);
                sleepUntil(() -> !Rs2Widget.hasWidget("Choose an item..."));
                sleep(600, 1600);
            }
            setQuantity(quantity);
            if (buyItemAbove5Percent()) {
                return true;
            }
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
        return false;
    }
    private static boolean buyItemAbove5Percent() {
        Widget pricePerItemButton5Percent = getPricePerItemButton_Plus5Percent();
        if (pricePerItemButton5Percent != null) {
            int basePrice = getItemPrice();
            Microbot.getMouse().click(pricePerItemButton5Percent.getBounds());
            sleepUntil(() -> hasOfferPriceChanged(basePrice), 1600);
            confirm();
            return true;
        } else {
            System.out.println("unable to find widget setprice.");
            return false;
        }
    }
    private static boolean useGrandExchange() {
        if (!isOpen()) {
            boolean hasExchangeOpen = openExchange();
            if (!hasExchangeOpen) {
                boolean isAtGe = walkToGrandExchange();
                return !isAtGe;
            }
        }
        return false;
    }
    /**
     * Sell item to the grand exchange
     *
     * @param itemName name of the item to sell
     * @param quantity quantity of the item to sell
     * @param price    price of the item to sell
     * @return
     */
    public static boolean sellItem(String itemName, int quantity, int price) {
        try {
            if (!Rs2Inventory.hasItem(itemName)) return false;
            if (useGrandExchange()) return false;
            Pair<GrandExchangeSlots, Integer> slot = getAvailableSlot();
            Widget sellOffer = getOfferSellButton(slot.getLeft());
            if (sellOffer == null) return false;
            Microbot.getMouse().click(sellOffer.getBounds());
            sleepUntil(Rs2GrandExchange::isOfferTextVisible, 5000);
            Rs2Inventory.interact(itemName, "Offer");
            sleepUntil(() -> Rs2Widget.hasWidget("actively traded price"));
            sleep(300, 600);
            Widget pricePerItemButtonX = getPricePerItemButton_X();
            if (pricePerItemButtonX != null) {
                Microbot.getMouse().click(pricePerItemButtonX.getBounds());
                sleepUntil(() -> Rs2Widget.getWidget(162, 41) != null, 5000); //GE Enter Price
                sleep(1000);
                Rs2Keyboard.typeString(Integer.toString(price));
                Rs2Keyboard.enter();
                sleep(300, 500);
                setQuantity(quantity);
                Microbot.getMouse().click(getConfirm().getBounds());
                sleepUntil(() -> !isOfferTextVisible());
                return true;
            } else {
                System.out.println("unable to find widget setprice.");
            }
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
        return false;
    }
    public static boolean sellItemUnder5Percent(String itemName) {
        return sellItemUnder5Percent(itemName, false);
    }
    public static boolean sellItemUnder5Percent(String itemName, boolean exact) {
        try {
            if (!Rs2Inventory.hasItem(itemName)) return false;
            if (!isOpen()) {
                openExchange();
            }
            Pair<GrandExchangeSlots, Integer> slot = getAvailableSlot();
            Widget sellOffer = getOfferSellButton(slot.getLeft());
            if (sellOffer == null) return false;
            Microbot.getMouse().click(sellOffer.getBounds());
            sleepUntil(Rs2GrandExchange::isOfferTextVisible, 5000);
            Rs2Inventory.interact(itemName, "Offer", exact);
            sleepUntil(() -> Rs2Widget.hasWidget("actively traded price"));
            sleep(300, 600);
            Widget pricePerItemButton5Percent = getPricePerItemButton_Minus_5Percent();
            if (pricePerItemButton5Percent != null) {
                Microbot.getMouse().click(pricePerItemButton5Percent.getBounds());
                Microbot.getMouse().click(getConfirm().getBounds());
                sleepUntil(() -> !isOfferTextVisible());
                return true;
            } else {
                System.out.println("unable to find widget setprice.");
            }
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
        return false;
    }
    /**
     * Collect all the grand exchange slots to the bank or inventory
     *
     * @param collectToBank
     * @return
     */
    public static boolean collect(boolean collectToBank) {
        if (isAllSlotsEmpty()) {
            return true;
        }
        if (Rs2Inventory.isFull()) {
            if (Rs2Bank.useBank()) {
                Rs2Bank.depositAll();
            }
        }
        if (!isOpen()) {
            openExchange();
        }
        sleepUntil(Rs2GrandExchange::isOpen);
        Widget[] collectButton = Rs2Widget.getWidget(465,6).getDynamicChildren();
        if (!collectButton[1].isSelfHidden()) {
            Rs2Widget.clickWidgetFast(
                    COLLECT_BUTTON, collectToBank ? 2 : 1);
            sleepUntil(() -> collectButton[1].isSelfHidden());
        }
        return collectButton[1].isSelfHidden();
    }
    public static boolean collectToInventory() {
        return collect(false);
    }
    /**
     * Collect all the grand exchange items to your bank
     * @return
     */
    public static boolean collectToBank() {
        return collect(true);
    }
    /**
     * sells all the tradeable loot items from a specific npc name
     * @param npcName
     * @return true if there is no more loot to sell
     */
    public static boolean sellLoot(String npcName, List<String> itemsToNotSell) {
        boolean soldAllItems = Rs2Bank.withdrawLootItems(npcName, itemsToNotSell);
        if (soldAllItems) {
            boolean isSuccess = sellInventory();
            return isSuccess;
        }
        return false;
    }
    /**
     * Sells all the tradeable items in your inventory
     * @return
     */
    public static boolean sellInventory() {
        for (Rs2Item item : Rs2Inventory.items()) {
            if (!item.isTradeable()) continue;
            if (Rs2GrandExchange.getAvailableSlot().getKey() == null && Rs2GrandExchange.hasSoldOffer()) {
                Rs2GrandExchange.collectToBank();
                sleep(600);
            }
            Rs2GrandExchange.sellItemUnder5Percent(item.name);
        }
        return Rs2Inventory.isEmpty();
    }
    public static Pair<Widget, Integer> getSearchResultWidget(String search) {
        Widget parent = Microbot.getClient().getWidget(ComponentID.CHATBOX_GE_SEARCH_RESULTS);
        if (parent == null || parent.getChildren() == null) return null;
        Widget child = Arrays.stream(parent.getChildren()).filter(x -> x.getText().equalsIgnoreCase(search)).findFirst().orElse(null);
        if (child != null) {
            List<Widget> children = Arrays.stream(parent.getChildren()).collect(Collectors.toList());
            int index = children.indexOf(child);
            int originalWidgetIndex = index - 1;
            return Pair.of(children.get(originalWidgetIndex), originalWidgetIndex);
        }
        return null;
    }
    public static Pair<Widget, Integer> getSearchResultWidget(int itemId) {
        Widget parent = Microbot.getClient().getWidget(WidgetInfo.CHATBOX_GE_SEARCH_RESULTS);
        if (parent == null || parent.getChildren() == null) return null;
        Widget child = Arrays.stream(parent.getChildren()).filter(x -> x.getItemId() == itemId).findFirst().orElse(null);
        if (child != null) {
            List<Widget> children = Arrays.stream(parent.getChildren()).collect(Collectors.toList());
            int index = children.indexOf(child);
            int originalWidgetIndex = index - 2;
            return Pair.of(children.get(originalWidgetIndex), originalWidgetIndex);
        }
        return null;
    }
    private static Widget getOfferContainer() {
        return Microbot.getClient().getWidget(ComponentID.GRAND_EXCHANGE_OFFER_CONTAINER);
    }
    public static Widget getQuantityButton_Minus() {
        var parent = getOfferContainer();
        return Optional.ofNullable(parent).map(p -> p.getChild(1)).orElse(null);
    }
    public static Widget getQuantityButton_Plus() {
        var parent = getOfferContainer();
        return Optional.ofNullable(parent).map(p -> p.getChild(2)).orElse(null);
    }
    public static Widget getQuantityButton_1() {
        var parent = getOfferContainer();
        return Optional.ofNullable(parent).map(p -> p.getChild(3)).orElse(null);
    }
    public static Widget getQuantityButton_10() {
        var parent = getOfferContainer();
        return Optional.ofNullable(parent).map(p -> p.getChild(4)).orElse(null);
    }
    public static Widget getQuantityButton_100() {
        var parent = getOfferContainer();
        return Optional.ofNullable(parent).map(p -> p.getChild(5)).orElse(null);
    }
    public static Widget getQuantityButton_1000() {
        var parent = getOfferContainer();
        return Optional.ofNullable(parent).map(p -> p.getChild(6)).orElse(null);
    }
    public static Widget getQuantityButton_X() {
        var parent = getOfferContainer();
        return Optional.ofNullable(parent).map(p -> p.getChild(7)).orElse(null);
    }
    public static Widget getPricePerItemButton_Minus() {
        var parent = getOfferContainer();
        return Optional.ofNullable(parent).map(p -> p.getChild(8)).orElse(null);
    }
    public static Widget getPricePerItemButton_Plus() {
        var parent = getOfferContainer();
        return Optional.ofNullable(parent).map(p -> p.getChild(9)).orElse(null);
    }
    public static Widget getPricePerItemButton_Minus_5Percent() {
        var parent = getOfferContainer();
        return Optional.ofNullable(parent).map(p -> p.getChild(10)).orElse(null);
    }
    public static Widget getPricePerItemButton_GuidePrice() {
        var parent = getOfferContainer();
        return Optional.ofNullable(parent).map(p -> p.getChild(11)).orElse(null);
    }
    public static Widget getPricePerItemButton_X() {
        var parent = getOfferContainer();
        return Optional.ofNullable(parent).map(p -> p.getChild(12)).orElse(null);
    }
    public static Widget getPricePerItemButton_Plus5Percent() {
        var parent = getOfferContainer();
        return Optional.ofNullable(parent).map(p -> p.getChild(13)).orElse(null);
    }
    public static Widget getChooseItem() {
        var parent = getOfferContainer();
        return Optional.ofNullable(parent).map(p -> p.getChild(20)).orElse(null);
    }
    public static Widget getConfirm() {
        var parent = getOfferContainer();
        return Rs2Widget.findWidget("Confirm", Arrays.stream(parent.getDynamicChildren()).collect(Collectors.toList()), true);
    }
    public static boolean isOfferTextVisible() {
        return Rs2Widget.isWidgetVisible(WidgetInfo.GRAND_EXCHANGE_OFFER_TEXT);
    }
    private static boolean hasOfferPriceChanged(int basePrice) {
        return basePrice != getItemPrice();
    }
    public static Widget getItemPriceWidget() {
        return Rs2Widget.getWidget(465, 27);
    }
    public static int getItemPrice() {
        return Integer.parseInt(Rs2Widget.getWidget(465, 27).getText());
    }
    public static Widget getSlot(GrandExchangeSlots slot) {
        switch (slot) {
            case ONE:
                return Rs2Widget.getWidget(465, 7);
            case TWO:
                return Rs2Widget.getWidget(465, 8);
            case THREE:
                return Rs2Widget.getWidget(465, 9);
            case FOUR:
                return Rs2Widget.getWidget(465, 10);
            case FIVE:
                return Rs2Widget.getWidget(465, 11);
            case SIX:
                return Rs2Widget.getWidget(465, 12);
            case SEVEN:
                return Rs2Widget.getWidget(465, 13);
            case EIGHT:
                return Rs2Widget.getWidget(465, 14);
            default:
                return null;
        }
    }
    public static boolean isSlotAvailable(GrandExchangeSlots slot) {
        Widget parent = getSlot(slot);
        return Optional.ofNullable(parent).map(p -> p.getChild(2).isSelfHidden()).orElse(false);
    }
    public static Widget getOfferBuyButton(GrandExchangeSlots slot) {
        Widget parent = getSlot(slot);
        return Optional.ofNullable(parent).map(p -> p.getChild(0)).orElse(null);
    }
    public static Widget getOfferSellButton(GrandExchangeSlots slot) {
        Widget parent = getSlot(slot);
        return Optional.ofNullable(parent).map(p -> p.getChild(1)).orElse(null);
    }
    public static Pair<GrandExchangeSlots, Integer> getAvailableSlot() {
        int maxSlots = getMaxSlots();
        int slotsAvailable = 0;
        GrandExchangeSlots availableSlot = null;
        for (int i = 0; i < maxSlots; i++) {
            GrandExchangeSlots slot = GrandExchangeSlots.values()[i];
            if (Rs2GrandExchange.isSlotAvailable(slot)) {
                if (availableSlot == null) {
                    availableSlot = slot;
                }
                slotsAvailable++;
            }
        }
        return Pair.of(availableSlot, slotsAvailable);
    }
    public static boolean isAllSlotsEmpty() {
        return getAvailableSlot().getRight() == Arrays.stream(GrandExchangeSlots.values()).count();
    }
    public static boolean hasBoughtOffer() {
        return Arrays.stream(Microbot.getClient().getGrandExchangeOffers()).anyMatch(x -> x.getState() == GrandExchangeOfferState.BOUGHT);
    }
    public static boolean hasSoldOffer() {
        return Arrays.stream(Microbot.getClient().getGrandExchangeOffers()).anyMatch(x -> x.getState() == GrandExchangeOfferState.SOLD);
    }
    private static int getMaxSlots() {
        return Rs2Player.isMember() ? 8 : 3;
    }
    public static boolean walkToGrandExchange() {
        return Rs2Walker.walkTo(BankLocation.GRAND_EXCHANGE.getWorldPoint());
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/grounditem/InteractModel.java
================
package net.runelite.client.plugins.microbot.util.grounditem;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;
@Getter
public class InteractModel {
    int id;
    WorldPoint location;
    String name;
    public InteractModel(int id, WorldPoint location, String name) {
        this.id = id;
        this.location = location;
        this.name = name;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/grounditem/LootingParameters.java
================
package net.runelite.client.plugins.microbot.util.grounditem;
public class LootingParameters {
    private int minValue, maxValue, range, minItems, minQuantity, minInvSlots;
    private boolean delayedLooting, antiLureProtection;
    private String[] names;
    /**
     * This constructor is used to create a new LootingParameters object.
     * It sets the minimum value, maximum value, range, minimum items, delayed looting, and anti-lure protection.
     *
     * @param minValue           The minimum value of the items to be looted.
     * @param maxValue           The maximum value of the items to be looted.
     * @param range              The range within which the items to be looted are located.
     * @param minItems           The minimum number of items to be looted.
     * @param minInvSlots        The minimum number of inventory slots to have open.
     * @param delayedLooting     A boolean indicating whether looting should be delayed.
     * @param antiLureProtection A boolean indicating whether anti-lure protection should be enabled.
     */
    public LootingParameters(int minValue, int maxValue, int range, int minItems, int minInvSlots, boolean delayedLooting, boolean antiLureProtection) {
        setValues(minValue, maxValue, range, minItems, 0, minInvSlots, delayedLooting, antiLureProtection, null);
    }
    /**
     * This constructor is used to create a new LootingParameters object.
     * It sets the range, minimum items, minimum quantity, delayed looting, anti-lure protection, and names of the items to be looted.
     *
     * @param range              The range within which the items to be looted are located.
     * @param minItems           The minimum number of items to be looted.
     * @param minQuantity        The minimum quantity of items to be looted.
     * @param minInvSlots        The minimum number of inventory slots to have open.
     * @param delayedLooting     A boolean indicating whether looting should be delayed.
     * @param antiLureProtection A boolean indicating whether anti-lure protection should be enabled.
     * @param names              The names of the items to be looted.
     */
    public LootingParameters(int range, int minItems, int minQuantity, int minInvSlots, boolean delayedLooting, boolean antiLureProtection, String... names) {
        setValues(0, 0, range, minItems, minQuantity, minInvSlots, delayedLooting, antiLureProtection, names);
    }
    private void setValues(int minValue, int maxValue, int range, int minItems, int minQuantity, int minInvSlots, boolean delayedLooting, boolean antiLureProtection, String[] names) {
        this.minValue = minValue;
        this.maxValue = maxValue;
        this.range = range;
        this.minItems = minItems;
        this.minQuantity = minQuantity;
        this.minInvSlots = minInvSlots;
        this.delayedLooting = delayedLooting;
        this.antiLureProtection = antiLureProtection;
        this.names = names;
    }
    // Getters
    public int getMinValue() {
        return minValue;
    }
    public int getMaxValue() {
        return maxValue;
    }
    public int getRange() {
        return range;
    }
    public int getMinItems() {
        return minItems;
    }
    public int getMinQuantity() {
        return minQuantity;
    }
    public int getMinInvSlots() {
        return minInvSlots;
    }
    public boolean isDelayedLooting() {
        return delayedLooting;
    }
    public boolean isAntiLureProtection() {
        return antiLureProtection;
    }
    public String[] getNames() {
        return names;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/grounditem/Rs2GroundItem.java
================
package net.runelite.client.plugins.microbot.util.grounditem;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.grounditems.GroundItem;
import net.runelite.client.plugins.grounditems.GroundItemsPlugin;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.menu.NewMenuEntry;
import net.runelite.client.plugins.microbot.util.models.RS2Item;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.microbot.util.reflection.Rs2Reflection;
import java.awt.*;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import static net.runelite.api.TileItem.OWNERSHIP_SELF;
import static net.runelite.client.plugins.microbot.util.Global.sleepUntil;
import static net.runelite.client.plugins.microbot.util.Global.sleepUntilTrue;
@Slf4j
public class Rs2GroundItem {
    private static boolean interact(RS2Item rs2Item, String action) {
        if (rs2Item == null) return false;
        try {
            interact(new InteractModel(rs2Item.getTileItem().getId(), rs2Item.getTile().getWorldLocation(), rs2Item.getItem().getName()), action);
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
        return true;
    }
    /**
     * Interacts with a ground item by performing a specified action.
     *
     * @param groundItem The ground item to interact with.
     * @param action     The action to perform on the ground item.
     *
     * @return true if the interaction was successful, false otherwise.
     */
    private static boolean interact(InteractModel groundItem, String action) {
        if (groundItem == null) return false;
        try {
            int param0;
            int param1;
            int identifier;
            String target;
            String option;
            MenuAction menuAction = MenuAction.CANCEL;
            ItemComposition item;
            item = Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getItemDefinition(groundItem.getId()));
            identifier = groundItem.getId();
            LocalPoint localPoint = LocalPoint.fromWorld(Microbot.getClient(), groundItem.getLocation());
            if (localPoint == null) return false;
            param0 = localPoint.getSceneX();
            target = "<col=ff9040>" + groundItem.getName();
            param1 = localPoint.getSceneY();
            option = action;
            String[] groundActions = Rs2Reflection.getGroundItemActions(item);
            int index = -1;
            for (int i = 0; i < groundActions.length; i++) {
                String groundAction = groundActions[i];
                if (groundAction == null || !groundAction.equalsIgnoreCase(action)) continue;
                index = i;
            }
            if (Microbot.getClient().isWidgetSelected()) {
                menuAction = MenuAction.WIDGET_TARGET_ON_GROUND_ITEM;
            } else if (index == 0) {
                menuAction = MenuAction.GROUND_ITEM_FIRST_OPTION;
            } else if (index == 1) {
                menuAction = MenuAction.GROUND_ITEM_SECOND_OPTION;
            } else if (index == 2) {
                menuAction = MenuAction.GROUND_ITEM_THIRD_OPTION;
            } else if (index == 3) {
                menuAction = MenuAction.GROUND_ITEM_FOURTH_OPTION;
            } else if (index == 4) {
                menuAction = MenuAction.GROUND_ITEM_FIFTH_OPTION;
            }
            LocalPoint localPoint1 = LocalPoint.fromWorld(Microbot.getClient(), groundItem.location);
            if (localPoint1 != null) {
                Microbot.doInvoke(new NewMenuEntry(action, param0, param1, menuAction.getId(), identifier, -1, target),
                        Perspective.getCanvasTilePoly(Microbot.getClient(), localPoint1).getBounds());
            } else {
                Microbot.doInvoke(new NewMenuEntry(action, param0, param1, menuAction.getId(), identifier, -1, target),
                        new Rectangle(1, 1, Microbot.getClient().getCanvasWidth(), Microbot.getClient().getCanvasHeight()));
            }
            //Rs2Reflection.invokeMenu(param0, param1, menuAction.getId(), identifier, -1, option, target, -1, -1);
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
        return true;
    }
    public static boolean interact(GroundItem groundItem) {
        return interact(new InteractModel(groundItem.getId(), groundItem.getLocation(), groundItem.getName()), "Take");
    }
    private static int calculateDespawnTime(GroundItem groundItem) {
        Instant spawnTime = groundItem.getSpawnTime();
        if (spawnTime == null) {
            return 0;
        }
        Instant despawnTime = spawnTime.plus(groundItem.getDespawnTime());
        if (Instant.now().isAfter(despawnTime)) {
            // that's weird
            return 0;
        }
        long despawnTimeMillis = despawnTime.toEpochMilli() - Instant.now().toEpochMilli();
        return (int) (despawnTimeMillis / 600);
    }
    /**
     * Returns all the ground items at a tile on the current plane.
     *
     * @param x The x position of the tile in the world.
     * @param y The y position of the tile in the world.
     *
     * @return An array of the ground items on the specified tile.
     */
    public static RS2Item[] getAllAt(int x, int y) {
        return Microbot.getClientThread().runOnClientThread(() -> {
            if (!Microbot.isLoggedIn()) {
                return null;
            }
            List<RS2Item> list = new ArrayList<>();
            Tile tile = getTile(x, y);
            if (tile == null) {
                return null;
            }
            List<TileItem> groundItems = tile.getGroundItems();
            if (groundItems != null && !groundItems.isEmpty()) {
                for (TileItem groundItem : groundItems) {
                    RS2Item rs2Item = new RS2Item(Microbot.getItemManager().getItemComposition(groundItem.getId()), tile, groundItem);
                    list.add(rs2Item);
                }
            }
            return list.toArray(new RS2Item[list.size()]);
        });
    }
    public static Tile getTile(int x, int y) {
        WorldPoint worldPoint = new WorldPoint(x, y, Microbot.getClient().getPlane());
        if (worldPoint.isInScene(Microbot.getClient())) {
            LocalPoint localPoint = LocalPoint.fromWorld(Microbot.getClient(), worldPoint);
            if (localPoint == null) return null;
            return Microbot.getClient().getScene().getTiles()[worldPoint.getPlane()][localPoint.getSceneX()][localPoint.getSceneY()];
        }
        return null;
    }
    public static RS2Item[] getAll(int range) {
        List<RS2Item> temp = new ArrayList<>();
        int pX = Microbot.getClient().getLocalPlayer().getWorldLocation().getX();
        int pY = Microbot.getClient().getLocalPlayer().getWorldLocation().getY();
        int minX = pX - range, minY = pY - range;
        int maxX = pX + range, maxY = pY + range;
        for (int x = minX; x < maxX; x++) {
            for (int y = minY; y < maxY; y++) {
                RS2Item[] items = getAllAt(x, y);
                if (items != null)
                    for (RS2Item item : items) {
                        if (item == null) {
                            continue;
                        }
                        temp.add(item);
                    }
            }
        }
        //sort on closest item first
        temp = temp.stream().sorted(Comparator
                        .comparingInt(value -> value.getTile().getLocalLocation()
                                .distanceTo(Microbot.getClient().getLocalPlayer().getLocalLocation())))
                .collect(Collectors.toList());
        //filter out items based on value
        return temp.toArray(new RS2Item[temp.size()]);
    }
    public static boolean loot(String lootItem, int range) {
        return loot(lootItem, 1, range);
    }
    public static boolean pickup(String lootItem, int range) {
        return loot(lootItem, 1, range);
    }
    public static boolean take(String lootItem, int range) {
        return loot(lootItem, 1, range);
    }
    public static boolean loot(String lootItem, int minQuantity, int range) {
        if (Rs2Inventory.isFull(lootItem)) return false;
        RS2Item[] groundItems = Microbot.getClientThread().runOnClientThread(() ->
                Rs2GroundItem.getAll(range)
        );
        for (RS2Item rs2Item : groundItems) {
            if (rs2Item.getItem().getName().equalsIgnoreCase(lootItem) && rs2Item.getTileItem().getQuantity() >= minQuantity) {
                interact(rs2Item);
                return true;
            }
        }
        return false;
    }
    public static boolean lootItemBasedOnValue(int value, int range) {
        RS2Item[] groundItems = Microbot.getClientThread().runOnClientThread(() ->
                Rs2GroundItem.getAll(range)
        );
        final int invSize = Rs2Inventory.size();
        for (RS2Item rs2Item : groundItems) {
            if (!hasLineOfSight(rs2Item.getTile())) continue;
            long totalPrice = (long) Microbot.getClientThread().runOnClientThread(() ->
                    Microbot.getItemManager().getItemPrice(rs2Item.getItem().getId()) * rs2Item.getTileItem().getQuantity());
            if (totalPrice >= value) {
                if (Rs2Inventory.isFull()) {
                    if (Rs2Player.eatAt(100)) {
                        Rs2Player.waitForAnimation();
                        boolean result = interact(rs2Item);
                        if (result) {
                            sleepUntil(() -> invSize != Rs2Inventory.size());
                        }
                        return result;
                    }
                }
                boolean result = interact(rs2Item);
                if (result) {
                    sleepUntil(() -> invSize != Rs2Inventory.size());
                }
                return result;
            }
        }
        return false;
    }
    private static boolean coreLoot(GroundItem groundItem) {
        final int quantity = groundItem.isStackable() ? 1 : groundItem.getQuantity();
        for (int i = 0; i < quantity; i++) {
            /**
             *  if the number of empty slots is less than the item quantity,
             *  return true only if the item is stackable and is already present in the inventory.
             *  Otherwise, return false.
             */
            if (Rs2Inventory.getEmptySlots() < quantity) {
                if (!groundItem.isStackable())
                    return false;
                if (!Rs2Inventory.hasItem(groundItem.getId()))
                    return false;
            }
            Microbot.pauseAllScripts = true;
            Rs2Inventory.waitForInventoryChanges(() -> interact(groundItem));
        }
        return true;
    }
    private static boolean validateLoot(Predicate<GroundItem> filter) {
        boolean hasLootableItems = sleepUntilTrue(() -> hasLootableItems(filter), 600, 5000);
        //If there are no more lootable items we succesfully looted everything in the filter
        // true to let the script know that we succesfully looted
        if (!hasLootableItems) {
            Microbot.pauseAllScripts = false;
            return true;
        }
        // If we reach this statement, we most likely still have items to loot, and we return false to the script
        // Script above can handle extra logic if the looting failed
        return false;
    }
    public static boolean lootItemBasedOnValue(LootingParameters params) {
        Predicate<GroundItem> filter = groundItem -> groundItem.getGePrice() > params.getMinValue() && (groundItem.getGePrice() / groundItem.getQuantity()) < params.getMaxValue() &&
                groundItem.getLocation().distanceTo(Microbot.getClient().getLocalPlayer().getWorldLocation()) < params.getRange() &&
                (!params.isAntiLureProtection() || (params.isAntiLureProtection() && groundItem.getOwnership() == OWNERSHIP_SELF));
        List<GroundItem> groundItems = GroundItemsPlugin.getCollectedGroundItems().values().stream()
                .filter(filter)
                .sorted(Comparator.comparingInt(value -> value.getLocation().distanceTo(Rs2Player.getWorldLocation())))
                .collect(Collectors.toList());
        if (groundItems.size() < params.getMinItems()) return false;
        if (params.isDelayedLooting()) {
            // Get the ground item with the lowest despawn time
            GroundItem item = groundItems.stream().min(Comparator.comparingInt(Rs2GroundItem::calculateDespawnTime)).orElse(null);
            assert item != null;
            if (calculateDespawnTime(item) > 150) return false;
        }
        for (GroundItem groundItem : groundItems) {
            if (groundItem.getQuantity() < params.getMinItems()) continue;
            if (Rs2Inventory.getEmptySlots() < params.getMinInvSlots()) return true;
            coreLoot(groundItem);
        }
        return validateLoot(filter);
    }
    public static boolean lootItemsBasedOnNames(LootingParameters params) {
        final Predicate<GroundItem> filter = groundItem ->
                groundItem.getLocation().distanceTo(Microbot.getClient().getLocalPlayer().getWorldLocation()) < params.getRange() &&
                        (!params.isAntiLureProtection() || (params.isAntiLureProtection() && groundItem.getOwnership() == OWNERSHIP_SELF)) &&
                        Arrays.stream(params.getNames()).anyMatch(name -> groundItem.getName().toLowerCase().contains(name.toLowerCase()));
        List<GroundItem> groundItems = GroundItemsPlugin.getCollectedGroundItems().values().stream()
                .filter(filter)
                .collect(Collectors.toList());
        if (groundItems.size() < params.getMinItems()) return false;
        if (params.isDelayedLooting()) {
            // Get the ground item with the lowest despawn time
            GroundItem item = groundItems.stream().min(Comparator.comparingInt(Rs2GroundItem::calculateDespawnTime)).orElse(null);
            assert item != null;
            if (calculateDespawnTime(item) > 150) return false;
        }
        for (GroundItem groundItem : groundItems) {
            if (groundItem.getQuantity() < params.getMinQuantity()) continue;
            if (Rs2Inventory.getEmptySlots() <= params.getMinInvSlots()) return true;
            coreLoot(groundItem);
        }
        return validateLoot(filter);
    }
    // Loot untradables
    public static boolean lootUntradables(LootingParameters params) {
        final Predicate<GroundItem> filter = groundItem ->
                groundItem.getLocation().distanceTo(Microbot.getClient().getLocalPlayer().getWorldLocation()) < params.getRange() &&
                        (!params.isAntiLureProtection() || (params.isAntiLureProtection() && groundItem.getOwnership() == OWNERSHIP_SELF)) &&
                        !groundItem.isTradeable() &&
                        groundItem.getId() != ItemID.COINS_995;
        List<GroundItem> groundItems = GroundItemsPlugin.getCollectedGroundItems().values().stream()
                .filter(filter)
                .collect(Collectors.toList());
        if (groundItems.size() < params.getMinItems()) return false;
        if (params.isDelayedLooting()) {
            // Get the ground item with the lowest despawn time
            GroundItem item = groundItems.stream().min(Comparator.comparingInt(Rs2GroundItem::calculateDespawnTime)).orElse(null);
            assert item != null;
            if (calculateDespawnTime(item) > 150) return false;
        }
        for (GroundItem groundItem : groundItems) {
            if (groundItem.getQuantity() < params.getMinQuantity()) continue;
            if (Rs2Inventory.getEmptySlots() <= params.getMinInvSlots()) return true;
            coreLoot(groundItem);
        }
        return validateLoot(filter);
    }
    // Loot coins
    public static boolean lootCoins(LootingParameters params) {
        final Predicate<GroundItem> filter = groundItem ->
                groundItem.getLocation().distanceTo(Microbot.getClient().getLocalPlayer().getWorldLocation()) < params.getRange() &&
                        (!params.isAntiLureProtection() || (params.isAntiLureProtection() && groundItem.getOwnership() == OWNERSHIP_SELF)) &&
                        groundItem.getId() == ItemID.COINS_995;
        List<GroundItem> groundItems = GroundItemsPlugin.getCollectedGroundItems().values().stream()
                .filter(filter)
                .collect(Collectors.toList());
        if (groundItems.size() < params.getMinItems()) return false;
        if (params.isDelayedLooting()) {
            // Get the ground item with the lowest despawn time
            GroundItem item = groundItems.stream().min(Comparator.comparingInt(Rs2GroundItem::calculateDespawnTime)).orElse(null);
            assert item != null;
            if (calculateDespawnTime(item) > 150) return false;
        }
        for (GroundItem groundItem : groundItems) {
            if (groundItem.getQuantity() < params.getMinQuantity()) continue;
            if (Rs2Inventory.getEmptySlots() <= params.getMinInvSlots()) return true;
            coreLoot(groundItem);
        }
        return validateLoot(filter);
    }
    private static boolean hasLootableItems(Predicate<GroundItem> filter) {
        List<GroundItem> groundItems = GroundItemsPlugin.getCollectedGroundItems().values().stream()
                .filter(filter)
                .collect(Collectors.toList());
        return !groundItems.isEmpty();
    }
    public static boolean isItemBasedOnValueOnGround(int value, int range) {
        RS2Item[] groundItems = Microbot.getClientThread().runOnClientThread(() ->
                Rs2GroundItem.getAll(range)
        );
        for (RS2Item rs2Item : groundItems) {
            long totalPrice = (long) Microbot.getClientThread().runOnClientThread(() ->
                    Microbot.getItemManager().getItemPrice(rs2Item.getItem().getId()) * rs2Item.getTileItem().getQuantity());
            if (totalPrice >= value) {
                return true;
            }
        }
        return false;
    }
    @Deprecated(since="1.4.6", forRemoval = true)
    public static boolean lootAllItemBasedOnValue(int value, int range) {
        RS2Item[] groundItems = Microbot.getClientThread().runOnClientThread(() ->
                Rs2GroundItem.getAll(range)
        );
        Rs2Inventory.dropEmptyVials();
        for (RS2Item rs2Item : groundItems) {
            if (Rs2Inventory.isFull(rs2Item.getItem().getName())) continue;
            long totalPrice = (long) Microbot.getClientThread().runOnClientThread(() ->
                    Microbot.getItemManager().getItemPrice(rs2Item.getItem().getId()) * rs2Item.getTileItem().getQuantity());
            if (totalPrice >= value) {
                return interact(rs2Item);
            }
        }
        return false;
    }
    @Deprecated(since="1.4.6", forRemoval = true)
    public static boolean loot(int itemId) {
        if (Rs2Inventory.isFull(itemId)) return false;
        RS2Item[] groundItems = Microbot.getClientThread().runOnClientThread(() ->
                Rs2GroundItem.getAll(50)
        );
        for (RS2Item rs2Item : groundItems) {
            if (rs2Item.getItem().getId() == itemId) {
                interact(rs2Item);
                return true;
            }
        }
        return false;
    }
    public static boolean lootAtGePrice(int minGePrice) {
        return lootItemBasedOnValue(minGePrice, 14);
    }
    public static boolean pickup(int itemId) {
        return loot(itemId);
    }
    public static boolean take(int itemId) {
        return loot(itemId);
    }
    public static boolean interact(RS2Item rs2Item) {
        return interact(rs2Item, "Take");
    }
    public static boolean interact(String itemName, String action) {
        return interact(itemName, action, 255);
    }
    public static boolean interact(String itemName, String action, int range) {
        RS2Item[] groundItems = Microbot.getClientThread().runOnClientThread(() -> Rs2GroundItem.getAll(range));
        for (RS2Item rs2Item : groundItems) {
            if (rs2Item.getItem().getName().equalsIgnoreCase(itemName)) {
                interact(rs2Item, action);
                return true;
            }
        }
        return false;
    }
    public static boolean interact(int itemId, String action, int range) {
        RS2Item[] groundItems = Microbot.getClientThread().runOnClientThread(() -> Rs2GroundItem.getAll(range));
        for (RS2Item rs2Item : groundItems) {
            if (rs2Item.getItem().getId() == itemId) {
                interact(rs2Item, action);
                return true;
            }
        }
        return false;
    }
    public static boolean exists(String itemName, int range) {
        RS2Item[] groundItems = Microbot.getClientThread().runOnClientThread(() -> Rs2GroundItem.getAll(range));
        for (RS2Item rs2Item : groundItems) {
            if (rs2Item.getItem().getName().equalsIgnoreCase(itemName)) {
                return true;
            }
        }
        return false;
    }
    public static boolean hasLineOfSight(Tile tile) {
        if (tile == null) return false;
        return new WorldArea(
                tile.getWorldLocation(),
                1,
                1)
                .hasLineOfSightTo(Microbot.getClient().getTopLevelWorldView(), Microbot.getClient().getLocalPlayer().getWorldLocation().toWorldArea());
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/inventory/DropOrder.java
================
package net.runelite.client.plugins.microbot.util.inventory;
public enum DropOrder {
    STANDARD,
    EFFICIENT_ROW,
    COLUMN,
    EFFICIENT_COLUMN,
    RANDOM;
    // return a random DropOrder
    public static DropOrder random() {
        return values()[(int) (Math.random() * values().length - 1)];
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/inventory/Rs2Inventory.java
================
package net.runelite.client.plugins.microbot.util.inventory;
import net.runelite.api.*;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.widgets.ComponentID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.globval.enums.InterfaceTab;
import net.runelite.client.plugins.microbot.qualityoflife.scripts.pouch.Pouch;
import net.runelite.client.plugins.microbot.util.antiban.Rs2AntibanSettings;
import net.runelite.client.plugins.microbot.util.bank.Rs2Bank;
import net.runelite.client.plugins.microbot.util.equipment.Rs2Equipment;
import net.runelite.client.plugins.microbot.util.gameobject.Rs2GameObject;
import net.runelite.client.plugins.microbot.util.grandexchange.Rs2GrandExchange;
import net.runelite.client.plugins.microbot.util.math.Random;
import net.runelite.client.plugins.microbot.util.menu.NewMenuEntry;
import net.runelite.client.plugins.microbot.util.misc.Rs2Potion;
import net.runelite.client.plugins.microbot.util.npc.Rs2Npc;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.microbot.util.shop.Rs2Shop;
import net.runelite.client.plugins.microbot.util.tabs.Rs2Tab;
import net.runelite.client.plugins.microbot.util.widget.Rs2Widget;
import org.apache.commons.lang3.NotImplementedException;
import java.awt.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.function.Predicate;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import static net.runelite.client.plugins.microbot.Microbot.log;
import static net.runelite.client.plugins.microbot.util.Global.sleep;
import static net.runelite.client.plugins.microbot.util.Global.sleepUntil;
public class Rs2Inventory {
    // The maximum capacity of the inventory
    private static final int CAPACITY = 28;
    private static final int COLUMNS = 4;
    private static final int ROWS = 7;
    public static List<Rs2Item> inventoryItems = new ArrayList<>();
    private static boolean isTrackingInventory = false;
    private static boolean isInventoryChanged = false;
    public static ItemContainer inventory() {
        return Microbot.getClient().getItemContainer(InventoryID.INVENTORY);
    }
    public static void storeInventoryItemsInMemory(ItemContainerChanged e) {
        if (e.getContainerId() == InventoryID.INVENTORY.getId() && e.getItemContainer() != null) {
            if (isTrackingInventory) {
                isInventoryChanged = true;
            }
            List<Rs2Item> _inventoryItems = new ArrayList<>();
            for (int i = 0; i < e.getItemContainer().getItems().length; i++) {
                Item item = inventory().getItems()[i];
                if (item.getId() == -1) continue;
                ItemComposition itemComposition = Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getItemDefinition(item.getId()));
                _inventoryItems.add(new Rs2Item(item, itemComposition, i));
            }
            inventoryItems = _inventoryItems;
        }
    }
    public static List<Rs2Item> items() {
        return inventoryItems;
    }
    /**
     * Gets all the items in the inventory.
     *
     * @return A list of all items in the inventory.
     */
    public static List<Rs2Item> all() {
        return items();
    }
    /**
     * A list of all the items that meet a specified filter criteria.
     *
     * @param filter The filter to apply when selecting items.
     *
     * @return A list of items that match the filter.
     */
    public static List<Rs2Item> all(Predicate<Rs2Item> filter) {
        return items().stream().filter(filter).collect(Collectors.toList());
    }
    /**
     * Returns the capacity of your inventory (28).
     *
     * @return The maximum number of items that can be held in the inventory.
     */
    public static int capacity() {
        return CAPACITY;
    }
    /**
     * Combines two items in the inventory by their IDs.
     *
     * @param primaryItemId   The ID of the primary item.
     * @param secondaryItemId The ID of the secondary item.
     *
     * @return True if the combine operation was successful, false otherwise.
     */
    public static boolean combine(int primaryItemId, int secondaryItemId) {
        boolean primaryItemInteracted = use(primaryItemId);
        sleep(100);
        boolean secondaryItemInteracted = use(secondaryItemId);
        return primaryItemInteracted && secondaryItemInteracted;
    }
    /**
     * Combines two items in the inventory by their names.
     *
     * @param primaryItemName   The name of the primary item.
     * @param secondaryItemName The name of the secondary item.
     *
     * @return True if the combine operation was successful, false otherwise.
     */
    public static boolean combine(String primaryItemName, String secondaryItemName) {
        boolean primaryItemInteracted = use(primaryItemName);
        sleep(100);
        boolean secondaryItemInteracted = use(secondaryItemName);
        return primaryItemInteracted && secondaryItemInteracted;
    }
    /**
     * Combines two items in the inventory.
     *
     * @param primary   The primary item.
     * @param secondary The secondary item.
     *
     * @return True if the combine operation was successful, false otherwise.
     */
    public static boolean combine(Rs2Item primary, Rs2Item secondary) {
        boolean primaryItemInteracted = use(primary);
        sleep(100, 175);
        boolean secondaryItemInteracted = use(secondary);
        return primaryItemInteracted && secondaryItemInteracted;
    }
    /**
     * Combines the closest items in the inventory based on their names.
     * <p>
     * This method searches for items in the inventory by their names, then finds the pair of primary and
     * secondary items with the smallest slot difference and combines them.
     * <p>
     * For combining items by their IDs, see {@link #combineClosest(int, int) combineClosest}.
     *
     * @param primaryItemName   the name of the primary item to combine
     * @param secondaryItemName the name of the secondary item to combine
     *
     * @return true if the items were successfully combined, false otherwise
     */
    public static boolean combineClosest(String primaryItemName, String secondaryItemName) {
        List<Rs2Item> primaryItems = items().stream().filter(x -> x.name.equalsIgnoreCase(primaryItemName)).collect(Collectors.toList());
        List<Rs2Item> secondaryItems = items().stream().filter(x -> x.name.equalsIgnoreCase(secondaryItemName)).collect(Collectors.toList());
        if (primaryItems.isEmpty() || secondaryItems.isEmpty()) return false;
        Rs2Item closestPrimaryItem = null;
        Rs2Item closestSecondaryItem = null;
        int minSlotDifference = Integer.MAX_VALUE;
        // Compare each primary item with each secondary item to find the closest slots
        for (Rs2Item primaryItem : primaryItems) {
            for (Rs2Item secondaryItem : secondaryItems) {
                int slotDifference = calculateSlotDifference(primaryItem.slot, secondaryItem.slot);
                if (slotDifference <= minSlotDifference) {
                    minSlotDifference = slotDifference;
                    closestPrimaryItem = primaryItem;
                    closestSecondaryItem = secondaryItem;
                }
            }
        }
        return combine(closestPrimaryItem, closestSecondaryItem);
    }
    /**
     * Combines the closest items in the inventory based on their IDs.
     * <p>
     * This method searches for items in the inventory by their IDs, then finds the pair of primary and
     * secondary items with the smallest slot difference and combines them.
     * <p>
     * For combining items by their names, see {@link #combineClosest(String, String) combineClosest}.
     *
     * @param primaryItemId   the ID of the primary item to combine
     * @param secondaryItemId the ID of the secondary item to combine
     *
     * @return true if the items were successfully combined, false otherwise
     */
    public static boolean combineClosest(int primaryItemId, int secondaryItemId) {
        List<Rs2Item> primaryItems = items().stream().filter(x -> x.id == primaryItemId).collect(Collectors.toList());
        List<Rs2Item> secondaryItems = items().stream().filter(x -> x.id == secondaryItemId).collect(Collectors.toList());
        if (primaryItems.isEmpty() || secondaryItems.isEmpty()) return false;
        Rs2Item closestPrimaryItem = null;
        Rs2Item closestSecondaryItem = null;
        int minSlotDifference = Integer.MAX_VALUE;
        // Compare each primary item with each secondary item to find the closest slots
        for (Rs2Item primaryItem : primaryItems) {
            for (Rs2Item secondaryItem : secondaryItems) {
                int slotDifference = calculateSlotDifference(primaryItem.slot, secondaryItem.slot);
                if (slotDifference <= minSlotDifference) {
                    minSlotDifference = slotDifference;
                    closestPrimaryItem = primaryItem;
                    closestSecondaryItem = secondaryItem;
                }
            }
        }
        return combine(closestPrimaryItem, closestSecondaryItem);
    }
    // Helper method to calculate the Manhattan distance between two inventory slots
    private static int calculateSlotDifference(int slot1, int slot2) {
        // Calculate the row and column for each slot
        int row1 = (slot1 - 1) / 4;
        int col1 = (slot1 - 1) % 4;
        int row2 = (slot2 - 1) / 4;
        int col2 = (slot2 - 1) % 4;
        // Calculate the Manhattan distance between the two slots
        return Math.abs(row1 - row2) + Math.abs(col1 - col2);
    }
    /**
     * Checks if the inventory contains an item with the specified ID.
     *
     * @param id The ID to check for.
     *
     * @return True if the inventory contains an item with the given ID, false otherwise.
     */
    public static boolean contains(int id) {
        return items().stream().anyMatch(x -> x.id == id);
    }
    /**
     * Checks if the inventory contains items with the specified IDs.
     *
     * @param ids The IDs to check for.
     *
     * @return True if the inventory contains all the specified IDs, false otherwise.
     */
    public static boolean contains(int[] ids) {
        return items().stream().anyMatch(x -> Arrays.stream(ids).anyMatch(id -> id == x.id));
    }
    /**
     * Checks if the inventory contains items with the specified IDs.
     *
     * @param ids The IDs to check for.
     *
     * @return True if the inventory contains all the specified IDs, false otherwise.
     */
    public static boolean contains(Integer... ids) {
        return items().stream().anyMatch(x -> Arrays.stream(ids).anyMatch(i -> i == x.id));
    }
    /**
     * Checks if the inventory contains an item with the specified name.
     *
     * @param name The name to check for.
     *
     * @return True if the inventory contains an item with the specified name, false otherwise.
     */
    public static boolean contains(String name) {
        return items().stream().anyMatch(x -> name.equalsIgnoreCase(x.name));
    }
    /**
     * Checks if the inventory contains items with the specified names.
     *
     * @param names The names to check for.
     *
     * @return True if the inventory contains all the specified names, false otherwise.
     */
    public static boolean contains(String... names) {
        return items().stream().anyMatch(x -> Arrays.stream(names).anyMatch(name -> name.equalsIgnoreCase(x.name)));
    }
    /**
     * Checks if the inventory contains an item that matches the specified filter.
     *
     * @param predicate The filter to apply.
     *
     * @return True if the inventory contains an item that matches the filter, false otherwise.
     */
    public static boolean contains(Predicate<Rs2Item> predicate) {
        return items().stream().anyMatch(predicate);
    }
    /**
     * Checks if the inventory contains all the specified IDs.
     *
     * @param ids The IDs to check for.
     *
     * @return True if the inventory contains all the specified IDs, false otherwise.
     */
    public static boolean containsAll(int... ids) {
        return Arrays.stream(ids).allMatch(x -> items().stream().anyMatch(y -> y.id == x));
    }
    /**
     * Checks if the inventory contains all the specified names.
     *
     * @param names The names to check for.
     *
     * @return True if the inventory contains all the specified names, false otherwise.
     */
    public static boolean containsAll(String... names) {
        return contains(names);
    }
    /**
     * Counts the number of items in the inventory that match the specified ID.
     *
     * @param id The ID to match.
     *
     * @return The count of items that match the ID.
     */
    public static int count(int id) {
        return (int) items().stream().filter(x -> x.id == id).count();
    }
    /**
     * Counts the number of items in the inventory
     *
     * @return The count of items
     */
    public static int count() {
        return items().size();
    }
    /**
     * Counts the number of items in the inventory that match the specified name.
     *
     * @param name The name to match.
     *
     * @return The count of items that match the name.
     */
    public static int count(String name) {
        return (int) items().stream().filter(x -> x.name.toLowerCase().contains(name.toLowerCase())).count();
    }
    /**
     * Counts the number of items in the inventory that match the specified filter.
     *
     * @param predicate The filter to apply.
     *
     * @return The count of items that match the filter.
     */
    public static int count(Predicate<Rs2Item> predicate) {
        return (int) items().stream().filter(predicate).count();
    }
    /**
     * Deselects any item if it is selected.
     *
     * @return True if an item was deselected, false otherwise.
     */
    public static boolean deselect() {
        if (isItemSelected()) {
            return use(getSelectedItemId());
        }
        return false;
    }
    /**
     * Drops the item with the specified ID from the inventory.
     *
     * @param id The ID of the item to drop.
     *
     * @return True if the item was successfully dropped, false otherwise.
     */
    public static boolean drop(int id) {
        Rs2Item item = items().stream().filter(x -> x.id == id).findFirst().orElse(null);
        if (item == null) return false;
        invokeMenu(item, "Drop");
        return true;
    }
    /**
     * Drops the item with the specified name from the inventory.
     *
     * @param name The name of the item to drop.
     *
     * @return True if the item was successfully dropped, false otherwise.
     */
    public static boolean drop(String name) {
        return drop(name, false);
    }
    /**
     *
     * @param name
     * @return
     */
    public static boolean drop(String name, boolean exact) {
        Rs2Item item;
        if (exact) {
             item = items().stream().filter(x -> x.name.toLowerCase().equalsIgnoreCase(name)).findFirst().orElse(null);
        } else {
             item = items().stream().filter(x -> x.name.toLowerCase().contains(name.toLowerCase())).findFirst().orElse(null);
        }
        if (item == null) return false;
        invokeMenu(item, "Drop");
        return true;
    }
    /**
     * Drops the item from the inventory that matches the specified filter.
     *
     * @param predicate The filter to identify the item to drop.
     *
     * @return True if the item was successfully dropped, false otherwise.
     */
    public static boolean drop(Predicate<Rs2Item> predicate) {
        Rs2Item item = items().stream().filter(predicate).findFirst().orElse(null);
        if (item == null) return false;
        invokeMenu(item, "Drop");
        return true;
    }
    /**
     * Drops all items in the inventory.
     *
     * @return True if all items were successfully dropped, false otherwise.
     */
    public static boolean dropAll() {
        for (Rs2Item item :
                items()) {
            if (item == null) continue;
            invokeMenu(item, "Drop");
            if (!Rs2AntibanSettings.naturalMouse)
                sleep(150, 300);
        }
        return true;
    }
    /**
     * Drops all items in the inventory matching the specified ID.
     *
     * @param id The ID to match.
     *
     * @return True if all matching items were successfully dropped, false otherwise.
     */
    public static boolean dropAll(int id) {
        for (Rs2Item item :
                items().stream().filter(x -> x.id == id).collect(Collectors.toList())) {
            if (item == null) continue;
            invokeMenu(item, "Drop");
            if (!Rs2AntibanSettings.naturalMouse)
                sleep(150, 300);
        }
        return true;
    }
    /**
     * Drops all items in the inventory matching the specified IDs.
     *
     * @param ids The IDs to match.
     *
     * @return True if all matching items were successfully dropped, false otherwise.
     */
    public static boolean dropAll(Integer... ids) {
        for (Rs2Item item :
                items().stream().filter(x -> Arrays.stream(ids).anyMatch(id -> id == x.id)).collect(Collectors.toList())) {
            if (item == null) continue;
            invokeMenu(item, "Drop");
            if (!Rs2AntibanSettings.naturalMouse)
                sleep(150, 300);
        }
        return true;
    }
    /**
     * Drops all items in the inventory matching the specified name.
     *
     * @param name The name to match.
     *
     * @return True if all matching items were successfully dropped, false otherwise.
     */
    public static boolean dropAll(String name) {
        for (Rs2Item item :
                items().stream().filter(x -> x.name.equalsIgnoreCase(name)).collect(Collectors.toList())) {
            if (item == null) continue;
            invokeMenu(item, "Drop");
            if (!Rs2AntibanSettings.naturalMouse)
                sleep(150, 300);
        }
        return true;
    }
    /**
     * Drops all items in the inventory matching the specified names.
     *
     * @param names The names to match.
     *
     * @return True if all matching items were successfully dropped, false otherwise.
     */
    public static boolean dropAll(String... names) {
        for (Rs2Item item :
                items().stream().filter(x -> Arrays.stream(names).anyMatch(name -> name.equalsIgnoreCase(x.name))).collect(Collectors.toList())) {
            if (item == null) continue;
            invokeMenu(item, "Drop");
            if (!Rs2AntibanSettings.naturalMouse)
                sleep(150, 300);
        }
        return true;
    }
    /**
     * Drops all items in the inventory matching the specified filter.
     *
     * @param predicate The filter to apply.
     *
     * @return True if all matching items were successfully dropped, false otherwise.
     */
    public static boolean dropAll(Predicate<Rs2Item> predicate) {
        for (Rs2Item item :
                items().stream().filter(predicate).collect(Collectors.toList())) {
            if (item == null) continue;
            invokeMenu(item, "Drop");
            if (!Rs2AntibanSettings.naturalMouse)
                sleep(150, 300);
        }
        return true;
    }
    /**
     * Drops all items in the inventory that match a specified filter, in a specified order.
     *
     * @param predicate The filter to apply. Only items that match this filter will be dropped.
     * @param dropOrder The order in which to drop the items. This can be one of the following:
     *                  - STANDARD: Items are dropped row by row, from left to right.
     *                  - EFFICIENT_ROW: Items are dropped row by row. For even rows, items are dropped from left to right. For odd rows, items are dropped from right to left.
     *                  - COLUMN: Items are dropped column by column, from top to bottom.
     *                  - EFFICIENT_COLUMN: Items are dropped column by column. For even columns, items are dropped from top to bottom. For odd columns, items are dropped from bottom to top.
     *
     * @return True if all matching items were successfully dropped, false otherwise.
     */
    public static boolean dropAll(Predicate<Rs2Item> predicate, DropOrder dropOrder) {
        List<Rs2Item> itemsToDrop = items().stream()
                .filter(predicate)
                .collect(Collectors.toList());
        switch (dropOrder) {
            case STANDARD:
                break;
            case EFFICIENT_ROW:
                itemsToDrop.sort((item1, item2) -> {
                    int index1 = item1.getSlot();
                    int index2 = item2.getSlot();
                    int row1 = index1 / COLUMNS;
                    int row2 = index2 / COLUMNS;
                    if (row1 != row2) {
                        return Integer.compare(row1, row2);
                    } else {
                        int col1 = index1 % COLUMNS;
                        int col2 = index2 % COLUMNS;
                        if (row1 % 2 == 0) {
                            // For even rows, sort columns normally (left to right)
                            return Integer.compare(col1, col2);
                        } else {
                            // For odd rows, sort columns in reverse (right to left)
                            return Integer.compare(col2, col1);
                        }
                    }
                });
                break;
            case COLUMN:
                itemsToDrop.sort((item1, item2) -> {
                    int index1 = item1.getSlot();
                    int index2 = item2.getSlot();
                    int col1 = index1 % COLUMNS;
                    int col2 = index2 % COLUMNS;
                    if (col1 != col2) {
                        return Integer.compare(col1, col2);
                    } else {
                        return Integer.compare(index1 / COLUMNS, index2 / COLUMNS);
                    }
                });
                break;
            case EFFICIENT_COLUMN:
                itemsToDrop.sort((item1, item2) -> {
                    int index1 = item1.getSlot();
                    int index2 = item2.getSlot();
                    int col1 = index1 % COLUMNS;
                    int col2 = index2 % COLUMNS;
                    if (col1 != col2) {
                        return Integer.compare(col1, col2);
                    } else {
                        int row1 = index1 / COLUMNS;
                        int row2 = index2 / COLUMNS;
                        if (col1 % 2 == 0) {
                            // For even columns, sort rows normally (top to bottom)
                            return Integer.compare(row1, row2);
                        } else {
                            // For odd columns, sort rows in reverse (bottom to top)
                            return Integer.compare(row2, row1);
                        }
                    }
                });
                break;
        }
        for (Rs2Item item : itemsToDrop) {
            if (item == null) continue;
            invokeMenu(item, "Drop");
            if (!Rs2AntibanSettings.naturalMouse)
                sleep(150, 300);
        }
        return true;
    }
    /**
     * Drops all items in the inventory that don't match the given IDs.
     *
     * @param ids The IDs to exclude.
     *
     * @return True if all non-matching items were successfully dropped, false otherwise.
     */
    public static boolean dropAllExcept(Integer... ids) {
        return dropAll(x -> Arrays.stream(ids).noneMatch(id -> id == x.id));
    }
    /**
     * Drops all items in the inventory that don't match the given names.
     *
     * @param names The names to exclude.
     *
     * @return True if all non-matching items were successfully dropped, false otherwise.
     */
    public static boolean dropAllExcept(String... names) {
        return dropAllExcept(false, DropOrder.STANDARD, names);
    }
    /**
     * Drops all items from the inventory except for the ones specified by the names parameter.
     * The exactness of the name matching and the order in which items are dropped can be controlled.
     *
     * @param exact     If true, items are kept in the inventory if their name exactly matches one of the names in the names parameter.
     *                  If false, items are kept in the inventory if their name contains one of the names in the names parameter.
     * @param dropOrder The order in which items are dropped from the inventory. This can be one of the following:
     *                  - STANDARD: Items are dropped row by row, from left to right.
     *                  - EFFICIENT_ROW: Items are dropped row by row. For even rows, items are dropped from left to right. For odd rows, items are dropped from right to left.
     *                  - COLUMN: Items are dropped column by column, from top to bottom.
     *                  - EFFICIENT_COLUMN: Items are dropped column by column. For even columns, items are dropped from top to bottom. For odd columns, items are dropped from bottom to top.
     * @param names     The names of the items to keep in the inventory.
     *
     * @return True if all non-matching items were successfully dropped, false otherwise.
     */
    public static boolean dropAllExcept(boolean exact, DropOrder dropOrder, String... names) {
        if (exact)
            return dropAll(x -> Arrays.stream(names).noneMatch(name -> name.equalsIgnoreCase(x.name)), dropOrder);
        else
            return dropAll(x -> Arrays.stream(names).noneMatch(name -> x.name.toLowerCase().contains(name.toLowerCase())), dropOrder);
    }
    /**
     * Drops all items in the inventory that are not filtered.
     *
     * @param predicate The filter to apply.
     *
     * @return True if all non-matching items were successfully dropped, false otherwise.
     */
    public static boolean dropAllExcept(Predicate<Rs2Item> predicate) {
        for (Rs2Item item :
                items().stream().filter(predicate).collect(Collectors.toList())) {
            if (item == null) continue;
            invokeMenu(item, "Drop");
            if (!Rs2AntibanSettings.naturalMouse)
                sleep(150, 300);
        }
        return true;
    }
    /**
     * Drop all items that fall under the gpValue
     *
     * @param gpValue minimum amount of gp required to not drop the item
     *
     * @return
     */
    public static boolean dropAllExcept(int gpValue) {
        return dropAllExcept(gpValue, List.of());
    }
    /**
     * Drop all items that fall under the gpValue
     *
     * @param gpValue     minimum amount of gp required to not drop the item
     * @param ignoreItems List of items to not drop
     *
     * @return
     */
    public static boolean dropAllExcept(int gpValue, List<String> ignoreItems) {
        for (Rs2Item item :
                new ArrayList<>(items())) {
            if (item == null) continue;
            if (ignoreItems.stream().anyMatch(x -> x.equalsIgnoreCase(item.name))) continue;
            long totalPrice = (long) Microbot.getClientThread().runOnClientThread(() ->
                    Microbot.getItemManager().getItemPrice(item.id) * item.quantity);
            if (totalPrice >= gpValue) continue;
            invokeMenu(item, "Drop");
            if (!Rs2AntibanSettings.naturalMouse)
                sleep(150, 300);
        }
        return true;
    }
    /**
     * Returns the count of empty slots in your inventory.
     *
     * @return The number of empty slots.
     */
    public static int emptySlotCount() {
        Widget inventory = getInventory();
        if (inventory == null) return -1;
        return capacity() - inventory.getDynamicChildren().length;
    }
    /**
     * Returns a list of items that do not fit the given criteria based on the provided filter.
     *
     * @param predicate The filter to apply.
     *
     * @return A list of items that do not match the filter criteria.
     */
    public static List<Rs2Item> except(Predicate<Rs2Item> predicate) {
        return items().stream().filter(predicate.negate()).collect(Collectors.toList());
    }
    /**
     * Returns the count of full slots in your inventory.
     *
     * @return The number of full slots.
     */
    public static int fullSlotCount() {
        // Implement fullSlotCount logic here
        return 0;
    }
    /**
     * Gets the last item in the inventory that matches the specified item ID.
     *
     * @param id The ID to match.
     *
     * @return The last item that matches the ID, or null if not found.
     */
    public static Rs2Item getLast(int id) {
        long count = items().size();
        Stream<Rs2Item> stream = items().stream();
        return stream.skip(count - 1).findFirst().orElse(null);
    }
    /**
     * Gets the first item in the inventory that matches the specified item ID.
     *
     * @param id The ID to match.
     *
     * @return The first item that matches the ID, or null if not found.
     */
    public static Rs2Item get(int id) {
        return items().stream().filter(x -> x.id == id).findFirst().orElse(null);
    }
    /**
     * Gets the first item in the inventory that matches one of the given IDs.
     *
     * @param ids The IDs to match.
     *
     * @return The first item that matches one of the IDs, or null if not found.
     */
    public static Rs2Item get(Integer... ids) {
        return items().stream().filter(x -> Arrays.stream(ids).anyMatch(i -> i == x.id)).findFirst().orElse(null);
    }
    /**
     * Gets the item in the inventory with the specified name.
     * this method ignores casing
     *
     * @param name The name to match.
     *
     * @return The item with the specified name, or null if not found.
     */
    public static Rs2Item get(String name) {
        return get(name, false);
    }
    /**
     * Gets the item in the inventory with the specified name.
     * this method ignores casing
     *
     * @param name The name to match.
     *
     * @return The item with the specified name, or null if not found.
     */
    public static Rs2Item get(String name, boolean exact) {
        if (exact)
            return items().stream().filter(x -> x.name.equalsIgnoreCase(name)).findFirst().orElse(null);
        else
            return items().stream().filter(x -> x.name.toLowerCase().contains(name.toLowerCase())).findFirst().orElse(null);
    }
    /**
     * Gets the item in the inventory with one of the specified names.
     *
     * @param names The names to match.
     *
     * @return The item with one of the specified names, or null if not found.
     */
    public static Rs2Item get(String... names) {
        return items().stream().filter(x -> Arrays.stream(names).anyMatch(n -> n.equalsIgnoreCase(x.name))).findFirst().orElse(null);
    }
    /**
     * Gets the item in the inventory with one of the specified names.
     *
     * @param names The names to match.
     * @param exact true to match the exact name
     *
     * @return The item with one of the specified names, or null if not found.
     */
    public static Rs2Item get(List<String> names, boolean exact) {
        if (exact) {
            return items().stream().filter(x -> names.stream().anyMatch(n -> n.equalsIgnoreCase(x.name))).findFirst().orElse(null);
        } else {
            return items().stream().filter(x -> names.stream().anyMatch(n -> n.toLowerCase().contains(x.name.split("\\(")[0].toLowerCase()))).findFirst().orElse(null);
        }
    }
    /**
     * Gets the item in the inventory with one of the specified names.
     *
     * @param names The names to match.
     *
     * @return The item with one of the specified names, or null if not found.
     */
    public static Rs2Item get(List<String> names) {
        return get(names, false);
    }
    /**
     * Gets the item in the inventory that matches the specified filter criteria.
     *
     * @param predicate The filter to apply.
     *
     * @return The item that matches the filter criteria, or null if not found.
     */
    public static Rs2Item get(Predicate<Rs2Item> predicate) {
        return items().stream().filter(predicate).findFirst().orElse(null);
    }
    /**
     * Checks if the player has a certain quantity of an item.
     *
     * @param id     The id of the item to check.
     * @param amount The desired quantity of the item.
     *
     * @return True if the player has the specified quantity of the item, false otherwise.
     */
    public static boolean hasItemAmount(int id, int amount) {
        Rs2Item rs2Item = get(id);
        if (rs2Item == null) return false;
        if (rs2Item.isStackable) {
            return rs2Item.quantity >= amount;
        } else {
            return items().stream().filter(x -> x.id == id).count() >= amount;
        }
    }
    /**
     * Checks if the player has a certain quantity of an item.
     *
     * @param id        The id of the item to check.
     * @param amount    The desired quantity of the item.
     * @param stackable A boolean indicating if the item is stackable.
     *
     * @return True if the player has the specified quantity of the item, false otherwise.
     */
    public static boolean hasItemAmount(int id, int amount, boolean stackable) {
        Rs2Item item = get(id);
        return stackable ? item.quantity >= amount : items().stream().filter(x -> x.id == id).count() >= amount;
    }
    /**
     * Checks if the player has a certain quantity of an item.
     *
     * @param name   The name of the item to check.
     * @param amount The desired quantity of the item.
     *
     * @return True if the player has the specified quantity of the item, false otherwise.
     */
    public static boolean hasItemAmount(String name, int amount) {
        Rs2Item item = get(name);
        if (item == null) return false;
        return hasItemAmount(name, amount, item.isStackable(), false);
    }
    /**
     * Retrieves the quantity of an item based on its ID.
     *
     * @param id The ID of the item.
     *
     * @return The quantity of the item if found, otherwise 0.
     */
    public static long ItemQuantity(int id) {
        Rs2Item rs2Item = get(id);
        if (rs2Item != null) {
            if (rs2Item.isStackable()) {
                return rs2Item.quantity;
            } else {
                return items().stream().filter(x -> x.id == id).count();
            }
        } else {
            return 0;
        }
    }
    /**
     * Retrieves the quantity of an item based on its name.
     *
     * @param itemName The name of the item.
     *
     * @return The quantity of the item if found, otherwise 0.
     */
    public static long ItemQuantity(String itemName) {
        Rs2Item rs2Item = get(itemName);
        if (rs2Item != null) {
            if (rs2Item.isStackable()) {
                return rs2Item.quantity;
            } else {
                return items().stream().filter(x -> x.id == rs2Item.getId()).count();
            }
        } else {
            return 0;
        }
    }
    /**
     * Checks if the player has a certain quantity of an item.
     *
     * @param name      The name of the item to check.
     * @param amount    The desired quantity of the item.
     * @param stackable A boolean indicating if the item is stackable.
     *
     * @return True if the player has the specified quantity of the item, false otherwise.
     */
    public static boolean hasItemAmount(String name, int amount, boolean stackable) {
        return hasItemAmount(name, amount, stackable, false);
    }
    /**
     * Checks if the player has a certain quantity of an item.
     *
     * @param name      The name of the item to check.
     * @param amount    The desired quantity of the item.
     * @param stackable A boolean indicating if the item is stackable.
     * @param exact     A boolean indicating whether the check should be exact or partial for non-stackable items.
     *
     * @return True if the player has the specified quantity of the item, false otherwise.
     */
    public static boolean hasItemAmount(String name, int amount, boolean stackable, boolean exact) {
        if (!stackable) {
            if (exact) {
                return items().stream().filter(x -> x.name.equalsIgnoreCase(name)).count() >= amount;
            } else {
                return items().stream().filter(x -> x.name.toLowerCase().contains(name.toLowerCase())).count() >= amount;
            }
        }
        Rs2Item item = get(name, exact);
        if (item == null) return false;
        return item.quantity >= amount;
    }
    /**
     * @param id
     *
     * @return boolean
     */
    public static boolean hasItem(int id) {
        return get(id) != null;
    }
    /**
     * @param ids
     *
     * @return boolean
     */
    public static boolean hasItem(Integer... ids) {
        return get(ids) != null;
    }
    /**
     * @param name
     *
     * @return boolean
     */
    public static boolean hasItem(String name) {
        return get(name) != null;
    }
    /**
     * @param name
     *
     * @return boolean
     */
    public static boolean hasItem(String name, boolean exact) {
        return get(name, true) != null;
    }
    /**
     * @param names
     *
     * @return boolean
     */
    public static boolean hasItem(String... names) {
        return get(names) != null;
    }
    /**
     * Checks if the inventory has any item with the specified IDs.
     *
     * @param ids The array of IDs to check.
     * @return true if any item with the specified IDs is found, false otherwise.
     */
    public static boolean hasItem(int[] ids) {
        return Arrays.stream(ids).anyMatch(id -> get(id) != null);
    }
    /**
     * @param names
     *
     * @return boolean
     */
    public static boolean hasItem(List<String> names) {
        return get(names) != null;
    }
    /**
     * Gets the actions available for the item in the specified slot.
     *
     * @param slot The slot to check.
     *
     * @return An array of available actions for the item in the slot.
     */
    public static String[] getActionsForSlot(int slot) {
        return items().stream()
                .filter(x -> x.slot == slot)
                .map(x -> x.getInventoryActions())
                .findFirst().orElse(new String[]{});
    }
    public static List<Rs2Item> getInventoryFood() {
        List<Rs2Item> items = items().stream()
                .filter(x -> Arrays.stream(x.getInventoryActions()).anyMatch(a -> a != null && a.equalsIgnoreCase("eat")) || x.getName().toLowerCase().contains("jug of wine"))
                .collect(Collectors.toList());
        return items;
    }
    public static List<Rs2Item> getPotions() {
        return items().stream()
                .filter(x -> Arrays.stream(x.getInventoryActions()).anyMatch(a -> a != null && a.equalsIgnoreCase("drink")))
                .collect(Collectors.toList());
    }
    // get bones with the action "bury"
    public static List<Rs2Item> getBones() {
        return items().stream()
                .filter(x -> Arrays.stream(x.inventoryActions).anyMatch(a -> a != null && a.equalsIgnoreCase("bury")))
                .collect(Collectors.toList());
    }
    // get items with the action "scatter"
    public static List<Rs2Item> getAshes() {
        return items().stream()
                .filter(x -> Arrays.stream(x.inventoryActions).anyMatch(a -> a != null && a.equalsIgnoreCase("scatter")))
                .collect(Collectors.toList());
    }
    /**
     * Gets the count of empty slots in your inventory.
     *
     * @return The number of empty slots.
     */
    public static int getEmptySlots() {
        return CAPACITY - items().size();
    }
    /**
     * Gets the index of the first empty slot in your inventory.
     * returns -1 if no empty slot is found
     *
     * @return The index of the first empty slot, or -1 if none are found.
     */
    public static int getFirstEmptySlot() {
        if (isFull()) return -1;
        for (int i = 0; i < inventory().getItems().length; i++) {
            if (inventory().getItems()[i].getId() == -1)
                return i;
        }
        return -1;
    }
    /**
     * Gets the index of the next full slot in your inventory.
     * return -1 if no full slot has been found
     *
     * @return The index of the next full slot, or -1 if none are found.
     */
    public static int getFirstFullSlot() {
        if (isEmpty()) return -1;
        return items().stream()
                .sorted()
                .findFirst()
                .map(Rs2Item::getSlot)
                .orElse(-1);
    }
    /**
     * Gets the ID of the item in the specified slot.
     * Returns -1 if the slot has not been found or no item has been found
     *
     * @param slot The slot to check.
     *
     * @return The ID of the item in the slot, or -1 if the slot is empty.
     */
    public static int getIdForSlot(int slot) {
        Rs2Item item = items().stream().filter(x -> x.slot == slot).findFirst().orElse(null);
        if (item == null) return -1;
        return item.id;
    }
    /**
     * Gets the basic inventory widget. Basic means the bank is not open, the Grand Exchange is not open, the shop is not open, etc.
     *
     * @return The basic inventory widget.
     */
    public static Widget getInventoryWidget() {
        return Rs2Widget.getWidget(ComponentID.INVENTORY_CONTAINER);
    }
    /**
     * Gets the item in the specified slot of the inventory.
     *
     * @param slot The index of the slot to retrieve.
     *
     * @return The item in the specified slot, or null if the slot is empty.
     */
    public static Rs2Item getItemInSlot(int slot) {
        return items().stream()
                .filter(x -> x.slot == slot)
                .findFirst()
                .orElse(null);
    }
    /**
     * Gets the name of the item in the specified slot of the inventory.
     *
     * @param slot The slot to retrieve the name for.
     *
     * @return The name of the item in the slot, or an empty string if the slot is empty.
     */
    public static String getNameForSlot(int slot) {
        return items().stream()
                .filter(x -> x.slot == slot)
                .findFirst()
                .map(x -> x.name)
                .orElse(null);
    }
    /**
     * Gets a random item from the inventory that matches the specified item IDs.
     *
     * @param itemIDs The item IDs to match.
     *
     * @return A random item that matches the item IDs, or null if no matching items are found.
     */
    public static Rs2Item getRandom(int... itemIDs) {
        return items().stream()
                .filter(x -> Arrays.stream(itemIDs)
                        .anyMatch(i -> i == x.id))
                .findAny()
                .orElse(null);
    }
    /**
     * Gets a random item from the inventory that matches the specified item names.
     *
     * @param itemNames The item names to match.
     *
     * @return A random item that matches the item names, or null if no matching items are found.
     */
    public static Rs2Item getRandom(String... itemNames) {
        return items().stream()
                .filter(x -> Arrays.stream(itemNames)
                        .anyMatch(i -> i.equalsIgnoreCase(x.name)))
                .findAny()
                .orElse(null);
    }
    /**
     * Gets a random item from the inventory that matches the specified item filter.
     *
     * @param itemFilter The filter to apply.
     *
     * @return A random item that matches the filter criteria, or null if no matching items are found.
     */
    public static Rs2Item getRandom(Predicate<Rs2Item> itemFilter) {
        return items().stream()
                .filter(itemFilter)
                .findAny()
                .orElse(null);
    }
    /**
     * Gets the ID of the currently selected item in the inventory.
     * Returns -1 if none is found
     *
     * @return The ID of the currently selected item, or -1 if no item is selected.
     */
    public static int getSelectedItemId() {
        if (Microbot.getClient().getSelectedWidget() == null) return -1;
        return Microbot.getClient().getSelectedWidget().getItemId();
    }
    /**
     * Gets the index of the currently selected item in the inventory.
     * Returns -1 if none is found
     *
     * @return The index of the currently selected item, or -1 if no item is selected.
     */
    public static int getSelectedItemIndex() {
        if (Microbot.getClient().getSelectedWidget() == null) return -1;
        return Microbot.getClient().getSelectedWidget().getIndex();
    }
    /**
     * Gets the name of the currently selected item in the inventory.
     *
     * @return The name of the currently selected item, or an empty string if no item is selected.
     */
    public static String getSelectedItemName() {
        if (Microbot.getClient().getSelectedWidget() == null) return null;
        return Microbot.getClient().getSelectedWidget().getName();
    }
    /**
     * Interacts with an item with the specified ID in the inventory using the first available action.
     *
     * @param id The ID of the item to interact with.
     *
     * @return True if the interaction was successful, false otherwise.
     */
    public static boolean interact(int id) {
        return interact(id, "");
    }
    /**
     * Interacts with an item with the specified ID in the inventory using the specified action.
     *
     * @param id     The ID of the item to interact with.
     * @param action The action to perform on the item.
     *
     * @return True if the interaction was successful, false otherwise.
     */
    public static boolean interact(int id, String action) {
        Rs2Item rs2Item = items().stream().filter(x -> x.id == id).findFirst().orElse(null);
        if (rs2Item == null) return false;
        invokeMenu(rs2Item, action);
        return true;
    }
    /**
     * Interacts with an item with the specified name in the inventory using the first available action.
     *
     * @param name The name of the item to interact with.
     *
     * @return True if the interaction was successful, false otherwise.
     */
    public static boolean interact(String name) {
        interact(name, "", false);
        return true;
    }
    /**
     * Interacts with an item with the specified name in the inventory using the specified action.
     *
     * @param name   The name of the item to interact with.
     * @param action The action to perform on the item.
     *
     * @return True if the interaction was successful, false otherwise.
     */
    public static boolean interact(String name, String action) {
        interact(name, action, false);
        return true;
    }
    /**
     * Interacts with an item with the specified name in the inventory using the specified action.
     *
     * @param names  The name of the item to interact with.
     * @param action The action to perform on the item.
     *
     * @return True if the interaction was successful, false otherwise.
     */
    public static boolean interact(List<String> names, String action) {
        for (String name : names) {
            if (interact(name, action, false))
                return true;
        }
        return false;
    }
    /**
     * Interacts with an item with the specified name in the inventory using the specified action.
     *
     * @param name   The name of the item to interact with.
     * @param action The action to perform on the item.
     *
     * @return True if the interaction was successful, false otherwise.
     */
    public static boolean interact(String name, String action, boolean exact) {
        Rs2Item rs2Item;
        if (exact) {
            rs2Item = items().stream().filter(x -> x.name.equalsIgnoreCase(name.toLowerCase())).findFirst().orElse(null);
        } else {
            rs2Item = items().stream().filter(x -> x.name.toLowerCase().contains(name.toLowerCase())).findFirst().orElse(null);
        }
        if (rs2Item == null) return false;
        invokeMenu(rs2Item, action);
        return true;
    }
    /**
     * Interacts with an item in the inventory using the first available action based on the specified filter.
     *
     * @param filter The filter to apply.
     *
     * @return True if the interaction was successful, false otherwise.
     */
    public static boolean interact(Predicate<Rs2Item> filter) {
        return interact(filter, "Use");
    }
    /**
     * Interacts with an item in the inventory using the specified action based on the specified filter.
     *
     * @param filter The filter to apply.
     * @param action The action to perform on the item.
     *
     * @return True if the interaction was successful, false otherwise.
     */
    public static boolean interact(Predicate<Rs2Item> filter, String action) {
        Rs2Item rs2Item = items().stream().filter(filter).findFirst().orElse(null);
        if (rs2Item == null) return false;
        invokeMenu(rs2Item, action);
        return true;
    }
    /**
     * Interacts with a given item in the inventory using the first available action.
     * If the item has an invalid slot value, it will find the slot based on the item ID.
     *
     * @param item The item to interact with.
     *
     * @return True if the interaction was successful, false otherwise.
     */
    public static boolean interact(Rs2Item item) {
        return interact(item, "");
    }
    /**
     * Interacts with a given item in the inventory using the specified action.
     * If the item has an invalid slot value, it will find the slot based on the item ID.
     *
     * @param item   The item to interact with.
     * @param action The action to perform on the item.
     *
     * @return True if the interaction was successful, false otherwise.
     */
    public static boolean interact(Rs2Item item, String action) {
        if (item == null) return false;
        invokeMenu(item, action);
        return true;
    }
    /**
     * Checks whether the inventory is empty (contains no items).
     *
     * @return True if the inventory is empty, false otherwise.
     */
    public static boolean isEmpty() {
        return items().isEmpty();
    }
    /**
     * Checks whether the inventory is configured to ignore whether shift interactions are enabled or not.
     *
     * @return True if the inventory ignores shift interactions, false otherwise.
     */
    public static boolean isForceNoShift() {
        throw new NotImplementedException("TODO");
    }
    /**
     * Determines whether the inventory is full (all slots are occupied).
     *
     * @return True if the inventory is full, false otherwise.
     */
    public static boolean isFull() {
        return items().size() == CAPACITY;
    }
    /**
     * Checks if the inventory is full based on the item name.
     *
     * @param name The name of the item to check.
     *
     * @return true if the inventory is full, false otherwise.
     */
    public static boolean isFull(String name) {
        Rs2Item rs2Item = get(name);
        if (rs2Item == null && items().size() == CAPACITY) return true;
        return rs2Item != null && rs2Item.quantity <= 1 && items().size() == CAPACITY;
    }
    /**
     * Checks if the inventory is full based on the item ID.
     *
     * @param id The ID of the item to check.
     *
     * @return true if the inventory is full, false otherwise.
     */
    public static boolean isFull(int id) {
        Rs2Item rs2Item = get(id);
        if (rs2Item == null && items().size() == CAPACITY) return true;
        return rs2Item != null && rs2Item.quantity <= 1 && items().size() == CAPACITY;
    }
    /**
     * Checks whether an item is currently selected in your inventory.
     *
     * @return True if an item is selected, false otherwise.
     */
    public static boolean isItemSelected() {
        return Microbot.getClient().isWidgetSelected();
    }
    /**
     * Checks whether the inventory is open.
     *
     * @return True if the inventory is open, false otherwise.
     */
    public static boolean isOpen() {
        return Rs2Tab.getCurrentTab() == InterfaceTab.INVENTORY;
    }
    /**
     * Checks if the given slot in the inventory is empty.
     *
     * @param slot The slot to check.
     *
     * @return True if the slot is empty, false otherwise.
     */
    public static boolean isSlotEmpty(int slot) {
        Widget inventory = getInventory();
        if (inventory == null) return false;
        Widget inventoryItem = inventory.getChild(slot);
        assert inventoryItem != null;
        return inventoryItem.getName().isEmpty();
    }
    /**
     * Checks if the given slot in the inventory is empty.
     *
     * @param slots The slots to check.
     *
     * @return True if the slot is empty, false otherwise.
     */
    public static boolean isSlotsEmpty(int... slots) {
        Widget inventory = getInventory();
        if (inventory == null) return false;
        for (int slot : slots) {
            if (slot < 0 || slot >= inventory.getDynamicChildren().length)
                return false; // Check if slot is within bounds
            Widget inventoryItem = inventory.getChild(slot);
            if (inventoryItem == null || !inventoryItem.getName().isEmpty()) return false; // Check if slot is empty
        }
        return true;
    }
    /**
     * Checks if the given slot in the inventory is full (contains an item).
     *
     * @param slot The slot to check.
     *
     * @return True if the slot is full, false otherwise.
     */
    public static boolean isSlotFull(int slot) {
        return !isSlotEmpty(slot);
    }
    /**
     * Gets the bounding rectangle for the slot of the specified item in the inventory.
     *
     * @param rs2Item The item to get the bounds for.
     *
     * @return The bounding rectangle for the item's slot, or null if the item is not found.
     */
    public static Rectangle itemBounds(Rs2Item rs2Item) {
        Widget inventory = getInventory();
        if (inventory == null) return null;
        Widget item = Arrays.stream(inventory.getDynamicChildren())
                .filter(x -> x.getIndex() == rs2Item.slot)
                .findFirst()
                .orElse(null);
        if (item == null) return null;
        return item.getBounds();
    }
    /**
     * Checks if your inventory only contains items with the specified ID.
     *
     * @param ids The IDs to check.
     *
     * @return True if the inventory only contains items with the specified IDs, false otherwise.
     */
    public static boolean onlyContains(Integer... ids) {
        return items().stream().allMatch(x -> Arrays.stream(ids).allMatch(id -> x.id == id));
    }
    /**
     * Checks if your inventory only contains items with the specified names.
     *
     * @param names The names to check.
     *
     * @return True if the inventory only contains items with the specified names, false otherwise.
     */
    public static boolean onlyContains(String... names) {
        return items().stream().allMatch(x -> Arrays.stream(names).allMatch(name -> x.name.equalsIgnoreCase(name)));
    }
    /**
     * Checks if your inventory only contains items that match the specified filter.
     *
     * @param predicate The filter to apply.
     *
     * @return True if the inventory only contains items that match the filter, false otherwise.
     */
    public static boolean onlyContains(Predicate<Rs2Item> predicate) {
        // Implement onlyContains logic here
        return items().stream().allMatch(predicate);
    }
    /**
     * Opens the inventory.
     *
     * @return True if the inventory is successfully opened, false otherwise.
     */
    public static boolean open() {
        Rs2Tab.switchToInventoryTab();
        return true;
    }
    /**
     * Gets the size of the inventory.
     *
     * @return The size of the inventory.
     */
    public static int size() {
        return items().size();
    }
    /**
     * Gets the total size of stackables of the inventory.
     *
     * @return The total size of stackable items of the inventory.
     */
    public static int stackableSize() {
        return items().stream().filter(x -> x.isNoted || x.isStackable).mapToInt(x -> x.quantity).sum();
    }
    /**
     * Gets the slot for the item with the specified ID.
     *
     * @param id The ID of the item.
     *
     * @return The slot index for the item, or -1 if not found.
     */
    public static int slot(int id) {
        Rs2Item item = items().stream().filter(x -> x.id == id).findFirst().orElse(null);
        if (item == null) return -1;
        return item.slot;
    }
    /**
     * Gets the slot for the item with the specified name.
     *
     * @param name The name of the item.
     *
     * @return The slot index for the item, or -1 if not found.
     */
    public static int slot(String name) {
        Rs2Item item = items().stream().filter(x -> x.name.equalsIgnoreCase(name)).findFirst().orElse(null);
        if (item == null) return -1;
        return item.slot;
    }
    /**
     * Gets the slot for the item that matches the specified filter.
     *
     * @param predicate The filter to apply.
     *
     * @return The slot index for the item, or -1 if not found.
     */
    public static int slot(Predicate<Rs2Item> predicate) {
        Rs2Item item = items().stream().filter(predicate).findFirst().orElse(null);
        if (item == null) return -1;
        return item.slot;
    }
    /**
     * Checks if the specified slot contains items that match the given IDs.
     *
     * @param slot The slot to check.
     * @param ids  The IDs to match.
     *
     * @return True if the slot contains items that match the IDs, false otherwise.
     */
    public static boolean slotContains(int slot, int[] ids) {
        Rs2Item item = items().get(slot);
        if (item == null) return false;
        return Arrays.stream(ids).anyMatch(x -> x == item.id);
    }
    /**
     * Checks if the specified slot contains items that match the given IDs.
     *
     * @param slot The slot to check.
     * @param ids  The IDs to match.
     *
     * @return True if the slot contains items that match the IDs, false otherwise.
     */
    public static boolean slotContains(int slot, Integer... ids) {
        Rs2Item item = items().get(slot);
        if (item == null) return false;
        return Arrays.stream(ids).anyMatch(x -> x == item.id);
    }
    /**
     * Checks if the specified slot contains items that match the given names.
     *
     * @param slot  The slot to check.
     * @param names The names to match.
     *
     * @return True if the slot contains items that match the names, false otherwise.
     */
    public static boolean slotContains(int slot, String... names) {
        Rs2Item item = items().get(slot);
        if (item == null) return false;
        return Arrays.stream(names).anyMatch(x -> x.equalsIgnoreCase(item.name));
    }
    /**
     * Interacts with the specified slot in the inventory using the first available action.
     *
     * @param slot The slot to interact with.
     *
     * @return True if the interaction is successful, false otherwise.
     */
    public static boolean slotInteract(int slot) {
        return slotInteract(slot, "");
    }
    /**
     * Interacts with the specified slot in the inventory using the specified action.
     *
     * @param slot   The slot to interact with.
     * @param action The action to perform.
     *
     * @return True if the interaction is successful, false otherwise.
     */
    public static boolean slotInteract(int slot, String action) {
        Rs2Item item = items().get(slot);
        if (item == null) return false;
        if (action == null || action.isEmpty())
            action = Arrays.stream(item.getInventoryActions()).findFirst().orElse("");
        return interact(item, action);
    }
    /**
     * Checks if the specified slot contains items whose names contain the given substring.
     *
     * @param slot The slot to check.
     * @param sub  The substring to search for in item names.
     *
     * @return True if the slot contains items with names containing the substring, false otherwise.
     */
    public static boolean slotNameContains(int slot, String sub) {
        Rs2Item item = items().get(slot);
        if (item == null) return false;
        return item.name.contains(sub);
    }
    /**
     * Uses the last item with the specified ID in the inventory.
     *
     * @param id The ID to match.
     *
     * @return The last item that matches the ID, or null if not found.
     */
    public static boolean useLast(int id) {
        Rs2Item rs2Item = getLast(id);
        if (rs2Item == null) return false;
        return use(rs2Item);
    }
    /**
     * Uses the item with the specified name in the inventory.
     *
     * @param name The name of the item to use.
     *
     * @return True if the item is successfully used, false otherwise.
     */
    public static boolean useUnNoted(String name) {
        Rs2Item item = items().stream().filter(x -> x.name.toLowerCase().contains(name.toLowerCase()) && !x.isNoted).findFirst().orElse(null);
        if (item == null) return false;
        return interact(item, "Use");
    }
    /**
     * Uses the item with the specified ID in the inventory.
     *
     * @param id The ID of the item to use.
     *
     * @return True if the item is successfully used, false otherwise.
     */
    public static boolean use(int id) {
        Rs2Item item = items().stream().filter(x -> x.id == id).findFirst().orElse(null);
        if (item == null) return false;
        return interact(id, "Use");
    }
    /**
     * Uses the item with the specified name in the inventory.
     *
     * @param name The name of the item to use.
     *
     * @return True if the item is successfully used, false otherwise.
     */
    public static boolean use(String name) {
        Rs2Item item = items().stream().filter(x -> x.name.toLowerCase().contains(name.toLowerCase())).findFirst().orElse(null);
        if (item == null) return false;
        return interact(name, "Use");
    }
    /**
     * Uses the given item in the inventory.
     *
     * @param rs2Item The item to use.
     *
     * @return True if the item is successfully used, false otherwise.
     */
    public static boolean use(Rs2Item rs2Item) {
        if (rs2Item == null) return false;
        return interact(rs2Item, "Use");
    }
    /**
     * @param name
     */
    public static void equip(String name) {
        wield(name);
    }
    /**
     * @param names possible item names to wield
     *
     * @return
     */
    public static boolean wield(String... names) {
        for (String name : names) {
            if (!Rs2Inventory.hasItem(name)) continue;
            if (Rs2Equipment.isWearing(name, true)) return true;
            invokeMenu(get(name), "wield");
            return true;
        }
        return false;
    }
    /**
     * @param name
     *
     * @return
     */
    public static boolean wield(String name) {
        if (!Rs2Inventory.hasItem(name)) return false;
        if (Rs2Equipment.isWearing(name, true)) return false;
        invokeMenu(get(name), "wield");
        return true;
    }
    /**
     * @param name item name
     */
    public static boolean wear(String name) {
        return wield(name);
    }
    /**
     * @param id item id
     */
    public static boolean equip(int id) {
        return wield(id);
    }
    /**
     * @param id item id
     */
    public static boolean wield(int id) {
        if (!Rs2Inventory.hasItem(id)) return false;
        if (Rs2Equipment.isWearing(id)) return false;
        invokeMenu(get(id), "wield");
        return true;
    }
    /**
     * @param id item id
     */
    public static void wear(int id) {
        invokeMenu(get(id), "wear");
    }
    /**
     * use unnoted inventory item on ingame object
     *
     * @param item     name of the item to use
     * @param objectID to use item on
     *
     * @return
     */
    public static boolean useUnNotedItemOnObject(String item, int objectID) {
        if (Rs2Bank.isOpen()) return false;
        useUnNoted(item);
        Rs2GameObject.interact(objectID);
        return true;
    }
    /**
     * use unnoted inventory item on ingame object
     *
     * @param item   name of the item to use
     * @param object to use item on
     *
     * @return
     */
    public static boolean useUnNotedItemOnObject(String item, TileObject object) {
        if (Rs2Bank.isOpen()) return false;
        useUnNoted(item);
        sleep(100);
        if (!isItemSelected()) return false;
        Rs2GameObject.interact(object);
        return true;
    }
    /**
     * use inventory item on ingame object
     *
     * @param item
     * @param objectID
     *
     * @return
     */
    public static boolean useItemOnObject(int item, int objectID) {
        if (Rs2Bank.isOpen()) return false;
        use(item);
        sleep(100);
        if (!isItemSelected()) return false;
        Rs2GameObject.interact(objectID);
        return true;
    }
    /**
     * @param itemId
     * @param npcID
     *
     * @return
     */
    public static boolean useItemOnNpc(int itemId, int npcID) {
        if (Rs2Bank.isOpen()) return false;
        use(itemId);
        sleep(100);
        if (!isItemSelected()) return false;
        Rs2Npc.interact(npcID);
        return true;
    }
    /**
     * @param itemId
     * @param Npc
     *
     * @return
     */
    public static boolean useItemOnNpc(int itemId, NPC Npc) {
        if (Rs2Bank.isOpen()) return false;
        use(itemId);
        sleep(100);
        if (!isItemSelected()) return false;
        Rs2Npc.interact(Npc);
        return true;
    }
    /**
     * @param name
     * @param exact
     *
     * @return
     */
    public static Rs2Item getNotedItem(String name, boolean exact) {
        if (exact)
            return items().stream().filter(x -> x.name.equalsIgnoreCase(name) && x.isNoted).findFirst().orElse(null);
        else
            return items().stream().filter(x -> x.name.toLowerCase().contains(name.toLowerCase()) && x.isNoted).findFirst().orElse(null);
    }
    /**
     * @param name
     *
     * @return
     */
    public static boolean hasNotedItem(String name) {
        return getNotedItem(name, false) != null;
    }
    /**
     * @param name
     * @param exact
     *
     * @return
     */
    public static boolean hasNotedItem(String name, boolean exact) {
        return getNotedItem(name, exact) != null;
    }
    public static Rs2Item getUnNotedItem(String name, boolean exact) {
        if (exact)
            return items().stream().filter(x -> x.name.equalsIgnoreCase(name) && !x.isNoted).findFirst().orElse(null);
        else
            return items().stream().filter(x -> x.name.toLowerCase().contains(name.toLowerCase()) && !x.isNoted).findFirst().orElse(null);
    }
    public static boolean hasUnNotedItem(String name) {
        return getUnNotedItem(name, false) != null;
    }
    public static boolean hasUnNotedItem(String name, boolean exact) {
        return getUnNotedItem(name, exact) != null;
    }
    /**
     * Method will search for restore energy items in inventory & use them
     */
    public static void useRestoreEnergyItem() {
        List<Rs2Item> filteredRestoreEnergyItems = getFilteredPotionItemsInInventory(Rs2Potion.getRestoreEnergyPotionsVariants());
        List<Rs2Item> filteredStaminaRestoreItems = getFilteredPotionItemsInInventory(Rs2Potion.getStaminaPotion());
        if (filteredStaminaRestoreItems.isEmpty() && filteredRestoreEnergyItems.isEmpty()) return;
        if (filteredStaminaRestoreItems.isEmpty()) {
            Rs2Inventory.interact(filteredRestoreEnergyItems.stream().findFirst().get().name, "drink");
        } else {
            if (Rs2Player.hasStaminaBuffActive() && !filteredRestoreEnergyItems.isEmpty()) {
                Rs2Inventory.interact(filteredRestoreEnergyItems.stream().findFirst().get().name, "drink");
            } else {
                Rs2Inventory.interact(filteredStaminaRestoreItems.stream().findFirst().get().name, "drink");
            }
        }
    }
    /**
     * Method fetches list of potion items in Inventory, will ignore uses
     *
     * @param potionName Potion Name
     *
     * @return List of Potion Items in Inventory
     */
    public static List<Rs2Item> getFilteredPotionItemsInInventory(String potionName) {
        return getFilteredPotionItemsInInventory(Collections.singletonList(potionName));
    }
    /**
     * Method fetches list of potion items in Inventory, will ignore uses
     *
     * @param potionNames List of Potion Names
     *
     * @return List of Potion Items in Inventory
     */
    public static List<Rs2Item> getFilteredPotionItemsInInventory(List<String> potionNames) {
        Pattern usesRegexPattern = Pattern.compile("^(.*?)(?:\\(\\d+\\))?$");
        return getPotions().stream()
                .filter(item -> {
                    Matcher matcher = usesRegexPattern.matcher(item.getName());
                    return matcher.matches() && potionNames.contains(matcher.group(1).trim());
                })
                .collect(Collectors.toList());
    }
    /**
     * Method executes menu actions
     *
     * @param rs2Item Current item to interact with
     * @param action  Action used on the item
     */
    private static void invokeMenu(Rs2Item rs2Item, String action) {
        if (rs2Item == null) return;
        Rs2Tab.switchToInventoryTab();
        Microbot.status = action + " " + rs2Item.name;
        int param0;
        int param1;
        int identifier = -1;
        MenuAction menuAction = MenuAction.CC_OP;
        Widget[] inventoryWidgets;
        param0 = rs2Item.slot;
        boolean isDepositBoxOpen = !Microbot.getClientThread().runOnClientThread(() -> Rs2Widget.getWidget(WidgetInfo.DEPOSIT_BOX_INVENTORY_ITEMS_CONTAINER) == null
                || Rs2Widget.getWidget(WidgetInfo.DEPOSIT_BOX_INVENTORY_ITEMS_CONTAINER).isHidden());
        if (Rs2Bank.isOpen()) {
            param1 = ComponentID.BANK_INVENTORY_ITEM_CONTAINER;
            inventoryWidgets = Rs2Widget.getWidget(ComponentID.BANK_INVENTORY_ITEM_CONTAINER).getChildren();
        } else if (isDepositBoxOpen) {
            param1 = ComponentID.DEPOSIT_BOX_INVENTORY_ITEM_CONTAINER;
            inventoryWidgets = Rs2Widget.getWidget(ComponentID.DEPOSIT_BOX_INVENTORY_ITEM_CONTAINER).getChildren();
        } else if (Rs2GrandExchange.isOpen()) {
            param1 = ComponentID.GRAND_EXCHANGE_INVENTORY_INVENTORY_ITEM_CONTAINER;
            inventoryWidgets = Rs2Widget.getWidget(ComponentID.GRAND_EXCHANGE_INVENTORY_INVENTORY_ITEM_CONTAINER).getChildren();
        } else if (Rs2Shop.isOpen()) {
            param1 = 19726336;
            inventoryWidgets = Rs2Widget.getWidget(19726336).getChildren();
        } else {
            param1 = ComponentID.INVENTORY_CONTAINER;
            inventoryWidgets = Rs2Widget.getWidget(ComponentID.INVENTORY_CONTAINER).getChildren();
        }
        if (!action.isEmpty()) {
            assert inventoryWidgets != null;
            var itemWidget = Arrays.stream(inventoryWidgets).filter(x -> x != null && x.getIndex() == rs2Item.slot).findFirst().orElseGet(null);
            String[] actions = itemWidget != null && itemWidget.getActions() != null ?
                    itemWidget.getActions() :
                    rs2Item.getInventoryActions();
            identifier = indexOfIgnoreCase(stripColTags(actions), action) + 1;
            System.out.println(identifier);
        }
        if (isItemSelected()) {
            menuAction = MenuAction.WIDGET_TARGET_ON_WIDGET;
        } else if (action.equalsIgnoreCase("use")) {
            menuAction = MenuAction.WIDGET_TARGET;
        } else if (action.equalsIgnoreCase("cast")) {
            menuAction = MenuAction.WIDGET_TARGET_ON_WIDGET;
        }
        Microbot.doInvoke(new NewMenuEntry(action, param0, param1, menuAction.getId(), identifier, rs2Item.id, rs2Item.name), (itemBounds(rs2Item) == null) ? new Rectangle(1, 1) : itemBounds(rs2Item));
        if (action.equalsIgnoreCase("destroy")) {
            sleepUntil(() -> Rs2Widget.isWidgetVisible(584, 0));
            Rs2Widget.clickWidget(Rs2Widget.getWidget(584, 1).getId());
        }
    }
    private static Widget getInventory() {
        final int BANK_PIN_INVENTORY_ITEM_CONTAINER = 17563648;
        return Microbot.getClientThread().runOnClientThread(() -> {
            Widget inventoryWidget = Microbot.getClient().getWidget(ComponentID.INVENTORY_CONTAINER);
            Widget bankInventoryWidget = Microbot.getClient().getWidget(ComponentID.BANK_INVENTORY_ITEM_CONTAINER);
            Widget bankPinInventoryWidget = Microbot.getClient().getWidget(BANK_PIN_INVENTORY_ITEM_CONTAINER);
            if (inventoryWidget != null && inventoryWidget.getDynamicChildren() != null && !inventoryWidget.isHidden()) {
                return inventoryWidget;
            }
            if (bankInventoryWidget != null && bankInventoryWidget.getDynamicChildren() != null && !bankInventoryWidget.isHidden()) {
                return bankInventoryWidget;
            }
            if (bankPinInventoryWidget != null && bankPinInventoryWidget.getDynamicChildren() != null && !bankPinInventoryWidget.isHidden()) {
                return bankPinInventoryWidget;
            }
            return null;
        });
    }
    /**
     * Sell item to the shop
     *
     * @param itemName item to sell
     * @param quantity STRING quantity of items to sell
     *
     * @return true if the item was successfully sold, false otherwise
     */
    public static boolean sellItem(String itemName, String quantity) {
        try {
            // Retrieve Rs2Item object corresponding to the item name
            Rs2Item rs2Item = items().stream()
                    .filter(item -> item.name.equalsIgnoreCase(itemName))
                    .findFirst().orElse(null);
            if (rs2Item == null) {
                System.out.println("Item not found in inventory.");
                return false;
            }
            String action = "Sell ";
            String actionAndQuantity = (action + quantity);
            invokeMenu(rs2Item, actionAndQuantity);
            return true;
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
            return false;
        }
    }
    public static boolean waitForInventoryChanges(Runnable actionWhileWaiting) {
        final int currentInventorySize = size();
        final int currentInventoryStackableSize = stackableSize();
        sleepUntil(() ->  {
            actionWhileWaiting.run();
            sleepUntil(() -> currentInventorySize != size() || currentInventoryStackableSize != stackableSize(), Random.random(600, 2100));
            return currentInventorySize != size() || currentInventoryStackableSize != stackableSize();
        });
        return currentInventorySize != size() || currentInventoryStackableSize != stackableSize();
    }
    /**
     * Moves the specified item to the specified slot in the inventory.
     *
     * @return
     */
    public static boolean moveItemToSlot(Rs2Item item, int slot) {
        if (item == null) return false;
        if (slot < 0 || slot >= CAPACITY) return false;
        if (item.slot == slot) return false;
        Widget inventory = getInventory();
        if (inventory == null) return false;
        Rectangle itemBounds = itemBounds(item);
        Rectangle slotBounds = inventory.getDynamicChildren()[slot].getBounds();
        Microbot.drag(itemBounds, slotBounds);
        return true;
    }
    public static boolean dropEmptyVials() {
        return dropAll("empty vial");
    }
    private static int indexOfIgnoreCase(String[] sourceList, String searchString) {
        if (sourceList == null || searchString == null) {
            return -1;  // or throw an IllegalArgumentException
        }
        if (searchString.equalsIgnoreCase("wield") || searchString.equalsIgnoreCase("wear")) {
            for (int i = 0; i < sourceList.length; i++) {
                if (sourceList[i] != null && (sourceList[i].equalsIgnoreCase("wield") || sourceList[i].equalsIgnoreCase("wear"))) {
                    return i;
                }
            }
        }
        for (int i = 0; i < sourceList.length; i++) {
            if (sourceList[i] != null && sourceList[i].equalsIgnoreCase(searchString)) {
                return i;
            }
        }
        return -1;  // return -1 if the string is not found
    }
    private static String[] stripColTags(String[] sourceList) {
        List<String> resultList = new ArrayList<>();
        String regex = "<col=[^>]*>";
        for (String item : sourceList) {
            if (item != null) {
                resultList.add(item.replaceAll(regex, ""));
            } else {
                resultList.add(null); // Handle null elements if needed
            }
        }
        return resultList.toArray(String[]::new);
    }
    public static boolean fillPouches() {
        log("Fill pouches...");
        for (Pouch pouch : Arrays.stream(Pouch.values()).filter(Pouch::hasRequiredRunecraftingLevel).collect(Collectors.toList())) {
            pouch.fill();
        }
        return true;
    }
    public static boolean emptyPouches() {
        if (isFull()) return false;
        log("Empty pouches...");
        for (Pouch pouch : Arrays.stream(Pouch.values()).filter(Pouch::hasRequiredRunecraftingLevel).collect(Collectors.toList())) {
            pouch.empty();
        }
       return true;
    }
    public static boolean checkPouches() {
        if (isFull()) return false;
        log("Checking pouches...");
        for (Pouch pouch : Arrays.stream(Pouch.values()).filter(Pouch::hasRequiredRunecraftingLevel).collect(Collectors.toList())) {
            pouch.check();
        }
        return true;
    }
    public static boolean anyPouchUnknown() {
        return Arrays.stream(Pouch.values()).filter(Pouch::hasPouchInInventory).anyMatch(x -> x.hasRequiredRunecraftingLevel() && x.isUnknown());
    }
    public static boolean anyPouchEmpty() {
        return Arrays.stream(Pouch.values()).filter(Pouch::hasPouchInInventory).anyMatch(x -> x.hasRequiredRunecraftingLevel() && x.getRemaining() > 0);
    }
    public static boolean anyPouchFull() {
        return Arrays.stream(Pouch.values()).filter(Pouch::hasPouchInInventory).anyMatch(x -> x.hasRequiredRunecraftingLevel() && x.getHolding() > 0);
    }
    public static boolean allPouchesFull() {
        return Arrays.stream(Pouch.values()).filter(Pouch::hasPouchInInventory).allMatch(x -> x.hasRequiredRunecraftingLevel() && x.getRemaining() == 0);
    }
    public static boolean allPouchesEmpty() {
        return Arrays.stream(Pouch.values()).filter(Pouch::hasPouchInInventory).allMatch(x -> x.hasRequiredRunecraftingLevel() && x.getHoldAmount() == 0);
    }
    public static boolean hasDegradedPouch() {
        return Arrays.stream(Pouch.values()).anyMatch(Pouch::isDegraded);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/inventory/Rs2Item.java
================
package net.runelite.client.plugins.microbot.util.inventory;
import lombok.Getter;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.ParamID;
import net.runelite.client.plugins.microbot.Microbot;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
public class Rs2Item {
    @Getter
    public  int id;
    public  int quantity;
    @Getter
    public int slot = -1;
    @Getter
    public String name;
    @Getter
    String[] inventoryActions;
    @Getter
    List<String> equipmentActions = new ArrayList();
    @Getter
    boolean isStackable;
    boolean isNoted;
    @Getter
    boolean isTradeable;
    int[] wearableActionIndexes = new int[] {
            ParamID.OC_ITEM_OP1,
            ParamID.OC_ITEM_OP2,
            ParamID.OC_ITEM_OP3,
            ParamID.OC_ITEM_OP4,
            ParamID.OC_ITEM_OP5,
            ParamID.OC_ITEM_OP6,
            ParamID.OC_ITEM_OP7,
            ParamID.OC_ITEM_OP8};
    public Rs2Item(Item item, ItemComposition itemComposition, int slot) {
        this.id = item.getId();
        this.quantity = item.getQuantity();
        this.name = itemComposition.getName();
        this.slot = slot;
        this.isStackable = itemComposition.isStackable();
        this.isNoted = itemComposition.getNote() == 799;
        this.isTradeable = this.isNoted
                ? Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getItemDefinition(this.id - 1)).isTradeable()
                : itemComposition.isTradeable();
        this.inventoryActions = itemComposition.getInventoryActions();
        addEquipmentActions(itemComposition);
    }
    public boolean isFood() {
        return Arrays.stream(inventoryActions).anyMatch(x -> x != null && x.equalsIgnoreCase("eat"));
    }
    private void addEquipmentActions(ItemComposition itemComposition) {
        for (int i = 0; i < wearableActionIndexes.length; i++) {
            try {
                String value = itemComposition.getStringValue(wearableActionIndexes[i]);
                this.equipmentActions.add(value);
            } catch(Exception ex) {
                this.equipmentActions.add("");
            }
        }
    }
    public int getPrice() {
        return Microbot.getClientThread().runOnClientThread(() ->
                Microbot.getItemManager().getItemPrice(id) * quantity);
    }
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + id;
        return result;
    }
    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Rs2Item other = (Rs2Item) obj;
        if (id != other.id)
            return false;
        return true;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/keyboard/Rs2Keyboard.java
================
package net.runelite.client.plugins.microbot.util.keyboard;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.Global;
import java.awt.*;
import java.awt.event.KeyEvent;
import static java.awt.event.KeyEvent.CHAR_UNDEFINED;
import static net.runelite.client.plugins.microbot.util.math.Random.random;
public class Rs2Keyboard {
    public static Canvas getCanvas() {
        return Microbot.getClient().getCanvas();
    }
    public static void typeString(final String word) {
        boolean originalFocusValue = Microbot.getClient().getCanvas().isFocusable();
        if (!originalFocusValue) {
            Microbot.getClient().getCanvas().setFocusable(!originalFocusValue);
        }
        for (int i = 0; i < word.length(); i++) {
            final int randomizer = random(20, 200);
            KeyEvent keyEvent = new KeyEvent(getCanvas(), KeyEvent.KEY_TYPED, System.currentTimeMillis() + randomizer, 0, KeyEvent.VK_UNDEFINED, word.charAt(i));
            getCanvas().dispatchEvent(keyEvent);
            Global.sleep(100, 200);
        }
        if (!originalFocusValue) {
            Microbot.getClient().getCanvas().setFocusable(originalFocusValue);
        }
    }
    public static void keyPress(final char key) {
        boolean originalFocusValue = Microbot.getClient().getCanvas().isFocusable();
        if (!originalFocusValue) {
            Microbot.getClient().getCanvas().setFocusable(!originalFocusValue);
        }
        final int randomizer = random(20, 200);
        KeyEvent keyEvent = new KeyEvent(getCanvas(), KeyEvent.KEY_TYPED, System.currentTimeMillis() + randomizer, 0, KeyEvent.VK_UNDEFINED, key);
        getCanvas().dispatchEvent(keyEvent);
        if (!originalFocusValue) {
            Microbot.getClient().getCanvas().setFocusable(originalFocusValue);
        }
    }
    public static void holdShift() {
        boolean originalFocusValue = Microbot.getClient().getCanvas().isFocusable();
        if (!originalFocusValue) {
            Microbot.getClient().getCanvas().setFocusable(!originalFocusValue);
        }
        final int randomizer = random(20, 200);
        KeyEvent keyEvent = new KeyEvent(getCanvas(), KeyEvent.KEY_PRESSED, System.currentTimeMillis() + randomizer, 0, KeyEvent.VK_SHIFT, CHAR_UNDEFINED);
        getCanvas().dispatchEvent(keyEvent);
        if (!originalFocusValue) {
            Microbot.getClient().getCanvas().setFocusable(originalFocusValue);
        }
    }
    public static void releaseShift() {
        boolean originalFocusValue = Microbot.getClient().getCanvas().isFocusable();
        if (!originalFocusValue) {
            Microbot.getClient().getCanvas().setFocusable(!originalFocusValue);
        }
        final int randomizer = random(20, 200);
        KeyEvent keyEvent = new KeyEvent(getCanvas(), KeyEvent.KEY_RELEASED, System.currentTimeMillis() + randomizer, 0, KeyEvent.VK_SHIFT);
        getCanvas().dispatchEvent(keyEvent);
        if (!originalFocusValue) {
            Microbot.getClient().getCanvas().setFocusable(originalFocusValue);
        }
    }
    public static void keyHold(int key) {
        boolean originalFocusValue = Microbot.getClient().getCanvas().isFocusable();
        if (!originalFocusValue) {
            Microbot.getClient().getCanvas().setFocusable(!originalFocusValue);
        }
        KeyEvent keyEvent = new KeyEvent(getCanvas(), KeyEvent.KEY_PRESSED, System.currentTimeMillis(), 0, key);
        getCanvas().dispatchEvent(keyEvent);
        if (!originalFocusValue) {
            Microbot.getClient().getCanvas().setFocusable(originalFocusValue);
        }
    }
    public static void keyRelease(int key) {
        boolean originalFocusValue = Microbot.getClient().getCanvas().isFocusable();
        if (!originalFocusValue) {
            Microbot.getClient().getCanvas().setFocusable(!originalFocusValue);
        }
        final int randomizer = random(20, 200);
        KeyEvent keyEvent = new KeyEvent(getCanvas(), KeyEvent.KEY_RELEASED, System.currentTimeMillis() + randomizer, 0, key);
        getCanvas().dispatchEvent(keyEvent);
        if (!originalFocusValue) {
            Microbot.getClient().getCanvas().setFocusable(originalFocusValue);
        }
    }
    public static void keyPress(int key) {
        keyHold(key);
        keyRelease(key);
    }
    public static void enter() {
        keyPress(KeyEvent.VK_ENTER);
        //FIX: this is to avoid automatically login with jagex account when you are on the login screen
        KeyEvent keyEvent = new KeyEvent(getCanvas(), KeyEvent.KEY_TYPED, System.currentTimeMillis() , 0, KeyEvent.VK_UNDEFINED, '\n');
        getCanvas().dispatchEvent(keyEvent);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/magic/Rs2Magic.java
================
package net.runelite.client.plugins.microbot.util.magic;
import net.runelite.api.Point;
import net.runelite.api.*;
import net.runelite.api.widgets.Widget;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.globval.enums.InterfaceTab;
import net.runelite.client.plugins.microbot.util.camera.Rs2Camera;
import net.runelite.client.plugins.microbot.util.dialogues.Rs2Dialogue;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Item;
import net.runelite.client.plugins.microbot.util.math.Random;
import net.runelite.client.plugins.microbot.util.menu.NewMenuEntry;
import net.runelite.client.plugins.microbot.util.npc.Rs2Npc;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.microbot.util.tabs.Rs2Tab;
import net.runelite.client.plugins.microbot.util.widget.Rs2Widget;
import net.runelite.client.plugins.skillcalculator.skills.MagicAction;
import org.apache.commons.lang3.NotImplementedException;
import java.awt.*;
import java.util.Arrays;
import java.util.stream.Collectors;
import static net.runelite.api.Varbits.SHADOW_VEIL;
import static net.runelite.client.plugins.microbot.Microbot.log;
import static net.runelite.client.plugins.microbot.util.Global.*;
public class Rs2Magic {
    public static boolean canCast(MagicAction magicSpell) {
        if (Rs2Tab.getCurrentTab() != InterfaceTab.MAGIC) {
            Rs2Tab.switchToMagicTab();
            sleep(150, 300);
        }
        if (magicSpell.getName().toLowerCase().contains("enchant")){
            if (Rs2Widget.findWidget(magicSpell.getName(), Arrays.stream(Rs2Widget.getWidget(218, 0).getStaticChildren()).collect(Collectors.toList())) == null) {
                if (Rs2Widget.isHidden(14286860)) return false;
                Rs2Widget.clickWidget(14286860);
                sleep(150, 300);
            }
        } else if (Rs2Widget.isWidgetVisible(218, 4) && Arrays.stream(Rs2Widget.getWidget(218, 4).getActions()).anyMatch(x -> x.equalsIgnoreCase("back"))){
            Rs2Widget.clickWidget(218, 4);
            sleep(150, 300);
        }
        Widget widget = Arrays.stream(Rs2Widget.getWidget(14286851).getStaticChildren()).filter(x -> x.getSpriteId() == magicSpell.getSprite()).findFirst().orElse(null);
        if (widget == null) {
            widget = Arrays.stream(Rs2Widget.getWidget(14286851).getStaticChildren()).filter(x -> x.getId() == magicSpell.getWidgetId()).findFirst().orElse(null);
        }
        return widget != null;
    }
    public static boolean cast(MagicAction magicSpell) {
        MenuAction menuAction;
        Rs2Tab.switchToMagicTab();
        Microbot.status = "Casting " + magicSpell.getName();
        sleep(150, 300);
        if (!canCast(magicSpell)) {
            log("Unable to cast " + magicSpell.getName());
            return false;
        }
        int identifier = 1;
        if (magicSpell.getName().toLowerCase().contains("teleport") || magicSpell.getName().toLowerCase().contains("Bones to") || Arrays.stream(magicSpell.getActions()).anyMatch(x -> x != null && x.equalsIgnoreCase("cast"))) {
            menuAction = MenuAction.CC_OP;
        } else {
            menuAction = MenuAction.WIDGET_TARGET;
        }
        if (magicSpell.getWidgetId() == -1)
            throw new NotImplementedException("This spell has not been configured yet in the MagicAction.java class");
        Microbot.doInvoke(new NewMenuEntry("cast", -1, magicSpell.getWidgetId(), menuAction.getId(), identifier, -1, magicSpell.getName()), new Rectangle(Rs2Widget.getWidget(magicSpell.getWidgetId()).getBounds()));
        //Rs2Reflection.invokeMenu(-1, magicSpell.getWidgetId(), menuAction.getId(), 1, -1, "Cast", "<col=00ff00>" + magicSpell.getName() + "</col>", -1, -1);
        return true;
    }
    public static void castOn(MagicAction magicSpell, Actor actor) {
        if (actor == null) return;
        cast(magicSpell);
        sleep(150, 300);
        if (!Rs2Camera.isTileOnScreen(actor.getLocalLocation())) {
            Rs2Camera.turnTo(actor.getLocalLocation());
            return;
        }
        if (actor instanceof NPC) {
            Rs2Npc.interact((NPC) actor);
        } else {
            Point point = Perspective.localToCanvas(Microbot.getClient(), actor.getLocalLocation(), Microbot.getClient().getPlane());
            Microbot.getMouse().click(point);
        }
    }
    public static void alch(String itemName, int sleepMin, int sleepMax) {
        Rs2Item item = Rs2Inventory.get(itemName);
        if (Microbot.getClient().getRealSkillLevel(Skill.MAGIC) >= 55) {
            highAlch(item, sleepMin, sleepMax);
        } else {
            lowAlch(item, sleepMin, sleepMax);
        }
    }
    public static void alch(String itemName) {
        Rs2Item item = Rs2Inventory.get(itemName);
        if (Microbot.getClient().getRealSkillLevel(Skill.MAGIC) >= 55) {
            highAlch(item, 300, 600);
        } else {
            lowAlch(item, 300, 600);
        }
    }
    /**
     * alch item with minsleep of 300 and maxsleep of 600
     *
     * @param item
     */
    public static void alch(Rs2Item item) {
        alch(item, 300, 600);
    }
    /**
     * @param item
     * @param sleepMin
     * @param sleepMax
     */
    public static void alch(Rs2Item item, int sleepMin, int sleepMax) {
        if (Microbot.getClient().getRealSkillLevel(Skill.MAGIC) >= 55) {
            highAlch(item, sleepMin, sleepMax);
        } else {
            lowAlch(item, sleepMin, sleepMax);
        }
    }
    public static void superHeat(String itemName) {
        Rs2Item item = Rs2Inventory.get(itemName);
        superHeat(item, 300, 600);
    }
    public static void superHeat(String itemName, int sleepMin, int sleepMax) {
        Rs2Item item = Rs2Inventory.get(itemName);
        superHeat(item, sleepMin, sleepMax);
    }
    public static void superHeat(int id) {
        Rs2Item item = Rs2Inventory.get(id);
        superHeat(item, 300, 600);
    }
    public static void superHeat(int id, int sleepMin, int sleepMax) {
        Rs2Item item = Rs2Inventory.get(id);
        superHeat(item, sleepMin, sleepMax);
    }
    public static void superHeat(Rs2Item item) {
        superHeat(item, 300, 600);
    }
    public static void superHeat(Rs2Item item, int sleepMin, int sleepMax) {
        sleepUntil(() -> {
            Rs2Tab.switchToMagicTab();
            sleep(50, 150);
            return Rs2Tab.getCurrentTab() == InterfaceTab.MAGIC;
        });
        if (Rs2Widget.isWidgetVisible(218, 4) && Arrays.stream(Rs2Widget.getWidget(218, 4).getActions()).anyMatch(x -> x.equalsIgnoreCase("back"))){
            Rs2Widget.clickWidget(218, 4);
            sleep(150, 300);
        }
        Widget superHeat = Rs2Widget.findWidget(MagicAction.SUPERHEAT_ITEM.getName());
        if (superHeat.getSpriteId() != SpriteID.SPELL_SUPERHEAT_ITEM) return;
        superHeat(superHeat, item, sleepMin, sleepMax);
    }
    private static void highAlch(Rs2Item item, int sleepMin, int sleepMax) {
        sleepUntil(() -> {
            Rs2Tab.switchToMagicTab();
            sleep(50, 150);
            return Rs2Tab.getCurrentTab() == InterfaceTab.MAGIC;
        });
        if (Rs2Widget.isWidgetVisible(218, 4) && Arrays.stream(Rs2Widget.getWidget(218, 4).getActions()).anyMatch(x -> x.equalsIgnoreCase("back"))){
            Rs2Widget.clickWidget(218, 4);
            sleep(150, 300);
        }
        Widget highAlch = Rs2Widget.findWidget(MagicAction.HIGH_LEVEL_ALCHEMY.getName());
        if (highAlch.getSpriteId() != 41) return;
        alch(highAlch, item, sleepMin, sleepMax);
    }
    private static void lowAlch(Rs2Item item, int sleepMin, int sleepMax) {
        sleepUntil(() -> {
            Rs2Tab.switchToMagicTab();
            sleep(50, 150);
            return Rs2Tab.getCurrentTab() == InterfaceTab.MAGIC;
        });
        if (Rs2Widget.isWidgetVisible(218, 4) && Arrays.stream(Rs2Widget.getWidget(218, 4).getActions()).anyMatch(x -> x.equalsIgnoreCase("back"))){
            Rs2Widget.clickWidget(218, 4);
            sleep(150, 300);
        }
        Widget lowAlch = Rs2Widget.findWidget(MagicAction.LOW_LEVEL_ALCHEMY.getName());
        if (lowAlch.getSpriteId() != 25) return;
        alch(lowAlch, item, sleepMin, sleepMax);
    }
    private static void alch(Widget alch, Rs2Item item, int sleepMin, int sleepMax) {
        if (alch == null) return;
        Point point = new Point((int) alch.getBounds().getCenterX(), (int) alch.getBounds().getCenterY());
        sleepUntil(() -> Microbot.getClientThread().runOnClientThread(() -> Rs2Tab.getCurrentTab() == InterfaceTab.MAGIC), 5000);
        sleep(sleepMin, sleepMax);
        Microbot.getMouse().click(point);
        sleepUntil(() -> Microbot.getClientThread().runOnClientThread(() -> Rs2Tab.getCurrentTab() == InterfaceTab.INVENTORY), 5000);
        sleep(sleepMin, sleepMax);
        if (item == null) {
            Microbot.status = "Alching x: " + point.getX() + " y: " + point.getY();
            Microbot.getMouse().click(point);
        } else {
            Microbot.status = "Alching " + item.name;
            Rs2Inventory.interact(item, "cast");
        }
    }
    private static void superHeat(Widget superheat, Rs2Item item, int sleepMin, int sleepMax) {
        if (superheat == null) return;
        Point point = new Point((int) superheat.getBounds().getCenterX(), (int) superheat.getBounds().getCenterY());
        sleepUntil(() -> Microbot.getClientThread().runOnClientThread(() -> Rs2Tab.getCurrentTab() == InterfaceTab.MAGIC), 5000);
        sleep(sleepMin, sleepMax);
        Microbot.getMouse().click(point);
        sleepUntil(() -> Microbot.getClientThread().runOnClientThread(() -> Rs2Tab.getCurrentTab() == InterfaceTab.INVENTORY), 5000);
        sleep(sleepMin, sleepMax);
        if (item == null) {
            Microbot.status = "Superheating x: " + point.getX() + " y: " + point.getY();
            Microbot.getMouse().click(point);
        } else {
            Microbot.status = "Superheating " + item.name;
            Rs2Inventory.interact(item, "cast");
        }
    }
    // humidify
    public static void humidify() {
        sleepUntil(() -> {
            Rs2Tab.switchToMagicTab();
            sleep(50, 150);
            return Rs2Tab.getCurrentTab() == InterfaceTab.MAGIC;
        });
        Widget humidify = Rs2Widget.findWidget(MagicAction.HUMIDIFY.getName());
        if (humidify.getSpriteId() == 1972) {
            Microbot.click(humidify.getBounds());
        }
    }
    public static boolean npcContact(String npcName) {
        if (!isLunar()) {
            Microbot.log("Tried casting npcContact, but lunar spellbook was not found.");
            return false;
        }
        final int chooseCharacterWidgetId = 4915200;
        boolean didCast = cast(MagicAction.NPC_CONTACT);
        if (!didCast) return false;
        boolean result = sleepUntilTrue(() -> Rs2Widget.getWidget(chooseCharacterWidgetId) != null && !Rs2Widget.isHidden(chooseCharacterWidgetId), 100, 5000);
        if (!result) return false;
        boolean clickResult = Rs2Widget.clickWidget(npcName, 75, 0, false);
        if (!clickResult) return false;
        sleepUntil(() -> !Rs2Player.isAnimating());
        return true;
    }
    public static boolean repairPouchesWithLunar() {
        log("Repairing pouches...");
        if (npcContact("dark mage")) {
            sleep(Random.randomGaussian(Random.random(600, 1200), 300));
            Rs2Dialogue.clickContinue();
            sleep(Random.randomGaussian(Random.random(1000, 2200), 300));
            Rs2Widget.sleepUntilHasWidget("Can you repair my pouches?");
            sleep(Random.randomGaussian(Random.random(600, 1200), 300));
            Rs2Widget.clickWidget("Can you repair my pouches?", 162, 0, true);
            sleep(Random.randomGaussian(Random.random(1000, 2200), 300));
            Rs2Dialogue.clickContinue();
            sleep(Random.randomGaussian(1500, 300));
            Rs2Tab.switchToInventoryTab();
        }
        return !Rs2Inventory.hasDegradedPouch();
    }
    private static void alch(Widget alch) {
        alch(alch, null, 300, 600);
    }
    private static void superHeat(Widget superHeat) {
        superHeat(superHeat, null, 300, 600);
    }
    public static boolean isLunar() {
        return Microbot.getVarbitValue(Varbits.SPELLBOOK) == 2;
    }
    public static boolean isAncient() {
        return Microbot.getVarbitValue(Varbits.SPELLBOOK) == 1;
    }
    public static boolean isModern() {
        return Microbot.getVarbitValue(Varbits.SPELLBOOK) == 0;
    }
    public static boolean isArceeus() {
        return Microbot.getVarbitValue(Varbits.SPELLBOOK) == 3;
    }
    public static boolean isShadowVeilActive() {
        return Microbot.getVarbitValue(SHADOW_VEIL) == 1;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/magic/Rs2Spells.java
================
package net.runelite.client.plugins.microbot.util.magic;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.api.World;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.skillcalculator.skills.MagicAction;
import org.apache.commons.lang3.tuple.Pair;
@Getter
@RequiredArgsConstructor
public enum Rs2Spells {
    VARROCK(25,
            new Pair[] {Pair.of("law rune", 1), Pair.of("air rune", 3), Pair.of("fire rune", 1)},
            new WorldPoint(3213, 3425, 0), "<col=00ff00>Varrock Teleport</col>", "Varrock teleport", MagicAction.VARROCK_TELEPORT),
    LUMBRIDGE(31,
                    new Pair[] {Pair.of("law rune", 1), Pair.of("air rune", 3), Pair.of("earth rune", 1)},
            new WorldPoint(3222, 3218, 0), "<col=00ff00>Lumbridge Teleport</col>", "Lumbridge teleport", MagicAction.LUMBRIDGE_TELEPORT),
    FALADOR(37,
                      new Pair[] {Pair.of("law rune", 1), Pair.of("air rune", 3), Pair.of("water rune", 1)},
            new WorldPoint(3093, 3380, 0), "<col=00ff00>Falador Teleport</col>", "Falador teleport", MagicAction.FALADOR_TELEPORT),
    CAMELOT(45,
                    new Pair[] {Pair.of("law rune", 1), Pair.of("air rune", 5)},
            new WorldPoint(2756, 3476, 0), "<col=00ff00>Camelot Teleport</col>", "Camelot teleport", MagicAction.CAMELOT_TELEPORT),
    ARDOUGNE(51,
                    new Pair[] {Pair.of("law rune", 2), Pair.of("water rune", 2)},
            new WorldPoint(2789, 3306, 0), "<col=00ff00>Ardougne Teleport</col>", "Ardougne teleport", MagicAction.ARDOUGNE_TELEPORT),
    CONFUSE(3,
                     new Pair[] {Pair.of("earth rune", 2), Pair.of("water rune", 3), Pair.of("body rune", 1)},
            new WorldPoint(-1, -1, 0), "<col=00ff00>Confuse</col>", "", MagicAction.CONFUSE),
    WEAKEN(11,
            new Pair[] {Pair.of("earth rune", 2), Pair.of("water rune", 3), Pair.of("body rune", 1)},
            new WorldPoint(-1, -1, 0), "<col=00ff00>Weaken</col>", "", MagicAction.WEAKEN),
    CURSE(19,
            new Pair[] {Pair.of("earth rune", 3), Pair.of("water rune", 2), Pair.of("body rune", 1)},
            new WorldPoint(-1, -1, 0), "<col=00ff00>Weaken</col>", "", MagicAction.CURSE),
    VULNERABILITY(76,
            new Pair[] {Pair.of("earth rune", 5), Pair.of("water rune", 5), Pair.of("soul rune", 1)},
            new WorldPoint(-1, -1, 0), "<col=00ff00>Weaken</col>", "", MagicAction.VULNERABILITY),
    ENFEEBLE(73,
                          new Pair[] {Pair.of("earth rune", 8), Pair.of("water rune", 8), Pair.of("soul rune", 1)},
            new WorldPoint(-1, -1, 0), "<col=00ff00>Weaken</col>", "", MagicAction.ENFEEBLE),
    STUN(80, new Pair[] {Pair.of("earth", 12), Pair.of("water rune", 12), Pair.of("soul rune", 1)},
            new WorldPoint(-1, -1, 0), "<col=00ff00>Weaken</col>", "", MagicAction.STUN);
    private final int level;
    private final Pair[] itemsRequired;
    private final WorldPoint destination;
    private final String widgetText;
    private final String tabletName;
    private final MagicAction spell;
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/math/Random.java
================
package net.runelite.client.plugins.microbot.util.math;
import java.util.concurrent.ThreadLocalRandom;
public class Random {
    public static int random(final int min, final int max) {
        final int n = Math.abs(max - min);
        return Math.min(min, max) + (n == 0 ? 0 : new java.util.Random().nextInt(n));
    }
    public static double randomDouble(final int min, final int max) {
        return  min + (max - min) * new java.util.Random().nextDouble();
    }
    public static double clamp(double val) {
        return Math.max(1.0, Math.min(13000.0, val));
    }
    public static long randomDelay() {
        return (long)clamp(Math.round(new java.util.Random().nextGaussian() * 8000.0));
    }
    /**
     * A Gaussian distribution (bell curve) generates values clustered around the mean but with random variations.
     * This approach mimics more natural randomness than a uniform random value.
     * @param mean
     * @param stddev
     * @return
     */
    public static int randomGaussian(double mean, double stddev) {
        double u, v, s;
        do {
            u = 2.0 * ThreadLocalRandom.current().nextDouble() - 1.0;
            v = 2.0 * ThreadLocalRandom.current().nextDouble() - 1.0;
            s = u * u + v * v;
        } while (s >= 1 || s == 0);
        double multiplier = Math.sqrt(-2.0 * Math.log(s) / s);
        return (int) (mean + stddev * u * multiplier);
    }
    public static int randomWithNoise(int base, int noise) {
        return base + ThreadLocalRandom.current().nextInt(-noise / 2, noise / 2 + 1);
    }
    public static int randomExponential(int base, double factor) {
        return (int) (base * Math.pow(2, ThreadLocalRandom.current().nextDouble() * factor));
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/math/RateCalculator.java
================
package net.runelite.client.plugins.microbot.util.math;
public class RateCalculator {
    private static long startTime = -1;
    public static int getRatePerHour(int currentValue) {
        if (startTime == -1)
            startTime = System.currentTimeMillis();
         final double MILLIS_TO_HOURS = 1.0 / (1000 * 60 * 60);
        double timeDifferenceInHours = (System.currentTimeMillis() - startTime) * MILLIS_TO_HOURS;
        // Calculate and return the rate
        return (int) (currentValue / timeDifferenceInHours);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/math/Rs2Random.java
================
package net.runelite.client.plugins.microbot.util.math;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Point;
import net.runelite.client.plugins.microbot.util.Global;
import java.awt.*;
import java.util.Random;
/**
 * The {@code Rs2Random} class provides a variety of random number generation methods
 * aimed at simulating human-like randomness and behavior in bots. This includes methods
 * for generating random numbers using Gaussian/Normal distributions, truncated ranges,
 * skewed distributions, and methods that generate random points on the game screen.
 *
 * <p>
 * The randomness generated by this class is intended to mimic the variability in human
 * actions, reducing the predictability of the bot's behavior and avoiding detection
 * by anti-cheat systems.
 * </p>
 *
 * <h3>Key Features:</h3>
 * <ul>
 *   <li>Gaussian/Normal random number generation with custom mean and deviation.</li>
 *   <li>Truncated Gaussian distribution for generating random numbers within specific bounds.</li>
 *   <li>Skewed random number generation towards a certain mode within a specified range.</li>
 *   <li>Methods for generating random points on the game screen, weighted around a center or skewed towards a direction.</li>
 *   <li>Random wait times and dice roll simulations based on probability percentages.</li>
 * </ul>
 *
 * <h3>Main Methods:</h3>
 * <ul>
 *   <li>{@code nzRandom()}: Returns a non-zero random double value, ensuring that the result
 *       is greater than a very small number.</li>
 *   <li>{@code gaussRand(double mean, double dev)}: Generates a random value based on a
 *       Gaussian (normal) distribution with the specified mean and standard deviation.</li>
 *   <li>{@code truncatedGauss(double left, double right, double cutoff)}: Generates a random
 *       number within the given range using a truncated Gaussian distribution.</li>
 *   <li>{@code skewedRand(double mode, double lo, double hi, double cutoff)}: Generates a random
 *       number skewed towards the specified mode within a specified range.</li>
 *   <li>{@code normalRange(double min, double max, double cutoff)}: Generates a random number
 *       within a range, with a bias towards the mean.</li>
 *   <li>{@code randomPoint(Point mean, int maxRad, double cutoff)}: Generates a random point
 *       on the screen, weighted around a central point within a maximum radius.</li>
 *   <li>{@code randomPoint(Rectangle rect, double cutoff)}: Generates a random point within the
 *       bounds of the given rectangle, biased towards the center.</li>
 *   <li>{@code dice(double chancePercent)}: Simulates a dice roll, returning true if the randomly
 *       generated number is within the chance percentage.</li>
 *   <li>{@code wait(double min, double max, EWaitDir weight)}: Simulates a wait with a random
 *       duration, biased towards the mean, left, or right of the given range.</li>
 *   <li>{@code waitEx(double mean, double dev)}: Waits for a random duration based on a Gaussian
 *       distribution.</li>
 * </ul>
 *
 * <h3>Use Cases:</h3>
 * <ul>
 *   <li>Generate human-like randomness in bot scripts for actions such as clicking, waiting,
 *       or moving the mouse.</li>
 *   <li>Simulate random wait times to avoid predictable patterns in bot behavior.</li>
 *   <li>Generate random points within a specified area for simulating mouse movements.</li>
 *   <li>Apply randomness in decision-making processes, such as determining whether to perform
 *       an action based on a random chance.</li>
 * </ul>
 *
 * <h3>Dependencies:</h3>
 * <ul>
 *   <li>{@code Global.sleep(int)}: Used in the {@code systemWait(long)} method to simulate delays.</li>
 *   <li>{@code Point} and {@code Rectangle}: Utilized for geometric calculations related to screen coordinates.</li>
 * </ul>
 *
 * <h3>Example Usage:</h3>
 * <pre>
 * // Example: Generate a random point on the screen within a rectangle, biased towards the center
 * Point randomPoint = Rs2Random.randomPoint(new Rectangle(100, 100, 300, 300), 2.0);
 *
 * // Example: Simulate a wait with random duration biased towards the middle of the range
 * Rs2Random.wait(1000, 2000, Rs2Random.EWaitDir.wdMean);
 * </pre>
 *
 * <h3>Limitations:</h3>
 * <ul>
 *   <li>The class heavily relies on randomness, which may produce unexpected results if not handled carefully.</li>
 *   <li>Randomness might not always be sufficient to simulate real human behavior and may require tuning for specific use cases.</li>
 * </ul>
 *
 * <h3>Enum:</h3>
 * <ul>
 *   <li>{@code EWaitDir}: Defines the direction of bias for random waits, including left, mean, and right skew.</li>
 * </ul>
 *
 * <h3>Private Helpers:</h3>
 * <ul>
 *   <li>{@code systemWait(long time)}: Invokes a system-level wait for the specified time in milliseconds.</li>
 *   <li>{@code rotatePoint(Point point, double angle, double originX, double originY)}: Rotates a point around an origin by a specified angle.</li>
 * </ul>
 */
@Slf4j
public class Rs2Random {
    private static final double GAUSS_CUTOFF = 4.0;
    private static final Random RANDOM = new Random();
    /**
     * Returns a non-zero random double value.
     * Ensures that the result is always greater than a very small number (1.0e-320),
     * preventing the generation of an exact zero.
     *
     * @return A non-zero random double value.
     */
    public static double nzRandom() {
        return Math.max(RANDOM.nextDouble(), 1.0e-320);
    }
    /**
     * Generates a random value based on a Gaussian (normal) distribution with a specified mean and standard deviation.
     *
     * @param mean The mean (center) value of the distribution.
     * @param dev  The standard deviation of the distribution.
     *
     * @return A random double value from the Gaussian distribution.
     */
    public static double gaussRand(double mean, double dev) {
        double len = dev * Math.sqrt(-2 * Math.log(nzRandom()));
        return mean + len * Math.cos(2 * Math.PI * RANDOM.nextDouble());
    }
    /**
     * Generates a random number within the given range using a truncated Gaussian distribution.
     * This ensures that the value is within the bounds of the left and right range.
     *
     * @param left   The minimum bound of the range.
     * @param right  The maximum bound of the range.
     * @param cutoff The cutoff value to restrict extreme values. Defaults to GAUSS_CUTOFF(4) if less than or equal to 0.
     *
     * @return A random double value within the specified range.
     */
    public static double truncatedGauss(double left, double right, double cutoff) {
        if (cutoff <= 0) {
            cutoff = GAUSS_CUTOFF;
        }
        double result;
        do {
            result = Math.abs(Math.sqrt(-2 * Math.log(nzRandom())) * Math.cos(2 * Math.PI * RANDOM.nextDouble()));
        } while (result >= cutoff);
        return result / cutoff * (right - left) + left;
    }
    /**
     * Generates a random long value within the given range using a truncated Gaussian distribution.
     *
     * @param left   The minimum bound of the range.
     * @param right  The maximum bound of the range.
     * @param cutoff The cutoff value to restrict extreme values.
     *
     * @return A random long value within the specified range.
     */
    public static long truncatedGauss(long left, long right, double cutoff) {
        return Math.round(truncatedGauss((double) left, (double) right, cutoff));
    }
    /**
     * Generates a random number skewed towards the specified mode within a specified range.
     * This allows for a biased distribution where the values tend to cluster around the mode.
     *
     * @param mode   The central value around which the distribution is skewed.
     * @param lo     The lower bound of the range.
     * @param hi     The upper bound of the range.
     * @param cutoff The cutoff value to restrict extreme values. Defaults to GAUSS_CUTOFF(4) if less than or equal to 0.
     *
     * @return A random double value skewed towards the mode.
     */
    public static double skewedRand(double mode, double lo, double hi, double cutoff) {
        if (cutoff <= 0) {
            cutoff = GAUSS_CUTOFF;
        }
        double top = lo;
        if (RANDOM.nextDouble() * (hi - lo) > mode - lo) {
            top = hi;
        }
        double result;
        do {
            result = Math.abs(Math.sqrt(-2 * Math.log(nzRandom())) * Math.cos(2 * Math.PI * RANDOM.nextDouble()));
        } while (result >= cutoff);
        return result / cutoff * (top - mode) + mode;
    }
    /**
     * Generates a random long value skewed towards the specified mode within a specified range.
     *
     * @param mode   The central value around which the distribution is skewed.
     * @param lo     The lower bound of the range.
     * @param hi     The upper bound of the range.
     * @param cutoff The cutoff value to restrict extreme values.
     *
     * @return A random long value skewed towards the mode.
     */
    public static long skewedRand(long mode, long lo, long hi, double cutoff) {
        return Math.round(skewedRand((double) mode, (double) lo, (double) hi, cutoff));
    }
    /**
     * Generates a random number within the specified range, biased towards the mean.
     * The distribution has a higher likelihood of generating numbers closer to the midpoint of the range.
     *
     * @param min    The minimum bound of the range.
     * @param max    The maximum bound of the range.
     * @param cutoff The cutoff value to restrict extreme values. Defaults to GAUSS_CUTOFF(4) if less than or equal to 0.
     *
     * @return A random double value within the specified range, biased towards the middle.
     */
    public static double normalRange(double min, double max, double cutoff) {
        if (cutoff <= 0) {
            cutoff = GAUSS_CUTOFF;
        }
        switch (RANDOM.nextInt(2)) {
            case 0:
                return (max + min) / 2.0 + truncatedGauss(0, (max - min) / 2, cutoff);
            case 1:
                return (max + min) / 2.0 - truncatedGauss(0, (max - min) / 2, cutoff);
            default:
                throw new IllegalStateException("Unexpected value: " + RANDOM.nextInt(2));
        }
    }
    /**
     * Generates a random long value within the specified range, biased towards the mean.
     *
     * @param min    The minimum bound of the range.
     * @param max    The maximum bound of the range.
     * @param cutoff The cutoff value to restrict extreme values. Defaults to GAUSS_CUTOFF(4) if less than or equal to 0.
     *
     * @return A random long value within the specified range, biased towards the middle.
     */
    public static long normalRange(long min, long max, double cutoff) {
        if (cutoff <= 0) {
            cutoff = GAUSS_CUTOFF;
        }
        switch (RANDOM.nextInt(2)) {
            case 0:
                return Math.round((max + min) / 2.0 + truncatedGauss(0, (max - min) / 2, cutoff));
            case 1:
                return Math.round((max + min) / 2.0 - truncatedGauss(0, (max - min) / 2, cutoff));
            default:
                throw new IllegalStateException("Unexpected value: " + RANDOM.nextInt(2));
        }
    }
    /**
     * Generates a random point on the screen, weighted around a central point (mean) within a maximum radius.
     * The point is selected to simulate human-like randomness in mouse movement or other actions.
     *
     * @param mean   The central point to weight the randomness around.
     * @param maxRad The maximum radius away from the central point.
     * @param cutoff The cutoff value for restricting extreme values. Defaults to GAUSS_CUTOFF(4) if less than or equal to 0.
     *
     * @return A random point near the central point, within the specified radius.
     */
    public static Point randomPoint(Point mean, int maxRad, double cutoff) {
        int x = (int) normalRange(mean.getX() - maxRad, mean.getX() + maxRad, cutoff);
        int y = (int) normalRange(mean.getY() - maxRad, mean.getY() + maxRad, cutoff);
        return new Point(x, y);
    }
    /**
     * Generates a random point within the bounds of the given rectangle, biased towards the center.
     * This method is useful for simulating human-like randomness in screen interactions.
     *
     * @param rect   The rectangular area within which to generate the random point.
     * @param cutoff The cutoff value for restricting extreme values. Defaults to GAUSS_CUTOFF(4) if less than or equal to 0.
     *
     * @return A random point within the rectangle, biased towards the middle.
     */
    public static Point randomPoint(Rectangle rect, double cutoff) {
        double x1 = rect.getX();
        double y1 = rect.getY();
        double x2 = rect.getX() + rect.getWidth();
        double y2 = rect.getY() + rect.getHeight();
        double a = Math.atan2(rect.getHeight(), rect.getWidth());
        int x = (int) normalRange(x1 + 1, x2 - 1, cutoff);
        int y = (int) normalRange(y1 + 1, y2 - 1, cutoff);
        return rotatePoint(new Point(x, y), a, (x2 + x1) / 2 + RANDOM.nextDouble() - 0.5, (y2 + y1) / 2 + RANDOM.nextDouble() - 0.5);
    }
    /**
     * Generates a random point within the bounds of a rectangle, skewed towards a specified 'from' point.
     * Useful for simulating more human-like randomness in actions such as dragging or moving the mouse.
     *
     * @param from  The point to bias the random point generation towards.
     * @param rect  The rectangular area within which to generate the random point.
     * @param force A multiplier that defines how strongly the point should be skewed towards the 'from' point.
     *
     * @return A random point within the rectangle, skewed towards the 'from' point.
     */
    public static Point randomPointEx(Point from, Rectangle rect, double force) {
        Point p = from;
        p = new Point(Math.min(Math.max(p.getX(), (int) rect.getX()), (int) (rect.getX() + rect.getWidth())), Math.min(Math.max(p.getY(), (int) rect.getY()), (int) (rect.getY() + rect.getHeight())));
        Point c = new Point((int) (rect.getX() + rect.getWidth() / 2), (int) (rect.getY() + rect.getHeight() / 2));
        double r = Math.hypot(p.getX() - c.getX(), p.getY() - c.getY()) * force;
        double x = Math.atan2(c.getY() - p.getY(), c.getX() - p.getX());
        p = new Point((int) (p.getX() + Math.round(Math.cos(x) * r)), (int) (p.getY() + Math.round(Math.sin(x) * r)));
        int resultX = (int) skewedRand(p.getX(), (int) rect.getX(), (int) (rect.getX() + rect.getWidth()), GAUSS_CUTOFF);
        int resultY = (int) skewedRand(p.getY(), (int) rect.getY(), (int) (rect.getY() + rect.getHeight()), GAUSS_CUTOFF);
        return new Point(resultX, resultY);
    }
    /**
     * Simulates a dice roll using a fractional probability (e.g., 0.1 for 10%).
     *
     * @param fractionalChance A decimal between 0 and 1 representing the chance.
     *
     * @return True if the random number falls within the chance, false otherwise.
     */
    public static boolean diceFractional(double fractionalChance) {
        // Generate a random number between 0 and 1 and compare
        return RANDOM.nextDouble() < fractionalChance;
    }
    /**
     * Simulates a dice roll using a whole number percentage (e.g., 10 for 10%).
     *
     * @param percentageChance A whole number between 0 and 100 representing the chance.
     *
     * @return True if the random number falls within the chance, false otherwise.
     */
    public static boolean dicePercentage(double percentageChance) {
        // Generate a random number between 0 and 100 and compare
        return RANDOM.nextDouble() * 100 < percentageChance;
    }
    /**
     * Simulates a wait with a random duration, biased towards the mean, left, or right of the given range.
     * This method is useful for introducing randomness in bot actions to reduce predictability.
     *
     * @param min    The minimum wait time in milliseconds.
     * @param max    The maximum wait time in milliseconds.
     * @param weight The direction of bias for the wait time (left, mean, or right skew).
     */
    public static void wait(double min, double max, EWaitDir weight) {
        switch (weight) {
            case wdLeft:
                systemWait(Math.round(truncatedGauss(min, max, 0)));
                break;
            case wdMean:
                systemWait(Math.round(normalRange(min, max, 0)));
                break;
            case wdRight:
                systemWait(Math.round(truncatedGauss(max, min, 0)));
                break;
        }
    }
    /**
     * Simulates a wait with a random duration, biased towards the left side of the given range.
     *
     * @param min The minimum wait time in milliseconds.
     * @param max The maximum wait time in milliseconds.
     */
    public static void wait(int min, int max) {
        wait(min, max, EWaitDir.wdLeft);
    }
    /**
     * Waits for a random duration based on a Gaussian distribution.
     * The wait time is calculated using a normal distribution with the specified mean and standard deviation.
     *
     * @param mean The mean wait time in milliseconds.
     * @param dev  The standard deviation of the wait time.
     */
    public static void waitEx(double mean, double dev) {
        wait(Math.abs(Math.round(gaussRand(mean, dev))), 0, EWaitDir.wdMean);
    }
    /**
     * Pauses the execution for a specified amount of time in milliseconds.
     * This method is a system-level wait used for simulating delays in bot actions.
     *
     * @param time The duration to wait in milliseconds.
     */
    private static void systemWait(long time) {
        Global.sleep((int) time);
    }
    /**
     * Rotates a given point around a specified origin by a certain angle.
     * This method is used for calculating rotated positions in 2D space.
     *
     * @param point   The point to be rotated.
     * @param angle   The angle to rotate the point, in radians.
     * @param originX The x-coordinate of the origin point.
     * @param originY The y-coordinate of the origin point.
     *
     * @return A new point representing the rotated coordinates.
     */
    private static Point rotatePoint(Point point, double angle, double originX, double originY) {
        double sin = Math.sin(angle);
        double cos = Math.cos(angle);
        double dx = point.getX() - originX;
        double dy = point.getY() - originY;
        int newX = (int) (cos * dx - sin * dy + originX);
        int newY = (int) (sin * dx + cos * dy + originY);
        return new Point(newX, newY);
    }
    /**
     * Generates a random integer between min (inclusive) and max (inclusive) with options
     * for skewing the distribution towards either the lower or higher bound.
     *
     * @param min         The minimum value (inclusive).
     * @param max         The maximum value (inclusive).
     * @param skewFactor  The skew factor. A value > 1 will skew the distribution towards the higher end,
     *                    while a value < 1 will skew it towards the lower end. A value of 1 produces
     *                    a standard Gaussian distribution centered around the midpoint.
     * @param useGaussian If true, the method will use a Gaussian distribution instead of a uniform one.
     *
     * @return A random integer between min and max, possibly skewed based on the parameters.
     */
    public static int nextInt(int min, int max, double skewFactor, boolean useGaussian) {
        if (min > max) {
            throw new IllegalArgumentException("Min cannot be greater than Max.");
        }
        if (useGaussian) {
            // Generate a Gaussian (normal) distributed value
            double mean = (max + min) / 2.0; // Center around the middle
            double deviation = (max - min) / 6.0; // Ensure 99.7% of values are within [min, max]
            // Generate a random value using Gaussian distribution
            double gaussianRandom = mean + RANDOM.nextGaussian() * deviation;
            // Clamp the result to stay within the [min, max] range
            int result = (int) Math.round(Math.max(min, Math.min(max, gaussianRandom)));
            return result;
        } else {
            // Skewed random number generation
            double rawRandom = RANDOM.nextDouble();  // A random number between 0 and 1
            // Apply skew factor to bias the result
            if (skewFactor != 1) {
                rawRandom = Math.pow(rawRandom, skewFactor);
            }
            // Scale the result to the [min, max] range
            int result = (int) Math.round(min + rawRandom * (max - min));
            return result;
        }
    }
    enum EWaitDir {
        wdLeft, wdMean, wdRight
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/menu/NewMenuEntry.java
================
package net.runelite.client.plugins.microbot.util.menu;
import net.runelite.api.*;
import net.runelite.api.widgets.Widget;
import org.jetbrains.annotations.NotNull;
import javax.annotation.Nullable;
import java.util.function.Consumer;
public class NewMenuEntry implements MenuEntry {
    private String option;
    private String target;
    private int identifier;
    private MenuAction type;
    private int param0;
    private int param1;
    private boolean forceLeftClick;
    private int itemId;
    private Actor actor;
    private TileObject gameObject;
    private Widget widget;
    public NewMenuEntry(int param0, int param1, int opcode, int identifier, int itemId, String target) {
        this.option = "Use";
        this.target = target;
        this.identifier = identifier;
        this.type = MenuAction.of(opcode);
        this.param0 = param0;
        this.param1 = param1;
        this.forceLeftClick = false;
        this.itemId = itemId;
    }
    public NewMenuEntry(int param0, int param1, int opcode, int identifier, int itemId, String target, Actor actor) {
        this.option = "Use";
        this.target = target;
        this.identifier = identifier;
        this.type = MenuAction.of(opcode);
        this.param0 = param0;
        this.param1 = param1;
        this.forceLeftClick = false;
        this.itemId = itemId;
        this.actor = actor;
    }
    public NewMenuEntry(int param0, int param1, int opcode, int identifier, int itemId, String option, String target, TileObject gameObject) {
        this.option = "Use";
        this.target = target;
        this.identifier = identifier;
        this.type = MenuAction.of(opcode);
        this.param0 = param0;
        this.param1 = param1;
        this.forceLeftClick = false;
        this.itemId = itemId;
        this.option = option;
        this.gameObject = gameObject;
    }
    public NewMenuEntry(String option, String target, int identifier, MenuAction type, int param0, int param1, boolean forceLeftClick) {
        this.option = option;
        this.target = target;
        this.identifier = identifier;
        this.type = type;
        this.param0 = param0;
        this.param1 = param1;
        this.forceLeftClick = forceLeftClick;
    }
    public NewMenuEntry(String option, int param0, int param1, int opcode, int identifier, int itemId, String target) {
        this.option = option;
        this.target = target;
        this.identifier = identifier;
        this.type = MenuAction.of(opcode);
        this.param0 = param0;
        this.param1 = param1;
        this.forceLeftClick = false;
        this.itemId = itemId;
    }
    public NewMenuEntry() {
    }
    public String getOption() {
        return this.option;
    }
    public MenuEntry setOption(String option) {
        this.option = option;
        return this;
    }
    public String getTarget() {
        return this.target;
    }
    public MenuEntry setTarget(String target) {
        this.target = target;
        return this;
    }
    public int getIdentifier() {
        return this.identifier;
    }
    public MenuEntry setIdentifier(int identifier) {
        this.identifier = identifier;
        return this;
    }
    public MenuAction getType() {
        return this.type;
    }
    public MenuEntry setType(MenuAction type) {
        this.type = type;
        return this;
    }
    public int getParam0() {
        return this.param0;
    }
    public MenuEntry setParam0(int param0) {
        this.param0 = param0;
        return this;
    }
    public int getParam1() {
        return this.param1;
    }
    public MenuEntry setParam1(int param1) {
        this.param1 = param1;
        return this;
    }
    public boolean isForceLeftClick() {
        return this.forceLeftClick;
    }
    public MenuEntry setForceLeftClick(boolean forceLeftClick) {
        this.forceLeftClick = forceLeftClick;
        return this;
    }
    @Override
    public int getWorldViewId() {
        return 0;
    }
    @Override
    public MenuEntry setWorldViewId(int worldViewId) {
        return null;
    }
    public boolean isDeprioritized() {
        return false;
    }
    public MenuEntry setDeprioritized(boolean deprioritized) {
        return this;
    }
    public MenuEntry onClick(Consumer<MenuEntry> callback) {
        return this;
    }
    @Override
    public Consumer<MenuEntry> onClick() {
        return null;
    }
    public MenuEntry getParent() {
        return this;
    }
    public boolean isItemOp() {
        return false;
    }
    public int getItemOp() {
        return 0;
    }
    public int getItemId() {
        return itemId;
    }
    @Override
    public MenuEntry setItemId(int itemId) {
        this.itemId = itemId;
        return this;
    }
    public MenuEntry setWidget(Widget widget) {
        this.widget = widget;
        return this;
    }
    @Nullable
    public Widget getWidget() {
        return widget;
    }
    @Nullable
    public NPC getNpc() {
        return actor instanceof NPC ? (NPC) actor : null;
    }
    @Nullable
    public Player getPlayer() {
        return actor instanceof Player ? (Player) actor : null;
    }
    @Nullable
    public Actor getActor() {
        return actor;
    }
    @Nullable
    public TileObject getGameObject() {
        return gameObject;
    }
    @org.jetbrains.annotations.Nullable
    @Override
    public Menu getSubMenu() {
        return null;
    }
    @NotNull
    @Override
    public Menu createSubMenu() {
        return null;
    }
    @Override
    public void deleteSubMenu() {
    }
    public boolean equals(Object o) {
        if (o == this) {
            return true;
        } else if (!(o instanceof NewMenuEntry)) {
            return false;
        } else {
            NewMenuEntry other = (NewMenuEntry)o;
            if (!other.canEqual(this)) {
                return false;
            } else if (this.getIdentifier() != other.getIdentifier()) {
                return false;
            } else if (this.getParam0() != other.getParam0()) {
                return false;
            } else if (this.getParam1() != other.getParam1()) {
                return false;
            } else if (this.isForceLeftClick() != other.isForceLeftClick()) {
                return false;
            } else {
                Object this$option = this.getOption();
                Object other$option = other.getOption();
                if (this$option == null) {
                    if (other$option != null) {
                        return false;
                    }
                } else if (!this$option.equals(other$option)) {
                    return false;
                }
                Object this$target = this.getTarget();
                Object other$target = other.getTarget();
                if (this$target == null) {
                    if (other$target != null) {
                        return false;
                    }
                } else if (!this$target.equals(other$target)) {
                    return false;
                }
                Object this$type = this.getType();
                Object other$type = other.getType();
                if (this$type == null) {
                    return other$type == null;
                } else return this$type.equals(other$type);
            }
        }
    }
    protected boolean canEqual(Object other) {
        return other instanceof NewMenuEntry;
    }
    public int hashCode() {
        boolean PRIME = true;
        int result = 1;
        result = result * 59 + this.getIdentifier();
        result = result * 59 + this.getParam0();
        result = result * 59 + this.getParam1();
        result = result * 59 + (this.isForceLeftClick() ? 79 : 97);
        Object $option = this.getOption();
        result = result * 59 + ($option == null ? 43 : $option.hashCode());
        Object $target = this.getTarget();
        result = result * 59 + ($target == null ? 43 : $target.hashCode());
        Object $type = this.getType();
        result = result * 59 + ($type == null ? 43 : $type.hashCode());
        return result;
    }
    public String toString() {
        String var10000 = this.getOption();
        return "NewMenuEntry(option=" + var10000 + ", target=" + this.getTarget() + ", identifier=" + this.getIdentifier() + ", type=" + this.getType() + ", param0=" + this.getParam0() + ", param1=" + this.getParam1() + ", forceLeftClick=" + this.isForceLeftClick() + ")";
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/misc/Operation.java
================
package net.runelite.client.plugins.microbot.util.misc;
import lombok.Getter;
import java.util.function.BiFunction;
public enum Operation
{
    GREATER(">", (x,y) -> x > y),
    LESS("<", (x,y) -> x < y),
    LESS_EQUAL("<=", (x,y) -> x <= y),
    EQUAL("==", Integer::equals),
    GREATER_EQUAL(">=", (x,y) -> x >= y),
    NOT_EQUAL("=/=", (x,y) -> !x.equals(y));
    private final BiFunction<Integer, Integer, Boolean> operation;
    @Getter
    private String displayText;
    Operation(String displayText, BiFunction<Integer, Integer, Boolean> operation) {
        this.displayText = displayText;
        this.operation = operation;
    }
    public boolean check(int numberToCheck, int numberToCheckAgainst) {
        return operation.apply(numberToCheck, numberToCheckAgainst);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/misc/Predicates.java
================
package net.runelite.client.plugins.microbot.util.misc;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;
import java.util.function.Predicate;
public class Predicates {
    public static <T> Predicate<T> distinctByProperty(Function<? super T, ?> propertyExtractor) {
        Set<Object> seen = ConcurrentHashMap.newKeySet();
        return t -> seen.add(propertyExtractor.apply(t));
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/misc/Rs2Food.java
================
package net.runelite.client.plugins.microbot.util.misc;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
@Getter
@RequiredArgsConstructor
public enum Rs2Food {
    Dark_Crab(11936, 27, "Dark Crab"),
    ROCKTAIL(15272, 23, "Rocktail"),
    MANTA(391, 22, "Manta Ray"),
    SHARK(385, 20, "Shark"),
    KARAMBWAN(3144, 18, "Cooked karambwan"),
    LOBSTER(379, 12, "Lobster"),
    TROUT(333, 7, "Trout"),
    SALMON(329, 9, "Salmon"),
    SWORDFISH(373, 14, "Swordfish"),
    TUNA(361, 10, "Tuna"),
    MONKFISH(7946, 16, "Monkfish"),
    SEA_TURTLE(397, 21, "Sea Turtle"),
    CAKE(1891, 4, "Cake"),
    BASS(365, 13, "Bass"),
    COD(339, 7, "Cod"),
    POTATO(1942, 1, "Potato"),
    BAKED_POTATO(6701, 4, "Baked Potato"),
    POTATO_WITH_CHEESE(6705, 16, "Potato with Cheese"),
    EGG_POTATO(7056, 16, "Egg Potato"),
    CHILLI_POTATO(7054, 14, "Chilli Potato"),
    MUSHROOM_POTATO(7058, 20, "Mushroom Potato"),
    TUNA_POTATO(7060, 22, "Tuna Potato"),
    SHRIMPS(315, 3, "Shrimps"),
    HERRING(347, 5, "Herring"),
    SARDINE(325, 4, "Sardine"),
    CHOCOLATE_CAKE(1897, 5, "Chocolate Cake"),
    ANCHOVIES(319, 1, "Anchovies"),
    PLAIN_PIZZA(2289, 7, "Plain Pizza"),
    MEAT_PIZZA(2293, 8, "Meat Pizza"),
    ANCHOVY_PIZZA(2297, 9, "Anchovy Pizza"),
    PINEAPPLE_PIZZA(2301, 11, "Pineapple Pizza"),
    BREAD(2309, 5, "Bread"),
    APPLE_PIE(2323, 7, "Apple Pie"),
    REDBERRY_PIE(2325, 5, "Redberry Pie"),
    MEAT_PIE(2327, 6, "Meat Pie"),
    PIKE(351, 8, "Pike"),
    POTATO_WITH_BUTTER(6703, 14, "Potato with Butter"),
    BANANA(1963, 2, "Banana"),
    PEACH(6883, 8, "Peach"),
    ORANGE(2108, 2, "Orange"),
    PINEAPPLE_RINGS(2118, 2, "Pineapple Rings"),
    PINEAPPLE_CHUNKS(2116, 2, "Pineapple Chunks"),
    JUG_OF_WINE(1993, 11, "Jug of wine"),
    COOKED_LARUPIA(29146, 11, "Cooked larupia"),
    COOKED_BARBTAILED_KEBBIT(29131, 12, "Cooked barb-tailed kebbit"),
    COOKED_GRAAHK(29149, 14, "Cooked graahk"),
    COOKED_KYATT(29152, 17, "Cooked kyatt"),
    COOKED_PYRE_FOX(29137, 19, "Cooked pyre fox"),
    COOKED_SUNLIGHT_ANTELOPE(29140, 21, "Cooked sunlight antelope"),
    COOKED_DASHING_KEBBIT(29134, 23, "Cooked dashing kebbit"),
    COOKED_MOONLIGHT_ANTELOPE(29143, 26, "Cooked moonlight antelope"),
    PURPLE_SWEETS(10476, 3, "Purple Sweets");
    private int id;
    private int heal;
    private String name;
    Rs2Food(int id, int heal, String name) {
        this.id = id;
        this.heal = heal;
        this.name = name;
    }
    @Override
    public String toString() {
        return name + " (+" + getHeal() + ")";
    }
    public int getId() {
        return id;
    }
    public int getHeal() {
        return heal;
    }
    public String getName() {
        return name;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/misc/Rs2Potion.java
================
package net.runelite.client.plugins.microbot.util.misc;
import java.util.Arrays;
import java.util.List;
public class Rs2Potion {
    public static List<String> getPrayerPotionsVariants() {
        return Arrays.asList("prayer potion", "super restore", "moonlight moth mix");
    }
    public static List<String> getRangePotionsVariants() {
        return Arrays.asList("ranging potion", "bastion potion", "divine bastion potion");
    }
    public static String getStaminaPotion() {
        return "Stamina potion";
    }
    public static List<String> getRestoreEnergyPotionsVariants() {
        return Arrays.asList("Super energy", "Super energy mix", "Energy potion", "Energy mix");
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/misc/Rs2UiHelper.java
================
package net.runelite.client.plugins.microbot.util.misc;
import net.runelite.api.Actor;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.TileObject;
import net.runelite.api.coords.LocalPoint;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.antiban.Rs2AntibanSettings;
import net.runelite.client.plugins.microbot.util.math.Rs2Random;
import net.runelite.client.plugins.microbot.util.menu.NewMenuEntry;
import java.awt.*;
public class Rs2UiHelper {
    public static boolean isRectangleWithinViewport(Rectangle rectangle) {
        int viewportHeight = Microbot.getClient().getViewportHeight();
        int viewportWidth = Microbot.getClient().getViewportWidth();
        return !(rectangle.getX() > (double) viewportWidth) &&
                !(rectangle.getY() > (double) viewportHeight) &&
                !(rectangle.getX() < 0.0) &&
                !(rectangle.getY() < 0.0);
    }
    public static Point getClickingPoint(Rectangle rectangle, boolean randomize) {
        if (rectangle == null) return new Point(1, 1);
        if (rectangle.getX() == 1 && rectangle.getY() == 1) return new Point(1, 1);
        if (rectangle.getX() == 0 && rectangle.getY() == 0) return new Point(1, 1);
        if (!randomize) return new Point((int) rectangle.getCenterX(), (int) rectangle.getCenterY());
        //check if mouse is already within the rectangle and return current position
        if (Rs2AntibanSettings.naturalMouse) {
            java.awt.Point mousePos = Microbot.getMouse().getMousePosition();
            if (isMouseWithinRectangle(rectangle)) return new Point(mousePos.x, mousePos.y);
            else return Rs2Random.randomPointEx(new Point(mousePos.x, mousePos.y), rectangle, 0.5);
        } else
            return Rs2Random.randomPointEx(Microbot.getMouse().getLastClick(), rectangle, 0.5);
    }
    //check if mouse is already within the rectangle
    public static boolean isMouseWithinRectangle(Rectangle rectangle) {
        java.awt.Point mousePos = Microbot.getMouse().getMousePosition();
        if (rectangle.getX() == 1 && rectangle.getY() == 1) return true;
        if (rectangle.getX() == 0 && rectangle.getY() == 0) return true;
        return rectangle.contains(mousePos);
    }
    public static Rectangle getActorClickbox(Actor actor) {
        LocalPoint lp = actor.getLocalLocation();
        if (lp == null) {
            Microbot.log("LocalPoint is null");
            return new Rectangle(1, 1);
        }
        Shape clickbox = Microbot.getClientThread().runOnClientThread(() -> Perspective.getClickbox(Microbot.getClient(), actor.getModel(), actor.getCurrentOrientation(), lp.getX(), lp.getY(),
                Perspective.getTileHeight(Microbot.getClient(), lp, actor.getWorldLocation().getPlane())));
        if (clickbox == null) return new Rectangle(1, 1);  //return a small rectangle if clickbox is null
        return new Rectangle(clickbox.getBounds());
    }
    public static Rectangle getObjectClickbox(TileObject object) {
        if (object == null) return new Rectangle(1, 1);  //return a small rectangle if object is null
        Shape clickbox = Microbot.getClientThread().runOnClientThread(object::getClickbox);
        if (clickbox == null) return new Rectangle(1, 1);  //return a small rectangle if clickbox is null
        if (clickbox.getBounds() == null) return new Rectangle(1, 1);
        return new Rectangle(clickbox.getBounds());
    }
    // check if a menu entry is a actor
    public static boolean hasActor(NewMenuEntry entry) {
        return entry.getActor() != null;
    }
    // check if a menu entry is a game object
    public static boolean isGameObject(NewMenuEntry entry) {
        return entry.getGameObject() != null;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/misc/SpecialAttackWeaponEnum.java
================
package net.runelite.client.plugins.microbot.util.misc;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import net.runelite.client.plugins.microbot.util.equipment.Rs2Equipment;
@Getter
@RequiredArgsConstructor
public enum SpecialAttackWeaponEnum {
    DRAGON_DAGGER("dragon dagger", 250, false),
    GRANITE_MAUL("granite maul", 600, true),
    DRAGON_WARHAMMER("dragon warhammer", 500, false),
    DRAGON_SWORD("dragon sword", 250, false),
    ANCIENT_GODSWORD("ancient godsword", 500, true),
    ABYSSAL_DAGGER("abyssal dagger", 250, false),
    BANDOS_GODSWORD("bandos godsword", 500, true),
    DRAGON_MACE("dragon mace", 250, false),
    ZAMORAK_GODSWORD("zamorak godsword", 500, true),
    ARMADYL_GODSWORD("armadyl godsword", 500, true),
    ARMADYL_CROSSBOW("armadyl crossbow", 500, false),
    DRAGON_CROSSBOW("dragon crossbow", 600, false),
    SARADOMIN_GODSWORD("saradomin godsword", 500, true),
    HEAVY_BALLISTA("heavy ballista", 650, true),
    DRAGON_CLAWS("dragon claws", 550, true);
    private final String name;
    private final int energyRequired;
    private final boolean is2H;
    @Override
    public String toString() {
        return name;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/misc/TimeUtils.java
================
package net.runelite.client.plugins.microbot.util.misc;
import java.time.Duration;
import java.time.Instant;
public class TimeUtils {
    /**
     * Get formatted duration between two instants
     *
     * @param start
     * @param finish
     * @return duration as string formatted to d:mm:ss
     */
    public static String getFormattedDurationBetween(Instant start, Instant finish) {
        Duration duration = Duration.between(start, finish);
        return String.format("%d:%02d:%02d",
                duration.toHours(),
                duration.toMinutesPart(),
                duration.toSecondsPart());
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/models/RS2Item.java
================
package net.runelite.client.plugins.microbot.util.models;
import net.runelite.api.ItemComposition;
import net.runelite.api.Tile;
import net.runelite.api.TileItem;
@Deprecated(since="use inventory.rs2item")
public class RS2Item {
    private final ItemComposition item;
    private final Tile tile;
    private final TileItem tileItem;
    public RS2Item(ItemComposition item, Tile tile, TileItem tileItem) {
        this.item = item;
        this.tile = tile;
        this.tileItem = tileItem;
    }
    public ItemComposition getItem() {
        return item;
    }
    public Tile getTile() {
        return tile;
    }
    public TileItem getTileItem() {
        return tileItem;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/api/DeviationProvider.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.api;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support.DoublePoint;
/**
 * Creates arcs or deviation into mouse movement.
 * <p>
 * DeviationProvider implementation should be immutable.
 */
public interface DeviationProvider {
    /**
     * Gets the deviation for current trajectory. Deviation is an offset from the original straight trajectory.
     * <p>
     * Deviation is different from the Noise because it works like a mathematical function, the resulting
     * Point is added to single trajectory point and it will not have any effect in the next
     * mouse movement step, making it easy to implement this as a formula based on the input parameters.
     * e.g the something like 'deviation = totalDistanceInPixels / completionFraction', resulting in smooth movement.
     * (Don't actually use this formula), 'Noise' is generating an offset from the original trajectory and is accumulating.
     * <p>
     * As deviation should be deterministic and return same result for same parameters, it should not include Random
     * behaviour, thus Random is not included as a parameter.
     * <p>
     * It is recommended that deviation is decreasing when completionFraction nears 1, but MouseMotion itself
     * also makes sure that the effect of deviation is reduced when the mouse is nearing its destination.
     *
     * @param totalDistanceInPixels the total pixels between target and mouse initial position
     * @param completionFraction    the completed fraction of mouse movement total distance, value from 0...1 (0;1]
     * @return a point which describes how much the mouse is going to deviate from the straight trajectory between
     * target and initial position. This is not the final deviation of the mouse as MouseMotion will randomly decide
     * to either amplify or decrease it over the whole mouse movement, making the resulting arc stand out more or less,
     * or is flipped negatively.
     * @see NoiseProvider
     */
    DoublePoint getDeviation(double totalDistanceInPixels, double completionFraction);
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/api/MouseInfoAccessor.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.api;
import java.awt.*;
/**
 * Abstraction for getting mouse position.
 */
public interface MouseInfoAccessor {
    /**
     * Get the current mouse position.
     * NB, for optimization reasons this method might return the same Point instance, but is not quaranteed to.
     * It is recommended not to save this Point anywhere as it may or may not change its coordinates.
     *
     * @return the current mouse position
     */
    Point getMousePosition();
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/api/MouseMotion.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.api;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support.DoublePoint;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support.Flow;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support.MouseMotionNature;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support.mousemotion.MouseMovement;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support.mousemotion.MovementFactory;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.util.MathUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.util.ArrayDeque;
import java.util.Random;
/**
 * Contains instructions to move cursor smoothly to the destination coordinates from where ever the cursor
 * currently is. The class is reusable, meaning user can keep calling it and the cursor returns in a random,
 * but reliable way, described in this class, to the destination.
 */
public class MouseMotion {
    private static final Logger log = LoggerFactory.getLogger(MouseMotion.class);
    private static final int SLEEP_AFTER_ADJUSTMENT_MS = 2;
    private final int minSteps;
    private final int effectFadeSteps;
    private final int reactionTimeBaseMs;
    private final int reactionTimeVariationMs;
    private final double timeToStepsDivider;
    private final Dimension screenSize;
    private final SystemCalls systemCalls;
    private final DeviationProvider deviationProvider;
    private final NoiseProvider noiseProvider;
    private final SpeedManager speedManager;
    private final OvershootManager overshootManager;
    private final int xDest;
    private final int yDest;
    private final Random random;
    private final MouseInfoAccessor mouseInfo;
    private Point mousePosition;
    /**
     * @param nature the nature that defines how mouse is moved
     * @param xDest  the x-coordinate of destination
     * @param yDest  the y-coordinate of destination
     * @param random the random used for unpredictability
     */
    public MouseMotion(MouseMotionNature nature, Random random, int xDest, int yDest) {
        this.deviationProvider = nature.getDeviationProvider();
        this.noiseProvider = nature.getNoiseProvider();
        this.systemCalls = nature.getSystemCalls();
        this.screenSize = systemCalls.getScreenSize();
        this.xDest = limitByScreenWidth(xDest);
        this.yDest = limitByScreenHeight(yDest);
        this.random = random;
        this.mouseInfo = nature.getMouseInfo();
        this.speedManager = nature.getSpeedManager();
        this.timeToStepsDivider = nature.getTimeToStepsDivider();
        this.minSteps = nature.getMinSteps();
        this.effectFadeSteps = nature.getEffectFadeSteps();
        this.reactionTimeBaseMs = nature.getReactionTimeBaseMs();
        this.reactionTimeVariationMs = nature.getReactionTimeVariationMs();
        this.overshootManager = nature.getOvershootManager();
    }
    /**
     * Blocking call, starts to move the cursor to the specified location from where it currently is.
     *
     * @throws InterruptedException when interrupted
     */
    public void move() throws InterruptedException {
        move((x, y) ->
        {
        });
    }
    /**
     * Blocking call, starts to move the cursor to the specified location from where it currently is.
     *
     * @param observer Provide observer if you are interested receiving the location of mouse on every step
     * @throws InterruptedException when interrupted
     */
    public void move(MouseMotionObserver observer) throws InterruptedException {
        updateMouseInfo();
        MovementFactory movementFactory = new MovementFactory(xDest, yDest, speedManager, overshootManager, screenSize);
        ArrayDeque<MouseMovement> movements = movementFactory.createMovements(mousePosition);
        int overshoots = movements.size() - 1;
        while (mousePosition.x != xDest || mousePosition.y != yDest) {
            if (movements.isEmpty()) {
                // This shouldn't usually happen, but it's possible that somehow we won't end up on the target,
                // Then just re-attempt from mouse new position. (There are known JDK bugs, that can cause sending the cursor
                // to wrong pixel)
                updateMouseInfo();
                movements = movementFactory.createMovements(mousePosition);
            }
            MouseMovement movement = movements.removeFirst();
            double distance = movement.distance;
            long mouseMovementMs = movement.time;
            Flow flow = movement.flow;
            double xDistance = movement.xDistance;
            double yDistance = movement.yDistance;
      /* Number of steps is calculated from the movement time and limited by minimal amount of steps
         (should have at least MIN_STEPS) and distance (shouldn't have more steps than pixels travelled) */
            int steps = (int) Math.ceil(Math.min(distance, Math.max(mouseMovementMs / timeToStepsDivider, minSteps)));
            long startTime = systemCalls.currentTimeMillis();
            long stepTime = (long) (mouseMovementMs / (double) steps);
            updateMouseInfo();
            double simulatedMouseX = mousePosition.x;
            double simulatedMouseY = mousePosition.y;
            double deviationMultiplierX = (random.nextDouble() - 0.5) * 2;
            double deviationMultiplierY = (random.nextDouble() - 0.5) * 2;
            double completedXDistance = 0;
            double completedYDistance = 0;
            double noiseX = 0;
            double noiseY = 0;
            for (int i = 0; i < steps; i++) {
                // All steps take equal amount of time. This is a value from 0...1 describing how far along the process is.
                double timeCompletion = i / (double) steps;
                double effectFadeStep = Math.max(i - (steps - effectFadeSteps) + 1, 0);
                // value from 0 to 1, when effectFadeSteps remaining steps, starts to decrease to 0 linearly
                // This is here so noise and deviation wouldn't add offset to mouse final position, when we need accuracy.
                double effectFadeMultiplier = (effectFadeSteps - effectFadeStep) / effectFadeSteps;
                double xStepSize = flow.getStepSize(xDistance, steps, timeCompletion);
                double yStepSize = flow.getStepSize(yDistance, steps, timeCompletion);
                completedXDistance += xStepSize;
                completedYDistance += yStepSize;
                double completedDistance = Math.hypot(completedXDistance, completedYDistance);
                double completion = Math.min(1, completedDistance / distance);
                DoublePoint noise = noiseProvider.getNoise(random, xStepSize, yStepSize);
                DoublePoint deviation = deviationProvider.getDeviation(distance, completion);
                noiseX += noise.getX();
                noiseY += noise.getY();
                simulatedMouseX += xStepSize;
                simulatedMouseY += yStepSize;
                long endTime = startTime + stepTime * (i + 1);
                int mousePosX = MathUtil.roundTowards(simulatedMouseX + deviation.getX() * deviationMultiplierX * effectFadeMultiplier + noiseX * effectFadeMultiplier, movement.destX);
                int mousePosY = MathUtil.roundTowards(simulatedMouseY + deviation.getY() * deviationMultiplierY * effectFadeMultiplier + noiseY * effectFadeMultiplier, movement.destY);
                mousePosX = limitByScreenWidth(mousePosX);
                mousePosY = limitByScreenHeight(mousePosY);
                systemCalls.setMousePosition(mousePosX, mousePosY);
                // Allow other action to take place or just observe, we'll later compensate by sleeping less.
                observer.observe(mousePosX, mousePosY);
                long timeLeft = endTime - systemCalls.currentTimeMillis();
                sleepAround(Math.max(timeLeft, 0), 0);
            }
            updateMouseInfo();
            if (mousePosition.x != movement.destX || mousePosition.y != movement.destY) {
                // It's possible that mouse is manually moved or for some other reason.
                // Let's start next step from pre-calculated location to prevent errors from accumulating.
                // But print warning as this is not expected behavior.
                systemCalls.setMousePosition(movement.destX, movement.destY);
                // Let's wait a bit before getting mouse info.
                sleepAround(SLEEP_AFTER_ADJUSTMENT_MS, 0);
                updateMouseInfo();
            }
            if (mousePosition.x != xDest || mousePosition.y != yDest) {
                // We are dealing with overshoot, let's sleep a bit to simulate human reaction time.
                sleepAround(reactionTimeBaseMs, reactionTimeVariationMs);
            }
        }
    }
    private int limitByScreenWidth(int value) {
        return Math.max(0, Math.min(screenSize.width - 1, value));
    }
    private int limitByScreenHeight(int value) {
        return Math.max(0, Math.min(screenSize.height - 1, value));
    }
    private void sleepAround(long sleepMin, long randomPart) {
        long sleepTime = (long) (sleepMin + random.nextDouble() * randomPart);
        if (log.isTraceEnabled() && sleepTime > 0) {
            updateMouseInfo();
        }
        systemCalls.sleep(sleepTime);
    }
    private void updateMouseInfo() {
        mousePosition = mouseInfo.getMousePosition();
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/api/MouseMotionFactory.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.api;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support.DefaultMouseMotionNature;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support.MouseMotionNature;
import java.util.Random;
/**
 * This class should be used for creating new MouseMotion-s
 * The default instance is available via getDefault(), but can create new instance via constructor.
 */
public class MouseMotionFactory {
    private static final MouseMotionFactory defaultFactory = new MouseMotionFactory();
    private MouseMotionNature nature;
    private Random random = new Random();
    public MouseMotionFactory(MouseMotionNature nature) {
        this.nature = nature;
    }
    public MouseMotionFactory() {
        this(new DefaultMouseMotionNature());
    }
    /**
     * Get the default factory implementation.
     *
     * @return the factory
     */
    public static MouseMotionFactory getDefault() {
        return defaultFactory;
    }
    /**
     * Builds the MouseMotion, which can be executed instantly or saved for later.
     *
     * @param xDest the end position x-coordinate for the mouse
     * @param yDest the end position y-coordinate for the mouse
     * @return the MouseMotion which can be executed instantly or saved for later. (Mouse will be moved from its
     * current position, not from the position where mouse was during building.)
     */
    public MouseMotion build(int xDest, int yDest) {
        return new MouseMotion(nature, random, xDest, yDest);
    }
    /**
     * Start moving the mouse to specified location. Blocks until done.
     *
     * @param xDest the end position x-coordinate for the mouse
     * @param yDest the end position y-coordinate for the mouse
     * @throws InterruptedException if something interrupts the thread.
     */
    public void move(int xDest, int yDest) throws InterruptedException {
        build(xDest, yDest).move();
    }
    /**
     * see {@link MouseMotionNature#getSystemCalls()}
     *
     * @return the systemcalls
     */
    public SystemCalls getSystemCalls() {
        return nature.getSystemCalls();
    }
    /**
     * see {@link MouseMotionNature#setSystemCalls(SystemCalls)}
     *
     * @param systemCalls the systemcalls
     */
    public void setSystemCalls(SystemCalls systemCalls) {
        nature.setSystemCalls(systemCalls);
    }
    /**
     * see {@link MouseMotionNature#getDeviationProvider()}
     *
     * @return the deviation provider
     */
    public DeviationProvider getDeviationProvider() {
        return nature.getDeviationProvider();
    }
    /**
     * see {@link MouseMotionNature#setDeviationProvider(DeviationProvider)}
     *
     * @param deviationProvider the deviation provider
     */
    public void setDeviationProvider(DeviationProvider deviationProvider) {
        nature.setDeviationProvider(deviationProvider);
    }
    /**
     * see {@link MouseMotionNature#getNoiseProvider()}
     *
     * @return the noise provider
     */
    public NoiseProvider getNoiseProvider() {
        return nature.getNoiseProvider();
    }
    /**
     * see {@link MouseMotionNature#setNoiseProvider(NoiseProvider)}}
     *
     * @param noiseProvider the noise provider
     */
    public void setNoiseProvider(NoiseProvider noiseProvider) {
        nature.setNoiseProvider(noiseProvider);
    }
    /**
     * Get the random used whenever randomized behavior is needed in MouseMotion
     *
     * @return the random
     */
    public Random getRandom() {
        return random;
    }
    /**
     * Set the random used whenever randomized behavior is needed in MouseMotion
     *
     * @param random the random
     */
    public void setRandom(Random random) {
        this.random = random;
    }
    /**
     * see {@link MouseMotionNature#getMouseInfo()}
     *
     * @return the mouseInfo
     */
    public MouseInfoAccessor getMouseInfo() {
        return nature.getMouseInfo();
    }
    /**
     * see {@link MouseMotionNature#setMouseInfo(MouseInfoAccessor)}
     *
     * @param mouseInfo the mouseInfo
     */
    public void setMouseInfo(MouseInfoAccessor mouseInfo) {
        nature.setMouseInfo(mouseInfo);
    }
    /**
     * see {@link MouseMotionNature#getSpeedManager()}
     *
     * @return the manager
     */
    public SpeedManager getSpeedManager() {
        return nature.getSpeedManager();
    }
    /**
     * see {@link MouseMotionNature#setSpeedManager(SpeedManager)}
     *
     * @param speedManager the manager
     */
    public void setSpeedManager(SpeedManager speedManager) {
        nature.setSpeedManager(speedManager);
    }
    /**
     * The Nature of mousemotion covers all aspects how the mouse is moved.
     *
     * @return the nature
     */
    public MouseMotionNature getNature() {
        return nature;
    }
    /**
     * The Nature of mousemotion covers all aspects how the mouse is moved.
     *
     * @param nature the new nature
     */
    public void setNature(MouseMotionNature nature) {
        this.nature = nature;
    }
    /**
     * see {@link MouseMotionNature#getOvershootManager()}
     *
     * @return the manager
     */
    public OvershootManager getOvershootManager() {
        return nature.getOvershootManager();
    }
    /**
     * see {@link MouseMotionNature#setOvershootManager(OvershootManager)}
     *
     * @param manager the manager
     */
    public void setOvershootManager(OvershootManager manager) {
        nature.setOvershootManager(manager);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/api/MouseMotionObserver.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.api;
/**
 * Use to observe mouse movement in MouseMotion
 */
public interface MouseMotionObserver {
    void observe(int xPos, int yPos);
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/api/NoiseProvider.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.api;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support.DoublePoint;
import java.util.Random;
/**
 * Provides noise or mistakes in the mouse movement
 * <p>
 * NoiseProvider implementation should be immutable.
 */
public interface NoiseProvider {
    /**
     * Noise is offset from the original trajectory, simulating user and physical errors on mouse movement.
     * <p>
     * Noise is accumulating, so on average it should create an equal chance of either positive or negative movement
     * on each axis, otherwise the mouse movement will always be slightly offset to single direction.
     * <p>
     * Deviation from DeviationProvider is different from the Noise
     * because it works like a mathematical function and is not accumulating.
     * <p>
     * Not every step needs to add noise, use randomness to only add noise sometimes, otherwise return Point(0, 0).
     * <p>
     * During the final steps of mouse movement, the effect of noise is gradually reduced, so the mouse
     * would finish on the intended pixel smoothly, thus the implementation of this class can safely ignore
     * and not know the beginning and end of the movement.
     *
     * @param random    use this to generate randomness in the offset
     * @param xStepSize the step size that is taken horizontally
     * @param yStepSize the step size that is taken vertically
     * @return a point which describes how much the mouse offset is increased or decreased this step.
     * This value must not include the parameters xStepSize and yStepSize. For no change in noise just return (0,0).
     * @see DeviationProvider
     */
    DoublePoint getNoise(Random random, double xStepSize, double yStepSize);
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/api/OvershootManager.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.api;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support.Flow;
import java.awt.*;
/**
 * Overshoots provide a realistic way to simulate user trying to reach the destination with mouse, but miss.
 * Points around the destination are produced which will be hit before the mouse hits the real destination.
 * If overshoot happens to match the target, then overshooting is cancelled and real destination will be reached.
 */
public interface OvershootManager {
    /**
     * Get the maximum amount of overshoots the cursor does before reaching its final destination.
     *
     * @param flow            the flow which is planned to be used to reach the target.
     *                        (If returned overshoots &gt; 0, then a new flow will be calculated for each overshoot.).
     *                        This flow could be analyzed if overshooting is suitable. It is not available
     *                        as a parameter in overshootAmount calculation, because flow itself is calculated
     *                        from the movement distance, which is dependent on the overshoot amount.
     * @param mouseMovementMs the planned time for reaching the real target
     * @param distance        the distance between mouse position and real target
     * @return the number of maximum overshoots used or 0 if no overshoots
     */
    int getOvershoots(Flow flow, long mouseMovementMs, double distance);
    /**
     * Returns the overshoot amount which will be added to real target, thus getting the overshoot target.
     *
     * @param distanceToRealTargetX distance to real target X-coordinate
     * @param distanceToRealTargetY distance to real target Y-coordinate
     * @param mouseMovementMs       the time planned for reaching the real target
     * @param overshootsRemaining   the amount of overshoots remaining, current included.
     *                              Values from (n to 1), where n &gt;= 1
     * @return the amount which will be added to real target, thus getting the overshoot target.
     */
    Point getOvershootAmount(double distanceToRealTargetX, double distanceToRealTargetY, long mouseMovementMs, int overshootsRemaining);
    /**
     * Once the mouse reaches the overshoot target, new trajectory with new speed is calculated for next target
     * (can be real or overshoot target, if the next target is real target, the overshootsRemaining value is 0)
     *
     * @param mouseMovementMs     the last mouse movement in ms
     * @param overshootsRemaining the amount of overshoots remaining, including this.
     *                            Values from (n to 0), where n &gt;= 0
     * @return the next mouse movement time in ms
     */
    long deriveNextMouseMovementTimeMs(long mouseMovementMs, int overshootsRemaining);
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/api/SpeedManager.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.api;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support.Flow;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.util.Pair;
/**
 * SpeedManager controls how long does it take to complete a mouse movement and within that
 * time how slow or fast the cursor is moving at a particular moment, the flow.
 * Flow controls how jagged or smooth, accelerating or decelerating, the movement is.
 */
public interface SpeedManager {
    /**
     * Get the SpeedFlow object, which contains Flow and planned time for mouse movement in ms.
     *
     * @param distance the distance from where the cursor is now to the destination point   *
     * @return the SpeedFlow object, which details are a SpeedManager implementation decision.
     */
    Pair<Flow, Long> getFlowWithTime(double distance);
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/api/SystemCalls.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.api;
import java.awt.*;
/**
 * Abstracts ordinary static System calls away
 */
public interface SystemCalls {
    long currentTimeMillis();
    void sleep(long time);
    Dimension getScreenSize();
    void setMousePosition(int x, int y);
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/support/mousemotion/MouseMovement.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support.mousemotion;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support.Flow;
public class MouseMovement {
    public final int destX;
    public final int destY;
    public final double distance;
    public final int xDistance;
    public final int yDistance;
    public final long time;
    public final Flow flow;
    public MouseMovement(int destX, int destY, double distance, int xDistance, int yDistance, long time, Flow flow) {
        this.destX = destX;
        this.destY = destY;
        this.distance = distance;
        this.xDistance = xDistance;
        this.yDistance = yDistance;
        this.time = time;
        this.flow = flow;
    }
    @Override
    public String toString() {
        return "Movement{" +
                "destX=" + destX +
                ", destY=" + destY +
                ", xDistance=" + xDistance +
                ", yDistance=" + yDistance +
                ", time=" + time +
                '}';
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/support/mousemotion/MovementFactory.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support.mousemotion;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.api.OvershootManager;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.api.SpeedManager;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support.Flow;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.util.Pair;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.awt.*;
import java.util.ArrayDeque;
import java.util.Iterator;
public class MovementFactory {
    private static final Logger log = LoggerFactory.getLogger(MovementFactory.class);
    private final int xDest;
    private final int yDest;
    private final SpeedManager speedManager;
    private final OvershootManager overshootManager;
    private final Dimension screenSize;
    public MovementFactory(int xDest, int yDest, SpeedManager speedManager,
                           OvershootManager overshootManager, Dimension screenSize) {
        this.xDest = xDest;
        this.yDest = yDest;
        this.speedManager = speedManager;
        this.overshootManager = overshootManager;
        this.screenSize = screenSize;
    }
    public ArrayDeque<MouseMovement> createMovements(Point currentMousePosition) {
        ArrayDeque<MouseMovement> movements = new ArrayDeque<>();
        int lastMousePositionX = currentMousePosition.x;
        int lastMousePositionY = currentMousePosition.y;
        int xDistance = xDest - lastMousePositionX;
        int yDistance = yDest - lastMousePositionY;
        double initialDistance = Math.hypot(xDistance, yDistance);
        Pair<Flow, Long> flowTime = speedManager.getFlowWithTime(initialDistance);
        Flow flow = flowTime.x;
        long mouseMovementMs = flowTime.y;
        int overshoots = overshootManager.getOvershoots(flow, mouseMovementMs, initialDistance);
        if (overshoots == 0) {
            movements.add(new MouseMovement(xDest, yDest, initialDistance, xDistance, yDistance, mouseMovementMs, flow));
            return movements;
        }
        for (int i = overshoots; i > 0; i--) {
            Point overshoot = overshootManager.getOvershootAmount(
                    xDest - lastMousePositionX, yDest - lastMousePositionY, mouseMovementMs, i
            );
            int currentDestinationX = limitByScreenWidth(xDest + overshoot.x);
            int currentDestinationY = limitByScreenHeight(yDest + overshoot.y);
            xDistance = currentDestinationX - lastMousePositionX;
            yDistance = currentDestinationY - lastMousePositionY;
            double distance = Math.hypot(xDistance, yDistance);
            flow = speedManager.getFlowWithTime(distance).x;
            movements.add(
                    new MouseMovement(currentDestinationX, currentDestinationY, distance, xDistance, yDistance, mouseMovementMs, flow)
            );
            lastMousePositionX = currentDestinationX;
            lastMousePositionY = currentDestinationY;
            // Apply for the next overshoot if exists.
            mouseMovementMs = overshootManager.deriveNextMouseMovementTimeMs(mouseMovementMs, i - 1);
        }
        Iterator<MouseMovement> it = movements.descendingIterator();
        boolean remove = true;
        // Remove overshoots from the end, which are matching the final destination, but keep those in middle of motion.
        while (it.hasNext() && remove) {
            MouseMovement movement = it.next();
            if (movement.destX == xDest && movement.destY == yDest) {
                lastMousePositionX = movement.destX - movement.xDistance;
                lastMousePositionY = movement.destY - movement.yDistance;
                it.remove();
            } else {
                remove = false;
            }
        }
        xDistance = xDest - lastMousePositionX;
        yDistance = yDest - lastMousePositionY;
        double distance = Math.hypot(xDistance, yDistance);
        Pair<Flow, Long> movementToTargetFlowTime = speedManager.getFlowWithTime(distance);
        long finalMovementTime = overshootManager.deriveNextMouseMovementTimeMs(movementToTargetFlowTime.y, 0);
        MouseMovement finalMove = new MouseMovement(
                xDest, yDest, distance, xDistance, yDistance, finalMovementTime, movementToTargetFlowTime.x
        );
        movements.add(finalMove);
        return movements;
    }
    private int limitByScreenWidth(int value) {
        return Math.max(0, Math.min(screenSize.width - 1, value));
    }
    private int limitByScreenHeight(int value) {
        return Math.max(0, Math.min(screenSize.height - 1, value));
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/support/DefaultMouseInfoAccessor.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.api.MouseInfoAccessor;
import java.awt.*;
public class DefaultMouseInfoAccessor implements MouseInfoAccessor {
    @Override
    public Point getMousePosition() {
        return MouseInfo.getPointerInfo().getLocation();
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/support/DefaultMouseMotionNature.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support;
import java.awt.*;
import java.util.Random;
import static net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support.DefaultNoiseProvider.DEFAULT_NOISINESS_DIVIDER;
import static net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support.SinusoidalDeviationProvider.DEFAULT_SLOPE_DIVIDER;
public class DefaultMouseMotionNature extends MouseMotionNature {
    public static final int TIME_TO_STEPS_DIVIDER = 8;
    public static final int MIN_STEPS = 10;
    public static final int EFFECT_FADE_STEPS = 15;
    public static final int REACTION_TIME_BASE_MS = 20;
    public static final int REACTION_TIME_VARIATION_MS = 120;
    public DefaultMouseMotionNature() {
        try {
            setSystemCalls(new DefaultSystemCalls(new Robot()));
        } catch (AWTException e) {
            throw new RuntimeException(e);
        }
        setDeviationProvider(new SinusoidalDeviationProvider(DEFAULT_SLOPE_DIVIDER));
        setNoiseProvider(new DefaultNoiseProvider(DEFAULT_NOISINESS_DIVIDER));
        setSpeedManager(new DefaultSpeedManager());
        setOvershootManager(new DefaultOvershootManager(new Random()));
        setEffectFadeSteps(EFFECT_FADE_STEPS);
        setMinSteps(MIN_STEPS);
        setMouseInfo(new DefaultMouseInfoAccessor());
        setReactionTimeBaseMs(REACTION_TIME_BASE_MS);
        setReactionTimeVariationMs(REACTION_TIME_VARIATION_MS);
        setTimeToStepsDivider(TIME_TO_STEPS_DIVIDER);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/support/DefaultNoiseProvider.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.api.NoiseProvider;
import java.util.Random;
public class DefaultNoiseProvider implements NoiseProvider {
    public static final double DEFAULT_NOISINESS_DIVIDER = 2;
    private static final double SMALL_DELTA = 10e-6;
    private final double noisinessDivider;
    /**
     * @param noisinessDivider bigger value means less noise.
     */
    public DefaultNoiseProvider(double noisinessDivider) {
        this.noisinessDivider = noisinessDivider;
    }
    @Override
    public DoublePoint getNoise(Random random, double xStepSize, double yStepSize) {
        if (Math.abs(xStepSize - 0) < SMALL_DELTA && Math.abs(yStepSize - 0) < SMALL_DELTA) {
            return DoublePoint.ZERO;
        }
        double noiseX = 0;
        double noiseY = 0;
        double stepSize = Math.hypot(xStepSize, yStepSize);
        double noisiness = Math.max(0, (8 - stepSize)) / 50;
        if (random.nextDouble() < noisiness) {
            noiseX = (random.nextDouble() - 0.5) * Math.max(0, (8 - stepSize)) / noisinessDivider;
            noiseY = (random.nextDouble() - 0.5) * Math.max(0, (8 - stepSize)) / noisinessDivider;
        }
        return new DoublePoint(noiseX, noiseY);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/support/DefaultOvershootManager.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.api.OvershootManager;
import java.awt.*;
import java.util.Random;
public class DefaultOvershootManager implements OvershootManager {
    public static final double OVERSHOOT_SPEEDUP_DIVIDER = 1.8;
    public static final int MIN_OVERSHOOT_MOVEMENT_MS = 40;
    public static final int OVERSHOOT_RANDOM_MODIFIER_DIVIDER = 20;
    public static final int MIN_DISTANCE_FOR_OVERSHOOTS = 10;
    public static final int DEFAULT_OVERSHOOT_AMOUNT = 3;
    private final Random random;
    private long minOvershootMovementMs = MIN_OVERSHOOT_MOVEMENT_MS;
    private long minDistanceForOvershoots = MIN_DISTANCE_FOR_OVERSHOOTS;
    private double overshootRandomModifierDivider = OVERSHOOT_RANDOM_MODIFIER_DIVIDER;
    private double overshootSpeedupDivider = OVERSHOOT_SPEEDUP_DIVIDER;
    private int overshoots = DEFAULT_OVERSHOOT_AMOUNT;
    public DefaultOvershootManager(Random random) {
        this.random = random;
    }
    @Override
    public int getOvershoots(Flow flow, long mouseMovementMs, double distance) {
        if (distance < minDistanceForOvershoots) {
            return 0;
        }
        return overshoots;
    }
    @Override
    public Point getOvershootAmount(double distanceToRealTargetX, double distanceToRealTargetY, long mouseMovementMs, int overshootsRemaining) {
        double distanceToRealTarget = Math.hypot(distanceToRealTargetX, distanceToRealTargetY);
        double randomModifier = distanceToRealTarget / overshootRandomModifierDivider;
        //double speedPixelsPerSecond = distanceToRealTarget / mouseMovementMs * 1000; // TODO utilize speed
        int x = (int) (random.nextDouble() * randomModifier - randomModifier / 2d) * overshootsRemaining;
        int y = (int) (random.nextDouble() * randomModifier - randomModifier / 2d) * overshootsRemaining;
        return new Point(x, y);
    }
    @Override
    public long deriveNextMouseMovementTimeMs(long mouseMovementMs, int overshootsRemaining) {
        return Math.max((long) (mouseMovementMs / overshootSpeedupDivider), minOvershootMovementMs);
    }
    public long getMinOvershootMovementMs() {
        return minOvershootMovementMs;
    }
    public void setMinOvershootMovementMs(long minOvershootMovementMs) {
        this.minOvershootMovementMs = minOvershootMovementMs;
    }
    public double getOvershootRandomModifierDivider() {
        return overshootRandomModifierDivider;
    }
    public void setOvershootRandomModifierDivider(double overshootRandomModifierDivider) {
        this.overshootRandomModifierDivider = overshootRandomModifierDivider;
    }
    public double getOvershootSpeedupDivider() {
        return overshootSpeedupDivider;
    }
    public void setOvershootSpeedupDivider(double overshootSpeedupDivider) {
        this.overshootSpeedupDivider = overshootSpeedupDivider;
    }
    public int getOvershoots() {
        return overshoots;
    }
    public void setOvershoots(int overshoots) {
        this.overshoots = overshoots;
    }
    public long getMinDistanceForOvershoots() {
        return minDistanceForOvershoots;
    }
    public void setMinDistanceForOvershoots(long minDistanceForOvershoots) {
        this.minDistanceForOvershoots = minDistanceForOvershoots;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/support/DefaultSpeedManager.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.api.SpeedManager;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.util.FlowTemplates;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.util.Pair;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
public class DefaultSpeedManager implements SpeedManager {
    private static final double SMALL_DELTA = 10e-6;
    private final List<Flow> flows = new ArrayList<>();
    private long mouseMovementTimeMs = 500;
    public DefaultSpeedManager(Collection<Flow> flows) {
        this.flows.addAll(flows);
    }
    public DefaultSpeedManager() {
        this(Arrays.asList(
                new Flow(FlowTemplates.constantSpeed()),
                new Flow(FlowTemplates.variatingFlow()),
                new Flow(FlowTemplates.interruptedFlow()),
                new Flow(FlowTemplates.interruptedFlow2()),
                new Flow(FlowTemplates.slowStartupFlow()),
                new Flow(FlowTemplates.slowStartup2Flow()),
                new Flow(FlowTemplates.adjustingFlow()),
                new Flow(FlowTemplates.jaggedFlow()),
                new Flow(FlowTemplates.stoppingFlow())
        ));
    }
    @Override
    public Pair<Flow, Long> getFlowWithTime(double distance) {
        double time = mouseMovementTimeMs + (long) (Math.random() * mouseMovementTimeMs);
        Flow flow = flows.get((int) (Math.random() * flows.size()));
        // Let's ignore waiting time, e.g 0's in flow, by increasing the total time
        // by the amount of 0's there are in the flow multiplied by the time each bucket represents.
        double timePerBucket = time / (double) flow.getFlowCharacteristics().length;
        for (double bucket : flow.getFlowCharacteristics()) {
            if (Math.abs(bucket - 0) < SMALL_DELTA) {
                time += timePerBucket;
            }
        }
        return new Pair<>(flow, (long) time);
    }
    public void setMouseMovementBaseTimeMs(long mouseMovementSpeedMs) {
        this.mouseMovementTimeMs = mouseMovementSpeedMs;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/support/DefaultSystemCalls.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support;
import net.runelite.client.plugins.microbot.util.Global;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.api.SystemCalls;
import java.awt.*;
public class DefaultSystemCalls implements SystemCalls {
    private final Robot robot;
    public DefaultSystemCalls(Robot robot) {
        this.robot = robot;
    }
    @Override
    public long currentTimeMillis() {
        return System.currentTimeMillis();
    }
    @Override
    public void sleep(long time) {
        Global.sleep((int) time);
    }
    @Override
    public Dimension getScreenSize() {
        return Toolkit.getDefaultToolkit().getScreenSize();
    }
    /**
     * <p>Moves the mouse to specified pixel using the provided Robot.</p>
     *
     * <p>It seems there is a certain delay, measurable in less than milliseconds,
     * before the mouse actually ends up on the requested pixel when using a Robot class.
     * this usually isn't a problem, but when we ask the mouse position right after this call,
     * there's extremely low but real chance we get wrong information back. I didn't add sleep
     * here as it would cause overhead to sleep always, even when we don't instantly use
     * the mouse position, but just acknowledged the issue with this warning.
     * (Use fast unrestricted loop of Robot movement and checking the position after every move to invoke the issue.)</p>
     *
     * @param x the x-coordinate
     * @param y the y-coordinate
     */
    @Override
    public void setMousePosition(int x, int y) {
        robot.mouseMove(x, y);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/support/DoublePoint.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support;
public class DoublePoint {
    public final static DoublePoint ZERO = new DoublePoint(0, 0);
    private final double x;
    private final double y;
    public DoublePoint(double x, double y) {
        this.x = x;
        this.y = y;
    }
    public double getX() {
        return x;
    }
    public double getY() {
        return y;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/support/Flow.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support;
/**
 * Flow for the mouse movement
 * Flow defines how slow or fast the cursor is moving at a particular moment, defining the characteristics
 * of movement itself not the trajectory, but how jagged or smooth, accelerating or decelerating, the movement is.
 */
public class Flow {
    private static final int AVERAGE_BUCKET_VALUE = 100;
    private final double[] buckets;
    /**
     * @param characteristics the characteristics array, which can be any size, contain non-negative numbers.
     *                        The values in the array are translated to flow and all values are relative. For example an
     *                        array of [1,2,3,4] has the same meaning as [100, 200, 300, 400] or [10, 10, 20, 20, 30, 30, 40, 40]
     *                        Every array element describes a time of the movement, so that in array of n-elements every element is
     *                        describing (100 / n)% of the movement. In an array of [1,2,3,4] every element is responsible for
     *                        25% of time and the movement is accelerating - in the last 25% of time the mouse cursor is 4 times faster
     *                        than it was in the first 25% of the time.
     */
    public Flow(double[] characteristics) {
        buckets = normalizeBuckets(characteristics);
    }
    /**
     * Normalizes the characteristics to have an average of AVERAGE_BUCKET_VALUE
     *
     * @param flowCharacteristics an array of values which describe how the mouse should move at each moment
     * @return the normalized bucket array
     */
    private double[] normalizeBuckets(double[] flowCharacteristics) {
        double[] buckets = new double[flowCharacteristics.length];
        long sum = 0;
        for (int i = 0; i < flowCharacteristics.length; i++) {
            if (flowCharacteristics[i] < 0) {
                throw new IllegalArgumentException("Invalid FlowCharacteristics at [" + i + "] : " + flowCharacteristics[i]);
            }
            sum += flowCharacteristics[i];
        }
        if (sum == 0) {
            throw new IllegalArgumentException("Invalid FlowCharacteristics. All array elements can't be 0.");
        }
        /*
         * By multiplying AVERAGE_BUCKET_VALUE to buckets.length we get a required fill for the buckets,
         * For example if there are 5 buckets then 100 * 5 gives us 500, which is how much the buckets should
         * contain on total ideally. Then we divide it by the sum which we got from adding all contents of characteristics
         * array together. The resulting value describes the FlowCharacteristics array and how much is missing or
         * overfilled in it. for example when we get 0.5, then we know it contains twice as much as our normalized
         * buckets array should have and we multiply all characteristics values by 0.5, this preserves the
         * characteristics, but reduces the values to levels our algorithm knows how to work with.
         */
        double multiplier = (double) AVERAGE_BUCKET_VALUE * buckets.length / sum;
        for (int i = 0; i < flowCharacteristics.length; i++) {
            buckets[i] = flowCharacteristics[i] * multiplier;
        }
        return buckets;
    }
    public double[] getFlowCharacteristics() {
        return buckets;
    }
    /**
     * This returns step size for a single axis.
     *
     * @param distance   the total distance current movement has on current axis from beginning to target in pixels
     * @param steps      number of steps the current movement involves
     * @param completion value between 0 and 1, the value describes movement completion in time
     * @return the step size which should be taken next
     */
    public double getStepSize(double distance, int steps, double completion) {
        // This is essentially how big is a single completion step,
        // so we can expect next 'completion' is current completion + completionStep
        double completionStep = 1d / steps;
        // Define the first bucket we read from
        double bucketFrom = (completion * buckets.length);
        // Define the last bucket we read from
        double bucketUntil = ((completion + completionStep) * buckets.length);
        double bucketContents = getBucketsContents(bucketFrom, bucketUntil);
        // This shows how much distance is assigned to single contents value in the buckets.
        // For example if this gets assigned to 0.4, then for every value in the bucket
        // the cursor needs to travel 0.4 pixels, so for a bucket containing 50, the mouse
        // travelling distance is 0.4 * 50 = 20pixels
        double distancePerBucketContent = distance / (buckets.length * AVERAGE_BUCKET_VALUE);
        return bucketContents * distancePerBucketContent;
    }
    /**
     * Summarizes the bucket contents from bucketFrom to bucketUntil, where
     * provided parameters may have decimal places. In that case the value
     * from first or last bucket is just a fragment of it's full value, depending how
     * large portion the decimal place contains. For example getBucketContents(0.6, 2.4)
     * returns 0.4 * bucket[0] + 1 * bucket[1] + 0.4 * bucket[2]
     *
     * @param bucketFrom  bucket from where to start reading
     * @param bucketUntil bucket where to read
     * @return the sum of the contents in the buckets
     */
    private double getBucketsContents(double bucketFrom, double bucketUntil) {
        double sum = 0;
        for (int i = (int) bucketFrom; i < bucketUntil; i++) {
            double value = buckets[i];
            double endMultiplier = 1;
            double startMultiplier = 0;
            if (bucketUntil < i + 1) {
                endMultiplier = bucketUntil - (int) bucketUntil;
            }
            if ((int) bucketFrom == i) {
                startMultiplier = bucketFrom - (int) bucketFrom;
            }
            value *= endMultiplier - startMultiplier;
            sum += value;
        }
        return sum;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/support/MouseMotionNature.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.api.*;
public class MouseMotionNature {
    private double timeToStepsDivider;
    private int minSteps;
    private int effectFadeSteps;
    private int reactionTimeBaseMs;
    private int reactionTimeVariationMs;
    private DeviationProvider deviationProvider;
    private NoiseProvider noiseProvider;
    private OvershootManager overshootManager;
    private MouseInfoAccessor mouseInfo;
    private SystemCalls systemCalls;
    private SpeedManager speedManager;
    /**
     * Time to steps is how NaturalMouseMotion calculates how many locations need to be visited between
     * start and end point. More steps means more smooth movement. Thus increasing this divider means less
     * steps and decreasing means more steps.
     *
     * @return the divider which is used to get amount of steps from the planned movement time
     */
    public double getTimeToStepsDivider() {
        return timeToStepsDivider;
    }
    /**
     * Time to steps is how NaturalMouseMotion calculates how many locations need to be visited between
     * start and end point. More steps means more smooth movement. Thus increasing this divider means less
     * steps and decreasing means more steps. The default value should be as smooth as needed for any real
     * purpose. So unless this really is the issue, you shouldn't touch this value.
     *
     * @param timeToStepsDivider the divider which is used to get amount of steps from the planned movement time
     */
    public void setTimeToStepsDivider(double timeToStepsDivider) {
        this.timeToStepsDivider = timeToStepsDivider;
    }
    /**
     * Minimum amount of steps that is taken to reach the target, this is used when calculation otherwise would
     * lead to too few steps for smooth mouse movement, which can happen for very fast movements.
     *
     * @return the minimal amount of steps used.
     */
    public int getMinSteps() {
        return minSteps;
    }
    /**
     * Minimum amount of steps that is taken to reach the target, this is used when calculation otherwise would
     * lead to too few steps for smooth mouse movement, which can happen for very fast movements.
     * The default value should cover your needs, usually no need to touch this.
     *
     * @param minSteps the minimal amount of steps used
     */
    public void setMinSteps(int minSteps) {
        this.minSteps = minSteps;
    }
    /**
     * Effect fade decreases the noise and deviation effects linearly to 0 at the end of the mouse movement,
     * so mouse would end up in the intended target pixel even when noise or deviation would otherwise
     * add offset to mouse position.
     *
     * @return the number of steps before last the effect starts to fade
     */
    public int getEffectFadeSteps() {
        return effectFadeSteps;
    }
    /**
     * Effect fade decreases the noise and deviation effects linearly to 0 at the end of the mouse movement,
     * so mouse would end up in the intended target pixel even when noise or deviation would otherwise
     * add offset to mouse position.
     *
     * @param effectFadeSteps the number of steps before last the effect starts to fade
     */
    public void setEffectFadeSteps(int effectFadeSteps) {
        this.effectFadeSteps = effectFadeSteps;
    }
    /**
     * Get the minimal sleep time when overshoot or some other feature has caused mouse to miss the original target
     * to prepare for next attempt to move the mouse to target.
     *
     * @return the sleep time
     */
    public int getReactionTimeBaseMs() {
        return reactionTimeBaseMs;
    }
    /**
     * Set the minimal sleep time when overshoot or some other feature has caused mouse to miss the original target
     * to prepare for next attempt to move the mouse to target.
     *
     * @param reactionTimeBaseMs the sleep time
     */
    public void setReactionTimeBaseMs(int reactionTimeBaseMs) {
        this.reactionTimeBaseMs = reactionTimeBaseMs;
    }
    /**
     * Get the random sleep time when overshoot or some other feature has caused mouse to miss the original target
     * to prepare for next attempt to move the mouse to target. Random part of this is added to the reactionTimeBaseMs.
     *
     * @return reactionTimeVariationMs the sleep time
     */
    public int getReactionTimeVariationMs() {
        return reactionTimeVariationMs;
    }
    /**
     * Set the random sleep time when overshoot or some other feature has caused mouse to miss the original target
     * to prepare for next attempt to move the mouse to target. Random part of this is added to the reactionTimeBaseMs.
     *
     * @param reactionTimeVariationMs the sleep time
     */
    public void setReactionTimeVariationMs(int reactionTimeVariationMs) {
        this.reactionTimeVariationMs = reactionTimeVariationMs;
    }
    /**
     * Get the provider which is used to define how the MouseMotion trajectory is being deviated or arced
     *
     * @return the provider
     */
    public DeviationProvider getDeviationProvider() {
        return deviationProvider;
    }
    /**
     * Set the provider which is used to define how the MouseMotion trajectory is being deviated or arced.
     * Alters the underlying nature instance in this factory.
     *
     * @param deviationProvider the provider
     */
    public void setDeviationProvider(DeviationProvider deviationProvider) {
        this.deviationProvider = deviationProvider;
    }
    /**
     * Get the provider which is used to make random mistakes in the trajectory of the moving mouse
     *
     * @return the provider
     */
    public NoiseProvider getNoiseProvider() {
        return noiseProvider;
    }
    /**
     * set the provider which is used to make random mistakes in the trajectory of the moving mouse.
     * Alters the underlying nature instance in this factory.
     *
     * @param noiseProvider the provider
     */
    public void setNoiseProvider(NoiseProvider noiseProvider) {
        this.noiseProvider = noiseProvider;
    }
    /**
     * Get the accessor object, which MouseMotion uses to detect the position of mouse on screen.
     *
     * @return the accessor
     */
    public MouseInfoAccessor getMouseInfo() {
        return mouseInfo;
    }
    /**
     * Set the accessor object, which MouseMotion uses to detect the position of mouse on screen.
     *
     * @param mouseInfo the accessor object
     */
    public void setMouseInfo(MouseInfoAccessor mouseInfo) {
        this.mouseInfo = mouseInfo;
    }
    /**
     * Get a system call interface, which MouseMotion uses internally
     *
     * @return the interface
     */
    public SystemCalls getSystemCalls() {
        return systemCalls;
    }
    /**
     * Set a system call interface, which MouseMotion uses internally.
     *
     * @param systemCalls the interface
     */
    public void setSystemCalls(SystemCalls systemCalls) {
        this.systemCalls = systemCalls;
    }
    /**
     * Get the speed manager. SpeedManager controls how long does it take to complete a movement and within that
     * time how slow or fast the cursor is moving at a particular moment, the flow of movement.
     *
     * @return the SpeedManager
     */
    public SpeedManager getSpeedManager() {
        return speedManager;
    }
    /**
     * Sets the speed manager. SpeedManager controls how long does it take to complete a movement and within that
     * time how slow or fast the cursor is moving at a particular moment, the flow of movement.
     *
     * @param speedManager the SpeedManager
     */
    public void setSpeedManager(SpeedManager speedManager) {
        this.speedManager = speedManager;
    }
    /**
     * Get the manager that deals with overshoot properties.
     * Overshoots provide a realistic way to simulate user trying to reach the destination with mouse, but miss.
     *
     * @return the manager
     */
    public OvershootManager getOvershootManager() {
        return overshootManager;
    }
    /**
     * Set the manager that deals with overshoot properties.
     * Overshoots provide a realistic way to simulate user trying to reach the destination with mouse, but miss.
     *
     * @param overshootManager the manager
     */
    public void setOvershootManager(OvershootManager overshootManager) {
        this.overshootManager = overshootManager;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/support/ScreenAdjustedNature.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.api.MouseInfoAccessor;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.api.SystemCalls;
import java.awt.*;
/**
 * This nature translates mouse coordinates to specified offset and screen dimension.
 * Internally it wraps the SystemCalls and MouseInfoAccessor in proxies which handle the translations.
 */
public class ScreenAdjustedNature extends DefaultMouseMotionNature {
    private final Point offset;
    private final Dimension screenSize;
    public ScreenAdjustedNature(int x, int y, int x2, int y2) {
        this(new Dimension(x2 - x, y2 - y), new Point(x, y));
        if (y2 <= y || x2 <= x) {
            throw new IllegalArgumentException("Invalid range " + x + " " + y + " " + x2 + " " + y2);
        }
    }
    public ScreenAdjustedNature(Dimension screenSize, Point mouseOffset) {
        this.screenSize = screenSize;
        this.offset = mouseOffset;
    }
    @Override
    public void setMouseInfo(MouseInfoAccessor mouseInfo) {
        super.setMouseInfo(new ProxyMouseInfo(mouseInfo));
    }
    @Override
    public void setSystemCalls(SystemCalls systemCalls) {
        super.setSystemCalls(new ProxySystemCalls(systemCalls));
    }
    private class ProxyMouseInfo implements MouseInfoAccessor {
        private final MouseInfoAccessor underlying;
        // This implementation reuses the point.
        private final Point p = new Point();
        public ProxyMouseInfo(MouseInfoAccessor underlying) {
            this.underlying = underlying;
        }
        @Override
        public Point getMousePosition() {
            Point realPointer = underlying.getMousePosition();
            p.setLocation(realPointer.x - offset.x, realPointer.y - offset.y);
            return p;
        }
    }
    private class ProxySystemCalls implements SystemCalls {
        private final SystemCalls underlying;
        public ProxySystemCalls(SystemCalls underlying) {
            this.underlying = underlying;
        }
        @Override
        public long currentTimeMillis() {
            return underlying.currentTimeMillis();
        }
        @Override
        public void sleep(long time) {
            underlying.sleep(time);
        }
        @Override
        public Dimension getScreenSize() {
            return screenSize;
        }
        @Override
        public void setMousePosition(int x, int y) {
            underlying.setMousePosition(x + offset.x, y + offset.y);
        }
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/support/SinusoidalDeviationProvider.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.api.DeviationProvider;
public class SinusoidalDeviationProvider implements DeviationProvider {
    public static final int DEFAULT_SLOPE_DIVIDER = 10;
    private final double slopeDivider;
    public SinusoidalDeviationProvider(double slopeDivider) {
        this.slopeDivider = slopeDivider;
    }
    @Override
    public DoublePoint getDeviation(double totalDistanceInPixels, double completionFraction) {
        double deviationFunctionResult = (1 - Math.cos(completionFraction * Math.PI * 2)) / 2;
        double deviationX = totalDistanceInPixels / slopeDivider;
        double deviationY = totalDistanceInPixels / slopeDivider;
        return new DoublePoint(deviationFunctionResult * deviationX, deviationFunctionResult * deviationY);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/tools/SystemDiagnosis.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.tools;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.api.MouseInfoAccessor;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.api.SystemCalls;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support.DefaultMouseInfoAccessor;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support.DefaultSystemCalls;
import java.awt.*;
public class SystemDiagnosis {
    /**
     * Runs a diagnosis with default configuration, by setting mouse all over your screen and expecting to receive
     * correct coordinates back.
     * If java.awt.Robot cannot be constructed, then new RuntimeException is thrown.
     * If no issues are found, then this method completes without throwing an error, otherwise IllegalStateException is
     * thrown.
     */
    public static void validateMouseMovement() {
        try {
            Robot robot = new Robot();
            validateMouseMovement(new DefaultSystemCalls(robot), new DefaultMouseInfoAccessor());
        } catch (AWTException e) {
            throw new RuntimeException(e);
        }
    }
    /**
     * Runs a diagnosis, by setting mouse all over your screen and expecting to receive correct coordinates back.
     * If no issues are found, then this method completes without throwing an error, otherwise IllegalStateException is
     * thrown.
     *
     * @param system   a SystemCalls class which is used for setting the mouse position
     * @param accessor a MouseInfoAccessor which is used for querying mouse position
     */
    public static void validateMouseMovement(SystemCalls system, MouseInfoAccessor accessor) {
        Dimension dimension = system.getScreenSize();
        for (int y = 0; y < dimension.height; y += 50) {
            for (int x = 0; x < dimension.width; x += 50) {
                system.setMousePosition(x, y);
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                Point p = accessor.getMousePosition();
                if (x != p.x || y != p.y) {
                    throw new IllegalStateException(
                            "Tried to move mouse to (" + x + ", " + y + "). Actually moved to (" + p.x + ", " + p.y + ")" +
                                    "This means NaturalMouseMotion is not able to work optimally on this system as the cursor move " +
                                    "calls may miss the target pixels on the screen."
                    );
                }
            }
        }
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/util/FactoryTemplates.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.util;
import net.runelite.client.plugins.microbot.util.antiban.Rs2Antiban;
import net.runelite.client.plugins.microbot.util.antiban.Rs2AntibanSettings;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.api.MouseMotionFactory;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.api.SpeedManager;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
public class FactoryTemplates {
    /**
     * <h1>Stereotypical granny using a computer with non-optical mouse from the 90s.</h1>
     * Low speed, variating flow, lots of noise in movement.
     *
     * @return the factory
     */
    public static MouseMotionFactory createGrannyMotionFactory() {
        return createGrannyMotionFactory(new DefaultMouseMotionNature());
    }
    /**
     * <h1>Stereotypical granny using a computer with non-optical mouse from the 90s.</h1>
     * Low speed, variating flow, lots of noise in movement.
     *
     * @param nature the nature for the template to be configured on
     * @return the factory
     */
    public static MouseMotionFactory createGrannyMotionFactory(MouseMotionNature nature) {
        MouseMotionFactory factory = new MouseMotionFactory(nature);
        List<Flow> flows = new ArrayList<>(Arrays.asList(
                new Flow(FlowTemplates.jaggedFlow()),
                new Flow(FlowTemplates.random()),
                new Flow(FlowTemplates.interruptedFlow()),
                new Flow(FlowTemplates.interruptedFlow2()),
                new Flow(FlowTemplates.adjustingFlow()),
                new Flow(FlowTemplates.stoppingFlow())
        ));
        DefaultSpeedManager manager = new DefaultSpeedManager(flows);
        factory.setDeviationProvider(new SinusoidalDeviationProvider(9));
        factory.setNoiseProvider(new DefaultNoiseProvider(1.6));
        factory.getNature().setReactionTimeBaseMs(100);
        DefaultOvershootManager overshootManager = (DefaultOvershootManager) factory.getOvershootManager();
        if (Rs2AntibanSettings.simulateMistakes)
            overshootManager.setOvershoots(3);
        else
            overshootManager.setOvershoots(0);
        overshootManager.setMinDistanceForOvershoots(3);
        overshootManager.setMinOvershootMovementMs(400);
        overshootManager.setOvershootRandomModifierDivider(DefaultOvershootManager.OVERSHOOT_RANDOM_MODIFIER_DIVIDER / 2);
        overshootManager.setOvershootSpeedupDivider(DefaultOvershootManager.OVERSHOOT_SPEEDUP_DIVIDER * 2);
        factory.getNature().setTimeToStepsDivider(DefaultMouseMotionNature.TIME_TO_STEPS_DIVIDER - 2);
        manager.setMouseMovementBaseTimeMs(1000);
        factory.setSpeedManager(manager);
        return factory;
    }
    /**
     * <h1>Robotic fluent movement.</h1>
     * Custom speed, constant movement, no mistakes, no overshoots.
     *
     * @param motionTimeMsPer100Pixels approximate time a movement takes per 100 pixels of travelling
     * @return the factory
     */
    public static MouseMotionFactory createDemoRobotMotionFactory(long motionTimeMsPer100Pixels) {
        return createDemoRobotMotionFactory(new DefaultMouseMotionNature(), motionTimeMsPer100Pixels);
    }
    /**
     * <h1>Robotic fluent movement.</h1>
     * Custom speed, constant movement, no mistakes, no overshoots.
     *
     * @param nature                   the nature for the template to be configured on
     * @param motionTimeMsPer100Pixels approximate time a movement takes per 100 pixels of travelling
     * @return the factory
     */
    public static MouseMotionFactory createDemoRobotMotionFactory(
            MouseMotionNature nature, long motionTimeMsPer100Pixels
    ) {
        MouseMotionFactory factory = new MouseMotionFactory(nature);
        final Flow flow = new Flow(FlowTemplates.constantSpeed());
        double timePerPixel = motionTimeMsPer100Pixels / 100d;
        SpeedManager manager = distance -> new Pair<>(flow, (long) (timePerPixel * distance));
        factory.setDeviationProvider((totalDistanceInPixels, completionFraction) -> DoublePoint.ZERO);
        factory.setNoiseProvider(((random, xStepSize, yStepSize) -> DoublePoint.ZERO));
        DefaultOvershootManager overshootManager = (DefaultOvershootManager) factory.getOvershootManager();
        overshootManager.setOvershoots(0);
        factory.setSpeedManager(manager);
        return factory;
    }
    /**
     * <h1>Gamer with fast reflexes and quick mouse movements.</h1>
     * Quick movement, low noise, some deviation, lots of overshoots.
     *
     * @return the factory
     */
    public static MouseMotionFactory createNormalGamerMotionFactory() {
        return createNormalGamerMotionFactory(new DefaultMouseMotionNature());
    }
    /**
     * <h1>Gamer with fast reflexes and quick mouse movements.</h1>
     * Quick movement, low noise, some deviation, lots of overshoots.
     *
     * @param nature the nature for the template to be configured on
     * @return the factory
     */
    public static MouseMotionFactory createNormalGamerMotionFactory(MouseMotionNature nature) {
        int initialBaseTime = 150;
        int maxBaseTime = 200;
        int currentBaseTime = initialBaseTime;
        if (Rs2AntibanSettings.simulateFatigue)
            currentBaseTime = (Rs2Antiban.mouseFatigue.calculateBaseTimeWithNoise(currentBaseTime, maxBaseTime));
        MouseMotionFactory factory = new MouseMotionFactory(nature);
        List<Flow> flows = new ArrayList<>(Arrays.asList(
                new Flow(FlowTemplates.variatingFlow()),
                new Flow(FlowTemplates.slowStartupFlow()),
                new Flow(FlowTemplates.slowStartup2Flow()),
                new Flow(FlowTemplates.adjustingFlow()),
                new Flow(FlowTemplates.jaggedFlow())
        ));
        DefaultSpeedManager manager = new DefaultSpeedManager(flows);
        factory.setDeviationProvider(new SinusoidalDeviationProvider(SinusoidalDeviationProvider.DEFAULT_SLOPE_DIVIDER));
        factory.setNoiseProvider(new DefaultNoiseProvider(DefaultNoiseProvider.DEFAULT_NOISINESS_DIVIDER));
        factory.getNature().setReactionTimeVariationMs(100);
        manager.setMouseMovementBaseTimeMs(currentBaseTime);
        DefaultOvershootManager overshootManager = (DefaultOvershootManager) factory.getOvershootManager();
        if (Rs2AntibanSettings.simulateMistakes)
            overshootManager.setOvershoots(4);
        else
            overshootManager.setOvershoots(0);
        overshootManager.setMinDistanceForOvershoots(3);
        overshootManager.setMinOvershootMovementMs(250);
        factory.setSpeedManager(manager);
        return factory;
    }
    /**
     * <h1>Gamer with fast reflexes and quick mouse movements.</h1>
     * Quick movement, low noise, some deviation, lots of overshoots.
     *
     * @return the factory
     */
    public static MouseMotionFactory createFastGamerMotionFactory() {
        return createFastGamerMotionFactory(new DefaultMouseMotionNature());
    }
    /**
     * <h1>Gamer with fast reflexes and quick mouse movements.</h1>
     * Quick movement, low noise, some deviation, lots of overshoots.
     *
     * @param nature the nature for the template to be configured on
     * @return the factory
     */
    public static MouseMotionFactory createFastGamerMotionFactory(MouseMotionNature nature) {
        int initialBaseTime = 120;
        int maxBaseTime = 170;
        int currentBaseTime = initialBaseTime;
        if (Rs2AntibanSettings.simulateFatigue)
            currentBaseTime = (Rs2Antiban.mouseFatigue.calculateBaseTimeWithNoise(currentBaseTime, maxBaseTime));
        MouseMotionFactory factory = new MouseMotionFactory(nature);
        List<Flow> flows = new ArrayList<>(Arrays.asList(
                new Flow(FlowTemplates.variatingFlow()),
                new Flow(FlowTemplates.slowStartupFlow()),
                new Flow(FlowTemplates.slowStartup2Flow()),
                new Flow(FlowTemplates.adjustingFlow()),
                new Flow(FlowTemplates.jaggedFlow())
        ));
        DefaultSpeedManager manager = new DefaultSpeedManager(flows);
        factory.setDeviationProvider(new SinusoidalDeviationProvider(SinusoidalDeviationProvider.DEFAULT_SLOPE_DIVIDER));
        factory.setNoiseProvider(new DefaultNoiseProvider(DefaultNoiseProvider.DEFAULT_NOISINESS_DIVIDER));
        factory.getNature().setReactionTimeVariationMs(100);
        manager.setMouseMovementBaseTimeMs(currentBaseTime);
        DefaultOvershootManager overshootManager = (DefaultOvershootManager) factory.getOvershootManager();
        if (Rs2AntibanSettings.simulateMistakes)
            overshootManager.setOvershoots(3);
        else
            overshootManager.setOvershoots(0);
        overshootManager.setMinDistanceForOvershoots(3);
        overshootManager.setMinOvershootMovementMs(130);
        factory.setSpeedManager(manager);
        return factory;
    }
    // Super fast gamer
    public static MouseMotionFactory createSuperFastGamerMotionFactory() {
        return createSuperFastGamerMotionFactory(new DefaultMouseMotionNature());
    }
    public static MouseMotionFactory createSuperFastGamerMotionFactory(MouseMotionNature nature) {
        int initialBaseTime = 90;
        int maxBaseTime = 120;
        int currentBaseTime = initialBaseTime;
        if (Rs2AntibanSettings.simulateFatigue)
            currentBaseTime = (Rs2Antiban.mouseFatigue.calculateBaseTimeWithNoise(currentBaseTime, maxBaseTime));
        MouseMotionFactory factory = new MouseMotionFactory(nature);
        List<Flow> flows = new ArrayList<>(Arrays.asList(
                new Flow(FlowTemplates.variatingFlow()),
                new Flow(FlowTemplates.slowStartupFlow()),
                new Flow(FlowTemplates.slowStartup2Flow()),
                new Flow(FlowTemplates.adjustingFlow()),
                new Flow(FlowTemplates.jaggedFlow())
        ));
        DefaultSpeedManager manager = new DefaultSpeedManager(flows);
        factory.setDeviationProvider(new SinusoidalDeviationProvider(SinusoidalDeviationProvider.DEFAULT_SLOPE_DIVIDER));
        factory.setNoiseProvider(new DefaultNoiseProvider(DefaultNoiseProvider.DEFAULT_NOISINESS_DIVIDER));
        factory.getNature().setReactionTimeVariationMs(90);
        manager.setMouseMovementBaseTimeMs(currentBaseTime);
        DefaultOvershootManager overshootManager = (DefaultOvershootManager) factory.getOvershootManager();
        if (Rs2AntibanSettings.simulateMistakes)
            overshootManager.setOvershoots(2);
        else
            overshootManager.setOvershoots(0);
        overshootManager.setMinDistanceForOvershoots(3);
        overshootManager.setMinOvershootMovementMs(100);
        factory.setSpeedManager(manager);
        return factory;
    }
    /**
     * <h1>Standard computer user with average speed and movement mistakes</h1>
     * medium noise, medium speed, medium noise and deviation.
     *
     * @return the factory
     */
    public static MouseMotionFactory createAverageComputerUserMotionFactory() {
        return createAverageComputerUserMotionFactory(new DefaultMouseMotionNature());
    }
    /**
     * <h1>Standard computer user with average speed and movement mistakes</h1>
     * medium noise, medium speed, medium noise and deviation.
     *
     * @param nature the nature for the template to be configured on
     * @return the factory
     */
    public static MouseMotionFactory createAverageComputerUserMotionFactory(MouseMotionNature nature) {
        MouseMotionFactory factory = new MouseMotionFactory(nature);
        List<Flow> flows = new ArrayList<>(Arrays.asList(
                new Flow(FlowTemplates.variatingFlow()),
                new Flow(FlowTemplates.interruptedFlow()),
                new Flow(FlowTemplates.interruptedFlow2()),
                new Flow(FlowTemplates.slowStartupFlow()),
                new Flow(FlowTemplates.slowStartup2Flow()),
                new Flow(FlowTemplates.adjustingFlow()),
                new Flow(FlowTemplates.jaggedFlow()),
                new Flow(FlowTemplates.stoppingFlow())
        ));
        DefaultSpeedManager manager = new DefaultSpeedManager(flows);
        factory.setDeviationProvider(new SinusoidalDeviationProvider(SinusoidalDeviationProvider.DEFAULT_SLOPE_DIVIDER));
        factory.setNoiseProvider(new DefaultNoiseProvider(DefaultNoiseProvider.DEFAULT_NOISINESS_DIVIDER));
        factory.getNature().setReactionTimeVariationMs(110);
        manager.setMouseMovementBaseTimeMs(400);
        DefaultOvershootManager overshootManager = (DefaultOvershootManager) factory.getOvershootManager();
        if (Rs2AntibanSettings.simulateMistakes)
            overshootManager.setOvershoots(4);
        else
            overshootManager.setOvershoots(0);
        factory.setSpeedManager(manager);
        return factory;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/util/FlowTemplates.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.util;
import java.util.Arrays;
public class FlowTemplates {
    public static double[] variatingFlow() {
        return new double[]{
                10, 13, 14, 19, 16, 13, 15, 22, 56, 90, 97, 97, 66, 51, 50, 66, 91, 95, 87, 96, 98,
                88, 70, 62, 57, 63, 79, 93, 98, 97, 100, 104, 83, 49, 37, 53, 68, 73, 61, 51, 64, 107,
                103, 111, 94, 88, 95, 86, 88, 97, 108, 85, 86, 74, 72, 73, 58, 50, 50, 60, 62, 61, 52,
                53, 44, 30, 21, 25, 21, 17, 16, 13, 8, 2, 6, 9, 6, 3, 7, 12, 13, 15, 11, 9,
                9, 7, 6, 4, 1, 2, 3, 2, 2, 11, 15, 7, 1, 0, 0, 1
        };
    }
    public static double[] interruptedFlow() {
        return new double[]{
                12, 11, 10, 20, 24, 19, 26, 15, 9, 9, 10, 24, 26, 30, 24, 49, 72, 60, 81, 113, 82,
                99, 67, 10, 7, 7, 7, 10, 8, 7, 9, 6, 6, 7, 10, 11, 12, 8, 7, 3, 0, 2,
                8, 10, 10, 12, 6, 4, 4, 3, 8, 11, 11, 11, 11, 13, 11, 20, 25, 18, 21, 23, 56,
                40, 36, 58, 69, 60, 63, 51, 87, 71, 86, 66, 115, 97, 80, 65, 50, 66, 57, 24, 11, 11,
                7, 3, 0, 0, 1, 3, 3, 5, 6, 12, 11, 7, 11, 17, 17, 23
        };
    }
    public static double[] interruptedFlow2() {
        return new double[]{
                12, 11, 10, 20, 24, 19, 26, 15, 9, 9, 10, 24, 26, 30, 24, 49, 72, 60, 81, 113, 82,
                99, 67, 10, 12, 8, 11, 15, 16, 17, 17, 12, 16, 37, 10, 25, 12, 11, 41, 10, 12, 11,
                40, 36, 52, 61, 60, 64, 51, 82, 71, 81, 66, 105, 92, 59, 65, 51, 66, 54, 21, 21, 12,
                40, 36, 58, 69, 60, 63, 51, 87, 71, 86, 66, 115, 97, 80, 65, 50, 66, 57, 24, 11, 11,
                7, 3, 0, 0, 1, 3, 3, 5, 6, 12, 11, 7, 11, 17, 17, 23
        };
    }
    public static double[] slowStartupFlow() {
        return new double[]{
                8, 5, 1, 1, 1, 2, 2, 3, 3, 3, 5, 7, 9, 10, 10, 11, 11, 11, 12, 12, 13,
                15, 14, 13, 15, 15, 17, 17, 18, 18, 20, 19, 20, 20, 19, 20, 19, 20, 21, 22, 20, 17,
                20, 22, 18, 20, 21, 18, 20, 20, 18, 20, 19, 21, 19, 19, 19, 19, 20, 19, 20, 21, 19,
                19, 17, 21, 21, 17, 19, 18, 20, 18, 19, 24, 34, 43, 35, 40, 41, 42, 42, 38, 40, 40,
                37, 36, 42, 40, 63, 85, 98, 92, 103, 102, 95, 86, 70, 52, 31, 19
        };
    }
    public static double[] slowStartup2Flow() {
        return new double[]{
                7, 2, 1, 2, 2, 3, 5, 9, 10, 10, 11, 13, 13, 10, 4, 1, 1, 2, 3, 4, 6,
                9, 11, 11, 10, 14, 11, 9, 2, 1, 2, 2, 3, 4, 8, 9, 10, 11, 11, 13, 13, 15,
                14, 15, 18, 17, 19, 21, 20, 19, 18, 20, 20, 20, 20, 19, 20, 19, 19, 18, 20, 20, 19,
                20, 18, 20, 21, 19, 21, 18, 19, 25, 37, 37, 35, 41, 43, 41, 41, 40, 48, 81, 108, 91,
                88, 74, 46, 19, 46, 84, 35, 14, 19, 12, 13, 18, 38, 35, 11, 4
        };
    }
    public static double[] jaggedFlow() {
        return new double[]{
                52, 106, 122, 8, 6, 117, 32, 2, 68, 34, 21, 81, 61, 86, 55, 4, 104, 21, 51, 8, 93,
                90, 43, 65, 82, 31, 40, 115, 107, 13, 35, 73, 81, 67, 31, 79, 57, 100, 55, 64, 13, 54,
                18, 68, 82, 61, 11, 84, 37, 20, 68, 33, 36, 55, 68, 75, 56, 20, 41, 120, 63, 72, 102,
                49, 4, 48, 69, 50, 35, 49, 54, 19, 95, 121, 26, 78, 31, 62, 53, 123, 73, 22, 39, 72,
                98, 33, 26, 5, 103, 23, 75, 35, 69, 33, 44, 12, 10, 101, 122, 19
        };
    }
    public static double[] stoppingFlow() {
        return new double[]{
                8, 20, 39, 48, 66, 71, 79, 57, 29, 5, 2, 3, 2, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 1, 3, 6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 6, 10, 12, 15, 19,
                37, 60, 100, 103, 98, 82, 87, 74, 65, 51, 57, 54, 61, 46, 38, 16
        };
    }
    public static double[] adjustingFlow() {
        return new double[]{
                1, 1, 1, 3, 8, 7, 2, 2, 4, 8, 6, 3, 7, 13, 18, 19, 24, 35, 26, 14, 31,
                43, 49, 55, 61, 67, 61, 50, 43, 37, 30, 16, 5, 4, 4, 3, 3, 3, 4, 4, 3,
                2, 2, 3, 10, 14, 10, 7, 5, 5
        };
    }
    public static double[] random() {
        double[] result = new double[100];
        for (int i = 0; i < result.length; i++) {
            result[i] = (int) (Math.random() * 100);
        }
        return result;
    }
    public static double[] constantSpeed() {
        double[] flowBuckets = new double[10];
        Arrays.fill(flowBuckets, 100);
        return flowBuckets;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/util/FlowUtil.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.util;
import java.util.Arrays;
import java.util.function.Function;
public class FlowUtil {
    /**
     * Stretch flow to longer length. Tries to fill the caps with averages.
     * <p>
     * This is an unintuitive method, because it turns out that, for example, array size of 3
     * scales better to array size of 5 than it does to array size of 6. [1, 2, 3] can be
     * easily scaled to [1, 1.5, 2, 2.5, 3], but it's not possible without recalculating middle number (2)
     * with array size of 6, simplistic solutions quickly would run to trouble like this  [1, 1.5, 2, 2.5, 3, (3)? ]
     * or maybe: [1, 1.5, 2, 2.5, ..., 3 ]. The correct solution would correctly scale the middle numbers
     *
     * @param flow         the original flow
     * @param targetLength the resulting flow length
     * @return the resulting flow
     */
    public static double[] stretchFlow(double[] flow, int targetLength) {
        return stretchFlow(flow, targetLength, a -> a);
    }
    /**
     * Stretch flow to longer length. Tries to fill the caps with averages.
     * <p>
     * This is an unintuitive method, because it turns out that, for example, array size of 3
     * scales better to array size of 5 than it does to array size of 6. [1, 2, 3] can be
     * easily scaled to [1, 1.5, 2, 2.5, 3], but it's not possible without recalculating middle number (2)
     * with array size of 6, simplistic solutions quickly would run to trouble like this  [1, 1.5, 2, 2.5, 3, (3)? ]
     * or maybe: [1, 1.5, 2, 2.5, ..., 3 ]. The correct solution would correctly scale the middle numbers
     * over several indexes.
     *
     * @param flow         the original flow
     * @param targetLength the resulting flow length
     * @param modifier     modifies the resulting values, you can use this to provide noise or amplify
     *                     the flow characteristics.
     * @return the resulting flow
     */
    public static double[] stretchFlow(double[] flow, int targetLength, Function<Double, Double> modifier) {
        if (targetLength < flow.length) {
            throw new IllegalArgumentException("Target bucket length smaller than flow. " + targetLength + " vs " + flow.length);
        }
        double[] result;
        int tempLength = targetLength;
        if (flow.length != 1 && (tempLength - flow.length) % (flow.length - 1) != 0) {
            tempLength = (flow.length - 1) * (tempLength - flow.length) + 1;
        }
        result = new double[tempLength];
        int insider = flow.length - 2;
        int stepLength = (int) ((tempLength - 2) / (double) (insider + 1)) + 1;
        int countToNextStep = stepLength;
        int fillValueIndex = 0;
        for (int i = 0; i < tempLength; i++) {
            double fillValueBottom = flow[fillValueIndex];
            double fillValueTop = fillValueIndex + 1 < flow.length ? flow[fillValueIndex + 1] : flow[fillValueIndex];
            double completion = (stepLength - countToNextStep) / (double) stepLength;
            result[i] = fillValueBottom * (1 - completion) + fillValueTop * completion;
            countToNextStep--;
            if (countToNextStep == 0) {
                countToNextStep = stepLength;
                fillValueIndex++;
            }
        }
        if (tempLength != targetLength) {
            result = reduceFlow(result, targetLength);
        }
        return Arrays.stream(result).map(modifier::apply).toArray();
    }
    /**
     * Reduction causes loss of information, so the resulting flow is always 'good enough', but is not quaranteed
     * to be equivalent, just a shorter version of the original flow
     *
     * @param flow         the original flow
     * @param targetLength the resulting array length
     * @return the resulting flow
     */
    public static double[] reduceFlow(double[] flow, int targetLength) {
        if (flow.length <= targetLength) {
            throw new IllegalArgumentException("Bad arguments [" + flow.length + ", " + targetLength + "]");
        }
        double multiplier = targetLength / (double) flow.length;
        double[] result = new double[targetLength];
        for (int i = 0; i < flow.length; i++) {
            double index = (i * multiplier);
            double untilIndex = (i + 1) * multiplier;
            int indexInt = (int) index;
            int untilIndexInt = (int) untilIndex;
            if (indexInt != untilIndexInt) {
                double resultIndexPortion = 1 - (index - indexInt);
                double nextResultIndexPortion = untilIndex - untilIndexInt;
                result[indexInt] += flow[i] * resultIndexPortion;
                if (untilIndexInt < result.length) {
                    result[untilIndexInt] += flow[i] * nextResultIndexPortion;
                }
            } else {
                result[indexInt] += flow[i] * (untilIndex - index);
            }
        }
        return result;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/util/MathUtil.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.util;
public class MathUtil {
    /**
     * Rounds value towards target to exact integer value.
     *
     * @param value  the value to be rounded
     * @param target the target to be rounded towards
     * @return the rounded value
     */
    public static int roundTowards(double value, int target) {
        if (target > value) {
            return (int) Math.ceil(value);
        } else {
            return (int) Math.floor(value);
        }
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/util/Pair.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse.util;
public class Pair<X, Y> {
    public final X x;
    public final Y y;
    public Pair(X x, Y y) {
        this.x = x;
        this.y = y;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/naturalmouse/NaturalMouse.java
================
package net.runelite.client.plugins.microbot.util.mouse.naturalmouse;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Client;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.Global;
import net.runelite.client.plugins.microbot.util.antiban.Rs2Antiban;
import net.runelite.client.plugins.microbot.util.antiban.enums.ActivityIntensity;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.api.MouseInfoAccessor;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.api.MouseMotionFactory;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.api.SystemCalls;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support.DefaultMouseMotionNature;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support.DefaultSpeedManager;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support.Flow;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.support.MouseMotionNature;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.util.FactoryTemplates;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.util.FlowTemplates;
import net.runelite.client.plugins.microbot.util.mouse.naturalmouse.util.Pair;
import javax.inject.Inject;
import java.awt.*;
import java.util.Collection;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadLocalRandom;
@Slf4j
public class NaturalMouse {
    public final MouseMotionNature nature;
    private final ThreadLocalRandom random = ThreadLocalRandom.current();
    private final ExecutorService executorService = Executors.newSingleThreadExecutor();
    @Inject
    private Client client;
    @Getter
    @Setter
    private List<Flow> flows = List.of(
            new Flow(FlowTemplates.variatingFlow()),
            new Flow(FlowTemplates.slowStartupFlow()),
            new Flow(FlowTemplates.slowStartup2Flow()),
            new Flow(FlowTemplates.jaggedFlow()),
            new Flow(FlowTemplates.interruptedFlow()),
            new Flow(FlowTemplates.interruptedFlow2()),
            new Flow(FlowTemplates.stoppingFlow()),
            new Flow(FlowTemplates.adjustingFlow()),
            new Flow(FlowTemplates.random())
    );
    @Inject
    public NaturalMouse() {
        nature = new DefaultMouseMotionNature();
        nature.setSystemCalls(new SystemCallsImpl());
        nature.setMouseInfo(new MouseInfoImpl());
    }
    public synchronized void moveTo(int dx, int dy) {
//		if(Rs2UiHelper.isStretchedEnabled())
//		{
//			dx = Rs2UiHelper.stretchX(dx);
//			dy = Rs2UiHelper.stretchY(dy);
//		}
        int finalDx = dx;
        int finalDy = dy;
        if (!Microbot.getClient().isClientThread()) {
            move(finalDx, finalDy);
        } else {
            executorService.submit(() -> move(finalDx, finalDy));
        }
    }
    private synchronized void move(int dx, int dy) {
        var motion = getFactory().build(dx, dy);
        try {
            motion.move();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    public MouseMotionFactory getFactory() {
        if (Rs2Antiban.getActivityIntensity() == ActivityIntensity.VERY_LOW) {
            log.info("Creating average computer user motion factory");
            return FactoryTemplates.createAverageComputerUserMotionFactory(nature);
        } else if (Rs2Antiban.getActivityIntensity() == ActivityIntensity.LOW) {
            log.info("Creating normal gamer motion factory");
            return FactoryTemplates.createNormalGamerMotionFactory(nature);
        } else if (Rs2Antiban.getActivityIntensity() == ActivityIntensity.MODERATE) {
            log.info("Creating fast gamer motion factory");
            return FactoryTemplates.createFastGamerMotionFactory(nature);
        } else if (Rs2Antiban.getActivityIntensity() == ActivityIntensity.HIGH) {
            log.info("Creating fast gamer motion factory");
            return FactoryTemplates.createFastGamerMotionFactory(nature);
        } else if (Rs2Antiban.getActivityIntensity() == ActivityIntensity.EXTREME) {
            log.info("Creating super fast gamer motion factory");
            return FactoryTemplates.createSuperFastGamerMotionFactory(nature);
        } else {
            log.info("Default: Creating super fast gamer motion factory");
            return FactoryTemplates.createSuperFastGamerMotionFactory(nature);
        }
//		var factory = new MouseMotionFactory();
//		factory.setNature(nature);
//		factory.setRandom(random);
//
//		var manager = new SpeedManagerImpl(flows);
//		factory.setDeviationProvider(new SinusoidalDeviationProvider(15.0));
//		factory.setNoiseProvider(new DefaultNoiseProvider(2.0));
//		factory.getNature().setReactionTimeVariationMs(120);
//		manager.setMouseMovementBaseTimeMs(130);
//
//		var overshootManager = (DefaultOvershootManager) factory.getOvershootManager();
//		overshootManager.setOvershoots(2);
//		factory.setSpeedManager(manager);
//
//		return factory;
    }
    public void moveOffScreen() {
        // 1 in 4 chance of moving off screen
        if (random.nextInt(4) == 0) {
            // Edges of the screen
            int horizontal = random.nextBoolean() ? -1 : client.getCanvasWidth() + 1;
            int vertical = random.nextBoolean() ? -1 : client.getCanvasHeight() + 1;
            boolean exitHorizontally = random.nextBoolean();
            if (exitHorizontally) {
                moveTo(horizontal, random.nextInt(0, client.getCanvasHeight() + 1));
            } else {
                moveTo(random.nextInt(0, client.getCanvasWidth() + 1), vertical);
            }
        }
    }
    // Move to a random point on the screen
    public void moveRandom() {
        moveTo(random.nextInt(0, client.getCanvasWidth() + 1), random.nextInt(0, client.getCanvasHeight() + 1));
    }
    private static class SpeedManagerImpl extends DefaultSpeedManager {
        private SpeedManagerImpl(Collection<Flow> flows) {
            super(flows);
        }
        @Override
        public Pair<Flow, Long> getFlowWithTime(double distance) {
            var pair = super.getFlowWithTime(distance);
            return new Pair<>(pair.x, pair.y);
        }
    }
    private static class MouseInfoImpl implements MouseInfoAccessor {
        @Override
        public Point getMousePosition() {
            return Microbot.getMouse().getMousePosition();
        }
    }
    private class SystemCallsImpl implements SystemCalls {
        @Override
        public long currentTimeMillis() {
            return System.currentTimeMillis();
        }
        @Override
        public void sleep(long time) {
            Global.sleep((int) time);
        }
        @Override
        public Dimension getScreenSize() {
            return Microbot.getClient().getCanvas().getSize();
        }
        @Override
        public void setMousePosition(int x, int y) {
            Microbot.getMouse().move(x, y);
        }
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/Mouse.java
================
package net.runelite.client.plugins.microbot.util.mouse;
import lombok.Getter;
import net.runelite.api.Point;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.math.Rs2Random;
import net.runelite.client.plugins.microbot.util.menu.NewMenuEntry;
import javax.swing.*;
import java.awt.*;
import java.util.LinkedList;
@Getter
public abstract class Mouse {
    private static final int POINT_LIFETIME = 12;// Maximum number of points to store
    final int MAX_POINTS = 500;
    LinkedList<Point> points = new LinkedList<>();
    Point lastClick = new Point(-1, -1); // getter for last click
    // getter for click before last click
    Point lastClick2 = new Point(-1, -1);
    Point lastMove = new Point(-1, -1); // getter for last move
    float hue = 0.0f; // Initial hue value
    Timer timer = new Timer(POINT_LIFETIME, e -> {
        if (!points.isEmpty()) {
            try {
                points.removeFirst();
            } catch (Exception ignore) {
            }
        }
    });
    public Mouse() {
    }
    public Color getRainbowColor() {
        hue += 0.001f; // Increment hue to cycle through colors
        if (hue > 1.0f) {
            hue = 0.0f; // Reset hue when it exceeds 1.0
        }
        return Color.getHSBColor(hue, 1.0f, 1.0f);
    }
    public Canvas getCanvas() {
        return Microbot.getClient().getCanvas();
    }
    public int randomizeClick() {
        return (int) Rs2Random.normalRange(-10, 10, 4);
    }
    public abstract void setLastClick(Point point);
    public abstract void setLastMove(Point point);
    public abstract Mouse click(int x, int y);
    public abstract Mouse click(double x, double y);
    public abstract Mouse click(Rectangle rectangle);
    public abstract Mouse click(int x, int y, boolean rightClick);
    public abstract Mouse click(Point point);
    public abstract Mouse click(Point point, boolean rightClick);
    public abstract Mouse click(Point point, NewMenuEntry entry);
    public abstract Mouse click();
    public abstract Mouse move(Point point);
    public abstract Mouse move(Rectangle rect);
    public abstract Mouse move(int x, int y);
    public abstract Mouse move(double x, double y);
    public abstract Mouse move(Polygon polygon);
    public abstract Mouse scrollDown(Point point);
    public abstract Mouse scrollUp(Point point);
    public abstract Mouse drag(Point startPoint, Point endPoint);
    public abstract java.awt.Point getMousePosition();
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/mouse/VirtualMouse.java
================
package net.runelite.client.plugins.microbot.util.mouse;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.Point;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.antiban.Rs2AntibanSettings;
import net.runelite.client.plugins.microbot.util.menu.NewMenuEntry;
import net.runelite.client.plugins.microbot.util.misc.Rs2UiHelper;
import javax.inject.Inject;
import java.awt.*;
import java.awt.event.MouseEvent;
import java.awt.event.MouseWheelEvent;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import static net.runelite.client.plugins.microbot.util.Global.sleep;
import static net.runelite.client.plugins.microbot.util.math.Random.random;
@Slf4j
public class VirtualMouse extends Mouse {
    private final ScheduledExecutorService scheduledExecutorService;
    private boolean exited = true;
    @Inject
    public VirtualMouse() {
        super();
        this.scheduledExecutorService = Executors.newScheduledThreadPool(10);
        //getCanvas().setFocusable(false);
    }
    public void setLastClick(Point point) {
        lastClick2 = lastClick;
        lastClick = point;
    }
    public void setLastMove(Point point) {
        lastMove = point;
        points.add(point);
        if (points.size() > MAX_POINTS) {
            points.removeFirst();
        }
    }
    private void handleClick(Point point, boolean rightClick) {
        entered(point);
        exited(point);
        moved(point);
        pressed(point, rightClick ? MouseEvent.BUTTON3 : MouseEvent.BUTTON1);
        released(point, rightClick ? MouseEvent.BUTTON3 : MouseEvent.BUTTON1);
        clicked(point, rightClick ? MouseEvent.BUTTON3 : MouseEvent.BUTTON1);
        setLastClick(point);
    }
    public Mouse click(Point point, boolean rightClick) {
        if (point == null) return this;
        if (Rs2AntibanSettings.naturalMouse && (point.getX() > 1 && point.getY() > 1))
            Microbot.naturalMouse.moveTo(point.getX(), point.getY());
        if (Microbot.getClient().isClientThread()) {
            scheduledExecutorService.schedule(() -> {
                handleClick(point, rightClick);
            }, 0, TimeUnit.MILLISECONDS);
        } else {
            handleClick(point, rightClick);
        }
        return this;
    }
    public Mouse click(Point point, boolean rightClick, NewMenuEntry entry) {
        if (point == null) return this;
        if (Rs2AntibanSettings.naturalMouse && (point.getX() > 1 && point.getY() > 1)) {
            Microbot.naturalMouse.moveTo(point.getX(), point.getY());
            if (Rs2UiHelper.hasActor(entry)) {
                log.info("Actor found: " + entry.getActor().getName());
                Rectangle rectangle = Rs2UiHelper.getActorClickbox(entry.getActor());
                if (!Rs2UiHelper.isMouseWithinRectangle(rectangle)) {
                    point = Rs2UiHelper.getClickingPoint(rectangle, true);
                    Microbot.naturalMouse.moveTo(point.getX(), point.getY());
                }
            }
            if (Rs2UiHelper.isGameObject(entry)) {
                log.info("Game Object found: " + entry.getGameObject().toString());
                Rectangle rectangle = Rs2UiHelper.getObjectClickbox(entry.getGameObject());
                if (!Rs2UiHelper.isMouseWithinRectangle(rectangle)) {
                    point = Rs2UiHelper.getClickingPoint(rectangle, true);
                    Microbot.naturalMouse.moveTo(point.getX(), point.getY());
                }
            }
        }
        // Target menu was set before mouse movement causing some unintended behavior
        // This will set the target menu after the mouse movement is finished
        Microbot.targetMenu = entry;
        if (Microbot.getClient().isClientThread()) {
            Point finalPoint = point;
            scheduledExecutorService.schedule(() -> {
                handleClick(finalPoint, rightClick);
            }, 0, TimeUnit.MILLISECONDS);
        } else {
            handleClick(point, rightClick);
        }
        return this;
    }
    public Mouse click(int x, int y) {
        return click(new Point(x, y), false);
    }
    public Mouse click(double x, double y) {
        return click(new Point((int) x, (int) y), false);
    }
    public Mouse click(Rectangle rectangle) {
        return click(Rs2UiHelper.getClickingPoint(rectangle, true), false);
    }
    @Override
    public Mouse click(int x, int y, boolean rightClick) {
        return click(new Point(x, y), rightClick);
    }
    @Override
    public Mouse click(Point point) {
        return click(point, false);
    }
    @Override
    public Mouse click(Point point, NewMenuEntry entry) {
        return click(point, false, entry);
    }
    @Override
    public Mouse click() {
        return click(Microbot.getClient().getMouseCanvasPosition());
    }
    public Mouse move(Point point) {
        setLastMove(point);
        MouseEvent mouseMove = new MouseEvent(Microbot.getClient().getCanvas(), MouseEvent.MOUSE_MOVED, System.currentTimeMillis(), 0, point.getX(), point.getY(), 0, false);
        mouseMove.setSource("Microbot");
        getCanvas().dispatchEvent(mouseMove);
        return this;
    }
    public Mouse move(Rectangle rect) {
        MouseEvent mouseMove = new MouseEvent(Microbot.getClient().getCanvas(), MouseEvent.MOUSE_MOVED, System.currentTimeMillis(), 0, (int) rect.getCenterX(), (int) rect.getCenterY(), 0, false);
        mouseMove.setSource("Microbot");
        getCanvas().dispatchEvent(mouseMove);
        return this;
    }
    public Mouse move(Polygon polygon) {
        Point point = new Point((int) polygon.getBounds().getCenterX(), (int) polygon.getBounds().getCenterY());
        MouseEvent mouseMove = new MouseEvent(getCanvas(), MouseEvent.MOUSE_MOVED, System.currentTimeMillis(), 0, point.getX(), point.getY(), 0, false);
        mouseMove.setSource("Microbot");
        getCanvas().dispatchEvent(mouseMove);
        return this;
    }
    public Mouse scrollDown(Point point) {
        long time = System.currentTimeMillis();
        move(point);
        scheduledExecutorService.schedule(() -> {
            MouseEvent mouseScroll = new MouseWheelEvent(getCanvas(), MouseEvent.MOUSE_WHEEL, time, 0, point.getX(), point.getY(), 0, false,
                    0, 10, 2);
            mouseScroll.setSource("Microbot");
            getCanvas().dispatchEvent(mouseScroll);
        }, random(40, 100), TimeUnit.MILLISECONDS);
        return this;
    }
    public Mouse scrollUp(Point point) {
        long time = System.currentTimeMillis();
        MouseEvent mouseScroll = new MouseWheelEvent(getCanvas(), MouseEvent.MOUSE_WHEEL, time, 0, point.getX(), point.getY(), 0, false,
                0, -10, -2);
        getCanvas().dispatchEvent(mouseScroll);
        return this;
    }
    @Override
    public java.awt.Point getMousePosition() {
        Point point = lastMove;
        return new java.awt.Point(point.getX(), point.getY());
    }
    @Override
    public Mouse move(int x, int y) {
        return move(new Point(x, y));
    }
    @Override
    public Mouse move(double x, double y) {
        return move(new Point((int) x, (int) y));
    }
    @Deprecated
    private void mouseEvent(int id, Point point, boolean rightClick) {
        int button = rightClick ? MouseEvent.BUTTON3 : MouseEvent.BUTTON1;
        MouseEvent e = new MouseEvent(Microbot.getClient().getCanvas(), id, System.currentTimeMillis(), 0, point.getX(), point.getY(), 1, false, button);
        getCanvas().dispatchEvent(e);
    }
    private synchronized void pressed(Point point, int button) {
        MouseEvent event = new MouseEvent(Microbot.getClient().getCanvas(), MouseEvent.MOUSE_PRESSED, System.currentTimeMillis(), 0, point.getX(), point.getY(), 1, false, button);
        event.setSource("Microbot");
        getCanvas().dispatchEvent(event);
    }
    private synchronized void released(Point point, int button) {
        MouseEvent event = new MouseEvent(Microbot.getClient().getCanvas(), MouseEvent.MOUSE_RELEASED, System.currentTimeMillis(), 0, point.getX(), point.getY(), 1, false, button);
        event.setSource("Microbot");
        getCanvas().dispatchEvent(event);
    }
    private synchronized void clicked(Point point, int button) {
        MouseEvent event = new MouseEvent(Microbot.getClient().getCanvas(), MouseEvent.MOUSE_CLICKED, System.currentTimeMillis(), 0, point.getX(), point.getY(), 1, false, button);
        event.setSource("Microbot");
        getCanvas().dispatchEvent(event);
    }
    private synchronized void exited(Point point) {
        MouseEvent event = new MouseEvent(Microbot.getClient().getCanvas(), MouseEvent.MOUSE_EXITED, System.currentTimeMillis(), 0, point.getX(), point.getY(), 0, false);
        event.setSource("Microbot");
        getCanvas().dispatchEvent(event);
        exited = true;
    }
    private synchronized void entered(Point point) {
        MouseEvent event = new MouseEvent(Microbot.getClient().getCanvas(), MouseEvent.MOUSE_ENTERED, System.currentTimeMillis(), 0, point.getX(), point.getY(), 0, false);
        event.setSource("Microbot");
        getCanvas().dispatchEvent(event);
        exited = false;
    }
    private synchronized void moved(Point point) {
        MouseEvent event = new MouseEvent(Microbot.getClient().getCanvas(), MouseEvent.MOUSE_MOVED, System.currentTimeMillis(), 0, point.getX(), point.getY(), 0, false);
        event.setSource("Microbot");
        getCanvas().dispatchEvent(event);
    }
    // New drag method
    public Mouse drag(Point startPoint, Point endPoint) {
        if (startPoint == null || endPoint == null) return this;
        if (Rs2AntibanSettings.naturalMouse && (startPoint.getX() > 1 && startPoint.getY() > 1))
            Microbot.naturalMouse.moveTo(startPoint.getX(), startPoint.getY());
        else
            move(startPoint);
        sleep(50, 80);
        // Press the mouse button at the start point
        pressed(startPoint, MouseEvent.BUTTON1);
        sleep(80, 120);
        // Move to the end point while holding the button down
        if (Rs2AntibanSettings.naturalMouse && (endPoint.getX() > 1 && endPoint.getY() > 1))
            Microbot.naturalMouse.moveTo(endPoint.getX(), endPoint.getY());
        else
            move(endPoint);
        sleep(80, 120);
        // Release the mouse button at the end point
        released(endPoint, MouseEvent.BUTTON1);
        return this;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/npc/Rs2Npc.java
================
package net.runelite.client.plugins.microbot.util.npc;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.game.npcoverlay.HighlightedNpc;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.antiban.Rs2AntibanSettings;
import net.runelite.client.plugins.microbot.util.camera.Rs2Camera;
import net.runelite.client.plugins.microbot.util.combat.Rs2Combat;
import net.runelite.client.plugins.microbot.util.menu.NewMenuEntry;
import net.runelite.client.plugins.microbot.util.misc.Rs2UiHelper;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.microbot.util.tile.Rs2Tile;
import net.runelite.client.plugins.microbot.util.walker.Rs2Walker;
import org.jetbrains.annotations.Nullable;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;
public class Rs2Npc {
    public static NPC getNpcByIndex(int index) {
        return Microbot.getClient().getNpcs().stream()
                .filter(x -> x.getIndex() == index)
                .findFirst()
                .orElse(null);
    }
    public static NPC validateInteractable(NPC npc) {
        if (npc != null) {
            Rs2Walker.walkTo(npc.getWorldLocation());
            Rs2Camera.turnTo(npc);
            return npc;
        }
        return null;
    }
    public static List<NPC> getNpcsForPlayer() {
        return Microbot.getClient().getNpcs().stream()
                .filter(x -> x.getInteracting() == Microbot.getClient().getLocalPlayer())
                .sorted(Comparator
                        .comparingInt(value -> value
                                .getLocalLocation()
                                .distanceTo(Microbot.getClient().getLocalPlayer().getLocalLocation())))
                .collect(Collectors.toList());
    }
    public static List<NPC> getNpcsForPlayer(String name) {
        List<NPC> npcs = Microbot.getClient().getNpcs().stream()
                .filter(x -> x.getInteracting() == Microbot.getClient().getLocalPlayer() && x.getName().equalsIgnoreCase(name))
                .sorted(Comparator
                        .comparingInt(value -> value
                                .getLocalLocation()
                                .distanceTo(Microbot.getClient().getLocalPlayer().getLocalLocation())))
                .collect(Collectors.toList());
        return npcs;
    }
    public static double getHealth(Actor npc) {
        int ratio = npc.getHealthRatio();
        int scale = npc.getHealthScale();
        double targetHpPercent = (double) ratio / (double) scale * 100;
        return targetHpPercent;
    }
    /**
     * @return
     */
    public static Stream<NPC> getNpcs() {
        Stream<NPC> npcs = Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getNpcs().stream()
                .filter(x -> x != null && x.getName() != null && !x.isDead())
                .sorted(Comparator.comparingInt(value -> value.getLocalLocation()
                        .distanceTo(Microbot.getClient().getLocalPlayer().getLocalLocation()))));
        return npcs;
    }
    /**
     * @param name
     *
     * @return
     */
    public static Stream<NPC> getNpcs(String name) {
        return getNpcs(name, true);
    }
    /**
     * @param name
     * @param exact
     *
     * @return
     */
    public static Stream<NPC> getNpcs(String name, boolean exact) {
        Stream<NPC> npcs = getNpcs();
        if (exact) {
            npcs = npcs.filter(x -> x.getName().equalsIgnoreCase(name));
        } else {
            npcs = npcs.filter(x -> x.getName().toLowerCase().contains(name.toLowerCase()));
        }
        return npcs;
    }
    /**
     * @param id
     *
     * @return
     */
    public static Stream<NPC> getNpcs(int id) {
        return getNpcs().filter(x -> x.getId() == id);
    }
    public static Stream<NPC> getAttackableNpcs() {
        Stream<NPC> npcs = Microbot.getClient().getNpcs().stream()
                .filter((npc) -> npc.getCombatLevel() > 0 && !npc.isDead())
                .sorted(Comparator.comparingInt(value -> value.getLocalLocation().distanceTo(Microbot.getClient().getLocalPlayer().getLocalLocation())));
        if (!Rs2Player.isInMulti()) {
            npcs = npcs.filter((npc) -> !npc.isInteracting());
        }
        return npcs;
    }
    public static Stream<NPC> getAttackableNpcs(String name) {
        return getAttackableNpcs()
                .filter(x -> x.getName().equalsIgnoreCase(name));
    }
    public static NPC[] getPestControlPortals() {
        List<NPC> npcs = Microbot.getClient().getNpcs().stream()
                .filter((npc) -> !npc.isDead() && npc.getHealthRatio() > 0 && npc.getName().equalsIgnoreCase("portal"))
                .sorted(Comparator.comparingInt(value -> value.getLocalLocation().distanceTo(Microbot.getClient().getLocalPlayer().getLocalLocation())))
                .collect(Collectors.toList());
        return npcs.toArray(new NPC[npcs.size()]);
    }
    public static NPC getNpc(String name) {
        return getNpc(name, true);
    }
    public static NPC getNpc(String name, boolean exact) {
        return getNpcs(name, exact)
                .findFirst()
                .orElse(null);
    }
    public static NPC getNpc(int id) {
        return getNpcs()
                .filter(x -> x.getId() == id)
                .findFirst()
                .orElse(null);
    }
    public static Optional<NPC> getNpc(int id, List<Integer> excludedIndexes) {
        return getNpcs()
                .filter(x -> x != null && x.getId() == id && !excludedIndexes.contains(x.getIndex()))
                .min(Comparator.comparingInt(value ->
                        value.getLocalLocation().distanceTo(Microbot.getClient().getLocalPlayer().getLocalLocation())));
    }
    public static NPC getRandomEventNPC() {
        return getNpcs()
                .filter(value -> (value.getComposition() != null && value.getComposition().getActions() != null &&
                        Arrays.asList(value.getComposition().getActions()).contains("Dismiss")) && value.getInteracting() == Microbot.getClient().getLocalPlayer())
                .findFirst()
                .orElse(null);
    }
    public static NPC getBankerNPC() {
        return getNpcs()
                .filter(value -> (value.getComposition() != null && value.getComposition().getActions() != null &&
                        Arrays.asList(value.getComposition().getActions()).contains("Bank")))
                .findFirst()
                .orElse(null);
    }
    public static boolean interact(NPC npc, String action) {
        if (npc == null) return false;
        Microbot.status = action + " " + npc.getName();
        try {
            NPCComposition npcComposition = Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getNpcDefinition(npc.getId()));
            int index = 0;
            for (int i = 0; i < npcComposition.getActions().length; i++) {
                String npcAction = npcComposition.getActions()[i];
                if (npcAction == null || !npcAction.equalsIgnoreCase(action)) continue;
                index = i;
            }
            MenuAction menuAction = getMenuAction(index);
            if (menuAction != null) {
                Microbot.doInvoke(new NewMenuEntry(0, 0, menuAction.getId(), npc.getIndex(), -1, npc.getName(), npc), Rs2UiHelper.getActorClickbox(npc));
            }
        } catch (Exception ex) {
            Microbot.log(ex.getMessage());
        }
        return true;
    }
    @Nullable
    private static MenuAction getMenuAction(int index) {
        MenuAction menuAction = null;
        if (Microbot.getClient().isWidgetSelected()) {
            menuAction = MenuAction.WIDGET_TARGET_ON_NPC;
        } else if (index == 0) {
            menuAction = MenuAction.NPC_FIRST_OPTION;
        } else if (index == 1) {
            menuAction = MenuAction.NPC_SECOND_OPTION;
        } else if (index == 2) {
            menuAction = MenuAction.NPC_THIRD_OPTION;
        } else if (index == 3) {
            menuAction = MenuAction.NPC_FOURTH_OPTION;
        } else if (index == 4) {
            menuAction = MenuAction.NPC_FIFTH_OPTION;
        }
        return menuAction;
    }
    public static boolean interact(NPC npc) {
        return interact(npc, "");
    }
    public static boolean interact(int id) {
        return interact(id, "");
    }
    public static boolean interact(int npcId, String action) {
        NPC npc = getNpc(npcId);
        return interact(npc, action);
    }
    public static boolean attack(NPC npc) {
        if (npc == null) return false;
        if (!hasLineOfSight(npc)) return false;
        if (Rs2Combat.inCombat()) return false;
        if (npc.isInteracting() && npc.getInteracting() != Microbot.getClient().getLocalPlayer() && !Rs2Player.isInMulti())
            return false;
        return interact(npc, "attack");
    }
    public static boolean attack(int npcId) {
        NPC npc = getNpc(npcId);
        return attack(npc);
    }
    public static boolean attack(String npcName) {
        return attack(Collections.singletonList(npcName));
    }
    public static boolean attack(List<String> npcNames) {
        for (String npcName : npcNames) {
            NPC npc = getNpc(npcName);
            if (npc == null) continue;
            if (!hasLineOfSight(npc)) continue;
            if (Rs2Combat.inCombat()) continue;
            if (npc.isInteracting() && npc.getInteracting() != Microbot.getClient().getLocalPlayer() && !Rs2Player.isInMulti())
                continue;
            return interact(npc, "attack");
        }
        return false;
    }
    public static boolean interact(String npcName, String action) {
        NPC npc = getNpc(npcName);
        return interact(npc, action);
    }
    public static boolean pickpocket(String npcName) {
        NPC npc = getNpc(npcName);
        if (npc == null) return false;
        if (!hasLineOfSight(npc)) {
            Rs2Walker.walkTo(npc.getWorldLocation(), 1);
            return false;
        }
        return interact(npc, "pickpocket");
    }
    public static boolean pickpocket(Map<NPC, HighlightedNpc> highlightedNpcs) {
        for (NPC npc : highlightedNpcs.keySet()) {
            if (!hasLineOfSight(npc)) {
                Rs2Walker.walkTo(npc.getWorldLocation(), 1);
                return false;
            }
            return interact(npc, "pickpocket");
        }
        return false;
    }
    public static boolean pickpocket(NPC npc) {
        return interact(npc, "pickpocket");
    }
    public static boolean hasLineOfSight(NPC npc) {
        if (npc == null) return false;
        return new WorldArea(
                npc.getWorldLocation(),
                npc.getComposition().getSize(),
                npc.getComposition().getSize())
                .hasLineOfSightTo(Microbot.getClient().getTopLevelWorldView(), Microbot.getClient().getLocalPlayer().getWorldLocation().toWorldArea());
    }
    public static WorldPoint getWorldLocation(NPC npc) {
        if (Microbot.getClient().isInInstancedRegion()) {
            LocalPoint l = LocalPoint.fromWorld(Microbot.getClient(), npc.getWorldLocation());
            WorldPoint npcInstancedWorldLocation = WorldPoint.fromLocalInstance(Microbot.getClient(), l);
            return npcInstancedWorldLocation;
        } else {
            return npc.getWorldLocation();
        }
    }
    public static boolean canWalkTo(NPC npc, int distance) {
        if (npc == null) return false;
        var location = getWorldLocation(npc);
        var tiles = Rs2Tile.getReachableTilesFromTile(Rs2Player.getWorldLocation(), distance);
        for (var tile : tiles.keySet()) {
            if (tile.equals(location))
                return true;
        }
        var localLocation = LocalPoint.fromWorld(Microbot.getClient().getTopLevelWorldView(), location);
        if (localLocation != null && !Rs2Tile.isWalkable(localLocation))
            return tiles.keySet().stream().anyMatch(x -> x.distanceTo(location) < 2);
        return false;
    }
    /**
     * @param player
     *
     * @return
     */
    public static List<NPC> getNpcsAttackingPlayer(Player player) {
        return getNpcs().filter(x -> x.getInteracting() != null && x.getInteracting() == player).collect(Collectors.toList());
    }
    /**
     * gets list of npcs within line of sight for a player by name
     *
     * @param name of the npc
     *
     * @return list of npcs
     */
    public static List<NPC> getNpcsInLineOfSight(String name) {
        return getNpcs().filter(npc -> hasLineOfSight(npc) && npc.getName().equalsIgnoreCase(name)).collect(Collectors.toList());
    }
    /**
     * gets the npc within line of sight for a player by name
     *
     * @param name of the npc
     *
     * @return npc
     */
    public static NPC getNpcInLineOfSight(String name) {
        List<NPC> npcsInLineOfSight = getNpcsInLineOfSight(name);
        if (npcsInLineOfSight.isEmpty()) return null;
        return npcsInLineOfSight.get(0);
    }
    /**
     * Hovers over the given actor (e.g., NPC).
     *
     * @param actor The actor to hover over.
     *
     * @return True if successfully hovered, otherwise false.
     */
    public static boolean hoverOverActor(Actor actor) {
        if (!Rs2AntibanSettings.naturalMouse) {
            Microbot.log("Natural mouse is not enabled, can't hover");
            return false;
        }
        Point point = Rs2UiHelper.getClickingPoint(Rs2UiHelper.getActorClickbox(actor), true);
        if (point.getX() == 1 && point.getY() == 1) {
            return false;
        }
        Microbot.getNaturalMouse().moveTo(point.getX(), point.getY());
        return true;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/npc/Rs2NpcManager.java
================
package net.runelite.client.plugins.microbot.util.npc;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import lombok.extern.slf4j.Slf4j;
import javax.annotation.Nullable;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Type;
import java.nio.charset.StandardCharsets;
import java.util.Collections;
import java.util.Map;
import java.util.Set;
/**
 * This class is responsible for managing NPCs in the game.
 * It provides utility methods for loading NPC data from JSON files and retrieving NPC stats.
 */
@Slf4j
public class Rs2NpcManager {
    private static final Set<Integer> blacklistXpMultiplier = Set.of(8026, 8058, 8059, 8060, 8061, 7850, 7852, 7853, 7884, 7885, 7849, 7851, 7854, 7855, 7882, 7883, 7886, 7887, 7888, 7889, 494, 6640, 6656, 2042, 2043, 2044);
    public static Map<Integer, String> attackStyleMap;
    public static Map<Integer, String> attackAnimationMap;
    private static Map<Integer, Rs2NpcStats> statsMap;
    /**
     * Loads NPC data from JSON files.
     * This method should be called before using any other methods in this class.
     */
    public static void loadJson() throws Exception {
        if (statsMap != null) {
            return;
        }
        Type statsTypeToken = new TypeToken<Map<Integer, Rs2NpcStats>>() {}.getType();
        statsMap = loadNpcStatsFromJsonFile("/npc/monsters_complete.json");
        Type attackStyleTypeToken = new TypeToken<Map<Integer, String>>() {}.getType();
        attackStyleMap = loadJsonFile("/npc/npcs_attack_style.json", attackStyleTypeToken);
        Type attackAnimationTypeToken = new TypeToken<Map<Integer, String>>() {}.getType();
        attackAnimationMap = loadJsonFile("/npc/npcs_attack_animation.json", attackAnimationTypeToken);
    }
    /**
     * Loads a JSON file and deserializes it into a map.
     * @param filename The name of the JSON file to load.
     * @param typeToken The type token of the map.
     * @param <T> The type of the values in the map.
     * @return The deserialized map.
     */
    private static <T> Map<Integer, T> loadJsonFile(String filename, Type typeToken) {
        Gson gson = new Gson();
        try (InputStream inputStream = Rs2NpcStats.class.getResourceAsStream(filename)) {
            if (inputStream == null) {
                System.out.println("Failed to load " + filename);
                return Collections.emptyMap();
            }
            return gson.fromJson(new InputStreamReader(inputStream, StandardCharsets.UTF_8), typeToken);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    private static Map<Integer, Rs2NpcStats> loadNpcStatsFromJsonFile(String filename) {
        Gson gson = new GsonBuilder()
                .registerTypeAdapter(Rs2NpcStats.class, Rs2NpcStats.NPC_STATS_TYPE_ADAPTER)
                .create();
        try (InputStream inputStream = Rs2NpcStats.class.getResourceAsStream(filename)) {
            if (inputStream == null) {
                System.out.println("Failed to load " + filename);
                return Collections.emptyMap();
            }
            // Deserialize the JSON directly into a Map<Integer, Rs2NpcStats>
            Type typeToken = new TypeToken<Map<Integer, Rs2NpcStats>>() {
            }.getType();
            Map<Integer, Rs2NpcStats> statsMap = gson.fromJson(new InputStreamReader(inputStream, StandardCharsets.UTF_8), typeToken);
            return statsMap;
        } catch (IOException e) {
            throw new RuntimeException("Error reading JSON file: " + filename, e);
        }
    }
    /**
     * Retrieves the stats of an NPC.
     * @param npcId The ID of the NPC.
     * @return The stats of the NPC, or null if the NPC does not exist.
     */
    @Nullable
    public static Rs2NpcStats getStats(int npcId) {
        return statsMap.get(npcId);
    }
    /**
     * Retrieves the health of an NPC.
     * @param npcId The ID of the NPC.
     * @return The health of the NPC, or -1 if the NPC does not exist or its health is unknown.
     */
    public static int getHealth(int npcId) {
        Rs2NpcStats s = statsMap.get(npcId);
        return s != null && s.getHitpoints() != -1 ? s.getHitpoints() : -1;
    }
    /**
     * Retrieves the attack speed of an NPC.
     * @param npcId The ID of the NPC.
     * @return The attack speed of the NPC, or -1 if the NPC does not exist or its attack speed is unknown.
     */
    public static int getAttackSpeed(int npcId) {
        Rs2NpcStats s = statsMap.get(npcId);
        log.info(s.toString());
        return s != null && s.getAttackSpeed() != -1 ? s.getAttackSpeed() : -1;
    }
    /**
     * Retrieves the XP modifier of an NPC.
     * @param npcId The ID of the NPC.
     * @return The XP modifier of the NPC, or 1.0 if the NPC does not exist or its XP modifier is unknown.
     */
    public static double getXpModifier(int npcId) {
        if (blacklistXpMultiplier.contains(npcId)) {
            return 1.0;
        } else {
            Rs2NpcStats s = statsMap.get(npcId);
            return s == null ? 1.0 : s.calculateXpModifier();
        }
    }
    /**
     * Retrieves the attack style of an NPC.
     * @param npcId The ID of the NPC.
     * @return The attack style of the NPC, or null if the NPC does not exist or its attack style is unknown.
     */
    public static String getAttackStyle(int npcId) {
        return attackStyleMap.get(npcId);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/npc/Rs2NpcStats.java
================
package net.runelite.client.plugins.microbot.util.npc;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonToken;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.util.Collections;
import java.util.List;
public final class Rs2NpcStats {
    public static final TypeAdapter<Rs2NpcStats> NPC_STATS_TYPE_ADAPTER = new TypeAdapter<Rs2NpcStats>() {
        public void write(JsonWriter out, Rs2NpcStats value) {
            throw new UnsupportedOperationException("Not supported");
        }
        public Rs2NpcStats read(JsonReader in) throws IOException {
            in.beginObject();
            Builder builder = Rs2NpcStats.builder();
            while (in.hasNext()) {
                switch (in.nextName()) {
                    case "id":
                        builder.id(in.nextInt());
                        break;
                    case "name":
                        builder.name(in.nextString());
                        break;
                    case "last_updated":
                        builder.lastUpdated(in.nextString());
                        break;
                    case "incomplete":
                        builder.incomplete(in.nextBoolean());
                        break;
                    case "members":
                        builder.members(in.nextBoolean());
                        break;
                    case "release_date":
                        if (in.peek() == JsonToken.NULL) {
                            in.nextNull();
                            builder.releaseDate(null);
                        } else
                            builder.releaseDate(in.nextString());
                        break;
                    case "combat_level":
                        builder.combatLevel(in.nextInt());
                        break;
                    case "size":
                        builder.size(in.nextInt());
                        break;
                    case "hitpoints":
                        if (in.peek() == JsonToken.NULL) {
                            in.nextNull();
                            builder.hitpoints(null);
                        } else
                            builder.hitpoints(in.nextInt());
                        break;
                    case "max_hit":
                        if (in.peek() == JsonToken.NULL) {
                            in.nextNull();
                            builder.maxHit(null);
                        } else
                            builder.maxHit(in.nextInt());
                        break;
                    case "attack_type":
                        in.beginArray();
                        while (in.hasNext()) {
                            builder.attackType(Collections.singletonList(in.nextString()));
                        }
                        in.endArray();
                        break;
                    case "attack_speed":
                        if (in.peek() == JsonToken.NULL) {
                            in.nextNull();
                            builder.attackSpeed(null);
                        } else
                            builder.attackSpeed(in.nextInt());
                        break;
                    case "aggressive":
                        builder.aggressive(in.nextBoolean());
                        break;
                    case "poisonous":
                        builder.poisonous(in.nextBoolean());
                        break;
                    case "venomous":
                        builder.venomous(in.nextBoolean());
                        break;
                    case "immune_poison":
                        builder.immunePoison(in.nextBoolean());
                        break;
                    case "immune_venom":
                        builder.immuneVenom(in.nextBoolean());
                        break;
                    case "attributes":
                        in.beginArray();
                        while (in.hasNext()) {
                            builder.attributes(Collections.singletonList(in.nextString()));
                        }
                        in.endArray();
                        break;
                    case "category":
                        in.beginArray();
                        while (in.hasNext()) {
                            builder.category(Collections.singletonList(in.nextString()));
                        }
                        in.endArray();
                        break;
                    case "slayer_monster":
                        builder.slayerMonster(in.nextBoolean());
                        break;
                    case "slayer_level":
                        if (in.peek() == JsonToken.NULL) {
                            in.nextNull();
                            builder.slayerLevel(null);
                        } else {
                            builder.slayerLevel(in.nextInt());
                        }
                        //builder.slayerLevel(in.nextInt());
                        break;
                    case "slayer_xp":
                        if (in.peek() == JsonToken.NULL) {
                            in.nextNull();
                            builder.slayerXp(null);
                        } else {
                            builder.slayerXp((float) in.nextDouble());
                        }
                        break;
                    case "slayer_masters":
                        in.beginArray();
                        while (in.hasNext()) {
                            builder.slayerMasters(Collections.singletonList(in.nextString()));
                        }
                        in.endArray();
                        break;
                    case "duplicate":
                        builder.duplicate(in.nextBoolean());
                        break;
                    case "examine":
                        builder.examine(in.nextString());
                        break;
                    case "wiki_name":
                        builder.wikiName(in.nextString());
                        break;
                    case "wiki_url":
                        builder.wikiUrl(in.nextString());
                        break;
                    case "attack_level":
                        builder.attackLevel(in.nextInt());
                        break;
                    case "strength_level":
                        builder.strengthLevel(in.nextInt());
                        break;
                    case "defence_level":
                        builder.defenceLevel(in.nextInt());
                        break;
                    case "magic_level":
                        builder.magicLevel(in.nextInt());
                        break;
                    case "ranged_level":
                        builder.rangedLevel(in.nextInt());
                        break;
                    case "attack_bonus":
                        builder.attackBonus(in.nextInt());
                        break;
                    case "strength_bonus":
                        builder.strengthBonus(in.nextInt());
                        break;
                    case "attack_magic":
                        builder.attackMagic(in.nextInt());
                        break;
                    case "magic_bonus":
                        builder.magicBonus(in.nextInt());
                        break;
                    case "attack_ranged":
                        builder.attackRanged(in.nextInt());
                        break;
                    case "ranged_bonus":
                        builder.rangedBonus(in.nextInt());
                        break;
                    case "defence_stab":
                        builder.defenceStab(in.nextInt());
                        break;
                    case "defence_slash":
                        builder.defenceSlash(in.nextInt());
                        break;
                    case "defence_crush":
                        builder.defenceCrush(in.nextInt());
                        break;
                    case "defence_magic":
                        builder.defenceMagic(in.nextInt());
                        break;
                    case "defence_ranged":
                        builder.defenceRanged(in.nextInt());
                        break;
                    case "drops":
                        in.beginArray();
                        while (in.hasNext()) {
                            in.beginObject();
                            int dropId = -1;
                            String dropName = null;
                            boolean dropMembers = false;
                            String dropQuantity = null;
                            boolean dropNoted = false;
                            float dropRarity = -1;
                            int dropRolls = -1;
                            while (in.hasNext()) {
                                switch (in.nextName()) {
                                    case "id":
                                        dropId = in.nextInt();
                                        break;
                                    case "name":
                                        dropName = in.nextString();
                                        break;
                                    case "members":
                                        dropMembers = in.nextBoolean();
                                        break;
                                    case "quantity":
                                        if (in.peek() == JsonToken.NULL) {
                                            in.nextNull();
                                            dropQuantity = null;
                                        } else
                                            dropQuantity = in.nextString();
                                        break;
                                    case "noted":
                                        dropNoted = in.nextBoolean();
                                        break;
                                    case "rarity":
                                        dropRarity = (float) in.nextDouble();
                                        break;
                                    case "rolls":
                                        dropRolls = in.nextInt();
                                        break;
                                    default:
                                        in.skipValue();
                                }
                            }
                            in.endObject();
                            builder.drops(Collections.singletonList(new Drop(dropId, dropName, dropMembers, dropQuantity, dropNoted, dropRarity, dropRolls)));
                        }
                        in.endArray();
                        break;
                    default:
                        in.skipValue();
                }
            }
            in.endObject();
            return builder.build();
        }
    };
    private final int id;
    private final String name;
    private final String lastUpdated;
    private final boolean incomplete;
    private final boolean members;
    private final String releaseDate;
    private final int combatLevel;
    private final int size;
    private final Integer hitpoints;
    private final Integer maxHit;
    private final List<String> attackType;
    private final Integer attackSpeed;
    private final boolean aggressive;
    private final boolean poisonous;
    private final boolean venomous;
    private final boolean immunePoison;
    private final boolean immuneVenom;
    private final List<String> attributes;
    private final List<String> category;
    private final boolean slayerMonster;
    private final Integer slayerLevel;
    private final Float slayerXp;
    private final List<String> slayerMasters;
    private final boolean duplicate;
    private final String examine;
    private final String wikiName;
    private final String wikiUrl;
    private final int attackLevel;
    private final int strengthLevel;
    private final int defenceLevel;
    private final int magicLevel;
    private final int rangedLevel;
    private final int attackBonus;
    private final int strengthBonus;
    private final int attackMagic;
    private final int magicBonus;
    private final int attackRanged;
    private final int rangedBonus;
    private final int defenceStab;
    private final int defenceSlash;
    private final int defenceCrush;
    private final int defenceMagic;
    private final int defenceRanged;
    private final List<Drop> drops;
    public Rs2NpcStats(
            int id, String name, String lastUpdated, boolean incomplete, boolean members,
            String releaseDate, int combatLevel, int size, Integer hitpoints, Integer maxHit,
            List<String> attackType, Integer attackSpeed, boolean aggressive, boolean poisonous,
            boolean venomous, boolean immunePoison, boolean immuneVenom, List<String> attributes,
            List<String> category, boolean slayerMonster, Integer slayerLevel, Float slayerXp,
            List<String> slayerMasters, boolean duplicate, String examine, String wikiName, String wikiUrl,
            int attackLevel, int strengthLevel, int defenceLevel, int magicLevel, int rangedLevel,
            int attackBonus, int strengthBonus, int attackMagic, int magicBonus, int attackRanged,
            int rangedBonus, int defenceStab, int defenceSlash, int defenceCrush, int defenceMagic,
            int defenceRanged, List<Drop> drops) {
        this.id = id;
        this.name = name;
        this.lastUpdated = lastUpdated;
        this.incomplete = incomplete;
        this.members = members;
        this.releaseDate = releaseDate;
        this.combatLevel = combatLevel;
        this.size = size;
        this.hitpoints = hitpoints;
        this.maxHit = maxHit;
        this.attackType = attackType;
        this.attackSpeed = attackSpeed;
        this.aggressive = aggressive;
        this.poisonous = poisonous;
        this.venomous = venomous;
        this.immunePoison = immunePoison;
        this.immuneVenom = immuneVenom;
        this.attributes = attributes;
        this.category = category;
        this.slayerMonster = slayerMonster;
        this.slayerLevel = slayerLevel;
        this.slayerXp = slayerXp;
        this.slayerMasters = slayerMasters;
        this.duplicate = duplicate;
        this.examine = examine;
        this.wikiName = wikiName;
        this.wikiUrl = wikiUrl;
        this.attackLevel = attackLevel;
        this.strengthLevel = strengthLevel;
        this.defenceLevel = defenceLevel;
        this.magicLevel = magicLevel;
        this.rangedLevel = rangedLevel;
        this.attackBonus = attackBonus;
        this.strengthBonus = strengthBonus;
        this.attackMagic = attackMagic;
        this.magicBonus = magicBonus;
        this.attackRanged = attackRanged;
        this.rangedBonus = rangedBonus;
        this.defenceStab = defenceStab;
        this.defenceSlash = defenceSlash;
        this.defenceCrush = defenceCrush;
        this.defenceMagic = defenceMagic;
        this.defenceRanged = defenceRanged;
        this.drops = drops;
    }
    public static Builder builder() {
        return new Builder();
    }
    @Override
    public String toString() {
        return "Rs2NpcStats{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", lastUpdated='" + lastUpdated + '\'' +
                ", incomplete=" + incomplete +
                ", members=" + members +
                ", releaseDate='" + releaseDate + '\'' +
                ", combatLevel=" + combatLevel +
                ", size=" + size +
                ", hitpoints=" + hitpoints +
                ", maxHit=" + maxHit +
                ", attackType=" + attackType +
                ", attackSpeed=" + attackSpeed +
                ", aggressive=" + aggressive +
                ", poisonous=" + poisonous +
                ", venomous=" + venomous +
                ", immunePoison=" + immunePoison +
                ", immuneVenom=" + immuneVenom +
                ", attributes=" + attributes +
                ", category=" + category +
                ", slayerMonster=" + slayerMonster +
                ", slayerLevel=" + slayerLevel +
                ", slayerXp=" + slayerXp +
                ", slayerMasters=" + slayerMasters +
                ", duplicate=" + duplicate +
                ", examine='" + examine + '\'' +
                ", wikiName='" + wikiName + '\'' +
                ", wikiUrl='" + wikiUrl + '\'' +
                ", attackLevel=" + attackLevel +
                ", strengthLevel=" + strengthLevel +
                ", defenceLevel=" + defenceLevel +
                ", magicLevel=" + magicLevel +
                ", rangedLevel=" + rangedLevel +
                ", attackBonus=" + attackBonus +
                ", strengthBonus=" + strengthBonus +
                ", attackMagic=" + attackMagic +
                ", magicBonus=" + magicBonus +
                ", attackRanged=" + attackRanged +
                ", rangedBonus=" + rangedBonus +
                ", defenceStab=" + defenceStab +
                ", defenceSlash=" + defenceSlash +
                ", defenceCrush=" + defenceCrush +
                ", defenceMagic=" + defenceMagic +
                ", defenceRanged=" + defenceRanged +
                ", drops=" + drops +
                '}';
    }
    public boolean isMembers() {
        return members;
    }
    public int getId() {
        return id;
    }
    public String getName() {
        return name;
    }
    public String getLastUpdated() {
        return lastUpdated;
    }
    public boolean isIncomplete() {
        return incomplete;
    }
    public String getReleaseDate() {
        return releaseDate;
    }
    public int getCombatLevel() {
        return combatLevel;
    }
    public int getSize() {
        return size;
    }
    public Integer getHitpoints() {
        return hitpoints;
    }
    public Integer getMaxHit() {
        return maxHit;
    }
    public List<String> getAttackType() {
        return attackType;
    }
    public Integer getAttackSpeed() {
        return attackSpeed;
    }
    public boolean isAggressive() {
        return aggressive;
    }
    public boolean isPoisonous() {
        return poisonous;
    }
    public boolean isVenomous() {
        return venomous;
    }
    public boolean isImmunePoison() {
        return immunePoison;
    }
    public boolean isImmuneVenom() {
        return immuneVenom;
    }
    public List<String> getAttributes() {
        return attributes;
    }
    public List<String> getCategory() {
        return category;
    }
    public boolean isSlayerMonster() {
        return slayerMonster;
    }
    public Integer getSlayerLevel() {
        return slayerLevel;
    }
    public Float getSlayerXp() {
        return slayerXp;
    }
    public List<String> getSlayerMasters() {
        return slayerMasters;
    }
    public boolean isDuplicate() {
        return duplicate;
    }
    public String getExamine() {
        return examine;
    }
    public String getWikiName() {
        return wikiName;
    }
    public String getWikiUrl() {
        return wikiUrl;
    }
    public int getAttackLevel() {
        return attackLevel;
    }
    public int getStrengthLevel() {
        return strengthLevel;
    }
    public int getDefenceLevel() {
        return defenceLevel;
    }
    public int getMagicLevel() {
        return magicLevel;
    }
    public int getRangedLevel() {
        return rangedLevel;
    }
    public int getAttackBonus() {
        return attackBonus;
    }
    public int getStrengthBonus() {
        return strengthBonus;
    }
    public int getAttackMagic() {
        return attackMagic;
    }
    public int getMagicBonus() {
        return magicBonus;
    }
    public int getAttackRanged() {
        return attackRanged;
    }
    public int getRangedBonus() {
        return rangedBonus;
    }
    public int getDefenceStab() {
        return defenceStab;
    }
    public int getDefenceSlash() {
        return defenceSlash;
    }
    public int getDefenceCrush() {
        return defenceCrush;
    }
    public int getDefenceMagic() {
        return defenceMagic;
    }
    public int getDefenceRanged() {
        return defenceRanged;
    }
    public List<Drop> getDrops() {
        return drops;
    }
    public double calculateXpModifier() {
        double averageLevel = Math.floor((this.attackLevel + this.strengthLevel + this.defenceLevel + this.hitpoints) / 4);
        double averageDefBonus = Math.floor((this.defenceStab + this.defenceSlash + this.defenceCrush) / 3);
        return 1.0 + Math.floor(averageLevel * (averageDefBonus + (double) this.strengthBonus + (double) this.attackBonus) / 5120.0) / 40.0;
    }
    // Define the Drop class similarly to the original
    public static final class Drop {
        private final int id;
        private final String name;
        private final boolean members;
        private final String quantity;
        private final boolean noted;
        private final float rarity;
        private final int rolls;
        public Drop(int id, String name, boolean members, String quantity, boolean noted, float rarity, int rolls) {
            this.id = id;
            this.name = name;
            this.members = members;
            this.quantity = quantity;
            this.noted = noted;
            this.rarity = rarity;
            this.rolls = rolls;
        }
        // Add getter methods for Drop fields here
    }
    public static final class Builder {
        private int id;
        private String name;
        private String lastUpdated;
        private boolean incomplete;
        private boolean members;
        private String releaseDate;
        private int combatLevel;
        private int size;
        private Integer hitpoints;
        private Integer maxHit;
        private List<String> attackType;
        private Integer attackSpeed;
        private boolean aggressive;
        private boolean poisonous;
        private boolean venomous;
        private boolean immunePoison;
        private boolean immuneVenom;
        private List<String> attributes;
        private List<String> category;
        private boolean slayerMonster;
        private Integer slayerLevel;
        private Float slayerXp;
        private List<String> slayerMasters;
        private boolean duplicate;
        private String examine;
        private String wikiName;
        private String wikiUrl;
        private int attackLevel;
        private int strengthLevel;
        private int defenceLevel;
        private int magicLevel;
        private int rangedLevel;
        private int attackBonus;
        private int strengthBonus;
        private int attackMagic;
        private int magicBonus;
        private int attackRanged;
        private int rangedBonus;
        private int defenceStab;
        private int defenceSlash;
        private int defenceCrush;
        private int defenceMagic;
        private int defenceRanged;
        private List<Drop> drops;
        // Builder methods for all fields
        public Builder id(int id) {
            this.id = id;
            return this;
        }
        public Builder name(String name) {
            this.name = name;
            return this;
        }
        public Builder lastUpdated(String lastUpdated) {
            this.lastUpdated = lastUpdated;
            return this;
        }
        public Builder incomplete(boolean incomplete) {
            this.incomplete = incomplete;
            return this;
        }
        public Builder members(boolean members) {
            this.members = members;
            return this;
        }
        public Builder releaseDate(String releaseDate) {
            this.releaseDate = releaseDate;
            return this;
        }
        public Builder combatLevel(int combatLevel) {
            this.combatLevel = combatLevel;
            return this;
        }
        public Builder size(int size) {
            this.size = size;
            return this;
        }
        public Builder hitpoints(Integer hitpoints) {
            this.hitpoints = hitpoints;
            return this;
        }
        public Builder maxHit(Integer maxHit) {
            this.maxHit = maxHit;
            return this;
        }
        public Builder attackType(List<String> attackType) {
            this.attackType = attackType;
            return this;
        }
        public Builder attackSpeed(Integer attackSpeed) {
            this.attackSpeed = attackSpeed;
            return this;
        }
        public Builder aggressive(boolean aggressive) {
            this.aggressive = aggressive;
            return this;
        }
        public Builder poisonous(boolean poisonous) {
            this.poisonous = poisonous;
            return this;
        }
        public Builder venomous(boolean venomous) {
            this.venomous = venomous;
            return this;
        }
        public Builder immunePoison(boolean immunePoison) {
            this.immunePoison = immunePoison;
            return this;
        }
        public Builder immuneVenom(boolean immuneVenom) {
            this.immuneVenom = immuneVenom;
            return this;
        }
        public Builder attributes(List<String> attributes) {
            this.attributes = attributes;
            return this;
        }
        public Builder category(List<String> category) {
            this.category = category;
            return this;
        }
        public Builder slayerMonster(boolean slayerMonster) {
            this.slayerMonster = slayerMonster;
            return this;
        }
        public Builder slayerLevel(Integer slayerLevel) {
            this.slayerLevel = slayerLevel;
            return this;
        }
        public Builder slayerXp(Float slayerXp) {
            this.slayerXp = slayerXp;
            return this;
        }
        public Builder slayerMasters(List<String> slayerMasters) {
            this.slayerMasters = slayerMasters;
            return this;
        }
        public Builder duplicate(boolean duplicate) {
            this.duplicate = duplicate;
            return this;
        }
        public Builder examine(String examine) {
            this.examine = examine;
            return this;
        }
        public Builder wikiName(String wikiName) {
            this.wikiName = wikiName;
            return this;
        }
        public Builder wikiUrl(String wikiUrl) {
            this.wikiUrl = wikiUrl;
            return this;
        }
        public Builder attackLevel(int attackLevel) {
            this.attackLevel = attackLevel;
            return this;
        }
        public Builder strengthLevel(int strengthLevel) {
            this.strengthLevel = strengthLevel;
            return this;
        }
        public Builder defenceLevel(int defenceLevel) {
            this.defenceLevel = defenceLevel;
            return this;
        }
        public Builder magicLevel(int magicLevel) {
            this.magicLevel = magicLevel;
            return this;
        }
        public Builder rangedLevel(int rangedLevel) {
            this.rangedLevel = rangedLevel;
            return this;
        }
        public Builder attackBonus(int attackBonus) {
            this.attackBonus = attackBonus;
            return this;
        }
        public Builder strengthBonus(int strengthBonus) {
            this.strengthBonus = strengthBonus;
            return this;
        }
        public Builder attackMagic(int attackMagic) {
            this.attackMagic = attackMagic;
            return this;
        }
        public Builder magicBonus(int magicBonus) {
            this.magicBonus = magicBonus;
            return this;
        }
        public Builder attackRanged(int attackRanged) {
            this.attackRanged = attackRanged;
            return this;
        }
        public Builder rangedBonus(int rangedBonus) {
            this.rangedBonus = rangedBonus;
            return this;
        }
        public Builder defenceStab(int defenceStab) {
            this.defenceStab = defenceStab;
            return this;
        }
        public Builder defenceSlash(int defenceSlash) {
            this.defenceSlash = defenceSlash;
            return this;
        }
        public Builder defenceCrush(int defenceCrush) {
            this.defenceCrush = defenceCrush;
            return this;
        }
        public Builder defenceMagic(int defenceMagic) {
            this.defenceMagic = defenceMagic;
            return this;
        }
        public Builder defenceRanged(int defenceRanged) {
            this.defenceRanged = defenceRanged;
            return this;
        }
        public Builder drops(List<Drop> drops) {
            this.drops = drops;
            return this;
        }
        public Rs2NpcStats build() {
            return new Rs2NpcStats(
                    id, name, lastUpdated, incomplete, members, releaseDate, combatLevel, size, hitpoints, maxHit,
                    attackType, attackSpeed, aggressive, poisonous, venomous, immunePoison, immuneVenom, attributes,
                    category, slayerMonster, slayerLevel, slayerXp, slayerMasters, duplicate, examine, wikiName, wikiUrl,
                    attackLevel, strengthLevel, defenceLevel, magicLevel, rangedLevel, attackBonus, strengthBonus,
                    attackMagic, magicBonus, attackRanged, rangedBonus, defenceStab, defenceSlash, defenceCrush,
                    defenceMagic, defenceRanged, drops
            );
        }
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/player/NameGenerator.java
================
package net.runelite.client.plugins.microbot.util.player;
import java.util.Calendar;
import java.util.Random;
/**
 * Just did it for fun. :|
 *
 * @author amit
 *
 */
public class NameGenerator {
    private static final int diffBetweenAtoZ = 25;
    private static final int charValueOfa = 97;
    private String lastGeneratedName = "";
    int length;
    char[] vowels = {
            'a', 'e', 'i', 'o', 'u'
    };
    public NameGenerator(int lengthOfName) {
        if (lengthOfName < 5 || lengthOfName > 10) {
            System.out.println("Setting default length to 7");
            lengthOfName = 7;
        }
        this.length = lengthOfName;
    }
    public String getName() {
        for (;;) {
            Random randomNumberGenerator = new Random(Calendar.getInstance()
                    .getTimeInMillis());
            char[] nameInCharArray = new char[length];
            for (int i = 0; i < length; i++) {
                if (positionIsOdd(i)) {
                    nameInCharArray[i] = getVowel(randomNumberGenerator);
                } else {
                    nameInCharArray[i] = getConsonant(randomNumberGenerator);
                }
            }
            nameInCharArray[0] = Character
                    .toUpperCase(nameInCharArray[0]);
            String currentGeneratedName = new String(nameInCharArray);
            if (!currentGeneratedName.equals(lastGeneratedName)) {
                lastGeneratedName = currentGeneratedName;
                return currentGeneratedName;
            }
        }
    }
    private boolean positionIsOdd(int i) {
        return i % 2 == 0;
    }
    private char getConsonant(Random randomNumberGenerator) {
        for (;;) {
            char currentCharacter = (char) (randomNumberGenerator
                    .nextInt(diffBetweenAtoZ) + charValueOfa);
            if (currentCharacter == 'a' || currentCharacter == 'e'
                    || currentCharacter == 'i' || currentCharacter == 'o'
                    || currentCharacter == 'u')
                continue;
            else
                return currentCharacter;
        }
    }
    private char getVowel(Random randomNumberGenerator) {
        return vowels[randomNumberGenerator.nextInt(vowels.length)];
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/player/Rs2Player.java
================
package net.runelite.client.plugins.microbot.util.player;
import lombok.Getter;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.AnimationChanged;
import net.runelite.api.events.VarbitChanged;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.globval.VarbitValues;
import net.runelite.client.plugins.microbot.util.equipment.Rs2Equipment;
import net.runelite.client.plugins.microbot.util.gameobject.Rs2GameObject;
import net.runelite.client.plugins.microbot.util.grounditem.Rs2GroundItem;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Item;
import net.runelite.client.plugins.microbot.util.math.Random;
import net.runelite.client.plugins.microbot.util.menu.NewMenuEntry;
import net.runelite.client.plugins.microbot.util.security.Login;
import net.runelite.client.plugins.microbot.util.walker.Rs2Walker;
import net.runelite.client.plugins.microbot.util.widget.Rs2Widget;
import java.awt.*;
import java.time.Duration;
import java.time.Instant;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;
import static net.runelite.api.MenuAction.CC_OP;
import static net.runelite.client.plugins.microbot.util.Global.*;
public class Rs2Player {
    static int VENOM_VALUE_CUTOFF = -38;
    private static int antiFireTime = -1;
    private static int superAntiFireTime = -1;
    private static int divineRangedTime = -1;
    private static int divineBastionTime = -1;
    public static int antiVenomTime = -1;
    public static int staminaBuffTime = -1;
    public static int antiPoisonTime = -1;
    public static Instant lastAnimationTime = null;
    @Getter
    public static int lastAnimationID = AnimationID.IDLE;
    public static boolean hasAntiFireActive() {
        return antiFireTime > 0 || hasSuperAntiFireActive();
    }
    public static boolean hasSuperAntiFireActive() {
        return superAntiFireTime > 0;
    }
    public static boolean hasDivineRangedActive() {
        return divineRangedTime > 0 || hasDivineBastionActive();
    }
    public static boolean hasRangingPotionActive() {
        return Microbot.getClient().getBoostedSkillLevel(Skill.RANGED) - 5 > Microbot.getClient().getRealSkillLevel(Skill.RANGED);
    }
    public static boolean hasDivineBastionActive() {
        return divineBastionTime > 0;
    }
    public static boolean hasAntiVenomActive() {
        if (Rs2Equipment.isWearing("serpentine helm")) {
            return true;
        } else return antiVenomTime < VENOM_VALUE_CUTOFF;
    }
    public static boolean hasAntiPoisonActive() {
        return antiPoisonTime > 0;
    }
    public static boolean hasStaminaBuffActive() {
        return staminaBuffTime > 0;
    }
    private static final Map<Player, Long> playerDetectionTimes = new ConcurrentHashMap<>();
    public static void handlePotionTimers(VarbitChanged event) {
        if (event.getVarbitId() == Varbits.ANTIFIRE) {
            antiFireTime = event.getValue();
        }
        if (event.getVarbitId() == Varbits.SUPER_ANTIFIRE) {
            superAntiFireTime = event.getValue();
        }
        if (event.getVarbitId() == Varbits.DIVINE_RANGING) {
            divineRangedTime = event.getValue();
        }
        if (event.getVarbitId() == Varbits.DIVINE_BASTION) {
            divineBastionTime = event.getValue();
        }
        if (event.getVarbitId() == Varbits.STAMINA_EFFECT) {
            staminaBuffTime = event.getValue();
        }
        if (event.getVarpId() == VarPlayer.POISON) {
            if (event.getValue() >= VENOM_VALUE_CUTOFF) {
                antiVenomTime = 0;
            } else {
                antiVenomTime = event.getValue();
            }
            final int poisonVarp = event.getValue();
            if (poisonVarp == 0) {
                antiPoisonTime = -1;
            } else {
                antiPoisonTime = poisonVarp;
            }
        }
    }
    public static void handleAnimationChanged(AnimationChanged event) {
        if (!(event.getActor() instanceof Player)) {
            return;
        }
        Player player = (Player) event.getActor();
        if (player != Microbot.getClient().getLocalPlayer()) {
            return;
        }
        if (player.getAnimation() != AnimationID.IDLE) {
            lastAnimationTime = Instant.now();
            lastAnimationID = player.getAnimation();
        }
    }
    /**
     * Wait for walking
     */
    public static void waitForWalking() {
        boolean result = sleepUntilTrue(Rs2Player::isWalking, 100, 5000);
        if (!result) return;
        sleepUntil(() -> !Rs2Player.isWalking());
    }
    /**
     * Wait for walking in time
     *
     * @param time
     */
    public static void waitForWalking(int time) {
        boolean result = sleepUntilTrue(Rs2Player::isWalking, 100, time);
        if (!result) return;
        sleepUntil(() -> !Rs2Player.isWalking(), time);
    }
    /**
     * Wait for XP Drop
     *
     * @param skill
     *
     * @return
     */
    public static boolean waitForXpDrop(Skill skill) {
        return waitForXpDrop(skill, 5000, false);
    }
    /**
     * Wait for XP Drop or if inventory is full
     *
     * @param skill
     * @param time
     *
     * @return
     */
    public static boolean waitForXpDrop(Skill skill, int time) {
        return waitForXpDrop(skill, time, false);
    }
    /**
     * Wait for XP Drop or if inventory is full
     *
     * @param skill
     * @param inventoryFullCheck
     *
     * @return
     */
    public static boolean waitForXpDrop(Skill skill, boolean inventoryFullCheck) {
        return waitForXpDrop(skill, 5000, inventoryFullCheck);
    }
    /**
     * Wait for XP Drop in time or if inventory is full
     *
     * @param skill
     * @param time
     * @param inventoryFullCheck
     *
     * @return
     */
    public static boolean waitForXpDrop(Skill skill, int time, boolean inventoryFullCheck) {
        final int skillExp = Microbot.getClient().getSkillExperience(skill);
        return sleepUntilTrue(() -> skillExp != Microbot.getClient().getSkillExperience(skill) || (inventoryFullCheck && Rs2Inventory.isFull()), 100, time);
    }
    /**
     * Wait for animation
     */
    public static void waitForAnimation() {
        boolean result = sleepUntilTrue(Rs2Player::isAnimating, 100, 5000);
        if (!result) return;
        sleepUntil(() -> !Rs2Player.isAnimating());
    }
    /**
     * Wait for animation
     *
     * @param time
     */
    public static void waitForAnimation(int time) {
        boolean result = sleepUntilTrue(Rs2Player::isAnimating, 100, time);
        if (!result) return;
        sleepUntil(() -> !Rs2Player.isAnimating(), time);
    }
    /**
     * Chek if the player is animating within the past ms
     *
     * @param ms
     *
     * @return
     */
    public static boolean isAnimating(int ms) {
        return (lastAnimationTime != null && Duration.between(lastAnimationTime, Instant.now()).toMillis() < ms) || getAnimation() != AnimationID.IDLE;
    }
    /**
     * Check if the player is animating within the past 600ms
     *
     * @return
     */
    public static boolean isAnimating() {
        return isAnimating(600);
    }
    /**
     * Check if the player is walking
     *
     * @return
     */
    public static boolean isWalking() {
        return Rs2Player.isMoving();
    }
    /**
     * Checks if the player is moving
     *
     * @return
     */
    public static boolean isMoving() {
        return Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getLocalPlayer().getPoseAnimation()
                != Microbot.getClient().getLocalPlayer().getIdlePoseAnimation());
    }
    /**
     * Checks if the player is interacting
     *
     * @return
     */
    public static boolean isInteracting() {
        return Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getLocalPlayer().isInteracting());
    }
    /**
     * Checks if the player is a member
     *
     * @return
     */
    public static boolean isMember() {
        return Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getVarpValue(VarPlayer.MEMBERSHIP_DAYS) > 0);
    }
    @Deprecated(since = "Use the Rs2Combat.specState method", forRemoval = true)
    public static void toggleSpecialAttack(int energyRequired) {
        int currentSpecEnergy = Microbot.getClient().getVarpValue(VarPlayer.SPECIAL_ATTACK_PERCENT);
        if (currentSpecEnergy >= energyRequired && (Microbot.getClient().getVarpValue(VarPlayer.SPECIAL_ATTACK_ENABLED) == 0)) {
            Rs2Widget.clickWidget("special attack");
        }
    }
    /**
     * Toggles player run
     *
     * @param toggle
     *
     * @return
     */
    public static boolean toggleRunEnergy(boolean toggle) {
        if (Microbot.getVarbitPlayerValue(173) == 0 && !toggle) return true;
        if (Microbot.getVarbitPlayerValue(173) == 1 && toggle) return true;
        Widget widget = Rs2Widget.getWidget(WidgetInfo.MINIMAP_TOGGLE_RUN_ORB.getId());
        if (widget == null) return false;
        if (Microbot.getClient().getEnergy() > 1000 && toggle) {
            Microbot.getMouse().click(widget.getCanvasLocation());
            sleep(150, 300);
            return true;
        } else if (!toggle) {
            Microbot.getMouse().click(widget.getCanvasLocation());
            sleep(150, 300);
            return true;
        }
        return false;
    }
    /**
     * Checks if run is enabled
     *
     * @return
     */
    public static boolean isRunEnabled() {
        return Microbot.getVarbitPlayerValue(173) == 1;
    }
    /**
     * Logs the player out of the game
     */
    public static void logout() {
        if (Microbot.isLoggedIn()) {
            //logout from main tab
            Microbot.doInvoke(new NewMenuEntry(-1, 11927560, CC_OP.getId(), 1, -1, "Logout"), new Rectangle(1, 1, Microbot.getClient().getCanvasWidth(), Microbot.getClient().getCanvasHeight()));
            //logout from world hopper
            Microbot.doInvoke(new NewMenuEntry(-1, 4522009, CC_OP.getId(), 1, -1, "Logout"), new Rectangle(1, 1, Microbot.getClient().getCanvasWidth(), Microbot.getClient().getCanvasHeight()));
        }
        //Rs2Reflection.invokeMenu(-1, 11927560, CC_OP.getId(), 1, -1, "Logout", "", -1, -1);
    }
    /**
     * Logouts out the player is found in an area around the player for time
     *
     * @param amountOfPlayers to detect before triggering logout
     * @param time            in milliseconds
     * @param distance        from the player
     *
     * @return
     */
    public static boolean logoutIfPlayerDetected(int amountOfPlayers, int time, int distance) {
        List<Player> players = getPlayers();
        long currentTime = System.currentTimeMillis();
        if (distance > 0) {
            players = players.stream()
                    .filter(x -> x != null && x.getWorldLocation().distanceTo(Rs2Player.getWorldLocation()) <= distance)
                    .collect(Collectors.toList());
        }
        if (time > 0 && players.size() > amountOfPlayers) {
            // Update detection times for currently detected players
            for (Player player : players) {
                playerDetectionTimes.putIfAbsent(player, currentTime);
            }
            // Remove players who are no longer detected
            playerDetectionTimes.keySet().retainAll(players);
            // Check if any player has been detected for longer than the specified time
            for (Player player : players) {
                long detectionTime = playerDetectionTimes.getOrDefault(player, 0L);
                if (currentTime - detectionTime >= time) { // convert time to milliseconds
                    logout();
                    return true;
                }
            }
        } else if (players.size() >= amountOfPlayers) {
            logout();
            return true;
        }
        return false;
    }
    /**
     * @param amountOfPlayers
     * @param time
     *
     * @return
     */
    public static boolean logoutIfPlayerDetected(int amountOfPlayers, int time) {
        return logoutIfPlayerDetected(amountOfPlayers, time, 0);
    }
    /**
     * @param amountOfPlayers
     *
     * @return
     */
    public static boolean logoutIfPlayerDetected(int amountOfPlayers) {
        return logoutIfPlayerDetected(amountOfPlayers, 0, 0);
    }
    /**
     * Hop if player is detected
     *
     * @param amountOfPlayers, time, distance
     *
     * @return true if player is detected and hopped
     */
    public static boolean hopIfPlayerDetected(int amountOfPlayers, int time, int distance) {
        List<Player> players = getPlayers();
        long currentTime = System.currentTimeMillis();
        if (distance > 0) {
            players = players.stream()
                    .filter(x -> x != null && x.getWorldLocation().distanceTo(Rs2Player.getWorldLocation()) <= distance)
                    .collect(Collectors.toList());
        }
        if (time > 0 && players.size() >= amountOfPlayers) {
            // Update detection times for currently detected players
            for (Player player : players) {
                playerDetectionTimes.putIfAbsent(player, currentTime);
            }
            // Remove players who are no longer detected
            playerDetectionTimes.keySet().retainAll(players);
            // Check if any player has been detected for longer than the specified time
            for (Player player : players) {
                long detectionTime = playerDetectionTimes.getOrDefault(player, 0L);
                if (currentTime - detectionTime >= time) { // convert time to milliseconds
                    int randomWorld = Login.getRandomWorld(isMember());
                    Microbot.hopToWorld(randomWorld);
                    return true;
                }
            }
        } else if (players.size() >= amountOfPlayers) {
            int randomWorld = Login.getRandomWorld(isMember());
            Microbot.hopToWorld(randomWorld);
            return true;
        }
        return false;
    }
    /**
     * Eat food at a certain health percentage, will search inventory for first possible food item.
     *
     * @param percentage
     *
     * @return
     */
    public static boolean eatAt(int percentage) {
        double treshHold = (double) (Microbot.getClient().getBoostedSkillLevel(Skill.HITPOINTS) * 100) / Microbot.getClient().getRealSkillLevel(Skill.HITPOINTS);
        if (treshHold <= percentage) {
            List<Rs2Item> foods = Rs2Inventory.getInventoryFood();
            if (!foods.isEmpty()) {
                if (foods.get(0).getName().toLowerCase().contains("jug of wine")) {
                    return Rs2Inventory.interact(foods.get(0), "drink");
                } else {
                    return Rs2Inventory.interact(foods.get(0), "eat");
                }
            }
        }
        return false;
    }
    public static List<Player> getPlayers() {
        return Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getPlayers()
                .stream()
                .filter(x -> x != Microbot.getClient().getLocalPlayer())
                .collect(Collectors.toList()));
    }
    /**
     * Gets the players current world location
     *
     * @return worldpoint
     */
    public static WorldPoint getWorldLocation() {
        if (Microbot.getClient().isInInstancedRegion()) {
            LocalPoint l = LocalPoint.fromWorld(Microbot.getClient(), Microbot.getClient().getLocalPlayer().getWorldLocation());
            WorldPoint playerInstancedWorldLocation = WorldPoint.fromLocalInstance(Microbot.getClient(), l);
            return playerInstancedWorldLocation;
        } else {
            return Microbot.getClient().getLocalPlayer().getWorldLocation();
        }
    }
    /**
     * Checks if the player is near a worldpoint
     *
     * @return
     */
    public static boolean isNearArea(WorldPoint worldPoint, int distance) {
        WorldArea worldArea = new WorldArea(worldPoint, distance, distance);
        return worldArea.contains(getWorldLocation());
    }
    /**
     * Gets the player's local point (commonly used in instanced areas)
     *
     * @return localpoint
     */
    public static LocalPoint getLocalLocation() {
        return Microbot.getClient().getLocalPlayer().getLocalLocation();
    }
    /**
     * Checks if the player has full health
     *
     * @return
     */
    public static boolean isFullHealth() {
        return Microbot.getClient().getBoostedSkillLevel(Skill.HITPOINTS) >= Microbot.getClient().getRealSkillLevel(Skill.HITPOINTS);
    }
    /**
     * Checks if the player is in multi-combat area
     *
     * @return
     */
    public static boolean isInMulti() {
        return Microbot.getVarbitValue(Varbits.MULTICOMBAT_AREA) == VarbitValues.INSIDE_MULTICOMBAT_ZONE.getValue();
    }
    /**
     * Drink prayer potion at prayer point level
     *
     * @param prayerPoints
     *
     * @return
     */
    public static boolean drinkPrayerPotionAt(int prayerPoints) {
        if (Microbot.getClient().getBoostedSkillLevel(Skill.PRAYER) <= prayerPoints) {
            return Rs2Inventory.interact("prayer potion", "drink");
        }
        return false;
    }
    /**
     * Checks if the player has prayer points remaining
     *
     * @return
     */
    public static boolean hasPrayerPoints() {
        return Microbot.getClient().getBoostedSkillLevel(Skill.PRAYER) > 0;
    }
    /**
     * Checks if the player is standing on a game object
     *
     * @return
     */
    public static boolean isStandingOnGameObject() {
        WorldPoint playerPoint = getWorldLocation();
        return Rs2GameObject.getGameObject(playerPoint) != null && Rs2GroundItem.getAllAt(getWorldLocation().getX(), getWorldLocation().getY()) != null;
    }
    /**
     * Checks if the player is standing on a ground item
     *
     * @return
     */
    public static boolean isStandingOnGroundItem() {
        WorldPoint playerPoint = getWorldLocation();
        return Arrays.stream(Rs2GroundItem.getAllAt(playerPoint.getX(), playerPoint.getY())).findAny().isPresent();
    }
    /**
     * Gets the player's current animation ID
     *
     * @return
     */
    public static int getAnimation() {
        if (Microbot.getClient().getLocalPlayer() == null) return -1;
        return Microbot.getClient().getLocalPlayer().getAnimation();
    }
    /**
     * Gets player's current pose animation ID
     *
     * @return
     */
    public static int getPoseAnimation() {
        return Microbot.getClient().getLocalPlayer().getPoseAnimation();
    }
    /**
     * Gets player's current QuestState for quest
     *
     * @param quest
     *
     * @return queststate
     */
    public static QuestState getQuestState(Quest quest) {
        Client client = Microbot.getClient();
        return Microbot.getClientThread().runOnClientThread(() -> quest.getState(client));
    }
    /**
     * Gets player's real level for skill
     *
     * @param skill
     *
     * @return level
     */
    public static int getRealSkillLevel(Skill skill) {
        return Microbot.getClient().getRealSkillLevel(skill);
    }
    /**
     * Gets player's boosted level for skill
     *
     * @param skill
     *
     * @return level
     */
    public static int getBoostedSkillLevel(Skill skill) {
        return Microbot.getClient().getBoostedSkillLevel(skill);
    }
    /**
     * Check if the player meets the level requirement for skill
     *
     * @param skill
     * @param levelRequired
     * @param isBoosted
     *
     * @return
     */
    public static boolean getSkillRequirement(Skill skill, int levelRequired, boolean isBoosted) {
        if (isBoosted) return getBoostedSkillLevel(skill) >= levelRequired;
        return getRealSkillLevel(skill) >= levelRequired;
    }
    /**
     * Check if the player meets the level requirement for skill
     *
     * @param skill
     * @param levelRequired
     *
     * @return
     */
    public static boolean getSkillRequirement(Skill skill, int levelRequired) {
        return getSkillRequirement(skill, levelRequired, false);
    }
    /**
     * Checks if the player is ironman or hardcore ironman
     *
     * @return
     */
    public static boolean isIronman() {
        int accountType = Microbot.getVarbitValue(Varbits.ACCOUNT_TYPE);
        return accountType > 0 && accountType <= 3;
    }
    /**
     * Check if the player is group ironman
     *
     * @return
     */
    public static boolean isGroupIronman() {
        int accountType = Microbot.getVarbitValue(Varbits.ACCOUNT_TYPE);
        return accountType >= 4;
    }
    /**
     * Gets the players current world
     *
     * @return world
     */
    public static int getWorld() {
        return Microbot.getClient().getWorld();
    }
    /**
     * Gets the distance from current player location to endpoint using ShortestPath (does not work in instanced regions)
     *
     * @param endpoint
     *
     * @return distance
     */
    public static int distanceTo(WorldPoint endpoint) {
        if (Microbot.getClient().isInInstancedRegion()) {
            return getWorldLocation().distanceTo(endpoint);
        }
        return Rs2Walker.getDistanceBetween(getWorldLocation(), endpoint);
    }
    /**
     * Checks whether a player is about to logout
     *
     * @return
     */
    public static boolean checkIdleLogout() {
        int idleClientTicks = Microbot.getClient().getKeyboardIdleTicks();
        return (long) idleClientTicks >= Random.randomDelay();
    }
    /**
     * Checks whether a player is about to logout
     *
     * @param randomDelay
     *
     * @return
     */
    public static boolean checkIdleLogout(long randomDelay) {
        int idleClientTicks = Microbot.getClient().getKeyboardIdleTicks();
        return (long) idleClientTicks >= randomDelay;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/player/Rs2Pvp.java
================
package net.runelite.client.plugins.microbot.util.player;/*
 * Copyright (c) 2019, PKLite
 * Copyright (c) 2020, ThatGamerBlue <thatgamerblue@gmail.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
import net.runelite.api.*;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.geometry.Cuboid;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.util.QuantityFormatter;
import org.apache.commons.lang3.ArrayUtils;
import java.awt.*;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import java.util.TreeMap;
public class Rs2Pvp {
    private static final Polygon NOT_WILDERNESS_BLACK_KNIGHTS = new Polygon( // this is black knights castle
            new int[]{2994, 2995, 2996, 2996, 2994, 2994, 2997, 2998, 2998, 2999, 3000, 3001, 3002, 3003, 3004, 3005, 3005,
                    3005, 3019, 3020, 3022, 3023, 3024, 3025, 3026, 3026, 3027, 3027, 3028, 3028, 3029, 3029, 3030, 3030, 3031,
                    3031, 3032, 3033, 3034, 3035, 3036, 3037, 3037},
            new int[]{3525, 3526, 3527, 3529, 3529, 3534, 3534, 3535, 3536, 3537, 3538, 3539, 3540, 3541, 3542, 3543, 3544,
                    3545, 3545, 3546, 3546, 3545, 3544, 3543, 3543, 3542, 3541, 3540, 3539, 3537, 3536, 3535, 3534, 3533, 3532,
                    3531, 3530, 3529, 3528, 3527, 3526, 3526, 3525},
            43
    );
    private static final Cuboid MAIN_WILDERNESS_CUBOID = new Cuboid(2944, 3525, 0, 3391, 4351, 3);
    private static final Cuboid GOD_WARS_WILDERNESS_CUBOID = new Cuboid(3008, 10112, 0, 3071, 10175, 3);
    private static final Cuboid WILDERNESS_UNDERGROUND_CUBOID = new Cuboid(2944, 9920, 0, 3455, 10879, 3);
    private static final Cuboid HUNTERS_END = new Cuboid(1728, 11520, 0, 1791, 11583, 3);
    private static final Cuboid SKELETAL_TOMB = new Cuboid(1856, 11520, 0, 1919, 11583, 3);
    private static final Cuboid WEB_CHASM = new Cuboid(1600, 11520, 0, 1663, 11583, 3);
    private static final Cuboid CALLISTOS_DEN = new Cuboid(3328, 10304, 0, 3391, 10367, 3);
    private static final Cuboid SILK_CHASM = new Cuboid(3392, 10176, 0, 3455, 10239, 3);
    private static final Cuboid VETIONS_REST = new Cuboid(3264, 10176, 0, 3327, 10239, 3);
    private static final Cuboid WILDERNESS_ESCAPE_CAVES = new Cuboid(3328, 10240, 0, 3391, 10303, 3);
    private static final Cuboid WILDERNESS_BH_CRATER = new Cuboid(3328, 3968, 0, 3519, 4159, 3);
    private static final Cuboid WILDERNESS_BH_CRATER_TWO = new Cuboid(3413, 4053, 0, 3434, 4074, 3);
    /**
     * Gets the wilderness level based on a world point
     * Java reimplementation of clientscript 384 [proc,wilderness_level]
     *
     * @param point the point in the world to get the wilderness level for
     * @return the int representing the wilderness level
     */
    public static int getWildernessLevelFrom(WorldPoint point) {
        int regionID = point.getRegionID();
        if (regionID != 12700 && regionID != 12187) {
            if (WILDERNESS_BH_CRATER.contains(point) && !WILDERNESS_BH_CRATER_TWO.contains(point)) {
                return 5;
            } else if (MAIN_WILDERNESS_CUBOID.contains(point)) {
                return NOT_WILDERNESS_BLACK_KNIGHTS.contains(point.getX(), point.getY()) ? 0 : (point.getY() - 3520) / 8 + 1;
            } else if (GOD_WARS_WILDERNESS_CUBOID.contains(point)) {
                return (point.getY() - 9920) / 8 - 1;
            } else if (VETIONS_REST.contains(point)) {
                return 35;
            } else if (SILK_CHASM.contains(point)) {
                return 35;
            } else if (CALLISTOS_DEN.contains(point)) {
                return 40;
            } else if (HUNTERS_END.contains(point)) {
                return 21;
            } else if (SKELETAL_TOMB.contains(point)) {
                return 21;
            } else if (WEB_CHASM.contains(point)) {
                return 29;
            } else if (WILDERNESS_ESCAPE_CAVES.contains(point)) {
                return 33 + (point.getY() % 64 - 6) * 7 / 50;
            } else {
                return WILDERNESS_UNDERGROUND_CUBOID.contains(point) ? (point.getY() - 9920) / 8 + 1 : 0;
            }
        } else {
            return 0;
        }
    }
    /**
     * Determines if another player is attackable based off of wilderness level and combat levels
     *
     * @param player the player to determine attackability
     * @return returns true if the player is attackable, false otherwise
     */
    public static boolean isAttackable(Player player) {
        int wildernessLevel = 0;
        if (WorldType.isDeadmanWorld(Microbot.getClient().getWorldType())) {
            return true;
        }
        if (WorldType.isPvpWorld(Microbot.getClient().getWorldType())) {
            wildernessLevel += 15;
        }
        if (Microbot.getVarbitValue(Varbits.IN_WILDERNESS) == 1) {
            wildernessLevel += getWildernessLevelFrom(Microbot.getClient().getLocalPlayer().getWorldLocation());
        }
        return wildernessLevel != 0 && Math.abs(Microbot.getClient().getLocalPlayer().getCombatLevel() - player.getCombatLevel()) <= wildernessLevel;
    }
    /**
     * Determines if another player is attackable based off of wilderness level and combat levels
     *
     * @param player the player to determine attackability
     * @return returns true if the player is attackable, false otherwise
     */
    public static boolean isAttackable(Player player, boolean isDeadManworld, boolean isPvpWorld, int wildernessLevel) {
        return wildernessLevel != 0 && Math.abs(Microbot.getClient().getLocalPlayer().getCombatLevel() - player.getCombatLevel()) <= wildernessLevel;
    }
    /**
     * Determines if any player is attackable based off of wilderness level and combat levels
     * @return
     */
    public static boolean isAttackable() {
        List<Player> players = Rs2Player.getPlayers();
        int wildernessLevel = 0;
        boolean isDeadManWorld = WorldType.isDeadmanWorld(Microbot.getClient().getWorldType());
        boolean isPVPWorld = WorldType.isPvpWorld(Microbot.getClient().getWorldType());
        if (Microbot.getVarbitValue(Varbits.IN_WILDERNESS) == 1) {
            wildernessLevel += getWildernessLevelFrom(Microbot.getClient().getLocalPlayer().getWorldLocation());
        }
        for(Player player: players) {
            if (!isAttackable(player, isDeadManWorld, isPVPWorld, wildernessLevel)) continue;
            System.out.println("Player: " + player.getName() + " with combat " + player.getCombatLevel() + " detected!");
            return true;
        }
        System.out.println("No attackable players detected...");
        return false;
    }
    public static int calculateRisk(Client client, ItemManager itemManager) {
        if (client.getItemContainer(InventoryID.EQUIPMENT) == null) {
            return 0;
        }
        if (client.getItemContainer(InventoryID.INVENTORY).getItems() == null) {
            return 0;
        }
        Item[] items = ArrayUtils.addAll(Objects.requireNonNull(client.getItemContainer(InventoryID.EQUIPMENT)).getItems(),
                Objects.requireNonNull(client.getItemContainer(InventoryID.INVENTORY)).getItems());
        TreeMap<Integer, Item> priceMap = new TreeMap<>(Comparator.comparingInt(Integer::intValue));
        int wealth = 0;
        for (Item i : items) {
            int value = (itemManager.getItemPrice(i.getId()) * i.getQuantity());
            final ItemComposition itemComposition = itemManager.getItemComposition(i.getId());
            if (!itemComposition.isTradeable() && value == 0) {
                value = itemComposition.getPrice() * i.getQuantity();
                priceMap.put(value, i);
            } else {
                value = itemManager.getItemPrice(i.getId()) * i.getQuantity();
                if (i.getId() > 0 && value > 0) {
                    priceMap.put(value, i);
                }
            }
            wealth += value;
        }
        return Integer.parseInt(QuantityFormatter.quantityToRSDecimalStack(priceMap.keySet().stream().mapToInt(Integer::intValue).sum()));
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/prayer/Rs2Prayer.java
================
package net.runelite.client.plugins.microbot.util.prayer;
import net.runelite.api.MenuAction;
import net.runelite.api.Skill;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.menu.NewMenuEntry;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.microbot.util.widget.Rs2Widget;
import java.awt.*;
import java.util.Arrays;
import static net.runelite.api.Varbits.QUICK_PRAYER;
import static net.runelite.client.plugins.microbot.globval.VarbitIndices.SELECTED_QUICK_PRAYERS;
import static net.runelite.client.plugins.microbot.globval.VarbitValues.QUICK_PRAYER_ENABLED;
import static net.runelite.client.plugins.microbot.util.Global.sleepUntil;
public class Rs2Prayer {
    public static void toggle(Rs2PrayerEnum name) {
        Microbot.doInvoke(new NewMenuEntry(-1, name.getIndex(), MenuAction.CC_OP.getId(), 1,-1, "Activate"), new Rectangle(1, 1, Microbot.getClient().getCanvasWidth(), Microbot.getClient().getCanvasHeight()));
        // Rs2Reflection.invokeMenu(-1, name.getIndex(), MenuAction.CC_OP.getId(), 1,-1, "Activate", "", -1, -1);
    }
    public static void toggle(Rs2PrayerEnum name, boolean on) {
        final int varBit = name.getVarbit();
        if(!on) {
            if (Microbot.getVarbitValue(varBit) == 0) return;
        } else {
            if (Microbot.getVarbitValue(varBit) == 1) return;
        }
        if (!Rs2Player.hasPrayerPoints()) return;
        Microbot.doInvoke(new NewMenuEntry(-1, name.getIndex(), MenuAction.CC_OP.getId(), 1,-1, "Activate"), new Rectangle(1, 1, Microbot.getClient().getCanvasWidth(), Microbot.getClient().getCanvasHeight()));
        //Rs2Reflection.invokeMenu(-1, name.getIndex(), MenuAction.CC_OP.getId(), 1,-1, "Activate", "", -1, -1);
    }
    public static boolean isQuickPrayerSet(Rs2PrayerEnum prayer) {
        int selectedQuickPrayersVarbit = Microbot.getVarbitValue(SELECTED_QUICK_PRAYERS);
        return (selectedQuickPrayersVarbit & (1 << prayer.getQuickPrayerIndex())) != 0;
    }
    public static boolean isPrayerActive(Rs2PrayerEnum name) {
        final int varBit = name.getVarbit();
        return Microbot.getClientThread().runOnClientThread(() ->
                Microbot.getClient().getVarbitValue(varBit) == 1);
    }
    public static boolean isQuickPrayerEnabled() {
        return Microbot.getVarbitValue(QUICK_PRAYER) == QUICK_PRAYER_ENABLED.getValue();
    }
    public static boolean setQuickPrayers(Rs2PrayerEnum[] prayers) {
        if (Rs2Widget.isHidden(10485779)) return false;
        // Open the menu
        Microbot.doInvoke(new NewMenuEntry("Setup",-1, 10485779, MenuAction.CC_OP.getId(), 2, -1, "Quick-prayers"), new Rectangle(1, 1, Microbot.getClient().getCanvasWidth(), Microbot.getClient().getCanvasHeight()));
        sleepUntil(() -> !Rs2Widget.isHidden(5046276));
        for (Rs2PrayerEnum prayer : prayers) {
            if(isQuickPrayerSet(prayer)) continue;
            Microbot.doInvoke(new NewMenuEntry(prayer.getName(),prayer.getQuickPrayerIndex(), 5046276, MenuAction.CC_OP.getId(), 1, -1, "Toggle"), new Rectangle(1, 1, Microbot.getClient().getCanvasWidth(), Microbot.getClient().getCanvasHeight()));
        }
        Microbot.doInvoke(new NewMenuEntry("Done",-1, 5046277, MenuAction.CC_OP.getId(), 1, -1, ""), new Rectangle(1, 1, Microbot.getClient().getCanvasWidth(), Microbot.getClient().getCanvasHeight()));
        return true;
    }
    public static boolean toggleQuickPrayer(boolean on) {
        boolean bit = Microbot.getVarbitValue(QUICK_PRAYER) == QUICK_PRAYER_ENABLED.getValue();
        boolean isQuickPrayerSet = Microbot.getVarbitValue(4102) > 0;
        if (!isQuickPrayerSet) return false;
        if (Rs2Widget.isHidden(10485779)) return false;
        if (on == bit) return true;
        Microbot.doInvoke(new NewMenuEntry(-1, 10485779, MenuAction.CC_OP.getId(), 1, -1, "Quick-prayers"), new Rectangle(1, 1, Microbot.getClient().getCanvasWidth(), Microbot.getClient().getCanvasHeight()));
        return true;
    }
    public static boolean isOutOfPrayer() {
        return Microbot.getClient().getBoostedSkillLevel(Skill.PRAYER) <= 0;
    }
    /**
     * Disables all active prayers.
     */
    public static void disableAllPrayers() {
        Arrays.stream(Rs2PrayerEnum.values()).filter(Rs2Prayer::isPrayerActive).forEach(Rs2Prayer::toggle);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/prayer/Rs2PrayerEnum.java
================
package net.runelite.client.plugins.microbot.util.prayer;
import net.runelite.api.Varbits;
import net.runelite.api.annotations.Varbit;
public enum Rs2PrayerEnum {
    THICK_SKIN("Thick Skin", 35454985, 1, Varbits.PRAYER_THICK_SKIN, 0),
    BURST_STRENGTH("Burst of Strength", 35454986, 4, Varbits.PRAYER_BURST_OF_STRENGTH, 1),
    CLARITY_THOUGHT("Clarity of Thought", 35454987, 7, Varbits.PRAYER_CLARITY_OF_THOUGHT, 2),
    SHARP_EYE("Sharp Eye", 35455003, 8, Varbits.PRAYER_SHARP_EYE, 3),
    MYSTIC_WILL("Mystic Will", 35455006, 9, Varbits.PRAYER_MYSTIC_WILL, 19),
    ROCK_SKIN("Rock Skin", 35454988, 10, Varbits.PRAYER_ROCK_SKIN, 3),
    SUPERHUMAN_STRENGTH("Superhuman Strength", 35454989, 13, Varbits.PRAYER_SUPERHUMAN_STRENGTH, 4),
    IMPROVED_REFLEXES("Improved Reflexes", 35454990, 16, Varbits.PRAYER_IMPROVED_REFLEXES, 5),
    RAPID_RESTORE("Rapid Restore", 35454991, 19, Varbits.PRAYER_RAPID_RESTORE, 6),
    RAPID_HEAL("Rapid heal", 35454992, 22, Varbits.PRAYER_RAPID_HEAL, 7),
    PROTECT_ITEM("Protect Item", 35454993, 25, Varbits.PRAYER_PROTECT_ITEM, 8),
    HAWK_EYE("Hawk eye", 35455004, 26, Varbits.PRAYER_HAWK_EYE, 20),
    MYSTIC_LORE("Mystic Lore", 35455007, 27, Varbits.PRAYER_MYSTIC_LORE, 21),
    STEEL_SKIN("Steel Skin", 35454994, 28, Varbits.PRAYER_STEEL_SKIN, 9),
    ULTIMATE_STRENGTH("Ultimate Strength", 35454995, 31, Varbits.PRAYER_ULTIMATE_STRENGTH, 10),
    INCREDIBLE_REFLEXES("Incredible Reflexes", 35454996, 34, Varbits.PRAYER_INCREDIBLE_REFLEXES, 11),
    PROTECT_MAGIC("Protect From Magic", 35454997, 37, Varbits.PRAYER_PROTECT_FROM_MAGIC, 12),
    PROTECT_RANGE("Protect From Missiles", 35454998, 40, Varbits.PRAYER_PROTECT_FROM_MISSILES, 13),
    PROTECT_MELEE("Protect From Melee", 35454999, 43, Varbits.PRAYER_PROTECT_FROM_MELEE, 14),
    EAGLE_EYE("Eagle Eye", 35455005, 44, Varbits.PRAYER_EAGLE_EYE, 22),
    MYSTIC_MIGHT("Mystic Might", 35455008, 45, Varbits.PRAYER_MYSTIC_MIGHT, 23),
    RETRIBUTION("Retribution", 35455000, 46, Varbits.PRAYER_RETRIBUTION, 15),
    REDEMPTION("Redemption", 35455001, 49, Varbits.PRAYER_REDEMPTION, 16),
    SMITE("Smite", 35455002, 52, Varbits.PRAYER_SMITE, 17),
    PRESERVE("Preserve", 35455013, 55, Varbits.PRAYER_PRESERVE, 28),
    CHIVALRY("Chivalry", 35455010,60, Varbits.PRAYER_CHIVALRY, 25),
    PIETY("Piety", 35455011, 70, Varbits.PRAYER_PIETY, 26),
    RIGOUR("Rigour", 35455009, 74, Varbits.PRAYER_RIGOUR, 24),
    AUGURY("Augury", 35455012, 77, Varbits.PRAYER_AUGURY, 27);
    private final String name;
    private final int index;
    private final int level;
    private final int pVar;
    private final int quickPrayerIndex;
    Rs2PrayerEnum(String name, int index, int level, int pVar, int quickPrayerIndex){
        this.name = name;
        this.index = index;
        this.level = level;
        this.pVar = pVar;
        this.quickPrayerIndex = quickPrayerIndex;
    }
    public String getName(){
        return name;
    }
    public int getIndex(){
        return index;
    }
    public int getLevel(){
        return level;
    }
    public int getQuickPrayerIndex(){ return quickPrayerIndex; }
    public @Varbit int getVarbit(){
        return pVar;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/reflection/Rs2Reflection.java
================
package net.runelite.client.plugins.microbot.util.reflection;
import lombok.SneakyThrows;
import net.runelite.api.ItemComposition;
import net.runelite.api.MenuEntry;
import net.runelite.api.NPC;
import net.runelite.api.ObjectID;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.keyboard.Rs2Keyboard;
import net.runelite.client.plugins.microbot.util.math.Random;
import java.awt.event.KeyEvent;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
public class Rs2Reflection {
    static String animationField = null;
    static Method doAction = null;
    /**
     * sequence maps to an actor animation
     * actor can be an npc/player
     */
    static int sequence = 1036457443;
    @SneakyThrows
    public static int getAnimation(NPC npc) {
        if (npc == null) {
            return -1;
        }
        if (animationField == null) {
            for (Field declaredField : npc.getClass().getSuperclass().getDeclaredFields()) {
                if (declaredField == null) {
                    continue;
                }
                declaredField.setAccessible(true);
                if (declaredField.getType() != int.class) {
                    continue;
                }
                if (Modifier.isFinal(declaredField.getModifiers())) {
                    continue;
                }
                if (Modifier.isStatic(declaredField.getModifiers())) {
                    continue;
                }
                int value = declaredField.getInt(npc);
                declaredField.setInt(npc, 4795789);
                if (npc.getAnimation() == sequence * 4795789) {
                    animationField = declaredField.getName();
                    declaredField.setInt(npc, value);
                    declaredField.setAccessible(false);
                    break;
                }
                declaredField.setInt(npc, value);
                declaredField.setAccessible(false);
            }
        }
        if (animationField == null) {
            return -1;
        }
        Field animation = npc.getClass().getSuperclass().getDeclaredField(animationField);
        animation.setAccessible(true);
        int anim = animation.getInt(npc) * sequence;
        animation.setAccessible(false);
        return anim;
    }
    @SneakyThrows
    public static String[] getGroundItemActions(ItemComposition item) {
        List<Field> fields = Arrays.stream(item.getClass().getFields()).filter(x -> x.getType().isArray()).collect(Collectors.toList());
        for (Field field : fields) {
            if (field.getType().getComponentType().getName().equals("java.lang.String")) {
                String[] actions = (String[]) field.get(item);
                if (Arrays.stream(actions).anyMatch(x -> x != null && x.equalsIgnoreCase("take"))) {
                    field.setAccessible(true);
                    return actions;
                }
            }
        }
        return new String[]{};
    }
    @SneakyThrows
    public static void setItemId(MenuEntry menuEntry, int itemId) throws IllegalAccessException, InvocationTargetException {
        var list =  Arrays.stream(menuEntry.getClass().getMethods())
                .filter(x -> x.getName().equals("setItemId"))
                .collect(Collectors.toList());
         list.get(0)
                .invoke(menuEntry, itemId); //use the setItemId method through reflection
    }
    @SneakyThrows
    public static ArrayList<Integer> getObjectByName(String[] names, boolean exact) {
        ArrayList<Integer> objectIds = new ArrayList<Integer>();
        Field[] fields = ObjectID.class.getDeclaredFields();
        for (Field field : fields) {
            field.setAccessible(true);
            if (field.getType() == int.class) {
                int fieldValue = field.getInt(null);
                if (exact)
                    if (Arrays.stream(names).noneMatch(name -> field.getName().equalsIgnoreCase(name)))
                        continue;
                if (!exact)
                    if (Arrays.stream(names).noneMatch(name -> field.getName().toLowerCase().contains(name.toLowerCase())))
                        continue;
                objectIds.add(fieldValue);
            }
        }
        return objectIds;
    }
    @SneakyThrows
    public static ArrayList<Integer> getObjectByName(String name, boolean exact) {
        return getObjectByName(new String[]{name}, exact);
    }
    @SneakyThrows
    public static void invokeMenu(int param0, int param1, int opcode, int identifier, int itemId, String option, String target, int x,
                              int y) {
        if (doAction == null) {
            doAction = Arrays.stream(Microbot.getClient().getClass().getDeclaredMethods())
                    .filter(m -> m.getReturnType().getName().equals("void") && m.getParameters().length == 9 && Arrays.stream(m.getParameters())
                            .anyMatch(p -> p.getType() == String.class))
                    .findFirst()
                    .orElse(null);
            if (doAction == null) {
                Microbot.showMessage("InvokeMenuAction method is broken!");
                return;
            }
        }
        doAction.setAccessible(true);
        Microbot.getClientThread().runOnClientThread(() -> doAction.invoke(null, param0, param1, opcode, identifier, itemId, option, target, x, y));
        if (Microbot.getClient().getKeyboardIdleTicks() > Random.random(5000, 10000)) {
            Rs2Keyboard.keyPress(KeyEvent.VK_BACK_SPACE);
        }
        System.out.println("[INVOKE] => param0: " + param0 + " param1: " + param1 + " opcode: " + opcode + " id: " + identifier + " itemid: " + itemId);
        doAction.setAccessible(false);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/security/Encryption.java
================
package net.runelite.client.plugins.microbot.util.security;
import javax.crypto.Cipher;
import javax.crypto.KeyGenerator;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;
public class Encryption {
    private static final String ALGORITHM = "AES";
    public static String encrypt(String plainText) throws Exception {
        if (plainText.endsWith("==")) return plainText;
        SecretKeySpec keySpec = new SecretKeySpec("microbot12345678".getBytes(), ALGORITHM);
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.ENCRYPT_MODE, keySpec);
        byte[] encryptedBytes = cipher.doFinal(plainText.getBytes());
        return Base64.getEncoder().encodeToString(encryptedBytes);
    }
    private static byte[] getBytes() throws NoSuchAlgorithmException {
        KeyGenerator keyGenerator = KeyGenerator.getInstance("AES");
        keyGenerator.init(256); // set the key size to 256 bits
        SecretKey secretKey = keyGenerator.generateKey();
        byte[] key = secretKey.getEncoded(); // get the raw key bytes
        return key;
    }
    public static String decrypt(String encryptedText) throws Exception {
        SecretKeySpec keySpec = new SecretKeySpec("microbot12345678".getBytes(), ALGORITHM);
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        cipher.init(Cipher.DECRYPT_MODE, keySpec);
        byte[] encryptedBytes = Base64.getDecoder().decode(encryptedText);
        byte[] decryptedBytes = cipher.doFinal(encryptedBytes);
        return new String(decryptedBytes);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/security/Login.java
================
package net.runelite.client.plugins.microbot.util.security;
import net.runelite.client.config.ConfigProfile;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.keyboard.Rs2Keyboard;
import net.runelite.client.util.WorldUtil;
import net.runelite.http.api.worlds.World;
import net.runelite.http.api.worlds.WorldRegion;
import net.runelite.http.api.worlds.WorldResult;
import net.runelite.http.api.worlds.WorldType;
import java.awt.event.KeyEvent;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;
import static net.runelite.client.plugins.microbot.util.Global.sleep;
public class Login {
    public static ConfigProfile activeProfile = null;
    private static final int MAX_PLAYER_COUNT = 1950;
    public Login() {
        this(getRandomWorld(activeProfile.isMember()));
    }
    public Login(int world) {
        this(activeProfile.getName(), activeProfile.getPassword(), world);
    }
    public Login(String username, String password) {
        this(username, password, 360);
    }
    public Login(String username, String password, int world) {
        if(Microbot.isLoggedIn())
            return;
        if (Microbot.getClient().getLoginIndex() == 3 || Microbot.getClient().getLoginIndex() == 24) { // you were disconnected from the server.
            int loginScreenWidth = 804;
            int startingWidth = (Microbot.getClient().getCanvasWidth() / 2) - (loginScreenWidth / 2);
            Microbot.getMouse().click(365 + startingWidth, 308); //clicks a button "OK" when you've been disconnected
            sleep(600);
        }
        Rs2Keyboard.keyPress(KeyEvent.VK_ENTER);
        sleep(600);
        try {
            setWorld(world);
        } catch (Exception e) {
            System.out.println("Changing world failed");
        }
        Microbot.getClient().setUsername(username);
        try {
            Microbot.getClient().setPassword(Encryption.decrypt(password));
        } catch (Exception e) {
            System.out.println("no password has been set in the profile");
        }
        sleep(300);
        Rs2Keyboard.keyPress(KeyEvent.VK_ENTER);
        sleep(300);
        Rs2Keyboard.keyPress(KeyEvent.VK_ENTER);
        if (Microbot.getClient().getLoginIndex() == 10) {
            int loginScreenWidth = 804;
            int startingWidth = (Microbot.getClient().getCanvasWidth() / 2) - (loginScreenWidth / 2);
            Microbot.getMouse().click(365 + startingWidth, 250); //clicks a button "OK" when you've been disconnected
        } else if (Microbot.getClient().getLoginIndex() == 9) {
            int loginScreenWidth = 804;
            int startingWidth = (Microbot.getClient().getCanvasWidth() / 2) - (loginScreenWidth / 2);
            Microbot.getMouse().click(365 + startingWidth, 300); //clicks a button "OK" when you've been disconnected
        }
    }
    public static int getRandomWorld(boolean isMembers, WorldRegion region) {
        WorldResult worldResult = Microbot.getWorldService().getWorlds();
        List<World> worlds;
        if (worldResult != null) {
            worlds = worldResult.getWorlds();
            Random r = new Random();
            List<World> filteredWorlds = worlds
                    .stream()
                    .filter(x ->
                            (!x.getTypes().contains(WorldType.PVP) &&
                                    !x.getTypes().contains(WorldType.HIGH_RISK) &&
                                    !x.getTypes().contains(WorldType.BOUNTY) &&
                                    !x.getTypes().contains(WorldType.SKILL_TOTAL) &&
                                    !x.getTypes().contains(WorldType.LAST_MAN_STANDING) &&
                                    !x.getTypes().contains(WorldType.QUEST_SPEEDRUNNING) &&
                                    !x.getTypes().contains(WorldType.BETA_WORLD) &&
                                    !x.getTypes().contains(WorldType.DEADMAN) &&
                                    !x.getTypes().contains(WorldType.PVP_ARENA) &&
                                    !x.getTypes().contains(WorldType.TOURNAMENT) &&
                                    !x.getTypes().contains(WorldType.FRESH_START_WORLD)) &&
                                    x.getPlayers() < MAX_PLAYER_COUNT &&
                                    x.getPlayers() >= 0)
                    .collect(Collectors.toList());
            if (!isMembers) {
                filteredWorlds = filteredWorlds
                        .stream()
                        .filter(x -> !x.getTypes().contains(WorldType.MEMBERS)).collect(Collectors.toList());
            } else {
                filteredWorlds = filteredWorlds
                        .stream()
                        .filter(x -> x.getTypes().contains(WorldType.MEMBERS)).collect(Collectors.toList());
            }
            if (region != null)
                filteredWorlds = filteredWorlds
                        .stream()
                        .filter(x -> x.getRegion() == region).collect(Collectors.toList());
            World world =
                    filteredWorlds.stream()
                            .skip(r.nextInt(filteredWorlds.size()))
                            .findFirst()
                            .orElse(null);
            if (world != null) {
                return world.getId();
            }
        }
        return isMembers ? 360 : 383;
    }
    public static int getRandomWorld(boolean isMembers) {
        return getRandomWorld(isMembers, null);
    }
    public void setWorld(int worldNumber) {
        try {
            net.runelite.http.api.worlds.World world = Microbot.getWorldService().getWorlds().findWorld(worldNumber);
            final net.runelite.api.World rsWorld = Microbot.getClient().createWorld();
            rsWorld.setActivity(world.getActivity());
            rsWorld.setAddress(world.getAddress());
            rsWorld.setId(world.getId());
            rsWorld.setPlayerCount(world.getPlayers());
            rsWorld.setLocation(world.getLocation());
            rsWorld.setTypes(WorldUtil.toWorldTypes(world.getTypes()));
            Microbot.getClient().changeWorld(rsWorld);
        } catch (Exception ex) {
            System.out.println("Failed to find world");
        }
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/settings/Rs2Settings.java
================
package net.runelite.client.plugins.microbot.util.settings;
import net.runelite.api.Varbits;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.keyboard.Rs2Keyboard;
import net.runelite.client.plugins.microbot.util.tabs.Rs2Tab;
import net.runelite.client.plugins.microbot.util.widget.Rs2Widget;
import java.awt.event.KeyEvent;
import static net.runelite.client.plugins.microbot.util.Global.*;
import static net.runelite.client.plugins.microbot.globval.VarbitIndices.TOGGLE_ROOFS;
public class Rs2Settings {
    public static boolean enableDropShiftSetting() {
        if (Rs2Widget.hasWidget("Click here to continue")) {
            Rs2Keyboard.keyPress(KeyEvent.VK_SPACE);
        }
        final int DROP_SHIFT_SETTING = 5542;
        if (Microbot.getVarbitValue(DROP_SHIFT_SETTING) == 0) {
            final int ALL_SETTINGS_BUTTON = 7602208;
            final int SETTINGS_INTERFACE = 8781825;
            Rs2Tab.switchToSettingsTab();
            Rs2Widget.clickWidget(ALL_SETTINGS_BUTTON);
            sleepUntilOnClientThread(() -> Rs2Widget.getWidget(SETTINGS_INTERFACE) != null);
            final boolean isSettingsInterfaceVisible = Rs2Widget.getWidget(SETTINGS_INTERFACE) != null;
            if (isSettingsInterfaceVisible) {
                Rs2Widget.clickWidget("controls", true);
                sleep(600);
                Rs2Widget.clickWidget("Shift click to drop items");
                sleep(600);
                Rs2Keyboard.keyPress(KeyEvent.VK_ESCAPE);
                Rs2Tab.switchToInventoryTab();
            }
        }
        return Microbot.getVarbitValue(DROP_SHIFT_SETTING) == 1;
    }
    public static boolean isHideRoofsEnabled() {
        return Microbot.getVarbitValue(TOGGLE_ROOFS) == 1;
    }
    public static void hideRoofs() {
        if (!isHideRoofsEnabled()) {
            Rs2Tab.switchToSettingsTab();
            Rs2Widget.clickWidget(7602208);
            sleepUntil(() -> Rs2Widget.hasWidget("Hide roofs"));
            sleep(1000);
            Rs2Widget.clickWidget("Hide roofs");
        }
    }
    public static boolean isLevelUpNotificationsEnabled() { return Microbot.getVarbitValue(Varbits.DISABLE_LEVEL_UP_INTERFACE) == 0; }
    public static boolean disableLevelUpNotifications() {
        if(isLevelUpNotificationsEnabled()){
            Rs2Tab.switchToSettingsTab();
            Rs2Widget.clickWidget(7602208);
            final boolean isSettingsInterfaceVisible = Rs2Widget.getWidget(8781825) != null;
            sleepUntilOnClientThread(() -> isSettingsInterfaceVisible);
            if(isSettingsInterfaceVisible){
                Rs2Widget.clickWidget(8781834);
                Rs2Keyboard.typeString("level-");
                Rs2Widget.clickWidget("Disable level-up interface");
                sleep(600);
                Rs2Keyboard.keyPress(KeyEvent.VK_ESCAPE);
                Rs2Tab.switchToInventoryTab();
            }
        }
        return Microbot.getVarbitValue(Varbits.DISABLE_LEVEL_UP_INTERFACE) == 1;
    }
    public static void turnOffMusic() {
        Rs2Tab.switchToSettingsTab();
        sleep(600);
        Rs2Widget.clickWidget(116, 68);
        sleep(600);
        boolean isMusicTurnedOff = !Rs2Widget.getWidget(116, 93).getChildren()[1].isSelfHidden();
        boolean isSoundEffectOff = !Rs2Widget.getWidget(116, 107).getChildren()[1].isSelfHidden();
        boolean isAreaSoundEffectOff = !Rs2Widget.getWidget(116, 122).getChildren()[1].isSelfHidden();
        if (isMusicTurnedOff && isSoundEffectOff && isAreaSoundEffectOff)
            return;
        Rs2Widget.clickWidget(7602244);
        sleep(1000);
        if (!isMusicTurnedOff)
            Rs2Widget.clickWidget(7602269);
        if (!isSoundEffectOff)
            Rs2Widget.clickWidget(7602283);
        if (!isAreaSoundEffectOff)
            Rs2Widget.clickWidget(7602298);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/shop/Actions.java
================
package net.runelite.client.plugins.microbot.util.shop;
public enum Actions {
    VALUE("Value"),
    SELL_ONE("Sell 1"),
    SELL_FIVE("Sell 5"),
    SELL_TEN("Sell 10"),
    SELL_FIFTY("Sell 50");
    private final String action;
    Actions(String action) {
        this.action = action;
    }
    public String getAction() {
        return action;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/shop/Rs2Shop.java
================
package net.runelite.client.plugins.microbot.util.shop;
import net.runelite.api.ItemComposition;
import net.runelite.api.MenuAction;
import net.runelite.api.NPC;
import net.runelite.api.events.ItemContainerChanged;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Item;
import net.runelite.client.plugins.microbot.util.menu.NewMenuEntry;
import net.runelite.client.plugins.microbot.util.npc.Rs2Npc;
import net.runelite.client.plugins.microbot.util.widget.Rs2Widget;
import java.awt.*;
import java.util.ArrayList;
import java.util.List;
import static net.runelite.client.plugins.microbot.Microbot.updateItemContainer;
import static net.runelite.client.plugins.microbot.util.Global.sleepUntil;
import static net.runelite.client.plugins.microbot.util.Global.sleepUntilOnClientThread;
public class Rs2Shop {
    public static final int SHOP_INVENTORY_ITEM_CONTAINER = 19660800;
    public static final int SHOP_CLOSE_BUTTON = 196960801;
    public static List<Rs2Item> shopItems = new ArrayList<Rs2Item>();
    /**
     * close the shop interface
     */
    public static void closeShop() {
        Microbot.status = "Closing Shop";
        if (!isOpen()) return;
        Rs2Widget.clickChildWidget(19660801, 11);
        sleepUntilOnClientThread(() -> Rs2Widget.getWidget(19660800) == null);
    }
    /**
     * check if the shop screen is open
     *
     * @return
     */
    public static boolean isOpen() {
        return Rs2Widget.getWidget(WidgetInfo.SHOP_INVENTORY_ITEMS_CONTAINER) != null
                && !Rs2Widget.isHidden(WidgetInfo.SHOP_INVENTORY_ITEMS_CONTAINER.getId());
    }
    /**
     * Opens the shop
     *
     * @return
     */
    public static boolean openShop(String NPC) {
        Microbot.status = "Opening Shop";
        try {
            if (isOpen()) return true;
            NPC npc = Rs2Npc.getNpc(NPC);
            if (npc == null) return false;
            Rs2Npc.interact(npc, "Trade");
            sleepUntil(Rs2Shop::isOpen, 5000);
            return false;
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
        return false;
    }
    /**
     * Buy Item from the shop
     *
     * @return
     */
    public static boolean buyItem(String itemName, String quantity) {
        Microbot.status = "Buying " + quantity + " " + itemName;
        try {
            Rs2Item rs2Item = shopItems.stream()
                    .filter(item -> item.name.equalsIgnoreCase(itemName))
                    .findFirst().orElse(null);
            String actionAndQuantity = "Buy " + quantity;
            System.out.println(actionAndQuantity);
            // Check if the item is in stock
            if (hasStock(itemName)) {
                System.out.println("We Have Stock of " + itemName);
                invokeMenu(rs2Item, actionAndQuantity);
            } else {
                return false;
            }
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
        return true;
    }
    /**
     * Checks if the specified item is in stock in the shop. **Note** if the item has stock 0 this will still return true.
     *
     * @param itemName The name of the item to check.
     *
     * @return true if the item is in stock, false otherwise.
     */
    public static boolean hasStock(String itemName) {
        // Iterate through the shop items to find the specified item
        for (Rs2Item item : shopItems) {
            // Check if the item name matches the specified item name
            if (item.name.equalsIgnoreCase(itemName)) {
                // System.out.println(item.name + " is in stock. Quantity: " + item.quantity + ", Slot: " + item.getSlot());
                return true; // Item found in stock
            }
        }
        System.out.println(itemName + " isn't in stock in the shop");
        return false; // Item not found in stock
    }
    /**
     * Checks if the specified item is in stock in the shop with quantity >= minimumQuantity.
     *
     * @param itemName        The name of the item to check.
     * @param minimumQuantity The minimum quantity required.
     *
     * @return true if the item is in stock with quantity >= minimumQuantity, false otherwise.
     */
    public static boolean hasMinimumStock(String itemName, int minimumQuantity) {
        // Iterate through the shop items to find the specified item
        for (Rs2Item item : shopItems) {
            // Check if the item name matches the specified item name and quantity is >= minimumQuantity
            if (item.name.equalsIgnoreCase(itemName) && item.quantity >= minimumQuantity) {
                return true; // Item found in stock with sufficient quantity
            }
        }
        System.out.println(itemName + " isn't in stock in the shop with minimum quantity of " + minimumQuantity);
        return false; // Item not found in stock or with sufficient quantity
    }
    /**
     * Updates the shop items in memory based on the provided event.
     *
     * @param e The event containing the latest shop items.
     */
    public static void storeShopItemsInMemory(ItemContainerChanged e, int id) {
        List<Rs2Item> list = updateItemContainer(id, e);
        if (list != null) {
            System.out.println("Storing shopItems");
            shopItems = list;
            /*Print each item's name
            System.out.println("Shop items:");
            for (Rs2Item item : shopItems) {
                System.out.println(item.name);
                System.out.println(item.quantity);
                System.out.println(item.slot);
            }
            */
        }
    }
    /**
     * Retrieves the slot number of the specified item in the shop.
     *
     * @param itemName The name of the item to find.
     *
     * @return The slot number of the item, or -1 if the item is not found.
     */
    public static int getSlot(String itemName) {
        // Iterate through the shop items to find the specified item
        for (int i = 0; i < shopItems.size(); i++) {
            Rs2Item item = shopItems.get(i);
            // Check if the item name matches the specified item name
            if (item.name.equalsIgnoreCase(itemName)) {
                return item.getSlot(); // Return the slot number of the item
            }
        }
        // Item not found, return -1
        return -1;
    }
    /**
     * Method executes menu actions
     *
     * @param rs2Item Current item to interact with
     * @param action  Action used on the item
     */
    private static void invokeMenu(Rs2Item rs2Item, String action) {
        if (rs2Item == null) return;
        Microbot.status = action + " " + rs2Item.name;
        int param0;
        int param1;
        int identifier = 3;
        MenuAction menuAction = MenuAction.CC_OP;
        ItemComposition itemComposition = Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getItemDefinition(rs2Item.id));
        if (!action.isEmpty()) {
            String[] actions;
            actions = itemComposition.getInventoryActions();
            for (int i = 0; i < actions.length; i++) {
                if (action.equalsIgnoreCase(actions[i])) {
                    identifier = i + 2;
                    break;
                }
            }
        }
        // Determine param0 (item slot in the shop)
        param0 = getSlot(rs2Item.name) + 1; // Use the getSlot method to get the slot number
        System.out.println(param0);
        // Shop Inventory
        switch (action) {
            case "Value":
                // Logic to check Value of item
                identifier = 1;
                param1 = 19660816;
            case "Buy 1":
                // Logic to sell one item
                identifier = 2;
                param1 = 19660816;
                break;
            case "Buy 5":
                // Logic to sell five items
                identifier = 3;
                param1 = 19660816;
                break;
            case "Buy 10":
                // Logic to sell ten items
                identifier = 4;
                param1 = 19660816;
                break;
            case "Buy 50":
                // Logic to sell fifty items
                identifier = 5;
                param1 = 19660816;
                break;
            default:
                System.out.println(action);
                throw new IllegalArgumentException("Invalid action");
        }
        Microbot.doInvoke(new NewMenuEntry(param0, param1, menuAction.getId(), identifier, rs2Item.id, rs2Item.name), (itemBounds(rs2Item) == null) ? new Rectangle(1, 1) : itemBounds(rs2Item));
        //Rs2Reflection.invokeMenu(param0, param1, menuAction.getId(), identifier, rs2Item.id, action, target, -1, -1);
    }
    /**
     * Method to get the bounds of the item
     *
     * @param rs2Item Current item to interact with
     *
     * @return Rectangle of the item
     */
    private static Rectangle itemBounds(Rs2Item rs2Item) {
        return Rs2Widget.getWidget(19660816).getDynamicChildren()[getSlot(rs2Item.getName())+1].getBounds();
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/tabs/Rs2Tab.java
================
package net.runelite.client.plugins.microbot.util.tabs;
import net.runelite.api.VarClientInt;
import net.runelite.api.widgets.Widget;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.globval.VarcIntValues;
import net.runelite.client.plugins.microbot.globval.enums.InterfaceTab;
import net.runelite.client.plugins.microbot.util.keyboard.Rs2Keyboard;
import net.runelite.client.plugins.microbot.util.widget.Rs2Widget;
import java.awt.event.KeyEvent;
import static net.runelite.client.plugins.microbot.util.Global.sleep;
public class Rs2Tab {
    public static InterfaceTab getCurrentTab() {
        int varcIntValue = Microbot.getClient().getVarcIntValue(VarClientInt.INVENTORY_TAB);
        switch (VarcIntValues.valueOf(varcIntValue)) {
            case TAB_COMBAT_OPTIONS:
                return InterfaceTab.COMBAT;
            case TAB_SKILLS:
                return InterfaceTab.SKILLS;
            case TAB_QUEST_LIST:
                return InterfaceTab.QUESTS;
            case TAB_INVENTORY:
                return InterfaceTab.INVENTORY;
            case TAB_WORN_EQUIPMENT:
                return InterfaceTab.EQUIPMENT;
            case TAB_PRAYER:
                return InterfaceTab.PRAYER;
            case TAB_SPELLBOOK:
                return InterfaceTab.MAGIC;
            case TAB_FRIEND_LIST:
                return InterfaceTab.FRIENDS;
            case TAB_LOGOUT:
                return InterfaceTab.LOGOUT;
            case TAB_SETTINGS:
                return InterfaceTab.SETTINGS;
            case TAB_MUSIC:
                return InterfaceTab.MUSIC;
            case TAB_CHAT_CHANNEL:
                return InterfaceTab.CHAT;
            case TAB_ACC_MANAGEMENT:
                return InterfaceTab.ACC_MAN;
            case TAB_EMOTES:
                return InterfaceTab.EMOTES;
            case TAB_NOT_SELECTED:
                return InterfaceTab.NOTHING_SELECTED;
            default:
                throw new IllegalStateException("Unexpected value: " + VarcIntValues.valueOf(varcIntValue));
        }
    }
    public static boolean switchToInventoryTab() {
        if (getCurrentTab() == InterfaceTab.INVENTORY) {
            return true;
        }
        Rs2Keyboard.keyPress(getKeyBind(Microbot.getVarbitValue(4678), InterfaceTab.INVENTORY));
        return getCurrentTab() == InterfaceTab.INVENTORY;
    }
    public static boolean switchToCombatOptionsTab() {
        if (getCurrentTab() == InterfaceTab.COMBAT) {
            return true;
        }
        Rs2Keyboard.keyPress(getKeyBind(Microbot.getVarbitValue(4675), InterfaceTab.COMBAT));
        return getCurrentTab() == InterfaceTab.COMBAT;
    }
    public static boolean switchToSkillsTab() {
        if (getCurrentTab() == InterfaceTab.SKILLS) {
            return true;
        }
        Rs2Keyboard.keyPress(getKeyBind(Microbot.getVarbitValue(4676), InterfaceTab.SKILLS));
        return getCurrentTab() == InterfaceTab.SKILLS;
    }
    public static boolean switchToQuestTab() {
        if (getCurrentTab() == InterfaceTab.QUESTS) {
            return true;
        }
        Rs2Keyboard.keyPress(getKeyBind(Microbot.getVarbitValue(4677), InterfaceTab.QUESTS));
        return getCurrentTab() == InterfaceTab.QUESTS;
    }
    public static boolean switchToEquipmentTab() {
        if (getCurrentTab() == InterfaceTab.EQUIPMENT) {
            return true;
        }
        Rs2Keyboard.keyPress(getKeyBind(Microbot.getVarbitValue(4679), InterfaceTab.EQUIPMENT));
        return getCurrentTab() == InterfaceTab.EQUIPMENT;
    }
    public static boolean switchToPrayerTab() {
        if (getCurrentTab() == InterfaceTab.PRAYER) {
            return true;
        }
        Rs2Keyboard.keyPress(getKeyBind(Microbot.getVarbitValue(4680), InterfaceTab.PRAYER));
        return getCurrentTab() == InterfaceTab.PRAYER;
    }
    public static boolean switchToMagicTab() {
        if (getCurrentTab() == InterfaceTab.MAGIC) {
            return true;
        }
        Rs2Keyboard.keyPress(getKeyBind(Microbot.getVarbitValue(4682), InterfaceTab.MAGIC));
        return getCurrentTab() == InterfaceTab.MAGIC;
    }
    public static boolean switchToGroupingTab() {
        if (getCurrentTab() == InterfaceTab.CHAT) {
            return true;
        }
        Rs2Keyboard.keyPress(getKeyBind(Microbot.getVarbitValue(4683), InterfaceTab.CHAT));
        return getCurrentTab() == InterfaceTab.CHAT;
    }
    public static boolean switchToFriendsTab() {
        if (getCurrentTab() == InterfaceTab.FRIENDS) {
            return true;
        }
        Rs2Keyboard.keyPress(getKeyBind(Microbot.getVarbitValue(4684), InterfaceTab.FRIENDS));
        return getCurrentTab() == InterfaceTab.FRIENDS;
    }
    public static boolean switchToAccountManagementTab() {
        if (getCurrentTab() == InterfaceTab.ACC_MAN) {
            return true;
        }
        Rs2Keyboard.keyPress(getKeyBind(Microbot.getVarbitValue(6517),  InterfaceTab.ACC_MAN));
        return getCurrentTab() == InterfaceTab.ACC_MAN;
    }
    public static boolean switchToSettingsTab() {
        if (getCurrentTab() == InterfaceTab.SETTINGS) {
            return true;
        }
        Rs2Keyboard.keyPress(getKeyBind(Microbot.getVarbitValue(4686),InterfaceTab.SETTINGS));
        return getCurrentTab() == InterfaceTab.SETTINGS;
    }
    public static boolean switchToEmotesTab() {
        if (getCurrentTab() == InterfaceTab.EMOTES) {
            return true;
        }
        Rs2Keyboard.keyPress(getKeyBind(Microbot.getVarbitValue(4687), InterfaceTab.EMOTES));
        return getCurrentTab() == InterfaceTab.EMOTES;
    }
    public static boolean switchToMusicTab() {
        if (getCurrentTab() == InterfaceTab.MUSIC) {
            return true;
        }
        Rs2Keyboard.keyPress(getKeyBind(Microbot.getVarbitValue(4688), InterfaceTab.MUSIC));
        return getCurrentTab() == InterfaceTab.MUSIC;
    }
    public static boolean switchToLogout() {
        if (getCurrentTab() == InterfaceTab.LOGOUT) return true;
        int logout_widget_id = getLogoutWidgetId();
        if (logout_widget_id == 0) return false;
        Widget tab = Microbot.getClient().getWidget(logout_widget_id);
        if (tab == null) return false;
        Microbot.getMouse().click(tab.getBounds());
        sleep(200, 600);
        return getCurrentTab() == InterfaceTab.LOGOUT;
    }
    private static int getLogoutWidgetId() {
        /* Widget Ids - These may change during Runelite updates */
        final int FIXED_CLASSIC_DISPLAY__FIXED_VIEWPORT_OPTIONS_TAB = 35913778;
        final int RESIZABLE_CLASSIC_DISPLAY__RESIZABLE_VIEWPORT_LOGOUT_ICON = 10551342;
        try {
            if (Rs2Widget.getWidget(FIXED_CLASSIC_DISPLAY__FIXED_VIEWPORT_OPTIONS_TAB) != null) {
                return FIXED_CLASSIC_DISPLAY__FIXED_VIEWPORT_OPTIONS_TAB;
            } else if (Rs2Widget.getWidget(RESIZABLE_CLASSIC_DISPLAY__RESIZABLE_VIEWPORT_LOGOUT_ICON) != null) {
                return RESIZABLE_CLASSIC_DISPLAY__RESIZABLE_VIEWPORT_LOGOUT_ICON;
            } else {
                Microbot.showMessage("Logout for modern layout is not supported!");
            }
        } catch (Exception ex) {
            // Rs2Widget.getWidget returns null if the game isn't finished loading
            ex.printStackTrace();
        }
        return 0;
    }
    private static int getKeyBind(int value, InterfaceTab tab) {
        if (value == 1) return KeyEvent.VK_F1;
        if (value == 2) return KeyEvent.VK_F2;
        if (value == 3) return KeyEvent.VK_F3;
        if (value == 4) return KeyEvent.VK_F4;
        if (value == 5) return KeyEvent.VK_F5;
        if (value == 6) return KeyEvent.VK_F6;
        if (value == 7) return KeyEvent.VK_F7;
        if (value == 8) return KeyEvent.VK_F8;
        if (value == 9) return KeyEvent.VK_F9;
        if (value == 10) return KeyEvent.VK_F10;
        if (value == 11) return KeyEvent.VK_F11;
        if (value == 12) return KeyEvent.VK_F12;
        if (value == 13) return KeyEvent.VK_ESCAPE;
        if (value == 0 && Microbot.isLoggedIn()) {
            Microbot.showMessage("Keybinding not found for tab " + tab.getName() + ". Please fill in the keybinding in your settings");
            sleep(5000);
        }
        return -1;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/tabs/Tab.java
================
package net.runelite.client.plugins.microbot.util.tabs;
import net.runelite.client.plugins.microbot.globval.enums.InterfaceTab;
@Deprecated(since = "Use Rs2Tab instead", forRemoval = true)
public class Tab {
    public static InterfaceTab getCurrentTab() {
        return Rs2Tab.getCurrentTab();
    }
    public static boolean switchToInventoryTab() {
        return Rs2Tab.switchToInventoryTab();
    }
    public static boolean switchToCombatOptionsTab() {
        return Rs2Tab.switchToCombatOptionsTab();
    }
    public static boolean switchToSkillsTab() {
        return Rs2Tab.switchToSkillsTab();
    }
    public static boolean switchToQuestTab() {
        return Rs2Tab.switchToQuestTab();
    }
    public static boolean switchToEquipmentTab() {
        return Rs2Tab.switchToEquipmentTab();
    }
    public static boolean switchToPrayerTab() {
        return Rs2Tab.switchToPrayerTab();
    }
    public static boolean switchToMagicTab() {
        return Rs2Tab.switchToMagicTab();
    }
    public static boolean switchToGroupingTab() {
        return Rs2Tab.switchToGroupingTab();
    }
    public static boolean switchToFriendsTab() {
        return Rs2Tab.switchToFriendsTab();
    }
    public static boolean switchToAccountManagementTab() {
        return Rs2Tab.switchToAccountManagementTab();
    }
    public static boolean switchToSettingsTab() {
        return Rs2Tab.switchToSettingsTab();
    }
    public static boolean switchToEmotesTab() {
        return Rs2Tab.switchToEmotesTab();
    }
    public static boolean switchToMusicTab() {
        return Rs2Tab.switchToMusicTab();
    }
    public static boolean switchToLogout() {
        return Rs2Tab.switchToLogout();
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/tile/Rs2Tile.java
================
package net.runelite.client.plugins.microbot.util.tile;
import lombok.Getter;
import net.runelite.api.Client;
import net.runelite.api.CollisionDataFlag;
import net.runelite.api.GraphicsObject;
import net.runelite.api.Tile;
import net.runelite.api.coords.Direction;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.devtools.MovementFlag;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.microbot.util.walker.Rs2Walker;
import org.apache.commons.lang3.tuple.MutablePair;
import java.util.*;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;
public class Rs2Tile {
    @Getter
    public static List<MutablePair<WorldPoint, Integer>> dangerousGraphicsObjectTiles = new ArrayList<>();
    private static ScheduledExecutorService tileExecutor;
    public static void init() {
        if (tileExecutor == null) {
            tileExecutor = Executors.newSingleThreadScheduledExecutor();
            tileExecutor.scheduleWithFixedDelay(() -> {
                if (dangerousGraphicsObjectTiles.isEmpty()) return;
                for (MutablePair<WorldPoint, Integer> dangerousTile : dangerousGraphicsObjectTiles) {
                    dangerousTile.setValue(dangerousTile.getValue() - 600);
                }
                dangerousGraphicsObjectTiles = dangerousGraphicsObjectTiles.stream().filter(x -> x.getValue() > 0).collect(Collectors.toList());
            }, 0, 600, TimeUnit.MILLISECONDS);
        }
    }
    public static void addDangerousGraphicsObjectTile(GraphicsObject graphicsObject, int time) {
        WorldPoint worldPoint;
        if (Microbot.getClient().getTopLevelWorldView().getScene().isInstance()) {
            worldPoint = WorldPoint.fromLocalInstance(Microbot.getClient(), graphicsObject.getLocation());
        } else {
            worldPoint = WorldPoint.fromLocal(Microbot.getClient(), graphicsObject.getLocation());
        }
        if (worldPoint == null) return;
        final MutablePair<WorldPoint, Integer> dangerousTile = MutablePair.of(worldPoint, time);
        dangerousGraphicsObjectTiles.add(dangerousTile);
        if (Rs2Player.getWorldLocation().equals(worldPoint)) {
            Microbot.getClientThread().runOnSeperateThread(() -> {
                final WorldPoint safeTile = Rs2Tile.getSafeTile();
                System.out.println(safeTile);
                Rs2Walker.walkFastCanvas(safeTile);
                return true;
            });
        }
    }
    /**
     * Returns a safe tile based on dangerous tiles
     *
     * @return list of safe tile, sorted on the closest tile to the player
     */
    public static List<WorldPoint> getSafeTiles(int radius) {
        List<WorldPoint> safeTiles = new ArrayList<>();
        for (WorldPoint walkableTile : getWalkableTilesAroundPlayer(radius)) {
            boolean isDangerousTile = dangerousGraphicsObjectTiles.stream().anyMatch(x -> x.getKey().equals(walkableTile));
            if (isDangerousTile) continue;
            safeTiles.add(walkableTile);
        }
        return safeTiles;
    }
    public static WorldPoint getSafeTile() {
        List<WorldPoint> safeTiles = getSafeTiles(4)
                .stream()
                .sorted(Comparator.comparingInt(value -> value.distanceTo(Rs2Player.getWorldLocation()))).collect(Collectors.toList());
        if (safeTiles.isEmpty()) return null;
        return safeTiles.get(0);
    }
    public static boolean isWalkable(Tile tile) {
        Client client = Microbot.getClient();
        if (client.getCollisionMaps() != null) {
            int[][] flags = client.getCollisionMaps()[client.getPlane()].getFlags();
            int data = flags[tile.getSceneLocation().getX()][tile.getSceneLocation().getY()];
            Set<MovementFlag> movementFlags = MovementFlag.getSetFlags(data);
            return movementFlags.isEmpty();
        }
        return true;
    }
    public static boolean isWalkable(LocalPoint localPoint) {
        if (localPoint == null)
            return true;
        Client client = Microbot.getClient();
        if (client.getCollisionMaps() != null) {
            int[][] flags = client.getCollisionMaps()[client.getPlane()].getFlags();
            int data = flags[localPoint.getSceneX()][localPoint.getSceneY()];
            Set<MovementFlag> movementFlags = MovementFlag.getSetFlags(data);
            return !movementFlags.contains(MovementFlag.BLOCK_MOVEMENT_FULL)
                    && !movementFlags.contains(MovementFlag.BLOCK_MOVEMENT_FLOOR);
        }
        return true;
    }
    public static List<WorldPoint> getWalkableTilesAroundPlayer(int radius) {
        return getWalkableTilesAroundTile(Rs2Player.getWorldLocation(), radius);
    }
    public static List<WorldPoint> getWalkableTilesAroundTile(WorldPoint point, int radius) {
        List<WorldPoint> worldPoints = new ArrayList<>();
        LocalPoint playerLocalPosition = LocalPoint.fromWorld(Microbot.getClient().getTopLevelWorldView(), point);
        if (playerLocalPosition == null) return new ArrayList<>();
        for (int dx = -radius; dx <= radius; dx++) {
            for (int dy = -radius; dy <= radius; dy++) {
                if (dx == 0 && dy == 0) continue; // Skip the player's current position
                LocalPoint localPoint;
                WorldPoint worldPoint;
                localPoint = new LocalPoint(playerLocalPosition.getX() + (dx * 128), playerLocalPosition.getY() + (dy * 128), -1);
                if (Microbot.getClient().getTopLevelWorldView().getScene().isInstance()) {
                    worldPoint = WorldPoint.fromLocalInstance(Microbot.getClient(), localPoint);
                } else {
                    worldPoint = WorldPoint.fromLocal(Microbot.getClient(), localPoint);
                }
                if (!isWalkable(localPoint)) continue;
                worldPoints.add(worldPoint);
            }
        }
        return worldPoints;
    }
    public static HashMap<WorldPoint, Integer> getReachableTilesFromTile(WorldPoint tile, int distance) {
        var tileDistances = new HashMap<WorldPoint, Integer>();
        tileDistances.put(tile, 0);
        for (int i = 0; i < distance + 1; i++) {
            int dist = i;
            for (var kvp : tileDistances.entrySet().stream().filter(x -> x.getValue() == dist).collect(Collectors.toList())) {
                var point = kvp.getKey();
                LocalPoint localPoint;
                if (Microbot.getClient().isInInstancedRegion()) {
                    var worldPoint = WorldPoint.toLocalInstance(Microbot.getClient(), point).stream().findFirst().get();
                    localPoint = LocalPoint.fromWorld(Microbot.getClient(), worldPoint);
                } else
                    localPoint = LocalPoint.fromWorld(Microbot.getClient().getTopLevelWorldView(), point);
                if (Microbot.getClient().getCollisionMaps() != null && localPoint != null) {
                    int[][] flags = Microbot.getClient().getCollisionMaps()[Microbot.getClient().getPlane()].getFlags();
                    int data = flags[localPoint.getSceneX()][localPoint.getSceneY()];
                    Set<MovementFlag> movementFlags = MovementFlag.getSetFlags(data);
                    if (movementFlags.contains(MovementFlag.BLOCK_MOVEMENT_FULL)
                            || movementFlags.contains(MovementFlag.BLOCK_MOVEMENT_FLOOR)) {
                        tileDistances.remove(point);
                        continue;
                    }
                    if (kvp.getValue() >= distance)
                        continue;
                    if (!movementFlags.contains(MovementFlag.BLOCK_MOVEMENT_EAST))
                        tileDistances.putIfAbsent(point.dx(1), dist + 1);
                    if (!movementFlags.contains(MovementFlag.BLOCK_MOVEMENT_WEST))
                        tileDistances.putIfAbsent(point.dx(-1), dist + 1);
                    if (!movementFlags.contains(MovementFlag.BLOCK_MOVEMENT_NORTH))
                        tileDistances.putIfAbsent(point.dy(1), dist + 1);
                    if (!movementFlags.contains(MovementFlag.BLOCK_MOVEMENT_SOUTH))
                        tileDistances.putIfAbsent(point.dy(-1), dist + 1);
                }
            }
        }
        return tileDistances;
    }
    public static List<LocalPoint> getTilesAroundPlayer(int radius) {
        List<LocalPoint> localPoints = new ArrayList<>();
        LocalPoint playerLocalPosition = Rs2Player.getLocalLocation();
        for (int dx = -radius; dx <= radius; dx++) {
            for (int dy = -radius; dy <= radius; dy++) {
                if (dx == 0 && dy == 0) continue; // Skip the player's current position
                LocalPoint localPoint;
                WorldPoint worldPoint;
                localPoint = new LocalPoint(playerLocalPosition.getX() + (dx * 128), playerLocalPosition.getY() + (dy * 128), -1);
                localPoints.add(localPoint);
            }
        }
        return localPoints;
    }
    public static boolean isTileReachable(WorldPoint targetPoint) {
        boolean[][] visited = new boolean[104][104];
        int[][] flags = Microbot.getClient().getCollisionMaps()[Microbot.getClient().getPlane()].getFlags();
        WorldPoint playerLoc = Rs2Player.getWorldLocation();
        int startX = 0;
        int startY = 0;
        int startPoint = 0;
        if (Microbot.getClient().isInInstancedRegion()) {
            LocalPoint localPoint = Rs2Player.getLocalLocation();
            startX = localPoint.getSceneX();
            startY = localPoint.getSceneY();
            startPoint = (startX << 16) | startY;
        } else {
            startX = playerLoc.getX() - Microbot.getClient().getBaseX();
            startY = playerLoc.getY() - Microbot.getClient().getBaseY();
            startPoint = (startX << 16) | startY;
        }
        ArrayDeque<Integer> queue = new ArrayDeque<>();
        queue.add(startPoint);
        visited[startX][startY] = true;
        while (!queue.isEmpty()) {
            int point = queue.poll();
            int x = point >> 16;
            int y = point & 0xFFFF;
            if (isWithinBounds(x, y)) {
                checkAndAddNeighbour(queue, visited, flags, x, y, -1, 0, CollisionDataFlag.BLOCK_MOVEMENT_WEST);
                checkAndAddNeighbour(queue, visited, flags, x, y, 1, 0, CollisionDataFlag.BLOCK_MOVEMENT_EAST);
                checkAndAddNeighbour(queue, visited, flags, x, y, 0, -1, CollisionDataFlag.BLOCK_MOVEMENT_SOUTH);
                checkAndAddNeighbour(queue, visited, flags, x, y, 0, 1, CollisionDataFlag.BLOCK_MOVEMENT_NORTH);
            }
        }
        return isVisited(targetPoint, visited);
    }
    public static boolean areSurroundingTilesWalkable(WorldPoint worldPoint, int sizeX, int sizeY) {
        for (int dx = -1; dx <= sizeX; dx++) {
            for (int dy = -1; dy <= sizeY; dy++) {
                // Skip the inside tiles, only check the border
                if (dx >= 0 && dx < sizeX && dy >= 0 && dy < sizeY) {
                    continue;
                }
                int checkX = worldPoint.getX() + dx;
                int checkY = worldPoint.getY() + dy;
                if (isTileReachable(new WorldPoint(checkX, checkY, worldPoint.getPlane()))) {
                    return true;
                }
            }
        }
        return false;
    }
    private static boolean isWithinBounds(int x, int y) {
        return x >= 0 && y >= 0 && x < 104 && y < 104;
    }
    private static void checkAndAddNeighbour(ArrayDeque<Integer> queue, boolean[][] visited, int[][] flags, int x, int y, int dx, int dy, int blockMovementFlag) {
        int nx = x + dx;
        int ny = y + dy;
        if (isWithinBounds(nx, ny) && !visited[nx][ny] && (flags[x][y] & blockMovementFlag) == 0 && (flags[nx][ny] & CollisionDataFlag.BLOCK_MOVEMENT_FULL) == 0) {
            queue.add((nx << 16) | ny);
            visited[nx][ny] = true;
        }
    }
    private static boolean isVisited(WorldPoint worldPoint, boolean[][] visited) {
        int baseX = 0;
        int baseY = 0;
        int x = 0;
        int y = 0;
        if (Microbot.getClient().isInInstancedRegion()) {
            LocalPoint localPoint = Rs2Player.getLocalLocation();
            x = localPoint.getSceneX();
            y = localPoint.getSceneY();
        } else {
            baseX = Microbot.getClient().getTopLevelWorldView().getBaseX();
            baseY = Microbot.getClient().getTopLevelWorldView().getBaseY();
            x = worldPoint.getX() - baseX;
            y = worldPoint.getY() - baseY;
        }
        return isWithinBounds(x, y) && visited[x][y];
    }
    /**
     * Gets the neighboring tile in the specified direction from the source tile.
     * <p>
     * This method calculates the neighboring tile based on the given direction
     * (NORTH, SOUTH, EAST, WEST) and returns the corresponding WorldPoint.
     *
     * @param direction The direction in which to find the neighboring tile.
     * @param source    The source tile from which to find the neighboring tile.
     *
     * @return The neighboring tile in the specified direction.
     *
     * @throws IllegalArgumentException if the direction is not one of the expected values.
     */
    private static WorldPoint getNeighbour(Direction direction, WorldPoint source) {
        switch (direction) {
            case NORTH:
                return source.dy(1);
            case SOUTH:
                return source.dy(-1);
            case WEST:
                return source.dx(-1);
            case EAST:
                return source.dx(1);
            default:
                throw new IllegalArgumentException();
        }
    }
    /**
     * Finds the nearest walkable tile from the given source tile.
     * <p>
     * This method iterates through all possible directions (NORTH, SOUTH, EAST, WEST)
     * from the source tile and checks if the neighboring tile in that direction is walkable.
     * If a walkable tile is found, it is returned.
     *
     * @param source The source tile from which to find the nearest walkable tile.
     *
     * @return The nearest walkable tile, or null if no walkable tile is found.
     */
    public static WorldPoint getNearestWalkableTile(WorldPoint source) {
        for (Direction direction : Direction.values()) {
            WorldPoint neighbour = getNeighbour(direction, source);
            if (isTileReachable(neighbour)) {
                return neighbour;
            }
        }
        return null;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/walker/Rs2MiniMap.java
================
package net.runelite.client.plugins.microbot.util.walker;
import net.runelite.api.Perspective;
import net.runelite.api.Point;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.microbot.Microbot;
import javax.annotation.Nullable;
public class Rs2MiniMap {
    @Nullable
    public static Point localToMinimap(LocalPoint localPoint) {
        if (localPoint == null) return null;
        return Microbot.getClientThread().runOnClientThread(() -> Perspective.localToMinimap(Microbot.getClient(), localPoint));
    }
    @Nullable
    public static Point worldToMinimap(WorldPoint point) {
        if (point == null) return null;
        LocalPoint localPoint = LocalPoint.fromWorld(Microbot.getClient(), point);
//        if (Microbot.getClient().isInInstancedRegion()) {
//            WorldPoint playerInstancedWorldLocation =  WorldPoint.fromLocal(Microbot.getClient(), Microbot.getClient().getLocalPlayer().getLocalLocation());
//            LocalPoint l = LocalPoint.fromWorld(Microbot.getClient(), point);
//            //in some instances areas like (tithe farm) the conversion is not needed
//            if (Microbot.getClient().getLocalPlayer().getLocalLocation().equals(l)) return Microbot.getClient().getLocalPlayer().getWorldLocation();
//            playerInstancedWorldLocation = WorldPoint.fromLocalInstance(Microbot.getClient(), l);
//            return playerInstancedWorldLocation;
//        } else {
//            localPoint = LocalPoint.fromWorld(Microbot.getClient(), point);
//        }
        if (localPoint == null) return null;
        return Microbot.getClientThread().runOnClientThread(() -> Perspective.localToMinimap(Microbot.getClient(), localPoint));
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/walker/Rs2Walker.java
================
package net.runelite.client.plugins.microbot.util.walker;
import com.google.common.util.concurrent.ThreadFactoryBuilder;
import lombok.Setter;
import net.runelite.api.Point;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.devtools.MovementFlag;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.shortestpath.ShortestPathConfig;
import net.runelite.client.plugins.microbot.shortestpath.ShortestPathPlugin;
import net.runelite.client.plugins.microbot.shortestpath.Transport;
import net.runelite.client.plugins.microbot.shortestpath.pathfinder.Pathfinder;
import net.runelite.client.plugins.microbot.util.gameobject.Rs2GameObject;
import net.runelite.client.plugins.microbot.util.math.Random;
import net.runelite.client.plugins.microbot.util.menu.NewMenuEntry;
import net.runelite.client.plugins.microbot.util.npc.Rs2Npc;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.microbot.util.tile.Rs2Tile;
import net.runelite.client.ui.overlay.worldmap.WorldMapPoint;
import java.awt.*;
import java.util.List;
import java.util.*;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.ThreadFactory;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import static net.runelite.client.plugins.microbot.util.Global.*;
public class Rs2Walker {
    private static final ExecutorService pathfindingExecutor = Executors.newSingleThreadExecutor();
    @Setter
    public static ShortestPathConfig config;
    static int stuckCount = 0;
    static WorldPoint lastPosition;
    static int idle = 0;
    static WorldPoint currentTarget;
    static int nextWalkingDistance = 10;
    public static boolean walkTo(WorldArea area, int distanceThreshold) {
        if (area.distanceTo(Rs2Player.getWorldLocation()) > distanceThreshold) {
            var points = area.toWorldPointList();
            var index = new java.util.Random().nextInt(points.size());
            return Rs2Walker.walkTo(points.get(index));
        }
        return true;
    }
    public static boolean walkTo(int x, int y, int plane) {
        return walkTo(x, y, plane, 6);
    }
    public static boolean walkTo(int x, int y, int plane, int distance) {
        return walkTo(new WorldPoint(x, y, plane), distance);
    }
    public static boolean walkTo(WorldPoint target) {
        return walkTo(target, config.reachedDistance());
    }
    public static boolean walkTo(WorldPoint target, int distance) {
        if (Rs2Tile.getReachableTilesFromTile(Rs2Player.getWorldLocation(), distance).containsKey(target)
                || !Rs2Tile.isWalkable(LocalPoint.fromWorld(Microbot.getClient().getTopLevelWorldView(), target)) && Rs2Player.getWorldLocation().distanceTo(target) <= distance) {
            return true;
        }
        if (currentTarget != null && currentTarget.equals(target) && ShortestPathPlugin.getMarker() != null && !Microbot.getClientThread().scheduledFuture.isDone())
            return false;
        setTarget(target);
        ShortestPathPlugin.setReachedDistance(distance);
        stuckCount = 0;
        idle = 0;
        Microbot.getClientThread().runOnSeperateThread(() -> {
            try {
                while (!Thread.currentThread().isInterrupted()) {
                    if (!Microbot.isLoggedIn()) {
                        setTarget(null);
                        break;
                    }
                    if (ShortestPathPlugin.getPathfinder() == null) {
                        if (ShortestPathPlugin.getMarker() == null)
                            break;
                        Microbot.status = "Waiting for pathfinder...";
                        continue;
                    }
                    if (!ShortestPathPlugin.getPathfinder().isDone()) {
                        Microbot.status = "Waiting for path calculation...";
                        continue;
                    }
                    if (isNear(ShortestPathPlugin.getPathfinder().getPath().get(ShortestPathPlugin.getPathfinder().getPath().size() - 1))) {
                        setTarget(null);
                        break;
                    }
                    //avoid tree attacking you in draynor
                    checkIfStuck();
                    if (stuckCount > 10) {
                        var moveableTiles = Rs2Tile.getReachableTilesFromTile(Rs2Player.getWorldLocation(), 5).keySet().toArray(new WorldPoint[0]);
                        walkMiniMap(moveableTiles[Random.random(0, moveableTiles.length)]);
                        sleep(600, 1000);
                    }
                    if (ShortestPathPlugin.getPathfinder() == null) break;
                    List<WorldPoint> path = ShortestPathPlugin.getPathfinder().getPath();
                    int indexOfStartPoint = getClosestTileIndex(path);
                    lastPosition = Rs2Player.getWorldLocation();
                    if (Rs2Player.getWorldLocation().distanceTo(target) == 0)
                        break;
                    /**
                     * MAIN WALK LOOP
                     */
                    boolean doorOrTransportResult = false;
                    for (int i = indexOfStartPoint; i < path.size(); i++) {
                        WorldPoint currentWorldPoint = path.get(i);
                        if (i > 0 && !Rs2Tile.isTileReachable(path.get(i - 1)) && !Microbot.getClient().isInInstancedRegion()) {
                            continue;
                        }
                        /**
                         * CHECK DOORS
                         */
                        Microbot.status = "Checking for doors...";
                        long startTime = System.currentTimeMillis();
                        doorOrTransportResult = handleDoors(path, i);
                        if (doorOrTransportResult) {
                            break;
                        }
                        long endTime = System.currentTimeMillis();
                        long totalTime = endTime - startTime;
                        System.out.println("Handling doors took " + totalTime + "ms");
                        if (!Microbot.getClient().isInInstancedRegion()) {
                            Microbot.status = "Checking for transports...";
                            startTime = System.currentTimeMillis();
                            doorOrTransportResult = handleTransports(path, i);
                            endTime = System.currentTimeMillis();
                            totalTime = endTime - startTime;
                            System.out.println("Handling transports took " + totalTime + "ms");
                        }
                        if (doorOrTransportResult)
                            break;
                        if (!Rs2Tile.isTileReachable(currentWorldPoint) && !Microbot.getClient().isInInstancedRegion()) {
                            continue;
                        }
                        if (currentWorldPoint.distanceTo2D(Rs2Player.getWorldLocation()) > nextWalkingDistance) {
                            nextWalkingDistance = Random.random(7, 11);
                            // InstancedRegions require localPoint instead of worldpoint to navigate
                            if (Microbot.getClient().isInInstancedRegion()) {
                                Rs2Walker.walkFastCanvas(currentWorldPoint);
                                sleep(600, 1000);
                            } else {
                                long movingStart = System.currentTimeMillis();
                                Rs2Walker.walkMiniMap(getPointWithWallDistance(currentWorldPoint));
                                int randomInt = Random.random(3, 5);
                                sleepUntilTrue(() -> currentWorldPoint.distanceTo2D(Rs2Player.getWorldLocation()) < randomInt, 100, 2000);
                                if (System.currentTimeMillis() - movingStart < 120) {
                                    sleep(600, 1000);
                                }
                                break;
                            }
                        }
                    }
                    if (!doorOrTransportResult){
                        var moveableTiles = Rs2Tile.getReachableTilesFromTile(path.get(path.size() - 1), Math.min(3, distance)).keySet().toArray(new WorldPoint[0]);
                        var finalTile = moveableTiles.length > 0 ? moveableTiles[Random.random(0, moveableTiles.length)] : path.get(path.size() - 1);
                        if (Rs2Tile.isTileReachable(finalTile)) {
                            System.out.println("walk minimap");
                            if (Microbot.getClient().isInInstancedRegion())
                                Rs2Walker.walkFastCanvas(finalTile);
                            else
                                Rs2Walker.walkMiniMap(finalTile);
                            sleep(600, 1200);
                            System.out.println("sleep walk minimap");
                        }
                    }
                }
                return Rs2Player.getWorldLocation().distanceTo(target) < distance;
            } catch (Exception ex) {
                if (ex instanceof InterruptedException) return false;
                Microbot.log("Microbot Walker Exception " + ex.getMessage());
                System.out.println(ex.getMessage());
                ex.printStackTrace(System.out);
            }
            return false;
        });
        return false;
    }
    public static WorldPoint getPointWithWallDistance(WorldPoint target) {
        var tiles = Rs2Tile.getReachableTilesFromTile(target, 1);
        var localPoint = LocalPoint.fromWorld(Microbot.getClient().getTopLevelWorldView(), target);
        if (Microbot.getClient().getCollisionMaps() != null && localPoint != null) {
            int[][] flags = Microbot.getClient().getCollisionMaps()[Microbot.getClient().getPlane()].getFlags();
            if (hasMinimapRelevantMovementFlag(localPoint, flags)) {
                for (var tile : tiles.keySet()) {
                    var localTilePoint = LocalPoint.fromWorld(Microbot.getClient().getTopLevelWorldView(), tile);
                    if (localTilePoint == null)
                        continue;
                    if (!hasMinimapRelevantMovementFlag(localTilePoint, flags))
                        return tile;
                }
            }
            int data = flags[localPoint.getSceneX()][localPoint.getSceneY()];
            Set<MovementFlag> movementFlags = MovementFlag.getSetFlags(data);
            if (movementFlags.contains(MovementFlag.BLOCK_MOVEMENT_EAST)
                    || movementFlags.contains(MovementFlag.BLOCK_MOVEMENT_WEST)
                    || movementFlags.contains(MovementFlag.BLOCK_MOVEMENT_NORTH)
                    || movementFlags.contains(MovementFlag.BLOCK_MOVEMENT_SOUTH)) {
                for (var tile : tiles.keySet()) {
                    var localTilePoint = LocalPoint.fromWorld(Microbot.getClient().getTopLevelWorldView(), tile);
                    if (localTilePoint == null)
                        continue;
                    int tileData = flags[localTilePoint.getSceneX()][localTilePoint.getSceneY()];
                    Set<MovementFlag> tileFlags = MovementFlag.getSetFlags(tileData);
                    if (tileFlags.isEmpty())
                        return tile;
                }
            }
        }
        return target;
    }
    static boolean hasMinimapRelevantMovementFlag(LocalPoint point, int[][] flagMap) {
        int data = flagMap[point.getSceneX()][point.getSceneY()];
        Set<MovementFlag> movementFlags = MovementFlag.getSetFlags(data);
        if (movementFlags.contains(MovementFlag.BLOCK_MOVEMENT_EAST)
                && Rs2Tile.isWalkable(point.dx(1)))
            return true;
        if (movementFlags.contains(MovementFlag.BLOCK_MOVEMENT_WEST)
                && Rs2Tile.isWalkable(point.dx(-1)))
            return true;
        if (movementFlags.contains(MovementFlag.BLOCK_MOVEMENT_NORTH)
                && Rs2Tile.isWalkable(point.dy(1)))
            return true;
        return movementFlags.contains(MovementFlag.BLOCK_MOVEMENT_SOUTH)
                && Rs2Tile.isWalkable(point.dy(-1));
    }
    public static boolean walkMiniMap(WorldPoint worldPoint, int zoomDistance) {
        if (Microbot.getClient().getMinimapZoom() != zoomDistance)
            Microbot.getClient().setMinimapZoom(zoomDistance);
        Point point = Rs2MiniMap.worldToMinimap(worldPoint);
        if (point == null) return false;
        Microbot.getMouse().click(point);
        return true;
    }
    public static boolean walkMiniMap(WorldPoint worldPoint) {
        return walkMiniMap(worldPoint, 5);
    }
    public static boolean walkMiniMap(WorldArea area) {
        var points = area.toWorldPointList();
        var index = new java.util.Random().nextInt(points.size());
        return Rs2Walker.walkMiniMap(points.get(index));
    }
    /**
     * Used in instances like vorkath, jad
     *
     * @param localPoint
     */
    public static void walkFastLocal(LocalPoint localPoint) {
        Point canv = Perspective.localToCanvas(Microbot.getClient(), localPoint, Microbot.getClient().getPlane());
        int canvasX = canv != null ? canv.getX() : -1;
        int canvasY = canv != null ? canv.getY() : -1;
        Microbot.doInvoke(new NewMenuEntry(canvasX, canvasY, MenuAction.WALK.getId(), 0, -1, "Walk here"), new Rectangle(1, 1, Microbot.getClient().getCanvasWidth(), Microbot.getClient().getCanvasHeight()));
        //Rs2Reflection.invokeMenu(canvasX, canvasY, MenuAction.WALK.getId(), 0, -1, "Walk here", "", -1, -1);
    }
    public static void walkFastCanvas(WorldPoint worldPoint) {
        walkFastCanvas(worldPoint, true);
    }
    public static void walkFastCanvas(WorldPoint worldPoint, boolean toogleRun) {
        Rs2Player.toggleRunEnergy(toogleRun);
        Point canv;
        if (Microbot.getClient().isInInstancedRegion()) {
            worldPoint = WorldPoint.toLocalInstance(Microbot.getClient(), worldPoint).stream().findFirst().get();
            LocalPoint localPoint = LocalPoint.fromWorld(Microbot.getClient(), worldPoint);
            canv = Perspective.localToCanvas(Microbot.getClient(), localPoint, Microbot.getClient().getPlane());
        } else {
            canv = Perspective.localToCanvas(Microbot.getClient(), LocalPoint.fromScene(worldPoint.getX() - Microbot.getClient().getBaseX(), worldPoint.getY() - Microbot.getClient().getBaseY(), Microbot.getClient().getTopLevelWorldView().getScene()), Microbot.getClient().getPlane());
        }
        int canvasX = canv != null ? canv.getX() : -1;
        int canvasY = canv != null ? canv.getY() : -1;
        Microbot.doInvoke(new NewMenuEntry(canvasX, canvasY, MenuAction.WALK.getId(), 0, -1, "Walk here"), new Rectangle(1, 1, Microbot.getClient().getCanvasWidth(), Microbot.getClient().getCanvasHeight()));
        //Rs2Reflection.invokeMenu(canvasX, canvasY, MenuAction.WALK.getId(), 0, -1, "Walk here", "", -1, -1);
    }
    public static WorldPoint walkCanvas(WorldPoint worldPoint) {
        Point point = Perspective.localToCanvas(Microbot.getClient(), LocalPoint.fromWorld(Microbot.getClient(), worldPoint), Microbot.getClient().getPlane());
        if (point == null) return null;
        Microbot.getMouse().click(point);
        return worldPoint;
    }
    // takes an avg 200-300 ms
    // Used mainly for agility, might have to tweak this for other stuff
    public static boolean canReach(WorldPoint worldPoint, int sizeX, int sizeY, int pathSizeX, int pathSizeY) {
        Pathfinder pathfinder = new Pathfinder(ShortestPathPlugin.getPathfinderConfig(), Rs2Player.getWorldLocation(), worldPoint);
        pathfindingExecutor.submit(pathfinder);
        sleepUntil(pathfinder::isDone);
        WorldArea pathArea = new WorldArea(pathfinder.getPath().get(pathfinder.getPath().size() - 1), pathSizeX, pathSizeY);
        WorldArea objectArea = new WorldArea(worldPoint, sizeX + 2, sizeY + 2);
        boolean result = pathArea
                .intersectsWith2D(objectArea);
        return result;
    }
    // takes an avg 200-300 ms
    // Used mainly for agility, might have to tweak this for other stuff
    public static boolean canReach(WorldPoint worldPoint, int sizeX, int sizeY) {
        Pathfinder pathfinder = new Pathfinder(ShortestPathPlugin.getPathfinderConfig(), Rs2Player.getWorldLocation(), worldPoint);
        pathfindingExecutor.submit(pathfinder);
        sleepUntil(pathfinder::isDone);
        WorldArea pathArea = new WorldArea(pathfinder.getPath().get(pathfinder.getPath().size() - 1), 3, 3);
        WorldArea objectArea = new WorldArea(worldPoint, sizeX + 2, sizeY + 2);
        boolean result = pathArea
                .intersectsWith2D(objectArea);
        return result;
    }
    public static boolean canReach(WorldPoint worldPoint) {
        Pathfinder pathfinder = new Pathfinder(ShortestPathPlugin.getPathfinderConfig(), Rs2Player.getWorldLocation(), worldPoint);
        pathfindingExecutor.submit(pathfinder);
        sleepUntil(pathfinder::isDone);
        if (pathfinder.getPath().get(pathfinder.getPath().size() - 1).getPlane() != worldPoint.getPlane()) return false;
        WorldArea pathArea = new WorldArea(pathfinder.getPath().get(pathfinder.getPath().size() - 1), 2, 2);
        WorldArea objectArea = new WorldArea(worldPoint, 2, 2);
        boolean result = pathArea
                .intersectsWith2D(objectArea);
        return result;
    }
    public static boolean isCloseToRegion(int distance, int regionX, int regionY) {
        WorldPoint worldPoint = WorldPoint.fromRegion(Microbot.getClient().getLocalPlayer().getWorldLocation().getRegionID(),
                regionX,
                regionY,
                Microbot.getClient().getPlane());
        return worldPoint.distanceTo(Microbot.getClient().getLocalPlayer().getWorldLocation()) < distance;
    }
    public static int distanceToRegion(int regionX, int regionY) {
        WorldPoint worldPoint = WorldPoint.fromRegion(Microbot.getClient().getLocalPlayer().getWorldLocation().getRegionID(),
                regionX,
                regionY,
                Microbot.getClient().getPlane());
        return worldPoint.distanceTo(Microbot.getClient().getLocalPlayer().getWorldLocation());
    }
    private static boolean handleDoors(List<WorldPoint> path, int index) {
        if (ShortestPathPlugin.getPathfinder() == null) return false;
        if (index == path.size() - 1) return false;
        var doorActions = Arrays.asList("pay-toll", "pick-lock", "walk-through", "go-through", "open");
        // Check this and the next tile for door objects
        for (int doorIndex = index; doorIndex < index + 2; doorIndex++){
            var point = path.get(doorIndex);
            // Handle wall and game objects
            TileObject object = null;
            var tile = Rs2GameObject.getTiles(3).stream()
                    .filter(x -> x.getWorldLocation().equals(point))
                    .findFirst().orElse(null);
            if (tile != null)
                object = tile.getWallObject();
            if (object == null)
                object = Rs2GameObject.getGameObject(point);
            if (object == null) continue;
            var objectComp = Rs2GameObject.getObjectComposition(object.getId());
            if (objectComp == null) continue;
            // Match action
            var action = Arrays.stream(objectComp.getActions())
                    .filter(x -> x != null && doorActions.stream().anyMatch(doorAction -> x.toLowerCase().startsWith(doorAction)))
                    .min(Comparator.comparing(x -> doorActions.indexOf(
                            doorActions.stream().filter(doorAction -> x.toLowerCase().startsWith(doorAction)).findFirst().orElse(""))))
                    .orElse(null);
            if (action == null) continue;
            boolean found = false;
            if (object instanceof WallObject){
                // Match wall objects by orientation
                var orientation = ((WallObject) object).getOrientationA();
                if (doorIndex == index){
                    // Forward
                    var neighborPoint = path.get(doorIndex + 1);
                    if (orientation == 1 && point.dx(-1).getX() == neighborPoint.getX()
                            || orientation == 4 && point.dx(+1).getX() == neighborPoint.getX()
                            || orientation == 2 && point.dy(1).getY() == neighborPoint.getY()
                            || orientation == 8 && point.dy(-1).getY() == neighborPoint.getY())
                        found = true;
                } else if (doorIndex == index + 1){
                    // Backward
                    var neighborPoint = path.get(doorIndex - 1);
                    if (orientation == 1 && point.dx(-1).getX() == neighborPoint.getX()
                            || orientation == 4 && point.dx(+1).getX() == neighborPoint.getX()
                            || orientation == 2 && point.dy(1).getY() == neighborPoint.getY()
                            || orientation == 8 && point.dy(-1).getY() == neighborPoint.getY())
                        found = true;
                    // Diagonal objects with any orientation
                    if (index + 2 < path.size() && (orientation == 16 || orientation == 32 || orientation == 64 || orientation == 128)){
                        var prevPoint = path.get(doorIndex - 1);
                        var nextPoint = path.get(doorIndex + 1);
                        if (Math.abs(prevPoint.getX() - nextPoint.getX()) > 0 && Math.abs(prevPoint.getY() - nextPoint.getY()) > 0)
                            found = true;
                    }
                }
            } else if (object instanceof GameObject){
                // Match game objects by name
                // Orientation does not work as game objects are not strictly oriented like walls
                var objectNames = Arrays.asList("door");
                if (objectNames.contains(objectComp.getName().toLowerCase()))
                    found = true;
            }
            if (found){
                System.out.println(action);
                Rs2GameObject.interact(object, action);
                Rs2Player.waitForWalking();
                return true;
            }
        }
        return false;
    }
    /**
     * @param path
     * @return
     */
    public static int getClosestTileIndex(List<WorldPoint> path) {
        WorldPoint startPoint;
        var tiles = Rs2Tile.getReachableTilesFromTile(Rs2Player.getWorldLocation(), 20);
        startPoint = path.stream()
                .min(Comparator.comparingInt(a -> {
                    if (tiles.containsKey(a))
                        return tiles.get(a);
                    return Integer.MAX_VALUE;
                }))
                .orElse(null);
        return IntStream.range(0, path.size())
                .filter(i -> path.get(i).equals(startPoint))
                .findFirst()
                .orElse(0);
    }
    /**
     * @param target
     */
    public static void setTarget(WorldPoint target) {
        if (!Microbot.isLoggedIn()) return;
        Player localPlayer = Microbot.getClient().getLocalPlayer();
        if (!ShortestPathPlugin.isStartPointSet() && localPlayer == null) {
            return;
        }
        currentTarget = target;
        if (target == null) {
            synchronized (ShortestPathPlugin.getPathfinderMutex()) {
                if (ShortestPathPlugin.getPathfinder() != null) {
                    ShortestPathPlugin.getPathfinder().cancel();
                }
                ShortestPathPlugin.setPathfinder(null);
            }
            Microbot.getWorldMapPointManager().remove(ShortestPathPlugin.getMarker());
            ShortestPathPlugin.setMarker(null);
            ShortestPathPlugin.setStartPointSet(false);
        } else {
            Microbot.getWorldMapPointManager().removeIf(x -> x == ShortestPathPlugin.getMarker());
            ShortestPathPlugin.setMarker(new WorldMapPoint(target, ShortestPathPlugin.MARKER_IMAGE));
            ShortestPathPlugin.getMarker().setName("Target");
            ShortestPathPlugin.getMarker().setTarget(ShortestPathPlugin.getMarker().getWorldPoint());
            ShortestPathPlugin.getMarker().setJumpOnClick(true);
            Microbot.getWorldMapPointManager().add(ShortestPathPlugin.getMarker());
            WorldPoint start = Microbot.getClient().isInInstancedRegion() ?
                    WorldPoint.fromLocalInstance(Microbot.getClient(), localPlayer.getLocalLocation()) : localPlayer.getWorldLocation();
            ShortestPathPlugin.setLastLocation(start);
            if (ShortestPathPlugin.isStartPointSet() && ShortestPathPlugin.getPathfinder() != null) {
                start = ShortestPathPlugin.getPathfinder().getStart();
            }
            restartPathfinding(start, target);
            if (Microbot.getClientThread().scheduledFuture != null)
                Microbot.getClientThread().scheduledFuture.cancel(true);
        }
    }
    /**
     * @param start
     * @param end
     */
    public static void restartPathfinding(WorldPoint start, WorldPoint end) {
        synchronized (ShortestPathPlugin.getPathfinderMutex()) {
            if (ShortestPathPlugin.getPathfinder() != null) {
                ShortestPathPlugin.getPathfinder().cancel();
                ShortestPathPlugin.getPathfinderFuture().cancel(true);
            }
            if (ShortestPathPlugin.getPathfindingExecutor() == null) {
                ThreadFactory shortestPathNaming = new ThreadFactoryBuilder().setNameFormat("shortest-path-%d").build();
                ShortestPathPlugin.setPathfindingExecutor(Executors.newSingleThreadExecutor(shortestPathNaming));
            }
        }
        Microbot.getClientThread().invokeLater(() -> {
            ShortestPathPlugin.getPathfinderConfig().refresh();
            synchronized (ShortestPathPlugin.getPathfinderMutex()) {
                ShortestPathPlugin.setPathfinder(new Pathfinder(ShortestPathPlugin.getPathfinderConfig(), start, end));
                ShortestPathPlugin.setPathfinderFuture(ShortestPathPlugin.getPathfindingExecutor().submit(ShortestPathPlugin.getPathfinder()));
            }
        });
    }
    /**
     * @param point
     * @return
     */
    public static Tile getTile(WorldPoint point) {
        LocalPoint a;
        if (Microbot.getClient().isInInstancedRegion()) {
            WorldPoint instancedWorldPoint = WorldPoint.toLocalInstance(Microbot.getClient(), point).stream().findFirst().get();
            a = LocalPoint.fromWorld(Microbot.getClient(), instancedWorldPoint);
        } else {
            a = LocalPoint.fromWorld(Microbot.getClient(), point);
        }
        if (a == null) {
            return null;
        }
        return Microbot.getClient().getScene().getTiles()[point.getPlane()][a.getSceneX()][a.getSceneY()];
    }
    /**
     * @param path
     * @param indexOfStartPoint
     * @return
     */
    public static boolean handleTransports(List<WorldPoint> path, int indexOfStartPoint) {
        for (Transport b : ShortestPathPlugin.getTransports().getOrDefault(path.get(indexOfStartPoint), new ArrayList<>())) {
            for (WorldPoint origin : WorldPoint.toLocalInstance(Microbot.getClient(), b.getOrigin())) {
                if (Rs2Player.getWorldLocation().getPlane() != b.getOrigin().getPlane()) {
                    continue;
                }
                for (int i = indexOfStartPoint; i < path.size(); i++) {
                    if (origin.getPlane() != Rs2Player.getWorldLocation().getPlane())
                        continue;
                    if (path.stream().noneMatch(x -> x.equals(b.getDestination()))) continue;
                    int indexOfOrigin = IntStream.range(0, path.size())
                            .filter(f -> path.get(f).equals(b.getOrigin()))
                            .findFirst()
                            .orElse(-1);
                    int indexOfDestination = IntStream.range(0, path.size())
                            .filter(f -> path.get(f).equals(b.getDestination()))
                            .findFirst()
                            .orElse(-1);
                    if (indexOfDestination == -1) continue;
                    if (indexOfOrigin == -1) continue;
                    if (indexOfDestination < indexOfOrigin) continue;
                    if (path.get(i).equals(origin)) {
                        if (b.isShip() || b.isNpc() || b.isBoat()) {
                            var npcAndAction = String.format("%s %s", b.getAction(), b.getNpcName());
                            NPC npc = null;
                            String action = "";
                            for (int n = npcAndAction.indexOf(" "); n >= 0; n = npcAndAction.indexOf(" ", n + 1)){
                                npc = Rs2Npc.getNpc(npcAndAction.substring(n + 1));
                                if (npc != null){
                                    action = npcAndAction.substring(0, n);
                                    break;
                                }
                            }
                            if (Rs2Npc.canWalkTo(npc, 20)){
                                Rs2Npc.interact(npc, action);
                                Rs2Player.waitForWalking();
                            } else {
                                Rs2Walker.walkFastCanvas(path.get(i));
                                sleep(1200, 1600);
                            }
                        }
                    }
                    if (b.getDestination().distanceTo2D(Rs2Player.getWorldLocation()) > 20) {
                        handleTrapdoor(b);
                    }
                    if (b.isSpiritTree()) {
                        b.handleSpiritTree();
                    }
                    if (b.isGnomeGlider()) {
                        b.handleGlider();
                    }
                    if (b.isFairyRing() && !Rs2Player.getWorldLocation().equals(b.getDestination())) {
                        b.handleFairyRing();
                    }
                    GameObject gameObject = Rs2GameObject.getGameObjects(b.getObjectId(), b.getOrigin()).stream().findFirst().orElse(null);
                    //check game objects
                    if (gameObject != null && gameObject.getId() == b.getObjectId()) {
                        boolean interact = Rs2GameObject.interact(gameObject, b.getAction(), true);
                        if (!interact) {
                            Rs2Walker.walkMiniMap(path.get(i));
                            sleep(1600, 2000);
                            return true;
                        }
                        Rs2Player.waitForWalking();
                        return true;
                    }
                        //check tile objects
                        List<TileObject> tileObjects = Rs2GameObject.getTileObjects(b.getObjectId(), b.getOrigin());
                        TileObject tileObject = tileObjects.stream().findFirst().orElse(null);
                        if (tileObject instanceof GroundObject)
                            tileObject = tileObjects.stream()
                                    .filter(x -> !x.getWorldLocation().equals(Rs2Player.getWorldLocation()))
                                    .min(Comparator.comparing(x -> ((TileObject)x).getWorldLocation().distanceTo(b.getOrigin()))
                                            .thenComparing(x -> ((TileObject)x).getWorldLocation().distanceTo(b.getDestination()))).orElse(null);
                        if (tileObject != null && tileObject.getId() == b.getObjectId()) {
                            boolean checkCanReach = tileObject.getId() != 16533;
                            boolean interact = Rs2GameObject.interact(tileObject, b.getAction(), checkCanReach);
                        if (!interact) {
                            Rs2Walker.walkMiniMap(path.get(i));
                            sleep(1600, 2000);
                            return true;
                        }
                        if (b.isAgilityShortcut()) {
                            Rs2Player.waitForAnimation();
                        } else {
                            Rs2Player.waitForWalking();
                        }
                        return true;
                    }
                }
            }
        }
        return false;
    }
    private static boolean handleTrapdoor(Transport b) {
        List<GroundObject> gameObjects = Rs2GameObject.getGroundObjects(25);
        gameObjects = gameObjects.stream().filter(g -> Rs2GameObject.getObjectIdsByName("trapdoor").stream().anyMatch(x -> g.getId() == x)).collect(Collectors.toList());
        GroundObject trapdoor = gameObjects
                .stream()
                .map(x -> {
                    ObjectComposition objectComposition = Rs2GameObject.convertGameObjectToObjectComposition(x.getId());
                    if (objectComposition == null) {
                        return null;
                    }
                    boolean isTrapdoorNearOrigin = x.getWorldLocation().distanceTo(b.getOrigin()) <= 5;
                    if (!isTrapdoorNearOrigin) {
                        return null;
                    }
                    boolean hasOpenAction = !Arrays.stream(objectComposition.getActions()).filter(Objects::nonNull).filter(o -> o.toLowerCase().contains("open")).findFirst().orElse("").isEmpty();
                    if (!hasOpenAction) {
                        return null;
                    }
                    return x;
                }).filter(Objects::nonNull)
                .findFirst().orElse(null);
        if (trapdoor != null) {
            Rs2GameObject.interact(trapdoor, "open");
            Rs2Player.waitForAnimation();
            return true;
        }
        return false;
    }
    /**
     * Checks if the player's current location is within the specified area defined by the given world points.
     *
     * @param worldPoints an array of two world points of the NW and SE corners of the area
     * @return true if the player's current location is within the specified area, false otherwise
     */
    public static boolean isInArea(WorldPoint... worldPoints) {
        WorldPoint playerLocation = Rs2Player.getWorldLocation();
        return playerLocation.getX() <= worldPoints[0].getX() &&   // NW corner x
                playerLocation.getY() >= worldPoints[0].getY() &&   // NW corner y
                playerLocation.getX() >= worldPoints[1].getX() &&   // SE corner x
                playerLocation.getY() <= worldPoints[1].getY();     // SE corner Y
        // draws box from 2 points to check against all variations of player X,Y from said points.
    }
    /**
     * Checks if the player's current location is within the specified range from the given center point.
     *
     * @param centerOfArea a WorldPoint which is the center of the desired area,
     * @param range        an int of range to which the boundaries will be drawn in a square,
     * @return true if the player's current location is within the specified area, false otherwise
     */
    public static boolean isInArea(WorldPoint centerOfArea, int range) {
        WorldPoint nwCorner = new WorldPoint(centerOfArea.getX() + range + range, centerOfArea.getY() - range, centerOfArea.getPlane());
        WorldPoint seCorner = new WorldPoint(centerOfArea.getX() - range - range, centerOfArea.getY() + range, centerOfArea.getPlane());
        return isInArea(nwCorner, seCorner); // call to our sibling
    }
    public static boolean isNear() {
        WorldPoint playerLocation = Rs2Player.getWorldLocation();
        int index = IntStream.range(0, ShortestPathPlugin.getPathfinder().getPath().size())
                .filter(f -> ShortestPathPlugin.getPathfinder().getPath().get(f).distanceTo2D(playerLocation) < 3)
                .findFirst()
                .orElse(-1);
        return index >= ShortestPathPlugin.getPathfinder().getPath().size() - 10;
    }
    /**
     * @param target
     * @return
     */
    public static boolean isNear(WorldPoint target) {
        return Rs2Player.getWorldLocation().equals(target);
    }
    private static void checkIfStuck() {
        if (Rs2Player.getWorldLocation().equals(lastPosition)) {
            stuckCount++;
        } else {
            stuckCount = 0;
        }
    }
    /**
     * @param start
     */
    public void setStart(WorldPoint start) {
        if (ShortestPathPlugin.getPathfinder() == null) {
            return;
        }
        ShortestPathPlugin.setStartPointSet(true);
        restartPathfinding(start, ShortestPathPlugin.getPathfinder().getTarget());
    }
    /**
     * Checks the distance between startpoint and endpoint using ShortestPath
     * 
     * @param startpoint
     * @param endpoint
     * @return distance
     */
    public static int getDistanceBetween(WorldPoint startpoint, WorldPoint endpoint) {
        ExecutorService pathfindingExecutor = Executors.newSingleThreadExecutor();
        Pathfinder pathfinder = new Pathfinder(ShortestPathPlugin.getPathfinderConfig(), startpoint, endpoint);
        pathfindingExecutor.submit(pathfinder);
        sleepUntil(pathfinder::isDone);
        return pathfinder.getPath().size();
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/widget/models/ItemWidget.java
================
package net.runelite.client.plugins.microbot.util.widget.models;
import net.runelite.api.FontTypeFace;
import net.runelite.api.Point;
import net.runelite.api.widgets.Widget;
import net.runelite.client.plugins.microbot.Microbot;
import javax.annotation.Nullable;
import java.awt.*;
public class ItemWidget implements Widget {
    int id;
    int index;
    String name;
    int itemId;
    int quantity;
    private int slot;
    // temp constructor untill we move everything from inventory to a memory list instead of widgets
    public ItemWidget(Widget w) {
        this.name = w.getName();
        this.itemId = w.getItemId();
        this.quantity = w.getItemQuantity();
        this.index = w.getIndex();
    }
    public ItemWidget(String name, int itemId, int quantity, int index) {
        this.name = name;
        this.itemId = itemId;
        this.quantity = quantity;
        this.index = index;
    }
    @Override
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    @Override
    public int getType() {
        return 0;
    }
    @Override
    public void setType(int type) {
    }
    @Override
    public int getContentType() {
        return 0;
    }
    @Override
    public Widget setContentType(int contentType) {
        return null;
    }
    @Override
    public int getClickMask() {
        return 0;
    }
    @Override
    public Widget setClickMask(int mask) {
        return null;
    }
    @Override
    public Widget getParent() {
        return null;
    }
    @Override
    public int getParentId() {
        return 0;
    }
    @Override
    public Widget getChild(int index) {
        return null;
    }
    @Nullable
    @Override
    public Widget[] getChildren() {
        return new Widget[0];
    }
    @Override
    public void setChildren(Widget[] children) {
    }
    @Override
    public Widget[] getDynamicChildren() {
        return new Widget[0];
    }
    @Override
    public Widget[] getStaticChildren() {
        return new Widget[0];
    }
    @Override
    public Widget[] getNestedChildren() {
        return new Widget[0];
    }
    @Override
    public int getRelativeX() {
        return 0;
    }
    @Override
    public void setRelativeX(int x) {
    }
    @Override
    public int getRelativeY() {
        return 0;
    }
    @Override
    public void setRelativeY(int y) {
    }
    @Override
    public void setForcedPosition(int x, int y) {
    }
    @Override
    public String getText() {
        return null;
    }
    @Override
    public Widget setText(String text) {
        return null;
    }
    @Override
    public int getTextColor() {
        return 0;
    }
    @Override
    public Widget setTextColor(int textColor) {
        return null;
    }
    @Override
    public int getOpacity() {
        return 0;
    }
    @Override
    public Widget setOpacity(int transparency) {
        return null;
    }
    @Override
    public String getName() {
        return name;
    }
    @Override
    public Widget setName(String name) {
        return null;
    }
    @Override
    public int getModelId() {
        return 0;
    }
    @Override
    public Widget setModelId(int id) {
        return null;
    }
    @Override
    public int getModelType() {
        return 0;
    }
    @Override
    public Widget setModelType(int type) {
        return null;
    }
    @Override
    public int getAnimationId() {
        return 0;
    }
    @Override
    public Widget setAnimationId(int animationId) {
        return null;
    }
    @Override
    public int getRotationX() {
        return 0;
    }
    @Override
    public Widget setRotationX(int modelX) {
        return null;
    }
    @Override
    public int getRotationY() {
        return 0;
    }
    @Override
    public Widget setRotationY(int modelY) {
        return null;
    }
    @Override
    public int getRotationZ() {
        return 0;
    }
    @Override
    public Widget setRotationZ(int modelZ) {
        return null;
    }
    @Override
    public int getModelZoom() {
        return 0;
    }
    @Override
    public Widget setModelZoom(int modelZoom) {
        return null;
    }
    @Override
    public int getSpriteId() {
        return 0;
    }
    @Override
    public boolean getSpriteTiling() {
        return false;
    }
    @Override
    public Widget setSpriteTiling(boolean tiling) {
        return null;
    }
    @Override
    public Widget setSpriteId(int spriteId) {
        return null;
    }
    @Override
    public boolean isHidden() {
        return false;
    }
    @Override
    public boolean isSelfHidden() {
        return false;
    }
    @Override
    public Widget setHidden(boolean hidden) {
        return null;
    }
    @Override
    public int getIndex() {
        return index;
    }
    public void setIndex(int index) {
        this.index = index;
    }
    public int getSlot() {
        return slot;
    }
    public void setSlot(int slot) {
        this.slot = slot;
    }
    @Override
    public Point getCanvasLocation() {
        return null;
    }
    @Override
    public int getWidth() {
        return 0;
    }
    @Override
    public void setWidth(int width) {
    }
    @Override
    public int getHeight() {
        return 0;
    }
    @Override
    public void setHeight(int height) {
    }
    @Override
    public Rectangle getBounds() {
        return null;
    }
    @Override
    public int getItemId() {
        return itemId;
    }
    @Override
    public Widget setItemId(int itemId) {
        return null;
    }
    @Override
    public int getItemQuantity() {
        return quantity;
    }
    @Override
    public Widget setItemQuantity(int quantity) {
        return null;
    }
    @Override
    public boolean contains(Point point) {
        return false;
    }
    @Override
    public int getScrollX() {
        return 0;
    }
    @Override
    public Widget setScrollX(int scrollX) {
        return null;
    }
    @Override
    public int getScrollY() {
        return 0;
    }
    @Override
    public Widget setScrollY(int scrollY) {
        return null;
    }
    @Override
    public int getScrollWidth() {
        return 0;
    }
    @Override
    public Widget setScrollWidth(int width) {
        return null;
    }
    @Override
    public int getScrollHeight() {
        return 0;
    }
    @Override
    public Widget setScrollHeight(int height) {
        return null;
    }
    @Override
    public int getOriginalX() {
        return 0;
    }
    @Override
    public Widget setOriginalX(int originalX) {
        return null;
    }
    @Override
    public int getOriginalY() {
        return 0;
    }
    @Override
    public Widget setOriginalY(int originalY) {
        return null;
    }
    @Override
    public Widget setPos(int x, int y) {
        return null;
    }
    @Override
    public Widget setPos(int x, int y, int xMode, int yMode) {
        return null;
    }
    @Override
    public int getOriginalHeight() {
        return 0;
    }
    @Override
    public Widget setOriginalHeight(int originalHeight) {
        return null;
    }
    @Override
    public int getOriginalWidth() {
        return 0;
    }
    @Override
    public Widget setOriginalWidth(int originalWidth) {
        return null;
    }
    @Override
    public Widget setSize(int width, int height) {
        return null;
    }
    @Override
    public Widget setSize(int width, int height, int widthMode, int heightMode) {
        return null;
    }
    @Nullable
    @Override
    public String[] getActions() {
        String[] actions = new String[10];
        //0
        switch (Microbot.getClient().getVarbitValue(6590)) {
            case 0:
                actions[0] = "Withdraw-1";
                break;
            case 1:
                actions[0] = "Withdraw-5";
                break;
            case 2:
                actions[0] = "Withdraw-10";
                break;
            case 3:
                actions[0] = "Withdraw-" + Microbot.getClient().getVarbitValue(3960);
                break;
            case 4:
                actions[0] = "Withdraw-All";
                break;
        }
        //1
        if (Microbot.getClient().getVarbitValue(6590) != 0) {
            actions[1] = "Withdraw-1";
        }
        //2-3
        actions[2] = "Withdraw-5";
        actions[3] = "Withdraw-10";
        //4
        if (Microbot.getClient().getVarbitValue(3960) > 0) {
            actions[4] = "Withdraw-" + Microbot.getClient().getVarbitValue(3960);
        }
        //5-7
        actions[5] = "Withdraw-X";
        actions[6] = "Withdraw-All";
        actions[7] = "Withdraw-All-but-1";
        //8
        if (Microbot.getClient().getVarbitValue(3755) == 0) {
            actions[8] = "Placeholder";
        }
        //9
        actions[9] = "Examine";
        return actions;
    }
    public Widget createStaticChild(int type) {
        return null;
    }
    @Override
    public Widget createChild(int index, int type) {
        return null;
    }
    @Override
    public Widget createChild(int type) {
        return null;
    }
    @Override
    public void deleteAllChildren() {
    }
    @Override
    public void setAction(int index, String action) {
    }
    @Override
    public void clearActions() {
    }
    @Override
    public void setOnOpListener(Object... args) {
    }
    @Override
    public void setOnDialogAbortListener(Object... args) {
    }
    @Override
    public void setOnKeyListener(Object... args) {
    }
    @Override
    public void setOnMouseOverListener(Object... args) {
    }
    @Override
    public void setOnMouseRepeatListener(Object... args) {
    }
    @Override
    public void setOnMouseLeaveListener(Object... args) {
    }
    @Override
    public void setOnTimerListener(Object... args) {
    }
    @Override
    public void setOnTargetEnterListener(Object... args) {
    }
    @Override
    public void setOnTargetLeaveListener(Object... args) {
    }
    @Override
    public boolean hasListener() {
        return false;
    }
    @Override
    public Widget setHasListener(boolean hasListener) {
        return null;
    }
    @Override
    public boolean isIf3() {
        return false;
    }
    @Override
    public void revalidate() {
    }
    @Override
    public void revalidateScroll() {
    }
    @Override
    public Object[] getOnOpListener() {
        return new Object[0];
    }
    @Override
    public Object[] getOnKeyListener() {
        return new Object[0];
    }
    @Override
    public Object[] getOnLoadListener() {
        return new Object[0];
    }
    @Override
    public Object[] getOnInvTransmitListener() {
        return new Object[0];
    }
    @Override
    public int getFontId() {
        return 0;
    }
    @Override
    public Widget setFontId(int id) {
        return null;
    }
    @Override
    public int getBorderType() {
        return 0;
    }
    @Override
    public void setBorderType(int thickness) {
    }
    @Override
    public boolean getTextShadowed() {
        return false;
    }
    @Override
    public Widget setTextShadowed(boolean shadowed) {
        return null;
    }
    @Override
    public int getDragDeadZone() {
        return 0;
    }
    @Override
    public void setDragDeadZone(int deadZone) {
    }
    @Override
    public int getDragDeadTime() {
        return 0;
    }
    @Override
    public void setDragDeadTime(int deadTime) {
    }
    @Override
    public int getItemQuantityMode() {
        return 0;
    }
    @Override
    public Widget setItemQuantityMode(int itemQuantityMode) {
        return null;
    }
    @Override
    public int getXPositionMode() {
        return 0;
    }
    @Override
    public Widget setXPositionMode(int xpm) {
        return null;
    }
    @Override
    public int getYPositionMode() {
        return 0;
    }
    @Override
    public Widget setYPositionMode(int ypm) {
        return null;
    }
    @Override
    public int getLineHeight() {
        return 0;
    }
    @Override
    public Widget setLineHeight(int lineHeight) {
        return null;
    }
    @Override
    public int getXTextAlignment() {
        return 0;
    }
    @Override
    public Widget setXTextAlignment(int xta) {
        return null;
    }
    @Override
    public int getYTextAlignment() {
        return 0;
    }
    @Override
    public Widget setYTextAlignment(int yta) {
        return null;
    }
    @Override
    public int getWidthMode() {
        return 0;
    }
    @Override
    public Widget setWidthMode(int widthMode) {
        return null;
    }
    @Override
    public int getHeightMode() {
        return 0;
    }
    @Override
    public Widget setHeightMode(int heightMode) {
        return null;
    }
    @Override
    public FontTypeFace getFont() {
        return null;
    }
    @Override
    public boolean isFilled() {
        return false;
    }
    @Override
    public Widget setFilled(boolean filled) {
        return null;
    }
    @Override
    public String getTargetVerb() {
        return null;
    }
    @Override
    public void setTargetVerb(String targetVerb) {
    }
    @Override
    public boolean getNoClickThrough() {
        return false;
    }
    @Override
    public void setNoClickThrough(boolean noClickThrough) {
    }
    @Override
    public boolean getNoScrollThrough() {
        return false;
    }
    @Override
    public void setNoScrollThrough(boolean noScrollThrough) {
    }
    @Override
    public void setVarTransmitTrigger(int... trigger) {
    }
    @Override
    public void setOnClickListener(Object... args) {
    }
    @Override
    public void setOnHoldListener(Object... args) {
    }
    @Override
    public void setOnReleaseListener(Object... args) {
    }
    @Override
    public void setOnDragCompleteListener(Object... args) {
    }
    @Override
    public void setOnDragListener(Object... args) {
    }
    @Override
    public void setOnScrollWheelListener(Object... args) {
    }
    @Override
    public Widget getDragParent() {
        return null;
    }
    @Override
    public Widget setDragParent(Widget dragParent) {
        return null;
    }
    @Override
    public Object[] getOnVarTransmitListener() {
        return new Object[0];
    }
    @Override
    public void setOnVarTransmitListener(Object... args) {
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/widget/Rs2Widget.java
================
package net.runelite.client.plugins.microbot.util.widget;
import net.runelite.api.MenuAction;
import net.runelite.api.widgets.InterfaceID;
import net.runelite.api.widgets.Widget;
import net.runelite.api.widgets.WidgetInfo;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.menu.NewMenuEntry;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import static net.runelite.client.plugins.microbot.util.Global.sleepUntil;
public class Rs2Widget {
    public static boolean clickWidget(String text, int widgetId, int childId, boolean exact) {
        return Microbot.getClientThread().runOnClientThread(() -> {
            Widget rootWidget = getWidget(widgetId, childId);
            Widget widget = null;
            if (rootWidget.getChildren() != null)
                widget = findWidget(text, Arrays.stream(rootWidget.getChildren()).filter(x -> x != null && !x.isHidden()).collect(Collectors.toList()), exact);
            if (rootWidget.getNestedChildren().length > 0)
                widget =  findWidget(text, Arrays.stream(rootWidget.getNestedChildren()).filter(x -> x != null && !x.isHidden()).collect(Collectors.toList()), exact);
            if (rootWidget.getDynamicChildren().length > 0)
                widget = findWidget(text, Arrays.stream(rootWidget.getDynamicChildren()).filter(x -> x != null && !x.isHidden()).collect(Collectors.toList()), exact);
            if (rootWidget.getStaticChildren().length > 0)
                widget = findWidget(text, Arrays.stream(rootWidget.getStaticChildren()).filter(x -> x != null && !x.isHidden()).collect(Collectors.toList()), exact);
            if (widget != null) {
                Microbot.getMouse().click(widget.getBounds());
                return true;
            }
            return false;
        });
    }
    public static boolean clickWidget(String text) {
        Widget widget = findWidget(text, null);
        if (widget != null) {
            Microbot.getMouse().click(widget.getBounds());
            return true;
        }
        return false;
    }
    public static boolean clickWidget(String text, boolean exact) {
        Widget widget = findWidget(text, null, exact);
        if (widget != null) {
            Microbot.getMouse().click(widget.getBounds());
            return true;
        }
        return false;
    }
    public static boolean clickWidget(int parentId, int childId) {
        Widget widget = getWidget(parentId, childId);
        if (widget != null) {
            Microbot.getMouse().click(widget.getBounds());
            return true;
        }
        return false;
    }
    public static boolean clickWidget(WidgetInfo widgetInfo) {
        Widget widget = getWidget(widgetInfo);
        if (widget != null) {
            Microbot.getMouse().click(widget.getBounds());
            return true;
        }
        return false;
    }
    public static boolean isWidgetVisible(WidgetInfo wiget) {
        return !Microbot.getClientThread().runOnClientThread(() -> getWidget(wiget) == null || getWidget(wiget).isHidden());
    }
    public static boolean isWidgetVisible(int widgetId, int childId) {
        return !Microbot.getClientThread().runOnClientThread(() -> getWidget(widgetId, childId) == null || getWidget(widgetId, childId).isHidden());
    }
    public static Widget getWidget(WidgetInfo wiget) {
        return Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getWidget(wiget));
    }
    public static Widget getWidget(int id) {
        return Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getWidget(id));
    }
    public static boolean isHidden(int id) {
        return Microbot.getClientThread().runOnClientThread(() -> {
            Widget widget = Microbot.getClient().getWidget(id);
            if (widget == null) return true;
            return widget.isHidden();
        });
    }
    public static Widget getWidget(int id, int child) {
        return Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getWidget(id, child));
    }
    public static boolean getWidgetChildText(int id, String matchingText) {
        return Microbot.getClientThread().runOnClientThread(() -> {
            Widget widget = Microbot.getClient().getWidget(id);
            if (widget == null) return false;
            if (widget.getChildren().length == 0) return false;
            return Arrays.stream(widget.getChildren()).anyMatch(x -> x.getText().contains(matchingText));
        });
    }
    public static Widget getWidgetChildName(int id, String matchingText) {
        return Microbot.getClientThread().runOnClientThread(() -> {
            Widget widget = Microbot.getClient().getWidget(id);
            if (widget == null) return null;
            if (widget.getChildren().length == 0) return null;
            return Arrays.stream(widget.getChildren()).filter(x -> x.getName().contains(matchingText)).findFirst().orElse(null);
        });
    }
    public static Widget getWidgetChildtxt(int id, String matchingText) {
        return Microbot.getClientThread().runOnClientThread(() -> {
            Widget widget = Microbot.getClient().getWidget(id);
            if (widget == null) return null;
            if (widget.getChildren().length == 0) return null;
            return Arrays.stream(widget.getChildren()).filter(x -> x.getText().contains(matchingText)).findFirst().orElse(null);
        });
    }
    public static Widget getWidgetChildSprite(int id, int matchingSpriteId) {
        return Microbot.getClientThread().runOnClientThread(() -> {
            Widget widget = Microbot.getClient().getWidget(id);
            if (widget == null) return null;
            if (widget.getChildren().length == 0) return null;
            return Arrays.stream(widget.getChildren()).filter(x -> x.getSpriteId() == (matchingSpriteId)).findFirst().orElse(null);
        });
    }
    public static int getChildWidgetSpriteID(int id, int childId) {
        return Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getWidget(id).getChild(childId).getSpriteId());
    }
    public static String getChildWidgetText(int id, int childId) {
        return Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getWidget(id).getChild(childId).getText());
    }
    public static boolean clickWidget(int id) {
        Widget widget = Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getWidget(id));
        if (widget == null) return false;
        Microbot.getMouse().click(widget.getBounds());
        return true;
    }
    public static boolean clickChildWidget(int id, int childId) {
        Widget widget = Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getWidget(id));
        if (widget == null) return false;
        Microbot.getMouse().click(widget.getChild(childId).getBounds());
        return true;
    }
    public static boolean childWidgetExits(int id, int childId) {
        return Microbot.getClientThread().runOnClientThread(() -> Microbot.getClient().getWidget(id).getChild(childId) != null);
    }
    public static void changeWidgetText(String textToSearch, String newText) {
        do {
            try {
                Widget widget = findWidget(textToSearch, null);
                if (widget == null) break;
                Microbot.getClientThread().runOnClientThread(() -> widget.setText(newText));
            } catch (Exception ex) {
                System.out.println(ex.getMessage());
            }
        } while (true);
    }
    public static Widget findWidget(String text, List<Widget> children, boolean exact) {
        return Microbot.getClientThread().runOnClientThread(() -> {
            Widget foundWidget = null;
            if (children == null) {
                List<Widget> rootWidgets = Arrays.stream(Microbot.getClient().getWidgetRoots()).filter(x -> x != null && !x.isHidden()).collect(Collectors.toList());
                for (Widget rootWidget : rootWidgets) {
                    if (exact) {
                        if (rootWidget.getText().toLowerCase().contains(text.toLowerCase()) || rootWidget.getName().toLowerCase().contains(">" + text.toLowerCase() + "<")) {
                            return rootWidget;
                        }
                    } else {
                        if (rootWidget.getText().toLowerCase().contains(text.toLowerCase()) || rootWidget.getName().toLowerCase().contains(text.toLowerCase())) {
                            return rootWidget;
                        }
                    }
                    if (rootWidget.getChildren() != null)
                        return findWidget(text, Arrays.stream(rootWidget.getChildren()).filter(x -> x != null && !x.isHidden()).collect(Collectors.toList()), exact);
                    if (rootWidget.getNestedChildren().length > 0)
                        return findWidget(text, Arrays.stream(rootWidget.getNestedChildren()).filter(x -> x != null && !x.isHidden()).collect(Collectors.toList()), exact);
                    if (rootWidget.getDynamicChildren().length > 0)
                        return findWidget(text, Arrays.stream(rootWidget.getDynamicChildren()).filter(x -> x != null && !x.isHidden()).collect(Collectors.toList()), exact);
                    if (rootWidget.getStaticChildren().length > 0)
                        return findWidget(text, Arrays.stream(rootWidget.getStaticChildren()).filter(x -> x != null && !x.isHidden()).collect(Collectors.toList()), exact);
                }
            } else if (children.size() > 0) {
                for (Widget child : children) {
                    foundWidget = searchChildren(text, child, exact);
                    if (foundWidget != null) break;
                }
            }
            return foundWidget;
        });
    }
    public static Widget findWidget(String text) {
        return findWidget(text, null, false);
    }
    public static Widget findWidgetExact(String text) {
        return findWidget(text, null, true);
    }
    public static boolean hasWidget(String text) {
        return findWidget(text, null, false) != null;
    }
    public static boolean sleepUntilHasWidget(String text) {
        sleepUntil(() -> findWidget(text, null, false) != null);
        return findWidget(text, null, false) != null;
    }
    public static Widget findWidget(String text, List<Widget> children) {
        return findWidget(text, children, false);
    }
    public static Widget searchChildren(String text, Widget child, boolean exact) {
        return Microbot.getClientThread().runOnClientThread(() -> {
            Widget found = null;
            if (exact) {
                if (child.getText().toLowerCase().contains(text.toLowerCase()) || child.getName().toLowerCase().contains(">" + text.toLowerCase() + "<")) {
                    return child;
                }
            } else {
                if (child.getText().toLowerCase().contains(text.toLowerCase()) || child.getName().toLowerCase().contains(text.toLowerCase())) {
                    return child;
                }
            }
            if (child.getChildren() != null) {
                List<Widget> visibleChildWidgets = Arrays.stream(child.getChildren()).filter(x -> x != null && !x.isHidden()).collect(Collectors.toList());
                if (visibleChildWidgets.size() > 0)
                    found = findWidget(text, visibleChildWidgets, exact);
            }
            if (found != null) return found;
            if (child.getNestedChildren().length > 0) {
                List<Widget> visibleChildWidgets = Arrays.stream(child.getNestedChildren()).filter(x -> x != null && !x.isHidden()).collect(Collectors.toList());
                if (visibleChildWidgets.size() > 0)
                    found = findWidget(text, visibleChildWidgets, exact);
            }
            if (found != null) return found;
            if (child.getDynamicChildren().length > 0) {
                List<Widget> visibleChildWidgets = Arrays.stream(child.getDynamicChildren()).filter(x -> x != null && !x.isHidden()).collect(Collectors.toList());
                if (visibleChildWidgets.size() > 0)
                    found = findWidget(text, visibleChildWidgets, exact);
            }
            if (found != null) return found;
            if (child.getStaticChildren().length > 0) {
                List<Widget> visibleChildWidgets = Arrays.stream(child.getStaticChildren()).filter(x -> x != null && !x.isHidden()).collect(Collectors.toList());
                if (visibleChildWidgets.size() > 0)
                    found = findWidget(text, visibleChildWidgets, exact);
            }
            return found;
        });
    }
    public static Widget searchChildren(String text, Widget child) {
        return searchChildren(text, child, false);
    }
    public static Widget findWidget(int spriteId, List<Widget> children) {
        return Microbot.getClientThread().runOnClientThread(() -> {
            Widget foundWidget = null;
            if (children == null) {
                List<Widget> rootWidgets = Arrays.stream(Microbot.getClient().getWidgetRoots()).filter(x -> x != null && !x.isHidden()).collect(Collectors.toList());
                for (Widget rootWidget : rootWidgets) {
                    if (rootWidget.getSpriteId() == spriteId) {
                        return rootWidget;
                    }
                    if (rootWidget.getChildren() != null)
                        return findWidget(spriteId, Arrays.stream(rootWidget.getChildren()).filter(x -> x != null && !x.isHidden()).collect(Collectors.toList()));
                    if (rootWidget.getNestedChildren().length > 0)
                        return findWidget(spriteId, Arrays.stream(rootWidget.getNestedChildren()).filter(x -> x != null && !x.isHidden()).collect(Collectors.toList()));
                    if (rootWidget.getDynamicChildren().length > 0)
                        return findWidget(spriteId, Arrays.stream(rootWidget.getDynamicChildren()).filter(x -> x != null && !x.isHidden()).collect(Collectors.toList()));
                    if (rootWidget.getStaticChildren().length > 0)
                        return findWidget(spriteId, Arrays.stream(rootWidget.getStaticChildren()).filter(x -> x != null && !x.isHidden()).collect(Collectors.toList()));
                }
            } else if (children.size() > 0) {
                for (Widget child : children) {
                    foundWidget = searchChildren(spriteId, child);
                    if (foundWidget != null) break;
                }
            }
            return foundWidget;
        });
    }
    public static Widget searchChildren(int spriteId, Widget child) {
        return Microbot.getClientThread().runOnClientThread(() -> {
            Widget found = null;
            if (child.getSpriteId() == spriteId) {
                return child;
            }
            if (child.getChildren() != null) {
                List<Widget> visibleChildWidgets = Arrays.stream(child.getChildren()).filter(x -> x != null && !x.isHidden()).collect(Collectors.toList());
                if (visibleChildWidgets.size() > 0)
                    found = findWidget(spriteId, visibleChildWidgets);
            }
            if (found != null) return found;
            if (child.getNestedChildren().length > 0) {
                List<Widget> visibleChildWidgets = Arrays.stream(child.getNestedChildren()).filter(x -> x != null && !x.isHidden()).collect(Collectors.toList());
                if (visibleChildWidgets.size() > 0)
                    found = findWidget(spriteId, visibleChildWidgets);
            }
            if (found != null) return found;
            if (child.getDynamicChildren().length > 0) {
                List<Widget> visibleChildWidgets = Arrays.stream(child.getDynamicChildren()).filter(x -> x != null && !x.isHidden()).collect(Collectors.toList());
                if (visibleChildWidgets.size() > 0)
                    found = findWidget(spriteId, visibleChildWidgets);
            }
            if (found != null) return found;
            if (child.getStaticChildren().length > 0) {
                List<Widget> visibleChildWidgets = Arrays.stream(child.getStaticChildren()).filter(x -> x != null && !x.isHidden()).collect(Collectors.toList());
                if (visibleChildWidgets.size() > 0)
                    found = findWidget(spriteId, visibleChildWidgets);
            }
            return found;
        });
    }
    public static void clickWidgetFast(int packetId, int identifier) {
        Widget widget = getWidget(packetId);
        clickWidgetFast(widget, -1, identifier);
    }
    public static void clickWidgetFast(int packetId, MenuAction menuAction) {
        Widget widget = getWidget(packetId);
        clickWidgetFast(widget, menuAction);
    }
    public static void clickWidgetFast(int packetId) {
        Widget widget = getWidget(packetId, 1);
        clickWidgetFast(widget);
    }
    public static void clickWidgetFast(Widget widget, MenuAction menuAction) {
        int param1 = widget.getId();
        String option = "Select";
        String target = "";
        Microbot.doInvoke(new NewMenuEntry(-1, param1, menuAction.getId(), 0, widget.getItemId(), target), widget.getBounds());
        // Rs2Reflection.invokeMenu(-1, param1, menuAction.getId(), 0, widget.getItemId(), option, target, -1, -1);
    }
    public static void clickWidgetFast(Widget widget, int param0, int identifier) {
        int param1 = widget.getId();
        String option = "Select";
        String target = "";
        MenuAction menuAction = MenuAction.CC_OP;
        Microbot.doInvoke(new NewMenuEntry(param0 != -1 ? param0 : widget.getType(), param1, menuAction.getId(), identifier, widget.getItemId(), target), widget.getBounds());
        // Rs2Reflection.invokeMenu(param0 != -1 ? param0 : widget.getType(), param1, menuAction.getId(), identifier, widget.getItemId(), option, target, -1, -1);
    }
    public static void clickWidgetFast(Widget widget, int param0, int identifier, MenuAction menuAction) {
        int param1 = widget.getId();
        String option = "Select";
        String target = "";
        Microbot.doInvoke(new NewMenuEntry(param0 != -1 ? param0 : widget.getType(), param1, menuAction.getId(), identifier, widget.getItemId(), target), widget.getBounds());
        // Rs2Reflection.invokeMenu(param0 != -1 ? param0 : widget.getType(), param1, menuAction.getId(), identifier, widget.getItemId(), option, target, -1, -1);
    }
    public static void clickWidgetFast(Widget widget, int param0) {
        clickWidgetFast(widget, param0, 1);
    }
    public static void clickWidgetFast(Widget widget) {
        clickWidgetFast(widget, -1, 1);
    }
    // check if production widget is open
    public static boolean isProductionWidgetOpen() {
        return isWidgetVisible(270, 0);
    }
    // check if GoldCrafting widget is open
    public static boolean isGoldCraftingWidgetOpen() {
        return isWidgetVisible(446, 0);
    }
    // check if SilverCrafting widget is open
    public static boolean isSilverCraftingWidgetOpen() {
        return isWidgetVisible(6, 0);
    }
    // check if smithing widget is open
    public static boolean isSmithingWidgetOpen() {
        return isWidgetVisible(InterfaceID.SMITHING, 0);
    }
    // check if deposit box widget is open
    public static boolean isDepositBoxWidgetOpen() {
        return isWidgetVisible(WidgetInfo.DEPOSIT_BOX_INVENTORY_ITEMS_CONTAINER);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/Global.java
================
package net.runelite.client.plugins.microbot.util;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.math.Random;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.function.BooleanSupplier;
public class Global {
    static ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(10);
    static ScheduledFuture<?> scheduledFuture;
    public static ScheduledFuture<?> awaitExecutionUntil(Runnable callback, BooleanSupplier awaitedCondition, int time) {
        scheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(() -> {
            if (awaitedCondition.getAsBoolean()) {
                scheduledFuture.cancel(true);
                scheduledFuture = null;
                callback.run();
            }
        }, 0, time, TimeUnit.MILLISECONDS);
        return scheduledFuture;
    }
    public static void sleep(int start) {
        if (Microbot.getClient().isClientThread()) return;
        try {
            Thread.sleep(start);
        } catch (InterruptedException e) {
            System.out.println(e.getMessage());
        }
    }
    public static void sleep(int start, int end) {
        int randomSleep = Random.random(start, end);
        try {
            Thread.sleep(randomSleep);
        } catch (InterruptedException e) {
            System.out.println(e.getMessage());
        }
    }
    public static void sleepUntil(BooleanSupplier awaitedCondition) {
      sleepUntil(awaitedCondition, 5000);
    }
    public static void sleepUntil(BooleanSupplier awaitedCondition, int time) {
        if (Microbot.getClient().isClientThread()) return;
        boolean done;
        long startTime = System.currentTimeMillis();
        do {
            done = awaitedCondition.getAsBoolean();
            sleep(100);
        } while (!done && System.currentTimeMillis() - startTime < time);
    }
    public static boolean sleepUntilTrue(BooleanSupplier awaitedCondition, int time, int timeout) {
        if (Microbot.getClient().isClientThread()) return false;
        long startTime = System.currentTimeMillis();
        do {
            if (awaitedCondition.getAsBoolean()) {
                return true;
            }
            sleep(time);
        } while (System.currentTimeMillis() - startTime < timeout);
        return false;
    }
    public static void sleepUntilOnClientThread(BooleanSupplier awaitedCondition) {
        sleepUntilOnClientThread(awaitedCondition, Random.random(2500, 5000));
    }
    public static void sleepUntilOnClientThread(BooleanSupplier awaitedCondition, int time) {
        if (Microbot.getClient().isClientThread()) return;
        boolean done;
        long startTime = System.currentTimeMillis();
        do {
            done = Microbot.getClientThread().runOnClientThread(() -> awaitedCondition.getAsBoolean());
        } while (!done && System.currentTimeMillis() - startTime < time);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/MicrobotInventorySetup.java
================
package net.runelite.client.plugins.microbot.util;
import net.runelite.api.Varbits;
import net.runelite.client.plugins.inventorysetups.InventorySetup;
import net.runelite.client.plugins.inventorysetups.InventorySetupsItem;
import net.runelite.client.plugins.inventorysetups.MInventorySetupsPlugin;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.bank.Rs2Bank;
import net.runelite.client.plugins.microbot.util.equipment.Rs2Equipment;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Item;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ScheduledFuture;
import java.util.stream.Collectors;
import static net.runelite.client.plugins.microbot.util.Global.sleep;
@Deprecated(since="1.3.6 - Use Rs2InventorySetup.java", forRemoval = true)
public class MicrobotInventorySetup {
    static InventorySetup inventorySetup;
    private static boolean getInventorySetup(String name) {
        inventorySetup = MInventorySetupsPlugin.getInventorySetups().stream().filter(Objects::nonNull).filter(x -> x.getName().equalsIgnoreCase(name)).findFirst().orElse(null);
        if (inventorySetup == null) {
            Microbot.showMessage("Inventory load with name " + name + " not found!");
            Microbot.pauseAllScripts = true;
            return false;
        }
        return true;
    }
    public static boolean loadInventory(String name, ScheduledFuture<?> mainScheduler) {
        Rs2Bank.openBank();
        if (!Rs2Bank.isOpen() || !getInventorySetup(name)) {
            return false;
        }
        Rs2Bank.depositAllExcept(itemsToNotDeposit(name));
        Map<Integer, List<InventorySetupsItem>> groupedByItems = inventorySetup.getInventory().stream().collect(Collectors.groupingBy(InventorySetupsItem::getId));
        for (Map.Entry<Integer, List<InventorySetupsItem>> entry : groupedByItems.entrySet()) {
            if (mainScheduler.isCancelled()) break;
            InventorySetupsItem inventorySetupsItem = entry.getValue().get(0);
            int key = entry.getKey();
            if (inventorySetupsItem.getId() == -1) continue;
            int withdrawQuantity = calculateWithdrawQuantity(entry.getValue(), inventorySetupsItem, key);
            if (withdrawQuantity == 0) continue;
            if (!Rs2Bank.hasBankItem(inventorySetupsItem.getName(), withdrawQuantity)) {
                Microbot.pauseAllScripts = true;
                Microbot.showMessage("Bank is missing the following item " + inventorySetupsItem.getName());
                break;
            }
            withdrawItem(inventorySetupsItem, withdrawQuantity);
        }
        sleep(1000);
        return doesInventoryMatch(name);
    }
    private static int calculateWithdrawQuantity(List<InventorySetupsItem> items, InventorySetupsItem inventorySetupsItem, int key) {
        int withdrawQuantity;
        if (items.size() == 1) {
            Rs2Item rs2Item = Rs2Inventory.get(key);
            if (rs2Item != null && rs2Item.isStackable()) {
                withdrawQuantity = inventorySetupsItem.getQuantity() - rs2Item.quantity;
                if (Rs2Inventory.hasItemAmount(inventorySetupsItem.getName(), inventorySetupsItem.getQuantity())) {
                    return 0;
                }
            } else {
                withdrawQuantity = items.get(0).getQuantity();
                if (Rs2Inventory.hasItemAmount(inventorySetupsItem.getName(), withdrawQuantity)) {
                    return 0;
                }
            }
        } else {
            withdrawQuantity = items.size() - (int) Rs2Inventory.items().stream().filter(x -> x.getId() == key).count();
            if (Rs2Inventory.hasItemAmount(inventorySetupsItem.getName(), items.size())) {
                return 0;
            }
        }
        return withdrawQuantity;
    }
    private static void withdrawItem(InventorySetupsItem item, int quantity) {
        if (item.isFuzzy()) {
            Rs2Bank.withdrawX(item.getName(), quantity);
        } else {
            if (quantity > 1) {
                Rs2Bank.withdrawX(item.getId(), quantity);
            } else {
                Rs2Bank.withdrawItem(item.getId());
            }
            sleep(100, 250);
        }
    }
    public static boolean loadEquipment(String name, ScheduledFuture<?> mainScheduler) {
        Rs2Bank.openBank();
        if (!Rs2Bank.isOpen() || !getInventorySetup(name)) {
            return false;
        }
        //Clear inventory if full
        if (Rs2Inventory.isFull()) {
            Rs2Bank.depositAll();
        } else {
            //only deposit the items we don't need
            Rs2Bank.depositAllExcept(itemsToNotDeposit(name));
        }
        if (inventorySetup == null) return false;
        for (InventorySetupsItem inventorySetupsItem : inventorySetup.getEquipment()) {
            if (mainScheduler.isCancelled()) break;
            if (InventorySetupsItem.itemIsDummy(inventorySetupsItem)) continue;
            if (inventorySetupsItem.isFuzzy()) {
                if (!Rs2Bank.hasBankItem(inventorySetupsItem.getName())) {
                    Microbot.pauseAllScripts = true;
                    Microbot.showMessage("Bank is missing the following item " + inventorySetupsItem.getName());
                    break;
                }
                if (Rs2Inventory.hasItemAmount(inventorySetupsItem.getName(), (int) inventorySetup.getInventory().stream().filter(x -> x.getId() == inventorySetupsItem.getId()).count()))
                    continue;
                if (Rs2Equipment.isWearing(inventorySetupsItem.getName()))
                    continue;
                if (inventorySetupsItem.getQuantity() > 1) {
                    Rs2Bank.withdrawAllAndEquip(inventorySetupsItem.getName());
                    sleep(100, 250);
                } else {
                    Rs2Bank.withdrawAndEquip(inventorySetupsItem.getName());
                    sleep(100, 250);
                }
            } else {
                if (inventorySetupsItem.getId() == -1 || !Rs2Bank.hasItem(inventorySetupsItem.getName()))
                    continue;
                if (Rs2Inventory.hasItem(inventorySetupsItem.getName())) {
                    Rs2Bank.wearItem(inventorySetupsItem.getName());
                    continue;
                }
                if (inventorySetupsItem.getQuantity() > 1) {
                    Rs2Bank.withdrawAllAndEquip(inventorySetupsItem.getName());
                    sleep(100, 250);
                } else {
                    Rs2Bank.withdrawAndEquip(inventorySetupsItem.getName());
                }
            }
        }
        sleep(1000);
        return doesEquipmentMatch(name);
    }
    public static boolean wearEquipment(String name) {
        if (!getInventorySetup(name)) {
            return false;
        }
        for (InventorySetupsItem inventorySetupsItem : inventorySetup.getEquipment()) {
            Rs2Inventory.wield(inventorySetupsItem.getId());
        }
        return doesEquipmentMatch(name);
    }
    public static boolean doesInventoryMatch(String name) {
        inventorySetup = MInventorySetupsPlugin.getInventorySetups().stream().filter(Objects::nonNull).filter(x -> x.getName().equalsIgnoreCase(name)).findFirst().orElse(null);
        if (inventorySetup == null) return false;
        Map<Integer, List<InventorySetupsItem>> groupedByItems = inventorySetup.getInventory().stream().collect(Collectors.groupingBy(InventorySetupsItem::getId));
        boolean found = true;
        for (Integer key : groupedByItems.keySet()) {
            InventorySetupsItem inventorySetupsItem = groupedByItems.get(key).get(0);
            if (inventorySetupsItem.getId() == -1) continue;
            int withdrawQuantity = -1;
            boolean isStackable = false;
            if (groupedByItems.get(key).size() == 1) {
                withdrawQuantity = groupedByItems.get(key).get(0).getQuantity();
                isStackable = withdrawQuantity > 1;
            } else {
                withdrawQuantity = groupedByItems.get(key).size();
            }
            if (!Rs2Inventory.hasItemAmount(inventorySetupsItem.getName(), withdrawQuantity, isStackable))
                found = false;
        }
        return found;
    }
    public static boolean doesEquipmentMatch(String name) {
        inventorySetup = MInventorySetupsPlugin.getInventorySetups().stream().filter(Objects::nonNull).filter(x -> x.getName().equalsIgnoreCase(name)).findFirst().orElse(null);
        if (inventorySetup == null) {
            Microbot.showMessage("Inventory setup with name " + name + " has not found been found. Please make this inventory setup.");
            sleep(5000);
            return false;
        }
        for (InventorySetupsItem inventorySetupsItem : inventorySetup.getEquipment()) {
            if (inventorySetupsItem.getId() == -1) continue;
            if (!Rs2Equipment.isWearing(inventorySetupsItem.getName(), true)) {
                return false;
            }
        }
        return true;
    }
    public static List<InventorySetupsItem> getInventoryItems(String name) {
        inventorySetup = MInventorySetupsPlugin.getInventorySetups().stream().filter(Objects::nonNull).filter(x -> x.getName().equalsIgnoreCase(name)).findFirst().orElse(null);
        if (inventorySetup == null) {
            Microbot.showMessage("Inventory setup with name " + name + " has not found been found. Please make this inventory setup.");
            sleep(5000);
            return null;
        }
        return inventorySetup.getInventory().stream().filter(x -> x.getId() != -1).collect(Collectors.toList());
    }
    public static List<InventorySetupsItem> getEquipmentItems(String name) {
        inventorySetup = MInventorySetupsPlugin.getInventorySetups().stream().filter(Objects::nonNull).filter(x -> x.getName().equalsIgnoreCase(name)).findFirst().orElse(null);
        if (inventorySetup == null) {
            Microbot.showMessage("Inventory setup with name " + name + " has not found been found. Please make this inventory setup.");
            sleep(5000);
            return null;
        }
        return inventorySetup.getEquipment().stream().filter(x -> x.getId() != -1).collect(Collectors.toList());
    }
    public static List<String> itemsToNotDeposit(String name) {
        List<InventorySetupsItem> inventorySetupItems = getInventoryItems(name);
        List<InventorySetupsItem> equipmentSetupItems = getEquipmentItems(name);
        List<InventorySetupsItem> combined = new ArrayList<>();
        combined.addAll(inventorySetupItems);
        combined.addAll(equipmentSetupItems);
        return combined.stream().map(InventorySetupsItem::getName).collect(Collectors.toList());
    }
    public static boolean hasSpellBook() {
        return inventorySetup.getSpellBook() == Microbot.getVarbitValue(Varbits.SPELLBOOK);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/microbot/util/Rs2InventorySetup.java
================
package net.runelite.client.plugins.microbot.util;
import net.runelite.api.Varbits;
import net.runelite.client.plugins.inventorysetups.InventorySetup;
import net.runelite.client.plugins.inventorysetups.InventorySetupsItem;
import net.runelite.client.plugins.inventorysetups.MInventorySetupsPlugin;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.bank.Rs2Bank;
import net.runelite.client.plugins.microbot.util.equipment.Rs2Equipment;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Item;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.concurrent.ScheduledFuture;
import java.util.stream.Collectors;
import static net.runelite.client.plugins.microbot.util.Global.sleep;
public class Rs2InventorySetup {
    InventorySetup inventorySetup;
    ScheduledFuture<?> _mainScheduler;
    public Rs2InventorySetup(String name, ScheduledFuture<?> mainScheduler) {
        inventorySetup = MInventorySetupsPlugin.getInventorySetups().stream().filter(Objects::nonNull).filter(x -> x.getName().equalsIgnoreCase(name)).findFirst().orElse(null);
        _mainScheduler = mainScheduler;
        if (inventorySetup == null) {
            Microbot.showMessage("Inventory load with name " + name + " not found!");
            Microbot.pauseAllScripts = true;
        }
    }
    private boolean isMainSchedulerCancelled() {
        return _mainScheduler != null && _mainScheduler.isCancelled();
    }
    public boolean loadInventory() {
        Rs2Bank.openBank();
        if (!Rs2Bank.isOpen()) {
            return false;
        }
        Rs2Bank.depositAllExcept(itemsToNotDeposit());
        Map<Integer, List<InventorySetupsItem>> groupedByItems = inventorySetup.getInventory().stream().collect(Collectors.groupingBy(InventorySetupsItem::getId));
        for (Map.Entry<Integer, List<InventorySetupsItem>> entry : groupedByItems.entrySet()) {
            if (isMainSchedulerCancelled()) break;
            InventorySetupsItem inventorySetupsItem = entry.getValue().get(0);
            int key = entry.getKey();
            if (inventorySetupsItem.getId() == -1) continue;
            int withdrawQuantity = calculateWithdrawQuantity(entry.getValue(), inventorySetupsItem, key);
            if (withdrawQuantity == 0) continue;
            if (!Rs2Bank.hasBankItem(inventorySetupsItem.getName(), withdrawQuantity)) {
                Microbot.pauseAllScripts = true;
                Microbot.showMessage("Bank is missing the following item " + inventorySetupsItem.getName());
                break;
            }
            withdrawItem(inventorySetupsItem, withdrawQuantity);
        }
        sleep(1000);
        return doesInventoryMatch();
    }
    private int calculateWithdrawQuantity(List<InventorySetupsItem> items, InventorySetupsItem inventorySetupsItem, int key) {
        int withdrawQuantity;
        if (items.size() == 1) {
            Rs2Item rs2Item = Rs2Inventory.get(key);
            if (rs2Item != null && rs2Item.isStackable()) {
                withdrawQuantity = inventorySetupsItem.getQuantity() - rs2Item.quantity;
                if (Rs2Inventory.hasItemAmount(inventorySetupsItem.getName(), inventorySetupsItem.getQuantity())) {
                    return 0;
                }
            } else {
                withdrawQuantity = items.get(0).getQuantity();
                if (Rs2Inventory.hasItemAmount(inventorySetupsItem.getName(), withdrawQuantity)) {
                    return 0;
                }
            }
        } else {
            withdrawQuantity = items.size() - (int) Rs2Inventory.items().stream().filter(x -> x.getId() == key).count();
            if (Rs2Inventory.hasItemAmount(inventorySetupsItem.getName(), items.size())) {
                return 0;
            }
        }
        return withdrawQuantity;
    }
    private void withdrawItem(InventorySetupsItem item, int quantity) {
        if (item.isFuzzy()) {
            Rs2Bank.withdrawX(item.getName(), quantity);
        } else {
            if (quantity > 1) {
                Rs2Bank.withdrawX(item.getId(), quantity);
            } else {
                Rs2Bank.withdrawItem(item.getId());
            }
            sleep(100, 250);
        }
    }
    public boolean loadEquipment() {
        Rs2Bank.openBank();
        if (!Rs2Bank.isOpen()) {
            return false;
        }
        //Clear inventory if full
        if (Rs2Inventory.isFull()) {
            Rs2Bank.depositAll();
        } else {
            //only deposit the items we don't need
            Rs2Bank.depositAllExcept(itemsToNotDeposit());
        }
        for (InventorySetupsItem inventorySetupsItem : inventorySetup.getEquipment()) {
            if (isMainSchedulerCancelled()) break;
            if (InventorySetupsItem.itemIsDummy(inventorySetupsItem)) continue;
            if (inventorySetupsItem.isFuzzy()) {
                if (!Rs2Bank.hasBankItem(inventorySetupsItem.getName())) {
                    Microbot.pauseAllScripts = true;
                    Microbot.showMessage("Bank is missing the following item " + inventorySetupsItem.getName());
                    break;
                }
                if (Rs2Inventory.hasItemAmount(inventorySetupsItem.getName(), (int) inventorySetup.getInventory().stream().filter(x -> x.getId() == inventorySetupsItem.getId()).count()))
                    continue;
                if (Rs2Equipment.isWearing(inventorySetupsItem.getName()))
                    continue;
                if (inventorySetupsItem.getQuantity() > 1) {
                    Rs2Bank.withdrawAllAndEquip(inventorySetupsItem.getName());
                    sleep(100, 250);
                } else {
                    Rs2Bank.withdrawAndEquip(inventorySetupsItem.getName());
                    sleep(100, 250);
                }
            } else {
                if (inventorySetupsItem.getId() == -1 || !Rs2Bank.hasItem(inventorySetupsItem.getName()))
                    continue;
                if (Rs2Inventory.hasItem(inventorySetupsItem.getName())) {
                    Rs2Bank.wearItem(inventorySetupsItem.getName());
                    continue;
                }
                if (inventorySetupsItem.getQuantity() > 1) {
                    Rs2Bank.withdrawAllAndEquip(inventorySetupsItem.getName());
                    sleep(100, 250);
                } else {
                    Rs2Bank.withdrawAndEquip(inventorySetupsItem.getName());
                }
            }
        }
        sleep(1000);
        return doesEquipmentMatch();
    }
    public boolean wearEquipment() {
        for (InventorySetupsItem inventorySetupsItem : inventorySetup.getEquipment()) {
            Rs2Inventory.wield(inventorySetupsItem.getId());
        }
        return doesEquipmentMatch();
    }
    public boolean doesInventoryMatch() {
        Map<Integer, List<InventorySetupsItem>> groupedByItems = inventorySetup.getInventory().stream().collect(Collectors.groupingBy(InventorySetupsItem::getId));
        boolean found = true;
        for (Integer key : groupedByItems.keySet()) {
            InventorySetupsItem inventorySetupsItem = groupedByItems.get(key).get(0);
            if (inventorySetupsItem.getId() == -1) continue;
            int withdrawQuantity = -1;
            boolean isStackable = false;
            if (groupedByItems.get(key).size() == 1) {
                withdrawQuantity = groupedByItems.get(key).get(0).getQuantity();
                isStackable = withdrawQuantity > 1;
            } else {
                withdrawQuantity = groupedByItems.get(key).size();
            }
            if (!Rs2Inventory.hasItemAmount(inventorySetupsItem.getName(), withdrawQuantity, isStackable))
                found = false;
        }
        return found;
    }
    public boolean doesEquipmentMatch() {
        for (InventorySetupsItem inventorySetupsItem : inventorySetup.getEquipment()) {
            if (inventorySetupsItem.getId() == -1) continue;
            if (!Rs2Equipment.isWearing(inventorySetupsItem.getName(), true)) {
                return false;
            }
        }
        return true;
    }
    public List<InventorySetupsItem> getInventoryItems() {
        return inventorySetup.getInventory().stream().filter(x -> x.getId() != -1).collect(Collectors.toList());
    }
    public List<InventorySetupsItem> getEquipmentItems() {
        return inventorySetup.getEquipment().stream().filter(x -> x.getId() != -1).collect(Collectors.toList());
    }
    public List<String> itemsToNotDeposit() {
        List<InventorySetupsItem> inventorySetupItems = getInventoryItems();
        List<InventorySetupsItem> equipmentSetupItems = getEquipmentItems();
        List<InventorySetupsItem> combined = new ArrayList<>();
        combined.addAll(inventorySetupItems);
        combined.addAll(equipmentSetupItems);
        return combined.stream().map(InventorySetupsItem::getName).collect(Collectors.toList());
    }
    public boolean hasSpellBook() {
        return inventorySetup.getSpellBook() == Microbot.getVarbitValue(Varbits.SPELLBOOK);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/data/locationData/ancientMagicksTeleports.json
================
{
  "ancient_magicks_teleports": [
    {
      "name": "Paddewwa Teleport",
      "location": "Edgeville Dungeon",
      "spellbook": "Ancient Magicks",
      "coordinates": {
        "x": 3098,
        "y": 9882,
        "z": 0
      },
      "requirements": {
        "magic_level": 54,
        "runes": {
          "law": 2,
          "fire": 1
        },
        "members_only": true
      }
    },
    {
      "name": "Senntisten Teleport",
      "location": "Senntisten",
      "spellbook": "Ancient Magicks",
      "coordinates": {
        "x": 3321,
        "y": 3335,
        "z": 0
      },
      "requirements": {
        "magic_level": 60,
        "runes": {
          "law": 2,
          "soul": 1
        },
        "members_only": true
      }
    },
    {
      "name": "Kharyrll Teleport",
      "location": "Canifis",
      "spellbook": "Ancient Magicks",
      "coordinates": {
        "x": 3493,
        "y": 3472,
        "z": 0
      },
      "requirements": {
        "magic_level": 66,
        "runes": {
          "law": 2,
          "blood": 1
        },
        "members_only": true
      }
    },
    {
      "name": "Lassar Teleport",
      "location": "Ice Mountain",
      "spellbook": "Ancient Magicks",
      "coordinates": {
        "x": 3001,
        "y": 3470,
        "z": 0
      },
      "requirements": {
        "magic_level": 72,
        "runes": {
          "law": 2,
          "water": 4
        },
        "members_only": true
      }
    },
    {
      "name": "Dareeyak Teleport",
      "location": "Wilderness Bandit Camp",
      "spellbook": "Ancient Magicks",
      "coordinates": {
        "x": 2969,
        "y": 3695,
        "z": 0
      },
      "requirements": {
        "magic_level": 78,
        "runes": {
          "law": 2,
          "fire": 3
        },
        "members_only": true
      }
    },
    {
      "name": "Carrallangar Teleport",
      "location": "Graveyard of Shadows (Wilderness)",
      "spellbook": "Ancient Magicks",
      "coordinates": {
        "x": 3172,
        "y": 3668,
        "z": 0
      },
      "requirements": {
        "magic_level": 84,
        "runes": {
          "law": 2,
          "blood": 2
        },
        "members_only": true
      }
    },
    {
      "name": "Annakarl Teleport",
      "location": "Demonic Ruins (Wilderness)",
      "spellbook": "Ancient Magicks",
      "coordinates": {
        "x": 3288,
        "y": 3886,
        "z": 0
      },
      "requirements": {
        "magic_level": 90,
        "runes": {
          "law": 2,
          "blood": 2
        },
        "members_only": true
      }
    },
    {
      "name": "Ghorrock Teleport",
      "location": "Frozen Waste Plateau (Wilderness)",
      "spellbook": "Ancient Magicks",
      "coordinates": {
        "x": 2977,
        "y": 3873,
        "z": 0
      },
      "requirements": {
        "magic_level": 96,
        "runes": {
          "law": 2,
          "water": 8
        },
        "members_only": true
      }
    }
  ]
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/data/locationData/arceuusTeleports.json
================
{
  "arceuus_teleports": [
    {
      "name": "Arceuus Home Teleport",
      "location": "Dark Altar",
      "spellbook": "Arceuus",
      "coordinates": {
        "x": 1714,
        "y": 3883,
        "z": 0
      },
      "requirements": {
        "magic_level": 1,
        "runes": {},
        "members_only": true
      }
    },
    {
      "name": "Arceuus Library Teleport",
      "location": "North of Arceuus Library",
      "spellbook": "Arceuus",
      "coordinates": {
        "x": 1632,
        "y": 3838,
        "z": 0
      },
      "requirements": {
        "magic_level": 6,
        "runes": {
          "law": 1,
          "earth": 2
        },
        "members_only": true
      }
    },
    {
      "name": "Draynor Manor Teleport",
      "location": "Draynor Manor",
      "spellbook": "Arceuus",
      "coordinates": {
        "x": 3108,
        "y": 3352,
        "z": 0
      },
      "requirements": {
        "magic_level": 17,
        "runes": {
          "law": 1,
          "earth": 1,
          "water": 1
        },
        "members_only": true
      }
    },
    {
      "name": "Battlefront Teleport",
      "location": "Ancient Grave",
      "spellbook": "Arceuus",
      "coordinates": {
        "x": 1349,
        "y": 3739,
        "z": 0
      },
      "requirements": {
        "magic_level": 23,
        "runes": {
          "law": 1,
          "earth": 1,
          "fire": 1
        },
        "members_only": true
      }
    },
    {
      "name": "Mind Altar Teleport",
      "location": "Mind Altar",
      "spellbook": "Arceuus",
      "coordinates": {
        "x": 2979,
        "y": 3509,
        "z": 0
      },
      "requirements": {
        "magic_level": 28,
        "runes": {
          "law": 1,
          "mind": 2
        },
        "members_only": true
      }
    },
    {
      "name": "Respawn Teleport",
      "location": "Current respawn point",
      "spellbook": "Arceuus",
      "coordinates": {
        "x": 0,
        "y": 0,
        "z": 0
      },
      "requirements": {
        "magic_level": 34,
        "runes": {
          "law": 1,
          "soul": 1
        },
        "members_only": true
      }
    },
    {
      "name": "Salve Graveyard Teleport",
      "location": "Mort Myre Swamp entrance",
      "spellbook": "Arceuus",
      "coordinates": {
        "x": 3432,
        "y": 3458,
        "z": 0
      },
      "requirements": {
        "magic_level": 40,
        "runes": {
          "law": 1,
          "soul": 2
        },
        "members_only": true,
        "quests": ["Priest in Peril"]
      }
    },
    {
      "name": "Fenkenstrain's Castle Teleport",
      "location": "Fenkenstrain's Castle",
      "spellbook": "Arceuus",
      "coordinates": {
        "x": 3548,
        "y": 3528,
        "z": 0
      },
      "requirements": {
        "magic_level": 48,
        "runes": {
          "law": 1,
          "soul": 1,
          "earth": 1
        },
        "members_only": true,
        "quests": ["Priest in Peril"]
      }
    },
    {
      "name": "West Ardougne Teleport",
      "location": "West Ardougne graveyard",
      "spellbook": "Arceuus",
      "coordinates": {
        "x": 2500,
        "y": 3291,
        "z": 0
      },
      "requirements": {
        "magic_level": 61,
        "runes": {
          "law": 2,
          "soul": 2
        },
        "members_only": true,
        "quests": ["Biohazard"]
      }
    },
    {
      "name": "Harmony Island Teleport",
      "location": "Harmony Island",
      "spellbook": "Arceuus",
      "coordinates": {
        "x": 3797,
        "y": 2866,
        "z": 0
      },
      "requirements": {
        "magic_level": 65,
        "runes": {
          "law": 1,
          "soul": 1,
          "nature": 1
        },
        "members_only": true,
        "quests": ["The Great Brain Robbery"]
      }
    },
    {
      "name": "Cemetery Teleport",
      "location": "The Forgotten Cemetery",
      "spellbook": "Arceuus",
      "coordinates": {
        "x": 2978,
        "y": 3763,
        "z": 0
      },
      "requirements": {
        "magic_level": 71,
        "runes": {
          "law": 1,
          "soul": 1,
          "blood": 1
        },
        "members_only": true
      }
    },
    {
      "name": "Barrows Teleport",
      "location": "Barrows",
      "spellbook": "Arceuus",
      "coordinates": {
        "x": 3565,
        "y": 3315,
        "z": 0
      },
      "requirements": {
        "magic_level": 83,
        "runes": {
          "law": 2,
          "soul": 2,
          "blood": 1
        },
        "members_only": true,
        "quests": ["Priest in Peril"]
      }
    },
    {
      "name": "Ape Atoll Teleport",
      "location": "Ape Atoll Dungeon",
      "spellbook": "Arceuus",
      "coordinates": {
        "x": 2769,
        "y": 9100,
        "z": 0
      },
      "requirements": {
        "magic_level": 90,
        "runes": {
          "law": 2,
          "soul": 2,
          "blood": 2
        },
        "members_only": true,
        "quests": ["Monkey Madness I"]
      }
    }
  ]
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/data/locationData/fairyRingTeleports.json
================
{
  "fairy_ring_teleports": [
    {
      "code": "AIR",
      "location": "Islands: South-east of Ardougne",
      "coordinates": { "x": 2700, "y": 3247, "z": 0 },
      "notes": "Empty island, used for clue scroll coordinates and the medium Ardougne diary. This is also the first fairy ring in the sequence used to access the Fairy Queen's hideout during and after the Fairytale II - Cure a Queen quest."
    },
    {
      "code": "AJP",
      "location": "Varlamore: Avium Savannah",
      "coordinates": { "x": 1651, "y": 3010, "z": 0 },
      "notes": "Requires having travelled to Civitas illa Fortis via Regulus Cento, after completion of Children of the Sun."
    },
    {
      "code": "AJQ",
      "location": "Dungeons: Cave south of Dorgesh-Kaan",
      "coordinates": { "x": 2735, "y": 5221, "z": 0 },
      "notes": "Completion of Death to the Dorgeshuun and a light source is required to enter this area.",
      "points_of_interest": ["Cave crawlers", "Cave bugs", "Cave slimes", "Molanisks", "Dorgesh-Kaan Agility Course"]
    },
    {
      "code": "AJR",
      "location": "Kandarin: Slayer cave south-east of Rellekka",
      "coordinates": { "x": 2780, "y": 3613, "z": 0 },
      "points_of_interest": ["Fremennik Slayer Dungeon", "Rellekka"]
    },
    {
      "code": "AJS",
      "location": "Islands: Penguins near Miscellania",
      "coordinates": { "x": 2500, "y": 3896, "z": 0 },
      "notes": "Penguins; no other access. This is also the fourth and final fairy ring in the sequence used to access the Fairy Queen's hideout during and after the Fairytale II - Cure a Queen quest."
    },
    {
      "code": "AKP",
      "location": "Kharidian Desert: Necropolis",
      "coordinates": { "x": 3284, "y": 2705, "z": 0 },
      "points_of_interest": ["Sophanem", "Menaphos", "Necropolis"],
      "notes": "Unlocked by entering the Necropolis in the beginning of Beneath Cursed Sands."
    },
    {
      "code": "AKQ",
      "location": "Kandarin: Piscatoris Hunter area",
      "coordinates": { "x": 2319, "y": 3619, "z": 0 },
      "points_of_interest": ["Kraken Cove", "Chinchompas (grey)", "Mining spots", "Piscatoris Fishing Colony"]
    },
    {
      "code": "AKR",
      "location": "Great Kourend: Hosidius Vinery",
      "coordinates": { "x": 1827, "y": 3538, "z": 0 },
      "points_of_interest": ["Hosidius Vinery", "Tithe Farm minigame"]
    },
    {
      "code": "AKS",
      "location": "Feldip Hills: Feldip Hunter area",
      "coordinates": { "x": 2571, "y": 2956, "z": 0 },
      "points_of_interest": ["Hunter jungle area", "Chompy hunting grounds", "Gnome glider"]
    },
    {
      "code": "ALP",
      "location": "Islands: Lighthouse",
      "coordinates": { "x": 2503, "y": 3636, "z": 0 },
      "points_of_interest": ["Jossik", "Barbarian Outpost", "Rellekka", "Dagannoths"]
    },
    {
      "code": "ALQ",
      "location": "Morytania: Haunted Woods east of Canifis",
      "coordinates": { "x": 3597, "y": 3495, "z": 0 },
      "notes": "Can be used in conjunction with the Ectophial to quickly access the fairy ring network, but this ring is surrounded by aggressive Vampyres and Leeches.",
      "points_of_interest": ["Farming patch", "Port Phasmatys"]
    },
    {
      "code": "ALR",
      "location": "Other Realms: Abyssal Area",
      "coordinates": { "x": 3059, "y": 4875, "z": 0 },
      "points_of_interest": ["Abyssal leeches", "Abyssal guardians", "Abyssal walkers", "Abyssal demons"],
      "notes": "Alternative area for players to get essence pouches."
    },
    {
      "code": "ALS",
      "location": "Kandarin: McGrubor's Wood",
      "coordinates": { "x": 2644, "y": 3495, "z": 0 },
      "points_of_interest": ["Seers' Village", "Coal trucks", "Fishing Guild", "Ranging Guild", "Hemenster"],
      "notes": "Going here is required for the medium Kandarin Diary."
    },
    {
      "code": "BIP",
      "location": "Islands: South-west of Mort Myre",
      "coordinates": { "x": 3410, "y": 3324, "z": 0 },
      "notes": "Empty island with a shortcut to enter Mort Myre, requiring level 50 Agility. This fairy ring is also used for the hard cryptic clue 'BIP 7013'."
    },
    {
      "code": "BIQ",
      "location": "Kharidian Desert near the Kalphite Hive",
      "coordinates": { "x": 3251, "y": 3095, "z": 0 },
      "points_of_interest": ["Kalphite Lair", "Kalphite Queen", "Shantay Pass"]
    },
    {
      "code": "BIS",
      "location": "Kandarin: Ardougne Zoo - Unicorns",
      "coordinates": { "x": 2635, "y": 3266, "z": 0 },
      "notes": "Unicorns; no other access. Required for the medium Ardougne Diary."
    },
    {
      "code": "BJP",
      "location": "Islands: Isle of Souls",
      "coordinates": { "x": 2267, "y": 2976, "z": 0 },
      "points_of_interest": ["Crumbling Tower", "Isle of Souls Dungeon"]
    },
    {
      "code": "BJR",
      "location": "Other Realms: Realm of the Fisher King",
      "coordinates": { "x": 2650, "y": 4730, "z": 0 },
      "notes": "Requires partial completion of the Holy Grail quest."
    },
    {
      "code": "BJS",
      "location": "Islands: Near Zul-Andra",
      "coordinates": { "x": 2150, "y": 3070, "z": 0 },
      "notes": "Requires completion of the Regicide quest. 76 Agility is needed to jump off the island."
    },
    {
      "code": "BKP",
      "location": "Feldip Hills: South of Castle Wars",
      "coordinates": { "x": 2385, "y": 3035, "z": 0 },
      "points_of_interest": ["Smoke Devil Dungeon", "Chompy bird hunting grounds", "Teak tree", "Castle Wars"]
    },
    {
      "code": "BKQ",
      "location": "Other Realms: Enchanted Valley",
      "coordinates": { "x": 3041, "y": 4532, "z": 0 },
      "points_of_interest": ["Tree spirits"]
    },
    {
      "code": "BKR",
      "location": "Morytania: Mort Myre Swamp, south of Canifis",
      "coordinates": { "x": 3469, "y": 3431, "z": 0 },
      "notes": "Swamp boat south-east (towards Barrows and Burgh de Rott)."
    },
    {
      "code": "BKS",
      "location": "Other Realms: Zanaris",
      "coordinates": { "x": 2412, "y": 4434, "z": 0 },
      "points_of_interest": ["Impetuous Impulses", "Chaeldar", "Cosmic runic altar"]
    },
    {
      "code": "BLP",
      "location": "Dungeons: TzHaar area",
      "coordinates": { "x": 2437, "y": 5126, "z": 0 },
      "points_of_interest": ["TzHaar Fight Cave", "TzHaar Fight Pit", "TzHaar monsters"]
    },
    {
      "code": "BLQ",
      "location": "Other Realms: Yu'biusk",
      "coordinates": { "x": 3573, "y": 4371, "z": 0 },
      "notes": "Requires partial completion of the Land of the Goblins quest. Used during the Hopespear's Will miniquest."
    },
    {
      "code": "BLR",
      "location": "Kandarin: Legends' Guild",
      "coordinates": { "x": 2740, "y": 3351, "z": 0 },
      "points_of_interest": ["Legends' Guild", "Mining spots", "Magic and Maple trees", "Witchaven", "East Ardougne"]
    },
    {
      "code": "BLS",
      "location": "Kebos Lowlands: South of Mount Quidamortem",
      "coordinates": { "x": 1295, "y": 3493, "z": 0 },
      "points_of_interest": ["Rowboat to The Stranglewood", "Mountain Guide for quick access to the Chambers of Xeric"]
    },
    {
      "code": "CIP",
      "location": "Islands: Miscellania",
      "coordinates": { "x": 2513, "y": 3884, "z": 0 },
      "notes": "Requires completion of The Fremennik Trials quest. Required for the medium Fremennik Diary.",
      "points_of_interest": ["Miscellania", "Etceteria", "Managing Miscellania"]
    },
    {
      "code": "CIQ",
      "location": "Kandarin: North-west of Yanille",
      "coordinates": { "x": 2528, "y": 3127, "z": 0 },
      "points_of_interest": ["Tree Gnome Village", "Yanille", "Gu'Tanoth", "Castle Wars"]
    },
    {
      "code": "CIR",
      "location": "Kebos Lowlands: South of Mount Karuulm",
      "coordinates": { "x": 1302, "y": 3762, "z": 0 },
      "notes": "The player must have visited Great Kourend at least once in order to access this fairy ring. Required for the medium Kourend & Kebos Diary.",
      "points_of_interest": ["Mount Karuulm", "Farming Guild"]
    },
    {
      "code": "CIS",
      "location": "Great Kourend: Arceuus Library",
      "coordinates": { "x": 1639, "y": 3868, "z": 0 },
      "notes": "North of the Arceuus Library in Arceuus."
    },
    {
      "code": "CJR",
      "location": "Kandarin: Sinclair Mansion (east)",
      "coordinates": { "x": 2705, "y": 3576, "z": 0 },
      "points_of_interest": ["Sinclair Mansion", "Seers' Village"]
    },
    {
      "code": "CKP",
      "location": "Other Realms: Cosmic entity's plane",
      "coordinates": { "x": 2075, "y": 4848, "z": 0 },
      "notes": "Used during the Fairytale II - Cure a Queen quest."
    },
    {
      "code": "CKR",
      "location": "Karamja: South of Tai Bwo Wannai Village",
      "coordinates": { "x": 2801, "y": 3003, "z": 0 },
      "points_of_interest": ["Graahks", "Shilo Village", "Tai Bwo Wannai Village", "Nature Altar"]
    },
    {
      "code": "CKS",
      "location": "Morytania: Canifis",
      "coordinates": { "x": 3447, "y": 3470, "z": 0 },
      "points_of_interest": ["Morytania Slayer Tower", "Canifis", "Paterdomus", "Mort Myre swamp"]
    },
    {
      "code": "CLP",
      "location": "Islands: Draynor island",
      "coordinates": { "x": 3082, "y": 3206, "z": 0 },
      "notes": "This is the solution to the hard coordinate clue '01 degrees 30 minutes north, 20 degrees 01 minutes east'."
    },
    {
      "code": "CLR",
      "location": "Islands: Ape Atoll",
      "coordinates": { "x": 2740, "y": 2738, "z": 0 },
      "notes": "Requires completion of the Monkey Madness I quest. In addition, 48 Agility and a Ninja monkey greegree or Kruk monkey greegree is required to exit the agility course and travel to the city without taking damage."
    },
    {
      "code": "CLS",
      "location": "Islands: Hazelmere's home",
      "coordinates": { "x": 2682, "y": 3081, "z": 0 },
      "notes": "Hazelmere lives nearby."
    },
    {
      "code": "DIP",
      "location": "Other Realms: Abyssal Nexus",
      "coordinates": { "x": 3037, "y": 4763, "z": 0 },
      "points_of_interest": ["Abyssal Sire"]
    },
    {
      "code": "DIP",
      "location": "Other Realms: Abyssal Nexus",
      "coordinates": { "x": 3037, "y": 4763, "z": 0 },
      "points_of_interest": ["Abyssal Sire"]
    },
    {
      "code": "DIQ",
      "location": "Player-owned house Superior Garden",
      "notes": "Only works if the player has a fairy ring in their house."
    },
    {
      "code": "DIR",
      "location": "Other Realms: Gorak's Plane",
      "coordinates": { "x": 3038, "y": 5348, "z": 0 },
      "notes": "The only place Goraks can be found other than the God Wars Dungeon."
    },
    {
      "code": "DIS",
      "location": "Misthalin: Wizards' Tower",
      "coordinates": { "x": 3108, "y": 3149, "z": 0 },
      "points_of_interest": ["Wizards' Tower", "Rune essence mine"],
      "notes": "Required for the medium Lumbridge & Draynor Diary."
    },
    {
      "code": "DJP",
      "location": "Kandarin: Tower of Life",
      "coordinates": { "x": 2658, "y": 3230, "z": 0 },
      "points_of_interest": ["Ardougne Monastery", "Ardougne cloak unlimited teleport", "East Ardougne", "Spirit tree", "Port Khazard"]
    },
    {
      "code": "DJR",
      "location": "Great Kourend: Chasm of Fire",
      "coordinates": { "x": 1455, "y": 3658, "z": 0 },
      "points_of_interest": ["Chasm of Fire", "North-west corner of Shayzien"]
    },
    {
      "code": "DKP",
      "location": "Karamja: Gnome Glider",
      "coordinates": { "x": 2900, "y": 3111, "z": 0 },
      "points_of_interest": ["Karambwan fishing spots"]
    },
    {
      "code": "DKR",
      "location": "Misthalin: Edgeville",
      "coordinates": { "x": 3129, "y": 3496, "z": 0 },
      "points_of_interest": ["Grand Exchange", "Edgeville bank", "Wilderness"]
    },
    {
      "code": "DKS",
      "location": "Fremennik: Polar Hunter area",
      "coordinates": { "x": 2744, "y": 3719, "z": 0 },
      "points_of_interest": ["Keldagrim entrance", "Brine Rat Cavern", "Rock crabs", "Rellekka"]
    },
    {
      "code": "DLQ",
      "location": "Kharidian Desert: North of Nardah",
      "coordinates": { "x": 3423, "y": 3016, "z": 0 },
      "points_of_interest": ["Desert lizards", "Jackals", "Nardah"]
    },
    {
      "code": "DLR",
      "location": "Islands: Poison Waste south of Isafdar",
      "coordinates": { "x": 2213, "y": 3099, "z": 0 },
      "notes": "Player can use Broken Handz's telescope to spectate players fighting Zulrah. There are also unattackable badgers on the island. This is also the second fairy ring in the sequence used to access the Fairy Queen's hideout during and after the Fairytale II - Cure a Queen quest."
    },
    {
      "code": "DLS",
      "location": "Dungeons: Myreque hideout under The Hollows",
      "coordinates": { "x": 3447, "y": 9824, "z": 0 },
      "notes": "Requires completion of the In Search of the Myreque quest. Find the cracks in the walls to enter the main tunnel under the Hair of the Dog pub in Canifis."
    }
  ]
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/data/locationData/JewelryTeleport.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.util.teleport;
import net.runelite.api.coords.WorldPoint;
import java.util.List;
public class JewelryTeleport extends Teleport {
    private int charges;
    private List<JewelryDestination> destinations;
    public JewelryTeleport(String name, int charges, List<JewelryDestination> destinations) {
        super(name, null, TeleportType.JEWELRY, 0, null, null);
        this.charges = charges;
        this.destinations = destinations;
    }
    public int getCharges() { return charges; }
    public List<JewelryDestination> getDestinations() { return destinations; }
    public static class JewelryDestination {
        private String name;
        private WorldPoint coordinates;
        private boolean membersOnly;
        public JewelryDestination(String name, WorldPoint coordinates, boolean membersOnly) {
            this.name = name;
            this.coordinates = coordinates;
            this.membersOnly = membersOnly;
        }
        public String getName() { return name; }
        public WorldPoint getCoordinates() { return coordinates; }
        public boolean isMembersOnly() { return membersOnly; }
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/data/locationData/jewelryTeleports.json
================
{
  "jewelry_teleports": [
    {
      "name": "Amulet of Glory",
      "charges": 4,
      "teleports": [
        {
          "location": "Edgeville",
          "coordinates": {
            "x": 3093,
            "y": 3493,
            "z": 0
          },
          "members_only": false,
          "requirements": null
        },
        {
          "location": "Draynor Village",
          "coordinates": {
            "x": 3081,
            "y": 3251,
            "z": 0
          },
          "members_only": false,
          "requirements": null
        },
        {
          "location": "Karamja",
          "coordinates": {
            "x": 2918,
            "y": 3176,
            "z": 0
          },
          "members_only": false,
          "requirements": null
        },
        {
          "location": "Al Kharid",
          "coordinates": {
            "x": 3293,
            "y": 3163,
            "z": 0
          },
          "members_only": false,
          "requirements": null
        }
      ]
    },
    {
      "name": "Ring of Dueling",
      "charges": 8,
      "teleports": [
        {
          "location": "Castle Wars",
          "coordinates": {
            "x": 2440,
            "y": 3089,
            "z": 0
          },
          "members_only": true,
          "requirements": null
        },
        {
          "location": "Ferox Enclave",
          "coordinates": {
            "x": 3151,
            "y": 3635,
            "z": 0
          },
          "members_only": false,
          "requirements": null
        }
      ]
    },
    {
      "name": "Games Necklace",
      "charges": 8,
      "teleports": [
        {
          "location": "Burthorpe Games Room",
          "coordinates": {
            "x": 2898,
            "y": 3553,
            "z": 0
          },
          "members_only": true,
          "requirements": null
        },
        {
          "location": "Barbarian Outpost",
          "coordinates": {
            "x": 2517,
            "y": 3570,
            "z": 0
          },
          "members_only": true,
          "requirements": null
        },
        {
          "location": "Corporeal Beast",
          "coordinates": {
            "x": 2965,
            "y": 4382,
            "z": 2
          },
          "members_only": true,
          "requirements": null
        },
        {
          "location": "Wintertodt Camp",
          "coordinates": {
            "x": 1624,
            "y": 3938,
            "z": 0
          },
          "members_only": true,
          "requirements": null
        }
      ]
    },
    {
      "name": "Ring of Wealth",
      "charges": 5,
      "teleports": [
        {
          "location": "Grand Exchange",
          "coordinates": {
            "x": 3161,
            "y": 3478,
            "z": 0
          },
          "members_only": false,
          "requirements": null
        },
        {
          "location": "Falador Park",
          "coordinates": {
            "x": 2995,
            "y": 3375,
            "z": 0
          },
          "members_only": false,
          "requirements": null
        }
      ]
    },
    {
      "name": "Skills Necklace",
      "charges": 4,
      "teleports": [
        {
          "location": "Fishing Guild",
          "coordinates": {
            "x": 2611,
            "y": 3391,
            "z": 0
          },
          "members_only": true,
          "requirements": "68 Fishing"
        },
        {
          "location": "Mining Guild",
          "coordinates": {
            "x": 3050,
            "y": 9763,
            "z": 0
          },
          "members_only": true,
          "requirements": "60 Mining"
        },
        {
          "location": "Crafting Guild",
          "coordinates": {
            "x": 2933,
            "y": 3286,
            "z": 0
          },
          "members_only": true,
          "requirements": "40 Crafting"
        },
        {
          "location": "Woodcutting Guild",
          "coordinates": {
            "x": 1659,
            "y": 3505,
            "z": 0
          },
          "members_only": true,
          "requirements": "60 Woodcutting"
        }
      ]
    },
    {
      "name": "Digsite Pendant",
      "charges": 5,
      "teleports": [
        {
          "location": "Digsite",
          "coordinates": {
            "x": 3340,
            "y": 3445,
            "z": 0
          },
          "members_only": true,
          "requirements": "Bone Voyage"
        },
        {
          "location": "Fossil Island",
          "coordinates": {
            "x": 3724,
            "y": 3808,
            "z": 0
          },
          "members_only": true,
          "requirements": "Bone Voyage"
        }
      ]
    },
    {
      "name": "Necklace of Passage",
      "charges": 5,
      "teleports": [
        {
          "location": "Wizards' Tower",
          "coordinates": {
            "x": 3107,
            "y": 3160,
            "z": 0
          },
          "members_only": false,
          "requirements": null
        },
        {
          "location": "Outpost",
          "coordinates": {
            "x": 2430,
            "y": 3349,
            "z": 0
          },
          "members_only": true,
          "requirements": null
        },
        {
          "location": "Eagles' Eyrie",
          "coordinates": {
            "x": 3408,
            "y": 3157,
            "z": 0
          },
          "members_only": true,
          "requirements": null
        }
      ]
    },
    {
      "name": "Burning Amulet",
      "charges": 5,
      "teleports": [
        {
          "location": "Bandit Camp",
          "coordinates": {
            "x": 3038,
            "y": 3652,
            "z": 0
          },
          "members_only": false,
          "requirements": null
        },
        {
          "location": "Lava Maze",
          "coordinates": {
            "x": 3029,
            "y": 3842,
            "z": 0
          },
          "members_only": false,
          "requirements": null
        },
        {
          "location": "Chaos Temple",
          "coordinates": {
            "x": 3235,
            "y": 3635,
            "z": 0
          },
          "members_only": false,
          "requirements": null
        }
      ]
    }
  ]
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/data/locationData/lunarMagicTeleports.json
================
{
  "lunar_magic_teleports": [
    {
      "name": "Moonclan Teleport",
      "location": "Moonclan Island",
      "spellbook": "Lunar",
      "coordinates": {
        "x": 2113,
        "y": 3915,
        "z": 0
      },
      "requirements": {
        "magic_level": 69,
        "runes": {
          "law": 1,
          "astral": 2,
          "earth": 2
        },
        "members_only": true,
        "quest": "Lunar Diplomacy"
      }
    },
    {
      "name": "Ourania Teleport",
      "location": "Ourania Altar",
      "spellbook": "Lunar",
      "coordinates": {
        "x": 2469,
        "y": 3246,
        "z": 0
      },
      "requirements": {
        "magic_level": 71,
        "runes": {
          "law": 1,
          "astral": 2,
          "earth": 6
        },
        "members_only": true
      }
    },
    {
      "name": "Waterbirth Teleport",
      "location": "Waterbirth Island",
      "spellbook": "Lunar",
      "coordinates": {
        "x": 2546,
        "y": 3757,
        "z": 0
      },
      "requirements": {
        "magic_level": 72,
        "runes": {
          "law": 1,
          "astral": 2,
          "water": 1
        },
        "members_only": true
      }
    },
    {
      "name": "Barbarian Teleport",
      "location": "Barbarian Outpost",
      "spellbook": "Lunar",
      "coordinates": {
        "x": 2544,
        "y": 3569,
        "z": 0
      },
      "requirements": {
        "magic_level": 75,
        "runes": {
          "law": 1,
          "astral": 2,
          "fire": 3
        },
        "members_only": true
      }
    },
    {
      "name": "Khazard Teleport",
      "location": "Port Khazard",
      "spellbook": "Lunar",
      "coordinates": {
        "x": 2634,
        "y": 3166,
        "z": 0
      },
      "requirements": {
        "magic_level": 78,
        "runes": {
          "law": 2,
          "astral": 2,
          "water": 4
        },
        "members_only": true
      }
    },
    {
      "name": "Fishing Guild Teleport",
      "location": "Fishing Guild",
      "spellbook": "Lunar",
      "coordinates": {
        "x": 2611,
        "y": 3391,
        "z": 0
      },
      "requirements": {
        "magic_level": 85,
        "runes": {
          "law": 3,
          "astral": 3,
          "water": 10
        },
        "members_only": true
      }
    },
    {
      "name": "Catherby Teleport",
      "location": "Catherby",
      "spellbook": "Lunar",
      "coordinates": {
        "x": 2804,
        "y": 3442,
        "z": 0
      },
      "requirements": {
        "magic_level": 87,
        "runes": {
          "law": 3,
          "astral": 3,
          "water": 10
        },
        "members_only": true
      }
    },
    {
      "name": "Ice Plateau Teleport",
      "location": "Ice Plateau (Wilderness)",
      "spellbook": "Lunar",
      "coordinates": {
        "x": 2976,
        "y": 3944,
        "z": 0
      },
      "requirements": {
        "magic_level": 89,
        "runes": {
          "law": 3,
          "astral": 3,
          "water": 8
        },
        "members_only": true
      }
    },
    {
      "name": "Trollheim Teleport",
      "location": "Trollheim",
      "spellbook": "Lunar",
      "coordinates": {
        "x": 2910,
        "y": 3611,
        "z": 0
      },
      "requirements": {
        "magic_level": 92,
        "runes": {
          "law": 3,
          "astral": 3,
          "earth": 10
        },
        "members_only": true,
        "quest": "Eadgar's Ruse"
      }
    }
  ]
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/data/locationData/POHTeleportOptions.json
================
{
  "poh_teleports": [
    {
      "name": "Jewelry Box",
      "type": "furniture",
      "teleports": [
        {
          "name": "Ring of dueling",
          "destinations": [
            {
              "name": "Emir's Arena",
              "coordinates": {
                "x": 3315,
                "y": 3235,
                "z": 0
              }
            },
            {
              "name": "Castle Wars Arena",
              "coordinates": {
                "x": 2440,
                "y": 3090,
                "z": 0
              }
            },
            {
              "name": "Ferox Enclave",
              "coordinates": {
                "x": 3151,
                "y": 3635,
                "z": 0
              }
            },
            {
              "name": "Fortis Colosseum",
              "coordinates": {
                "x": 1793,
                "y": 3107,
                "z": 0
              }
            }
          ]
        },
        {
          "name": "Games necklace",
          "destinations": [
            {
              "name": "Burthorpe",
              "coordinates": {
                "x": 2898,
                "y": 3553,
                "z": 0
              }
            },
            {
              "name": "Barbarian Outpost",
              "coordinates": {
                "x": 2520,
                "y": 3571,
                "z": 0
              }
            },
            {
              "name": "Corporeal Beast",
              "coordinates": {
                "x": 2967,
                "y": 4254,
                "z": 0
              }
            },
            {
              "name": "Chasm of Tears",
              "coordinates": {
                "x": 3245,
                "y": 9500,
                "z": 0
              }
            },
            {
              "name": "Wintertodt Camp",
              "coordinates": {
                "x": 1631,
                "y": 3940,
                "z": 0
              }
            }
          ]
        },
        {
          "name": "Combat bracelet",
          "destinations": [
            {
              "name": "Warriors' Guild",
              "coordinates": {
                "x": 2865,
                "y": 3546,
                "z": 0
              }
            },
            {
              "name": "Champions' Guild",
              "coordinates": {
                "x": 3192,
                "y": 3368,
                "z": 0
              }
            },
            {
              "name": "Edgeville Monastery",
              "coordinates": {
                "x": 3052,
                "y": 3490,
                "z": 0
              }
            },
            {
              "name": "Ranging Guild",
              "coordinates": {
                "x": 2653,
                "y": 3439,
                "z": 0
              }
            }
          ]
        },
        {
          "name": "Skills necklace",
          "destinations": [
            {
              "name": "Fishing Guild",
              "coordinates": {
                "x": 2611,
                "y": 3390,
                "z": 0
              }
            },
            {
              "name": "Mining Guild",
              "coordinates": {
                "x": 3046,
                "y": 9735,
                "z": 0
              }
            },
            {
              "name": "Crafting Guild",
              "coordinates": {
                "x": 2933,
                "y": 3295,
                "z": 0
              }
            },
            {
              "name": "Cooks' Guild",
              "coordinates": {
                "x": 3144,
                "y": 3438,
                "z": 0
              }
            },
            {
              "name": "Woodcutting Guild",
              "coordinates": {
                "x": 1662,
                "y": 3505,
                "z": 0
              }
            },
            {
              "name": "Farming Guild",
              "coordinates": {
                "x": 1248,
                "y": 3719,
                "z": 0
              }
            }
          ]
        },
        {
          "name": "Ring of wealth",
          "destinations": [
            {
              "name": "Miscellania",
              "coordinates": {
                "x": 2534,
                "y": 3862,
                "z": 0
              }
            },
            {
              "name": "Grand Exchange",
              "coordinates": {
                "x": 3163,
                "y": 3478,
                "z": 0
              }
            },
            {
              "name": "Falador Park",
              "coordinates": {
                "x": 2995,
                "y": 3375,
                "z": 0
              }
            },
            {
              "name": "Dondakan's Rock",
              "coordinates": {
                "x": 2824,
                "y": 10168,
                "z": 0
              }
            }
          ]
        },
        {
          "name": "Amulet of glory",
          "destinations": [
            {
              "name": "Edgeville",
              "coordinates": {
                "x": 3087,
                "y": 3496,
                "z": 0
              }
            },
            {
              "name": "Karamja",
              "coordinates": {
                "x": 2918,
                "y": 3176,
                "z": 0
              }
            },
            {
              "name": "Draynor Village",
              "coordinates": {
                "x": 3105,
                "y": 3251,
                "z": 0
              }
            },
            {
              "name": "Al Kharid",
              "coordinates": {
                "x": 3293,
                "y": 3163,
                "z": 0
              }
            }
          ]
        }
      ],
      "requirements": {
        "construction_level": 91
      },
      "members_only": true
    },
    {
      "name": "Portal Nexus",
      "type": "room",
      "teleports": [
        {
          "name": "Arceuus Library",
          "coordinates": {
            "x": 1632,
            "y": 3838,
            "z": 0
          },
          "requirements": {
            "magic_level": 6
          }
        },
        {
          "name": "Draynor Manor",
          "coordinates": {
            "x": 3108,
            "y": 3352,
            "z": 0
          },
          "requirements": {
            "magic_level": 17
          }
        },
        {
          "name": "Battlefront",
          "coordinates": {
            "x": 1349,
            "y": 3739,
            "z": 0
          },
          "requirements": {
            "magic_level": 23
          }
        },
        {
          "name": "Varrock",
          "coordinates": {
            "x": 3210,
            "y": 3424,
            "z": 0
          },
          "requirements": {
            "magic_level": 25
          }
        },
        {
          "name": "Lumbridge",
          "coordinates": {
            "x": 3222,
            "y": 3218,
            "z": 0
          },
          "requirements": {
            "magic_level": 31
          }
        },
        {
          "name": "Falador",
          "coordinates": {
            "x": 2965,
            "y": 3378,
            "z": 0
          },
          "requirements": {
            "magic_level": 37
          }
        },
        {
          "name": "Camelot",
          "coordinates": {
            "x": 2757,
            "y": 3477,
            "z": 0
          },
          "requirements": {
            "magic_level": 45
          }
        },
        {
          "name": "Ardougne",
          "coordinates": {
            "x": 2661,
            "y": 3300,
            "z": 0
          },
          "requirements": {
            "magic_level": 51,
            "quests": ["Plague City"]
          }
        },
        {
          "name": "Watchtower",
          "coordinates": {
            "x": 2545,
            "y": 3112,
            "z": 0
          },
          "requirements": {
            "magic_level": 58,
            "quests": ["Watchtower"]
          }
        },
        {
          "name": "Senntisten",
          "coordinates": {
            "x": 3321,
            "y": 3335,
            "z": 0
          },
          "requirements": {
            "magic_level": 60,
            "quests": ["Desert Treasure I"]
          }
        },
        {
          "name": "Kharyrll",
          "coordinates": {
            "x": 3493,
            "y": 3472,
            "z": 0
          },
          "requirements": {
            "magic_level": 66,
            "quests": ["Desert Treasure I"]
          }
        },
        {
          "name": "Lunar Isle",
          "coordinates": {
            "x": 2113,
            "y": 3915,
            "z": 0
          },
          "requirements": {
            "magic_level": 69,
            "quests": ["Lunar Diplomacy"]
          }
        },
        {
          "name": "Waterbirth Island",
          "coordinates": {
            "x": 2546,
            "y": 3757,
            "z": 0
          },
          "requirements": {
            "magic_level": 72,
            "quests": ["Lunar Diplomacy"]
          }
        },
        {
          "name": "Barbarian Outpost",
          "coordinates": {
            "x": 2544,
            "y": 3569,
            "z": 0
          },
          "requirements": {
            "magic_level": 75
          }
        },
        {
          "name": "Fishing Guild",
          "coordinates": {
            "x": 2611,
            "y": 3391,
            "z": 0
          },
          "requirements": {
            "magic_level": 85,
            "quests": ["Lunar Diplomacy"]
          }
        },
        {
          "name": "Catherby",
          "coordinates": {
            "x": 2804,
            "y": 3442,
            "z": 0
          },
          "requirements": {
            "magic_level": 87,
            "quests": ["Lunar Diplomacy"]
          }
        },
        {
          "name": "Annakarl",
          "coordinates": {
            "x": 3288,
            "y": 3886,
            "z": 0
          },
          "requirements": {
            "magic_level": 90,
            "quests": ["Desert Treasure I"]
          }
        },
        {
          "name": "Ape Atoll (Arceuus)",
          "coordinates": {
            "x": 2763,
            "y": 2702,
            "z": 0
          },
          "requirements": {
            "magic_level": 90,
            "quests": ["Monkey Madness I"]
          }
        },
        {
          "name": "Ghorrock",
          "coordinates": {
            "x": 2977,
            "y": 3873,
            "z": 0
          },
          "requirements": {
            "magic_level": 96,
            "quests": ["Desert Treasure I"]
          }
        }
      ],
      "requirements": {
        "construction_level": 80
      },
      "members_only": true
    },
    {
      "name": "Spirit Tree",
      "type": "garden_feature",
      "teleports": [
        {
          "name": "Tree Gnome Village",
          "coordinates": {
            "x": 2539,
            "y": 3166,
            "z": 0
          },
          "notes": "In the middle of the Gnome Maze"
        },
        {
          "name": "Gnome Stronghold",
          "coordinates": {
            "x": 2460,
            "y": 3446,
            "z": 0
          },
          "requirements": {
            "quests": ["The Grand Tree"]
          },
          "notes": "Requires quest completion to travel from this location. Can be used as a destination before quest completion."
        },
        {
          "name": "Battlefield of Khazard",
          "coordinates": {
            "x": 2555,
            "y": 3259,
            "z": 0
          },
          "notes": "Just south of West Ardougne"
        },
        {
          "name": "Grand Exchange",
          "coordinates": {
            "x": 3185,
            "y": 3510,
            "z": 0
          },
          "notes": "North-east corner of the Grand Exchange in Varrock"
        },
        {
          "name": "Feldip Hills",
          "coordinates": {
            "x": 2486,
            "y": 2850,
            "z": 0
          },
          "notes": "South-west corner, next to the Myths' Guild"
        },
        {
          "name": "Poison Waste",
          "coordinates": {
            "x": 2339,
            "y": 3111,
            "z": 0
          },
          "requirements": {
            "quests": ["The Path of Glouphrie (partial)"]
          },
          "notes": "East of the Poison Waste"
        },
        {
          "name": "Prifddinas",
          "coordinates": {
            "x": 3275,
            "y": 6124,
            "z": 0
          },
          "requirements": {
            "quests": ["Song of the Elves"]
          }
        }
      ],
      "player_grown_locations": [
        {
          "name": "Etceteria",
          "coordinates": {
            "x": 2613,
            "y": 3858,
            "z": 0
          },
          "notes": "South-eastern Etceteria"
        },
        {
          "name": "Port Sarim",
          "coordinates": {
            "x": 3060,
            "y": 3258,
            "z": 0
          },
          "notes": "Easternmost part of Port Sarim"
        },
        {
          "name": "Brimhaven",
          "coordinates": {
            "x": 2802,
            "y": 3203,
            "z": 0
          },
          "notes": "North-eastern part, near the Agility Arena"
        },
        {
          "name": "Hosidius",
          "coordinates": {
            "x": 1693,
            "y": 3542,
            "z": 0
          },
          "notes": "Next to the saltpetre deposits and south-east of the Forthos Ruin"
        },
        {
          "name": "Farming Guild",
          "coordinates": {
            "x": 1253,
            "y": 3750,
            "z": 0
          },
          "notes": "Inside the advanced tier of the Farming Guild. Can be accessed before level 85 with stat boosting items."
        }
      ],
      "player_owned_house": {
        "name": "Superior Garden",
        "requirements": {
          "construction_level": 75,
          "farming_level": 83
        },
        "notes": "Does not count towards limit on spirit trees planted. Provides 350 experience in both Farming and Construction."
      },
      "requirements": {
        "farming_level": 83
      },
      "members_only": true
    },
    {
      "name": "Fairy Ring",
      "type": "garden_feature",
      "teleports": [{
        "code": "AIQ",
        "location": "Asgarnia: Mudskipper Point",
        "coordinates": { "x": 2996, "y": 3114, "z": 0 },
        "points_of_interest": ["Mogres", "Rimmington", "Port Sarim", "Asgarnia Ice Dungeon"]
      },
      {
        "code": "AIR",
        "location": "Islands: South-east of Ardougne",
        "coordinates": { "x": 2700, "y": 3247, "z": 0 },
        "notes": "Empty island, used for clue scroll coordinates and the medium Ardougne diary. This is also the first fairy ring in the sequence used to access the Fairy Queen's hideout during and after the Fairytale II - Cure a Queen quest."
      },
      {
        "code": "AJP",
        "location": "Varlamore: Avium Savannah",
        "coordinates": { "x": 1651, "y": 3010, "z": 0 },
        "notes": "Requires having travelled to Civitas illa Fortis via Regulus Cento, after completion of Children of the Sun."
      },
      {
        "code": "AJQ",
        "location": "Dungeons: Cave south of Dorgesh-Kaan",
        "coordinates": { "x": 2735, "y": 5221, "z": 0 },
        "notes": "Completion of Death to the Dorgeshuun and a light source is required to enter this area.",
        "points_of_interest": ["Cave crawlers", "Cave bugs", "Cave slimes", "Molanisks", "Dorgesh-Kaan Agility Course"]
      },
      {
        "code": "AJR",
        "location": "Kandarin: Slayer cave south-east of Rellekka",
        "coordinates": { "x": 2780, "y": 3613, "z": 0 },
        "points_of_interest": ["Fremennik Slayer Dungeon", "Rellekka"]
      },
      {
        "code": "AJS",
        "location": "Islands: Penguins near Miscellania",
        "coordinates": { "x": 2500, "y": 3896, "z": 0 },
        "notes": "Penguins; no other access. This is also the fourth and final fairy ring in the sequence used to access the Fairy Queen's hideout during and after the Fairytale II - Cure a Queen quest."
      },
      {
        "code": "AKP",
        "location": "Kharidian Desert: Necropolis",
        "coordinates": { "x": 3284, "y": 2705, "z": 0 },
        "points_of_interest": ["Sophanem", "Menaphos", "Necropolis"],
        "notes": "Unlocked by entering the Necropolis in the beginning of Beneath Cursed Sands."
      },
      {
        "code": "AKQ",
        "location": "Kandarin: Piscatoris Hunter area",
        "coordinates": { "x": 2319, "y": 3619, "z": 0 },
        "points_of_interest": ["Kraken Cove", "Chinchompas (grey)", "Mining spots", "Piscatoris Fishing Colony"]
      },
      {
        "code": "AKR",
        "location": "Great Kourend: Hosidius Vinery",
        "coordinates": { "x": 1827, "y": 3538, "z": 0 },
        "points_of_interest": ["Hosidius Vinery", "Tithe Farm minigame"]
      },
      {
        "code": "AKS",
        "location": "Feldip Hills: Feldip Hunter area",
        "coordinates": { "x": 2571, "y": 2956, "z": 0 },
        "points_of_interest": ["Hunter jungle area", "Chompy hunting grounds", "Gnome glider"]
      },
      {
        "code": "ALP",
        "location": "Islands: Lighthouse",
        "coordinates": { "x": 2503, "y": 3636, "z": 0 },
        "points_of_interest": ["Jossik", "Barbarian Outpost", "Rellekka", "Dagannoths"]
      },
      {
        "code": "ALQ",
        "location": "Morytania: Haunted Woods east of Canifis",
        "coordinates": { "x": 3597, "y": 3495, "z": 0 },
        "notes": "Can be used in conjunction with the Ectophial to quickly access the fairy ring network, but this ring is surrounded by aggressive Vampyres and Leeches.",
        "points_of_interest": ["Farming patch", "Port Phasmatys"]
      },
      {
        "code": "ALR",
        "location": "Other Realms: Abyssal Area",
        "coordinates": { "x": 3059, "y": 4875, "z": 0 },
        "points_of_interest": ["Abyssal leeches", "Abyssal guardians", "Abyssal walkers", "Abyssal demons"],
        "notes": "Alternative area for players to get essence pouches."
      },
      {
        "code": "ALS",
        "location": "Kandarin: McGrubor's Wood",
        "coordinates": { "x": 2644, "y": 3495, "z": 0 },
        "points_of_interest": ["Seers' Village", "Coal trucks", "Fishing Guild", "Ranging Guild", "Hemenster"],
        "notes": "Going here is required for the medium Kandarin Diary."
      },
      {
        "code": "BIP",
        "location": "Islands: South-west of Mort Myre",
        "coordinates": { "x": 3410, "y": 3324, "z": 0 },
        "notes": "Empty island with a shortcut to enter Mort Myre, requiring level 50 Agility. This fairy ring is also used for the hard cryptic clue 'BIP 7013'."
      },
      {
        "code": "BIQ",
        "location": "Kharidian Desert near the Kalphite Hive",
        "coordinates": { "x": 3251, "y": 3095, "z": 0 },
        "points_of_interest": ["Kalphite Lair", "Kalphite Queen", "Shantay Pass"]
      },
      {
        "code": "BIS",
        "location": "Kandarin: Ardougne Zoo - Unicorns",
        "coordinates": { "x": 2635, "y": 3266, "z": 0 },
        "notes": "Unicorns; no other access. Required for the medium Ardougne Diary."
      },
      {
        "code": "BJP",
        "location": "Islands: Isle of Souls",
        "coordinates": { "x": 2267, "y": 2976, "z": 0 },
        "points_of_interest": ["Crumbling Tower", "Isle of Souls Dungeon"]
      },
      {
        "code": "BJR",
        "location": "Other Realms: Realm of the Fisher King",
        "coordinates": { "x": 2650, "y": 4730, "z": 0 },
        "notes": "Requires partial completion of the Holy Grail quest."
      },
      {
        "code": "BJS",
        "location": "Islands: Near Zul-Andra",
        "coordinates": { "x": 2150, "y": 3070, "z": 0 },
        "notes": "Requires completion of the Regicide quest. 76 Agility is needed to jump off the island."
      },
      {
        "code": "BKP",
        "location": "Feldip Hills: South of Castle Wars",
        "coordinates": { "x": 2385, "y": 3035, "z": 0 },
        "points_of_interest": ["Smoke Devil Dungeon", "Chompy bird hunting grounds", "Teak tree", "Castle Wars"]
      },
      {
        "code": "BKQ",
        "location": "Other Realms: Enchanted Valley",
        "coordinates": { "x": 3041, "y": 4532, "z": 0 },
        "points_of_interest": ["Tree spirits"]
      },
      {
        "code": "BKR",
        "location": "Morytania: Mort Myre Swamp, south of Canifis",
        "coordinates": { "x": 3469, "y": 3431, "z": 0 },
        "notes": "Swamp boat south-east (towards Barrows and Burgh de Rott)."
      },
      {
        "code": "BKS",
        "location": "Other Realms: Zanaris",
        "coordinates": { "x": 2412, "y": 4434, "z": 0 },
        "points_of_interest": ["Impetuous Impulses", "Chaeldar", "Cosmic runic altar"]
      },
      {
        "code": "BLP",
        "location": "Dungeons: TzHaar area",
        "coordinates": { "x": 2437, "y": 5126, "z": 0 },
        "points_of_interest": ["TzHaar Fight Cave", "TzHaar Fight Pit", "TzHaar monsters"]
      },
      {
        "code": "BLQ",
        "location": "Other Realms: Yu'biusk",
        "coordinates": { "x": 3573, "y": 4371, "z": 0 },
        "notes": "Requires partial completion of the Land of the Goblins quest. Used during the Hopespear's Will miniquest."
      },
      {
        "code": "BLR",
        "location": "Kandarin: Legends' Guild",
        "coordinates": { "x": 2740, "y": 3351, "z": 0 },
        "points_of_interest": ["Legends' Guild", "Mining spots", "Magic and Maple trees", "Witchaven", "East Ardougne"]
      },
      {
        "code": "BLS",
        "location": "Kebos Lowlands: South of Mount Quidamortem",
        "coordinates": { "x": 1295, "y": 3493, "z": 0 },
        "points_of_interest": ["Rowboat to The Stranglewood", "Mountain Guide for quick access to the Chambers of Xeric"]
      },
      {
        "code": "CIP",
        "location": "Islands: Miscellania",
        "coordinates": { "x": 2513, "y": 3884, "z": 0 },
        "notes": "Requires completion of The Fremennik Trials quest. Required for the medium Fremennik Diary.",
        "points_of_interest": ["Miscellania", "Etceteria", "Managing Miscellania"]
      },
      {
        "code": "CIQ",
        "location": "Kandarin: North-west of Yanille",
        "coordinates": { "x": 2528, "y": 3127, "z": 0 },
        "points_of_interest": ["Tree Gnome Village", "Yanille", "Gu'Tanoth", "Castle Wars"]
      },
      {
        "code": "CIR",
        "location": "Kebos Lowlands: South of Mount Karuulm",
        "coordinates": { "x": 1302, "y": 3762, "z": 0 },
        "notes": "The player must have visited Great Kourend at least once in order to access this fairy ring. Required for the medium Kourend & Kebos Diary.",
        "points_of_interest": ["Mount Karuulm", "Farming Guild"]
      },
      {
        "code": "CIS",
        "location": "Great Kourend: Arceuus Library",
        "coordinates": { "x": 1639, "y": 3868, "z": 0 },
        "notes": "North of the Arceuus Library in Arceuus."
      },
      {
        "code": "CJR",
        "location": "Kandarin: Sinclair Mansion (east)",
        "coordinates": { "x": 2705, "y": 3576, "z": 0 },
        "points_of_interest": ["Sinclair Mansion", "Seers' Village"]
      },
      {
        "code": "CKP",
        "location": "Other Realms: Cosmic entity's plane",
        "coordinates": { "x": 2075, "y": 4848, "z": 0 },
        "notes": "Used during the Fairytale II - Cure a Queen quest."
      },
      {
        "code": "CKR",
        "location": "Karamja: South of Tai Bwo Wannai Village",
        "coordinates": { "x": 2801, "y": 3003, "z": 0 },
        "points_of_interest": ["Graahks", "Shilo Village", "Tai Bwo Wannai Village", "Nature Altar"]
      },
      {
        "code": "CKS",
        "location": "Morytania: Canifis",
        "coordinates": { "x": 3447, "y": 3470, "z": 0 },
        "points_of_interest": ["Morytania Slayer Tower", "Canifis", "Paterdomus", "Mort Myre swamp"]
      },
      {
        "code": "CLP",
        "location": "Islands: Draynor island",
        "coordinates": { "x": 3082, "y": 3206, "z": 0 },
        "notes": "This is the solution to the hard coordinate clue '01 degrees 30 minutes north, 20 degrees 01 minutes east'."
      },
      {
        "code": "CLR",
        "location": "Islands: Ape Atoll",
        "coordinates": { "x": 2740, "y": 2738, "z": 0 },
        "notes": "Requires completion of the Monkey Madness I quest. In addition, 48 Agility and a Ninja monkey greegree or Kruk monkey greegree is required to exit the agility course and travel to the city without taking damage."
      },
      {
        "code": "CLS",
        "location": "Islands: Hazelmere's home",
        "coordinates": { "x": 2682, "y": 3081, "z": 0 },
        "notes": "Hazelmere lives nearby."
      },
      {
        "code": "DIP",
        "location": "Other Realms: Abyssal Nexus",
        "coordinates": { "x": 3037, "y": 4763, "z": 0 },
        "points_of_interest": ["Abyssal Sire"]
      },
      {
        "code": "DIP",
        "location": "Other Realms: Abyssal Nexus",
        "coordinates": { "x": 3037, "y": 4763, "z": 0 },
        "points_of_interest": ["Abyssal Sire"]
      },
      {
        "code": "DIQ",
        "location": "Player-owned house Superior Garden",
        "notes": "Only works if the player has a fairy ring in their house."
      },
      {
        "code": "DIR",
        "location": "Other Realms: Gorak's Plane",
        "coordinates": { "x": 3038, "y": 5348, "z": 0 },
        "notes": "The only place Goraks can be found other than the God Wars Dungeon."
      },
      {
        "code": "DIS",
        "location": "Misthalin: Wizards' Tower",
        "coordinates": { "x": 3108, "y": 3149, "z": 0 },
        "points_of_interest": ["Wizards' Tower", "Rune essence mine"],
        "notes": "Required for the medium Lumbridge & Draynor Diary."
      },
      {
        "code": "DJP",
        "location": "Kandarin: Tower of Life",
        "coordinates": { "x": 2658, "y": 3230, "z": 0 },
        "points_of_interest": ["Ardougne Monastery", "Ardougne cloak unlimited teleport", "East Ardougne", "Spirit tree", "Port Khazard"]
      },
      {
        "code": "DJR",
        "location": "Great Kourend: Chasm of Fire",
        "coordinates": { "x": 1455, "y": 3658, "z": 0 },
        "points_of_interest": ["Chasm of Fire", "North-west corner of Shayzien"]
      },
      {
        "code": "DKP",
        "location": "Karamja: Gnome Glider",
        "coordinates": { "x": 2900, "y": 3111, "z": 0 },
        "points_of_interest": ["Karambwan fishing spots"]
      },
      {
        "code": "DKR",
        "location": "Misthalin: Edgeville",
        "coordinates": { "x": 3129, "y": 3496, "z": 0 },
        "points_of_interest": ["Grand Exchange", "Edgeville bank", "Wilderness"]
      },
      {
        "code": "DKS",
        "location": "Fremennik: Polar Hunter area",
        "coordinates": { "x": 2744, "y": 3719, "z": 0 },
        "points_of_interest": ["Keldagrim entrance", "Brine Rat Cavern", "Rock crabs", "Rellekka"]
      },
      {
        "code": "DLQ",
        "location": "Kharidian Desert: North of Nardah",
        "coordinates": { "x": 3423, "y": 3016, "z": 0 },
        "points_of_interest": ["Desert lizards", "Jackals", "Nardah"]
      },
      {
        "code": "DLR",
        "location": "Islands: Poison Waste south of Isafdar",
        "coordinates": { "x": 2213, "y": 3099, "z": 0 },
        "notes": "Player can use Broken Handz's telescope to spectate players fighting Zulrah. There are also unattackable badgers on the island. This is also the second fairy ring in the sequence used to access the Fairy Queen's hideout during and after the Fairytale II - Cure a Queen quest."
      },
      {
        "code": "DLS",
        "location": "Dungeons: Myreque hideout under The Hollows",
        "coordinates": { "x": 3447, "y": 9824, "z": 0 },
        "notes": "Requires completion of the In Search of the Myreque quest. Find the cracks in the walls to enter the main tunnel under the Hair of the Dog pub in Canifis."
      }
      ],
      "requirements": {
        "construction_level": 85,
        "quests": ["Fairytale II - Cure a Queen (partial completion)"]
      },
      "members_only": true
    }
  ]
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/data/locationData/teleportationSpells.json
================
{
    "teleports": [
      {
        "name": "Varrock Teleport",
        "type": "spell",
        "spellbook": "standard",
        "coordinates": {
          "x": 3210,
          "y": 3424,
          "z": 0
        },
        "requirements": {
          "level": 25,
          "magic_runes": {
            "air": 3,
            "fire": 1,
            "law": 1
          },
          "quests": null
        },
        "cooldown": "none",
        "members_only": false
      },
      {
        "name": "Lumbridge Teleport",
        "type": "spell",
        "spellbook": "standard",
        "coordinates": {
          "x": 3222,
          "y": 3218,
          "z": 0
        },
        "requirements": {
          "level": 31,
          "magic_runes": {
            "air": 3,
            "earth": 1,
            "law": 1
          },
          "quests": null
        },
        "cooldown": "none",
        "members_only": false
      },
      {
        "name": "Falador Teleport",
        "type": "spell",
        "spellbook": "standard",
        "coordinates": {
          "x": 2965,
          "y": 3378,
          "z": 0
        },
        "requirements": {
          "level": 37,
          "magic_runes": {
            "air": 3,
            "water": 1,
            "law": 1
          },
          "quests": null
        },
        "cooldown": "none",
        "members_only": false
      },
      {
        "name": "Camelot Teleport",
        "type": "spell",
        "spellbook": "standard",
        "coordinates": {
          "x": 2757,
          "y": 3477,
          "z": 0
        },
        "requirements": {
          "level": 45,
          "magic_runes": {
            "air": 5,
            "law": 1
          },
          "quests": null
        },
        "cooldown": "none",
        "members_only": true
      },
      {
        "name": "Ardougne Teleport",
        "type": "spell",
        "spellbook": "standard",
        "coordinates": {
          "x": 2661,
          "y": 3300,
          "z": 0
        },
        "requirements": {
          "level": 51,
          "magic_runes": {
            "water": 2,
            "law": 2
          },
          "quests": "Plague City"
        },
        "cooldown": "none",
        "members_only": true
      },
      {
        "name": "Watchtower Teleport",
        "type": "spell",
        "spellbook": "standard",
        "coordinates": {
          "x": 2545,
          "y": 3112,
          "z": 0
        },
        "requirements": {
          "level": 58,
          "magic_runes": {
            "earth": 2,
            "law": 2
          },
          "quests": "Watchtower"
        },
        "cooldown": "none",
        "members_only": true
      },
      {
        "name": "Trollheim Teleport",
        "type": "spell",
        "spellbook": "standard",
        "coordinates": {
          "x": 2888,
          "y": 3676,
          "z": 0
        },
        "requirements": {
          "level": 61,
          "magic_runes": {
            "fire": 2,
            "law": 2
          },
          "quests": "Troll Stronghold"
        },
        "cooldown": "none",
        "members_only": true
      },
      {
        "name": "Ape Atoll Teleport",
        "type": "spell",
        "spellbook": "standard",
        "coordinates": {
          "x": 2755,
          "y": 2784,
          "z": 0
        },
        "requirements": {
          "level": 64,
          "magic_runes": {
            "fire": 2,
            "water": 2,
            "law": 2,
            "bananas": 1
          },
          "quests": "Monkey Madness I"
        },
        "cooldown": "none",
        "members_only": true
      }
    ]
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/skilling/hunter/VoxSylvaeAIOHunter/data/hunterCreatureData.json
================
{
  "creatures": [
    {
      "name": "Tropical Wagtail",
      "level": 19,
      "locations": [
        {
          "location": "Feldip Hunter area",
          "worldPoint": {
            "x": 2486,
            "y": 2905,
            "z": 0
          }
        }
      ],
      "assignedBy": ["Huntmaster Gilman"],
      "questRequirement": null
    },
    {
      "name": "Wild Kebbit",
      "level": 23,
      "locations": [
        {
          "location": "Piscatoris Hunter area",
          "worldPoint": {
            "x": 2333,
            "y": 3595,
            "z": 0
          }
        }
      ],
      "assignedBy": ["Huntmaster Gilman"],
      "questRequirement": null
    },
    {
      "name": "Sapphire Glacialis",
      "level": 25,
      "locations": [
        {
          "location": "Rellekka Hunter area",
          "worldPoint": {
            "x": 2640,
            "y": 3855,
            "z": 0
          }
        },
        {
          "location": "Farming Guild",
          "worldPoint": {
            "x": 1234,
            "y": 5678,
            "z": 0
          }
        }
      ],
      "assignedBy": ["Huntmaster Gilman"],
      "questRequirement": null
    },
    {
      "name": "Swamp Lizard",
      "level": 29,
      "locations": [
        {
          "location": "Canifis Hunter area",
          "worldPoint": {
            "x": 3487,
            "y": 3484,
            "z": 0
          }
        },
        {
          "location": "North-west of Slepe",
          "worldPoint": {
            "x": 3500,
            "y": 3505,
            "z": 0
          }
        }
      ],
      "assignedBy": ["Huntmaster Gilman", "Guild Hunter Cervus"],
      "questRequirement": "Priest in Peril"
    },
    {
      "name": "Spined Larupia",
      "level": 31,
      "locations": [
        {
          "location": "Feldip Hunter area",
          "worldPoint": {
            "x": 2520,
            "y": 2900,
            "z": 0
          }
        }
      ],
      "assignedBy": ["Huntmaster Gilman", "Guild Hunter Ornus"],
      "questRequirement": null
    },
    {
      "name": "Barb-tailed Kebbit",
      "level": 33,
      "locations": [
        {
          "location": "Feldip Hunter area",
          "worldPoint": {
            "x": 2530,
            "y": 2900,
            "z": 0
          }
        }
      ],
      "assignedBy": ["Huntmaster Gilman"],
      "questRequirement": null
    },
    {
      "name": "Snowy Knight",
      "level": 35,
      "locations": [
        {
          "location": "Rellekka Hunter area",
          "worldPoint": {
            "x": 2650,
            "y": 3860,
            "z": 0
          }
        },
        {
          "location": "Weiss",
          "worldPoint": {
            "x": 2840,
            "y": 3930,
            "z": 0
          }
        },
        {
          "location": "Farming Guild",
          "worldPoint": {
            "x": 3125,
            "y": 3325,
            "z": 0
          }
        }
      ],
      "assignedBy": ["Huntmaster Gilman"],
      "questRequirement": null
    },
    {
      "name": "Prickly Kebbit",
      "level": 37,
      "locations": [
        {
          "location": "Piscatoris Hunter area",
          "worldPoint": {
            "x": 2320,
            "y": 3580,
            "z": 0
          }
        }
      ],
      "assignedBy": ["Huntmaster Gilman"],
      "questRequirement": null
    },
    {
      "name": "Embertailed Jerboa",
      "level": 39,
      "locations": [
        {
          "location": "West of Hunter Guild",
          "worldPoint": {
            "x": 2350,
            "y": 3500,
            "z": 0
          }
        },
        {
          "location": "North-west of Locus Oasis",
          "worldPoint": {
            "x": 2400,
            "y": 3550,
            "z": 0
          }
        }
      ],
      "assignedBy": ["Huntmaster Gilman"],
      "questRequirement": "Eagles' Peak"
    },
    {
      "name": "Horned Graahk",
      "level": 41,
      "locations": [
        {
          "location": "Karamja Hunter area",
          "worldPoint": {
            "x": 2760,
            "y": 3010,
            "z": 0
          }
        }
      ],
      "assignedBy": ["Huntmaster Gilman", "Guild Hunter Cervus"],
      "questRequirement": null
    },
    {
      "name": "Spotted Kebbit",
      "level": 43,
      "locations": [
        {
          "location": "Piscatoris Falconry area",
          "worldPoint": {
            "x": 2380,
            "y": 3600,
            "z": 0
          }
        }
      ],
      "assignedBy": ["Huntmaster Gilman", "Guild Hunter Cervus", "Guild Hunter Ornus"],
      "questRequirement": null
    },
    {
      "name": "Black Warlock",
      "level": 45,
      "locations": [
        {
          "location": "Feldip Hunter area",
          "worldPoint": {
            "x": 2500,
            "y": 2900,
            "z": 0
          }
        },
        {
          "location": "Farming Guild",
          "worldPoint": {
            "x": 3150,
            "y": 3320,
            "z": 0
          }
        }
      ],
      "assignedBy": ["Huntmaster Gilman", "Guild Hunter Cervus"],
      "questRequirement": null
    },
    {
      "name": "Orange Salamander",
      "level": 47,
      "locations": [
        {
          "location": "Uzer Hunter area",
          "worldPoint": {
            "x": 3450,
            "y": 3150,
            "z": 0
          }
        },
        {
          "location": "Necropolis Hunter area",
          "worldPoint": {
            "x": 3500,
            "y": 3200,
            "z": 0
          }
        }
      ],
      "assignedBy": ["Huntmaster Gilman", "Guild Hunter Cervus", "Guild Hunter Ornus"],
      "questRequirement": null
    },
    {
      "name": "Sabre-toothed Kebbit",
      "level": 51,
      "locations": [
        {
          "location": "Rellekka Hunter area",
          "worldPoint": {
            "x": 2700,
            "y": 3850,
            "z": 0
          }
        }
      ],
      "assignedBy": ["Huntmaster Gilman", "Guild Hunter Ornus", "Guild Hunter Cervus"],
      "questRequirement": null
    },
    {
      "name": "Grey Chinchompa",
      "level": 53,
      "locations": [
        {
          "location": "Piscatoris Hunter area",
          "worldPoint": {
            "x": 2330,
            "y": 3605,
            "z": 0
          }
        },
        {
          "location": "Kourend Woodland",
          "worldPoint": {
            "x": 2150,
            "y": 3450,
            "z": 0
          }
        },
        {
          "location": "Isle of Souls",
          "worldPoint": {
            "x": 2900,
            "y": 3200,
            "z": 0
          }
        }
      ],
      "assignedBy": ["Huntmaster Gilman", "Guild Hunter Ornus", "Guild Hunter Cervus"],
      "questRequirement": "Eagles' Peak"
    },
    {
      "name": "Red Chinchompa",
      "level": 63,
      "locations": [
        {
          "location": "Feldip Hunter area",
          "worldPoint": {
            "x": 2524,
            "y": 2910,
            "z": 0
          }
        },
        {
          "location": "Gwenith Hunter area",
          "worldPoint": {
            "x": 2205,
            "y": 3390,
            "z": 0
          }
        }
      ],
      "assignedBy": [
        "Huntmaster Gilman",
        "Guild Hunter Aco",
        "Guild Hunter Teco",
        "Guild Hunter Wolf"
      ],
      "questRequirement": "Hard Western Provinces Diary"
    },
    {
      "name": "Herbiboar",
      "level": 80,
      "locations": [
        {
          "location": "Mushroom Forest, Fossil Island",
          "worldPoint": {
            "x": 3725,
            "y": 3800,
            "z": 0
          }
        }
      ],
      "assignedBy": ["Guild Hunter Teco"],
      "questRequirement": "Bone Voyage"
    },
    {
      "name": "Moonlight Moth",
      "level": 85,
      "locations": [
        {
          "location": "The Burrow",
          "worldPoint": {
            "x": 2750,
            "y": 2980,
            "z": 0
          }
        },
        {
          "location": "Neypotzli",
          "worldPoint": {
            "x": 3300,
            "y": 3200,
            "z": 0
          }
        }
      ],
      "assignedBy": ["Guild Hunter Wolf"],
      "questRequirement": null
    },
    {
      "name": "Moonlight Antelope",
      "level": 91,
      "locations": [
        {
          "location": "The Burrow",
          "worldPoint": {
            "x": 2770,
            "y": 2980,
            "z": 0
          }
        }
      ],
      "assignedBy": ["Guild Hunter Wolf"],
      "questRequirement": null
    }
  ]
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/skilling/hunter/VoxSylvaeAIOHunter/AIOHunterConfig.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.skilling.hunter.VoxSylvaeAIOHunter;
import static net.runelite.client.plugins.VoxSylvaePlugins.skilling.hunter.VoxSylvaeAIOHunter.AIOHunterConfig.GROUP;
import net.runelite.client.config.Config;
import net.runelite.client.config.ConfigGroup;
import net.runelite.client.config.ConfigItem;
import net.runelite.client.config.ConfigSection;
import net.runelite.client.config.Keybind;
import net.runelite.client.plugins.microbot.util.inventory.DropOrder;
import net.runelite.api.coords.WorldPoint;
import java.util.List;
@ConfigGroup(GROUP)
public interface AIOHunterConfig extends Config {
    String GROUP = "HuntersRumours";
    @ConfigSection(
            name = "General",
            description = "General settings",
            position = 0
    )
    String generalSection = "general";
    String huntingSection = "hunting";
    String antiBanSection = "AntiBan";
    @ConfigItem(
            keyName = "GUIDE",
            name = "GUIDE",
            description = "GUIDE",
            position = 0,
            section = generalSection
    )
    default String GUIDE() {
        return "This plugin allows for fully automated barbarian fishing at Otto's Grotto. \n\n" +
                "To use this plugin, simply start the script at Otto's Grotto with a Barbarian rod and feathers in your inventory.";
    }
    @ConfigItem(
        keyName = "toggleKeybind",
        name = "Toggle Hunter Plugin",
        description = "Keybind to start/stop the hunter plugin",        
        position = 1, // Adjust position as needed
        section = generalSection
    )
    default Keybind toggleKeybind() {
        return Keybind.NOT_SET;
    }
    @ConfigItem(
        keyName = "devDebug",
        name = "Enable developer debug",
        description = "Enable developer debug",
        position = 2, // Adjust position as needed
        section = generalSection
    )
    default boolean devDebug() {
        return true;
    }
    // drop order
    @ConfigItem(
            keyName = "dropOrder",
            name = "Drop Order",
            description = "The order in which to drop items",
            position = 3,
            section = generalSection
    )
    default DropOrder dropOrder() {
        return DropOrder.STANDARD;
    }
    @ConfigItem(
        keyName = "huntingMode",
        name = "Hunting Mode",
        description = "Choose between Hunter Rumours or Classic Hunting",
        position = 0,
        section = huntingSection
    )
    default HuntingMode huntingMode() {
        return HuntingMode.CLASSIC_HUNTING;
    }
    @ConfigItem(
        keyName = "preferredHuntingCreature",
        name = "preferred Hunting Creature",
        description = "Select the creature to hunt in classic mode",
        position = 1,
        section = huntingSection
    )
    default HunterCreatureTarget preferredHuntingCreature() {
        CreatureLocation location = new CreatureLocation("Feldip Hills", new WorldPoint(2536, 2910, 0));
        List<CreatureLocation> locations = List.of(location);
        HunterCreatureTarget tmp = new HunterCreatureTarget ("Red Chinchompa" , 63, "Box Traps", locations);
        return tmp;
    }
    @ConfigItem(
        keyName = "trapLimit",
        name = "Trap Limit",
        description = "The maximum number of traps to set"
    )
    default int trapLimit() {
        return 5;
    }
//######################### antiban settings
    @ConfigItem(
        keyName = "useAntiban",
        name = "Enable Antiban",
        description = "Enable antiban measures like random camera movements",
        section = antiBanSection
    )
    default boolean useAntiban() {
        return true;
    }
    @ConfigItem(
        keyName = "breakDuration",
        name = "Break Duration",
        description = "Duration of breaks in milliseconds",
        section = antiBanSection
    )
    default int breakDuration() {
        return 30000; // 30 seconds
    }
    enum HuntingMode {
        HUNTER_RUMOURS,
        CLASSIC_HUNTING
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/skilling/hunter/VoxSylvaeAIOHunter/AIOHunterOverlay.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.skilling.hunter.VoxSylvaeAIOHunter;
import net.runelite.client.plugins.hunter.HunterPlugin;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.fishing.barbarian.BarbarianFishingScript;
import net.runelite.client.plugins.microbot.util.antiban.Rs2Antiban;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.ui.overlay.Overlay;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import com.google.inject.Provides;
import net.runelite.api.Client;
import net.runelite.api.events.GameTick;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.microbot.util.mouse.VirtualMouse;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPanel;
import javax.inject.Inject;
import java.awt.*;
public class AIOHunterOverlay extends OverlayPanel{
    private final HuntersRumoursPlugin plugin;
    private final HuntersRumoursScript script;
    private final AIOHunterConfig config;
    @Inject
    public AIOHunterOverlay(HuntersRumoursPlugin plugin, HuntersRumoursScript  script,AIOHunterConfig config) {        
        super(plugin);
        this.plugin = plugin;
        this.config = config;
        this.script = script;
        setPosition(OverlayPosition.TOP_LEFT);
        setLayer(OverlayLayer.ABOVE_SCENE);        
        setNaughty();
    }
    @Override
    public Dimension render(Graphics2D graphics) {
        // Display information like traps set, animals caught, and antiban status
        //graphics.setColor(Color.WHITE);
        //graphics.drawString("Traps set: " + plugin.getTrapsSet(), 10, 10);
        //graphics.drawString("Animals caught: " + plugin.getAnimalsCaught(), 10, 25);
        try {
            panelComponent.setPreferredSize(new Dimension(250, 400));
            panelComponent.getChildren().add(TitleComponent.builder()
                    .text("\uD83E\uDD86 AIO Hunter Fisher \uD83E\uDD86")
                    .color(Color.ORANGE)
                    .build());
            panelComponent.getChildren().add(LineComponent.builder().build());
            // check if player is in the correct region(10038)
            int correctRegionId = 10038;
            HunterCreatureTarget configuredCreature = script.getTargetCreature();
            String region = Rs2Player.getWorldLocation() != null ? Rs2Player.getWorldLocation().getRegionID() == 10038 ? "In Region" : "Not in Region" : "Not in Region";
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Region: " + region)
                    .build());
            panelComponent.getChildren().add(LineComponent.builder().build());
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Barbarian rod: " + (Rs2Inventory.hasItem("Barbarian rod") ? "Present" : "Not Present"))
                    .build());
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Feathers: " + (Rs2Inventory.hasItem("feather") ? String.valueOf(Rs2Inventory.get("feather").quantity) : "Not Present"))
                    .build());
            if (configuredCreature != null) {
                String creatureName = configuredCreature.getName();               
                String method = configuredCreature.getMethod();
                int level = configuredCreature.getRequiredLevel();
                String goal = configuredCreature.getGoalName();
                int goalAmount = configuredCreature.getGoalAmount();
                String goalType = configuredCreature.getGoalTypeName();
            }else{
                String creatureName = "No creature selected";
                String method = "No method selected";
                int level = 0;
                String goal = "No goal selected";
                int goalAmount = 0;
                String goalType = "No goal type selected";
            }
            panelComponent.getChildren().add(LineComponent.builder().build());
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Creature: " + String(creatureName))
                    .build());
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Method: " + method)
                    .build());
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Level: " + configuredCreature.getRequiredLevel())
                    .build());
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Goal: " + configuredCreature.getGoalName().getGoalName())
                    .build());
            panelComponent.getChildren().add(LineComponent.builder().build());
            panelComponent.getChildren().add(LineComponent.builder().build());
            Rs2Antiban.renderAntibanOverlayComponents(panelComponent);
            panelComponent.getChildren().add(LineComponent.builder()
                    .left(Microbot.status)
                    .right("Version:" + HuntersRumoursScript.version)
                    .build());
            panelComponent.getChildren().add(LineComponent.builder().build());
                    Rs2Antiban.renderAntibanOverlayComponents(panelComponent);
        } catch (Exception ex) {
            System.out.println(ex.getMessage());
        }
        return super.render(graphics);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/skilling/hunter/VoxSylvaeAIOHunter/AIOHunterTaskManager.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.skilling.hunter.VoxSylvaeAIOHunter;
import com.google.gson.Gson;
import java.io.FileReader;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
public class AIOHunterTaskManager {
    private List<HunterMaster> taskMasters;
    private Map<String, HunterCreature> creatures;
    public AIOHunterTaskManager() {
        loadTaskMastersFromJson("path/to/hunterMasters.json");
        loadCreaturesFromJson("path/to/hunterCreatures.json");
    }
    private void loadTaskMastersFromJson(String path) {
        try (FileReader reader = new FileReader(path)) {
            Gson gson = new Gson();
            TaskMastersWrapper wrapper = gson.fromJson(reader, TaskMastersWrapper.class);
            taskMasters = wrapper.hunterMasters;
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    private void loadCreaturesFromJson(String path) {
        try (FileReader reader = new FileReader(path)) {
            Gson gson = new Gson();
            CreaturesWrapper wrapper = gson.fromJson(reader, CreaturesWrapper.class);
            creatures = wrapper.hunterCreatures.stream()
                .collect(Collectors.toMap(HunterCreature::getName, creature -> creature));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    public List<HunterCreature> getTasksForLevel(int hunterLevel, String taskMasterName) {
        for (HunterMaster master : taskMasters) {
            if (master.getName().equals(taskMasterName) && hunterLevel >= master.getRequiredLevel()) {
                return master.getCreatures().stream()
                    .map(creatures::get)
                    .filter(creature -> creature != null && hunterLevel >= creature.getRequiredLevel())
                    .collect(Collectors.toList());
            }
        }
        return null;
    }
    public List<HunterMaster> getTaskMasters() {
        return taskMasters;
    }
    public Map<String, HunterCreature> getCreatures() {
        return creatures;
    }
    // Wrapper classes for JSON deserialization
    private static class TaskMastersWrapper {
        List<HunterMaster> hunterMasters;
    }
    private static class CreaturesWrapper {
        List<HunterCreature> hunterCreatures;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/skilling/hunter/VoxSylvaeAIOHunter/CreatureLocation.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.skilling.hunter.VoxSylvaeAIOHunter;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
public class CreatureLocation {
    private String locationName;
    private WorldPoint worldPoint;
    public CreatureLocation(String locationName, WorldPoint worldPoint) {
        this.locationName = locationName;
        this.worldPoint = worldPoint;
    }
    // Getters
    public String getLocationName() { return locationName; }
    public WorldPoint getWorldPoint() { return worldPoint; }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/skilling/hunter/VoxSylvaeAIOHunter/HunterCreatureTarget.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.skilling.hunter.VoxSylvaeAIOHunter;
import java.util.List;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Item;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
public class HunterCreatureTarget {
    private String name;
    private int requiredLevel;
    private String method;
    private List<Integer> lootIds;
    private List<CreatureLocation> locations;
    private Goal goal;
    private enum GoalType{
        CATCHES, ITEMS
    }
    private class Goal{
        private String name;
        private int id;
        private int goalAmount;
        private int currentCatchCount;
        private boolean completed;
        private GoalType type;
        public Goal(String name, int amount, GoalType type){
            this.name = name;
            this.goalAmount = goalAmount;
            this.currentCatchCount = 0;
            this.completed = false;
            this.type = type;
            //int unprocessedItemPrice = Microbot.getItemManager().search(config.ITEM().getName()).get(0).getPrice();
            //int processedItemPrice = Microbot.getItemManager().search(config.ITEM().getFinished()).get(0).getPrice();
            //profitPerPlank = processedItemPrice - unprocessedItemPrice;
        }
        public void incrementCatch(){
            this.currentCatchCount++;
            if (type == GoalType.CATCHES && this.currentCatchCount >= this.goalAmount){
                this.completed = true;
            }
        }
        public boolean isCompleted(){
            return this.completed;
        }
        public int getGoalAmount(){
            return this.goalAmount;
        }
        public String getGoalName(){
            return this.name;
        }
        public String getGoalTypeName(){
            return this.type.name();
        }
    }
    public HunterCreature(String name, int requiredLevel, String method, List<CreatureLocation> locations) {
        this.name = name;
        this.requiredLevel = requiredLevel;
        this.method = method;
        this.locations = locations;
    }
    // Getters
    public String getName() { return name; }
    public int getRequiredLevel() { return requiredLevel; }
    public String getMethod() { return method; }
    public List<CreatureLocation> getLocations() { return locations; }
    public List<Integer> getLootIds() { return lootIds; }
    public void setLootIds(List<Integer> lootIds) { this.lootIds = lootIds; }
    public int getGoalAmount() { return this.goal.getGoalAmount(); }
    public boolean isCompleted() { return this.goal.isCompleted(); }
    public void incrementCatch() { this.goal.incrementCatch(); }
    public void getGoalName() { return this.goal.getGoalName(); }
    public void getGoalTypeName() { return this.goal.getGoalTypeName(); }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/skilling/hunter/VoxSylvaeAIOHunter/HunterMaster.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.skilling.hunter.VoxSylvaeAIOHunter;
import java.util.List;
import net.runelite.api.*;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
public class HunterMaster {
    private String name;
    private String tier;
    private int requiredLevel;
    private WorldPoint worldPoint;
    private List<String> creatures;
    private String questRequirement;
    public HunterMaster(String name, String tier, int requiredLevel, WorldPoint worldPoint, List<String> creatures, String questRequirement) {
        this.name = name;
        this.tier = tier;
        this.requiredLevel = requiredLevel;
        this.worldPoint = worldPoint;
        this.creatures = creatures;
        this.questRequirement = questRequirement;
    }
    // Getters
    public String getName() { return name; }
    public String getTier() { return tier; }
    public int getRequiredLevel() { return requiredLevel; }
    public WorldPoint getWorldPoint() { return worldPoint; }
    public List<String> getCreatures() { return creatures; }
    public String getQuestRequirement() { return questRequirement; }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/skilling/hunter/VoxSylvaeAIOHunter/HuntersRumoursPlugin.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.skilling.hunter.VoxSylvaeAIOHunter;
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.hunter.HunterConfig;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.antiban.AntibanOverlay;
import net.runelite.client.plugins.microbot.util.antiban.Rs2Antiban;
import net.runelite.client.plugins.microbot.util.antiban.Rs2AntibanSettings;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.mouse.VirtualMouse;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.xptracker.XpTrackerPlugin;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import net.runelite.api.AnimationID;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Skill;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.StatChanged;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ProfileChanged;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.microbot.breakhandler.BreakHandlerPlugin;
import net.runelite.client.plugins.microbot.util.antiban.AntibanPlugin;
//import net.runelite.client.plugins.microbot.fishing.barbarian.BarbarianFishingConfig;
//import net.runelite.client.plugins.microbot.fishing.barbarian.BarbarianFishingScript;
import net.runelite.client.plugins.microbot.util.antiban.enums.Activity;
import net.runelite.client.plugins.microbot.util.antiban.enums.ActivityIntensity;
import net.runelite.client.plugins.microbot.util.antiban.enums.CombatSkills;
import net.runelite.client.plugins.microbot.util.antiban.ui.MasterPanel;
import net.runelite.client.plugins.VoxSylvaePlugins.util.*;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.HotkeyListener;
import net.runelite.client.util.ImageUtil;
import javax.inject.Inject;
import javax.swing.*;
import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import java.awt.image.BufferedImage;
import java.time.Duration;
import java.time.Instant;
import java.util.EnumMap;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;
import java.awt.*;
@PluginDescriptor(
    name = PluginDescriptor.TRUNC+"Hunter Rumours Plugin",
    description = "Automatically handles hunter tasks",
    tags = {"hunter", "rumours", "automation"},
    alwaysOn = false,
    hidden = false
)
@PluginDependency(XpTrackerPlugin.class)
@PluginDependency(XpTrackerPlugin.class)
@Slf4j
public class HuntersRumoursPlugin extends Plugin{
    public static int ticksSinceLogin;
    private static int idleTicks = 0;
    private final Map<Skill, Integer> skillExp = new EnumMap<>(Skill.class);
    private boolean ready;
    private Skill lastSkillChanged;
    private NavigationButton navButton;
    private int IDLE_TIMEOUT = 400;
    @Inject
    Notifier notifier;
    @Inject
    private Client client;
    @Inject
    private ClientThread clientThread;
    @Inject
    private AIOHunterConfig config;
    @Inject
    private OverlayManager overlayManager;
    @Inject
    private AIOHunterOverlay AIOHunterOverlay_instance;
    @Inject
    HuntersRumoursScript HuntersRumoursScript;
    private boolean isRunning = false;
    @Inject
    private KeyManager keyManager;
    private final HotkeyListener hotkeyListener = new HotkeyListener(() -> config.toggleKeybind()) {
        @Override
        public void hotkeyPressed() {
            togglePlugin();
        }
    };
    @Override
    protected void startUp() throws Exception{
       /*  final MasterPanel panel = injector.getInstance(MasterPanel.class);
        final BufferedImage icon = ImageUtil.loadImageResource(getClass(), "antiban.png");
        navButton = NavigationButton.builder()
                .tooltip("Antiban")
                .icon(icon)
                .priority(1)
                .panel(panel)
                .build();
        Timer timer = new Timer();
        timer.scheduleAtFixedRate(new TimerTask() {
            @Override
            public void run() {
                SwingUtilities.invokeLater(panel::loadSettings);
            }
        }, 0, 600); */
        Microbot.pauseAllScripts = false;
        Microbot.setClient(client);
        Microbot.setClientThread(clientThread);
        Microbot.setNotifier(notifier);
        Microbot.setMouse(new VirtualMouse());
        if (overlayManager != null) {            
            overlayManager.add(AIOHunterOverlay_instance);
        }
        keyManager.registerKeyListener(hotkeyListener);
        //eventBus.register(this);
        //clientToolbar.addNavigation(navButton);
        //overlayManager.add(new AntibanOverlay());
    }
    @Override
    protected void shutDown() throws Exception{
        overlayManager.removeIf(overlay -> overlay instanceof AIOHunterOverlay);
        //clientToolbar.removeNavigation(navButton);
        keyManager.unregisterKeyListener(hotkeyListener);
        stopPlugin();
    }
    private void togglePlugin() {
        if (isRunning) {
            stopPlugin();
        } else {
            startPlugin();
        }
    }
    private void startPlugin() {
        if (!isRunning) {
            isRunning = true;
            ensurePluginEnabled(BreakHandlerPlugin.class , config.devDebug());
            HuntersRumoursScript.run(config);
            Microbot.showMessage("AIO hunter plugin started by user");               
        }
    }
    private void stopPlugin() {
        if (isRunning) {
            isRunning = false;
            HuntersRumoursScript.shutdown();
            Microbot.showMessage("AIO hunter plugin stopped by user");                                
        }
    }
    @Provides
    AIOHunterConfig provideConfig(ConfigManager configManager) {
        return configManager.getConfig(AIOHunterConfig.class);
    }
    @Subscribe
    public void onChatMessage(ChatMessage event) {
        //if (Rs2Antiban.checkForCookingEvent(event)) {
        //   updateLastCookingAction();
        //}
        if (isRunning) {
            HuntersRumoursScript.onChatMessage(event);
        }
    }
    @Subscribe
    public void onProfileChanged(ProfileChanged event) {
        Rs2Antiban.resetAntibanSettings();
        if (isRunning) {
            HuntersRumoursScript.onProfileChanged(event);
        }
    }
    @Subscribe
    public void onGameTick(GameTick event) {      
        if (isRunning) {
            HuntersRumoursScript.onGameTick();
        }        
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/skilling/hunter/VoxSylvaeAIOHunter/HuntersRumoursScript.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.skilling.hunter.VoxSylvaeAIOHunter;
import java.util.List;
import java.util.concurrent.TimeUnit;
import com.google.inject.Inject;
import net.runelite.api.Skill;
import net.runelite.api.WallObject;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.ChatMessage;
import net.runelite.client.events.ProfileChanged;
import net.runelite.client.plugins.VoxSylvaePlugins.skilling.hunter.VoxSylvaeAIOHunter.AIOHunterConfig.HuntingMode;
import net.runelite.client.plugins.VoxSylvaePlugins.util.*;
import net.runelite.client.plugins.VoxSylvaePlugins.util.navigation.*;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.Script;
import net.runelite.client.plugins.microbot.util.antiban.Rs2Antiban;
import net.runelite.client.plugins.microbot.util.antiban.Rs2AntibanSettings;
import net.runelite.client.plugins.microbot.util.antiban.enums.Activity;
import net.runelite.client.plugins.microbot.util.antiban.enums.ActivityIntensity;
import net.runelite.client.plugins.microbot.util.gameobject.Rs2GameObject;
import net.runelite.client.plugins.microbot.util.grounditem.LootingParameters;
import net.runelite.client.plugins.microbot.util.grounditem.Rs2GroundItem;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Item;
import net.runelite.client.plugins.microbot.util.npc.Rs2NpcManager;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.microbot.util.tile.Rs2Tile;
import net.runelite.client.plugins.questhelper.runeliteobjects.extendedruneliteobjects.FaceAnimationIDs;
public class HuntersRumoursScript extends Script {
    public static String version = "0.0.1";
    public static int timeout = 0;
    private HunterCreatureTarget currentHuntingCreatureTarget = null;
    private AIOHunterConfig config;
    private AIOHunterTaskManager rumoursTaskManager;
    @Inject
    private VoxSylvaeInventoryAndBankManagementScript inventoryAndBankManagementScript;
    @Inject
    private VoxSylvaeNavigationScript navigationScript;
    /*public enum HunterState {
        CHECK_REQUIREMENTS,   // Check if the player meets the requirements for the task
        SELECT_TASK_MASTER,   // Select the task master (configured or default)
        GET_TASK,             // Get a new task from the task master
        NAVIGATE_TO_HUNT,     // Navigate to the hunting area
        PERFORM_HUNTING,      // Perform the hunting task
        CHECK_BREAK,          // Check if a break should be taken
        GET_NEW_TASK,         // After hunting, get a new task
        FINISHED              // Bot is done with the task or has finished
    }*/
    public enum HunterState {
        INITIALIZE,   // Initialize the bot
        CHECK_REQUIREMENTS,   // Check if the player meets the requirements for the task
        SELECT_TASK,   // Select the task master (configured or default)
        GET_TASK,             // Get a new task from the task master
        SETUP_INVENTORY,      // Setup the inventory for the task
        NAVIGATE_TO_HUNT,     // Navigate to the hunting area
        PERFORM_HUNTING,      // Perform the hunting task
        PERFORM_SNARE,        // Perform the snare hunting task
        CHECK_BREAK,          // Check if a break should be taken
        FINISHED              // Bot is done with the task or has finished
    }
    private HunterState currentState = HunterState.INITIALIZE;
    public HunterState getCurrentState() {
        return currentState;
    }
    private void initialize(AIOHunterConfig config) {
        int hunterLevel = getSkillLevel(Skill.HUNTER);
        /*HunterTask currentTask = rumoursTaskManager.getRumourTaskForLevel(hunterLevel);*/
        //rumoursTaskManager = new HunterRumoursTaskManager();
        //classicHuntingManager = new ClassicHuntingManager();
        this.config = config;
        currentState = HunterState.CHECK_REQUIREMENTS;
        inventoryAndBankManagementScript = new VoxSylvaeInventoryAndBankManagementScript();
        navigationScript = new VoxSylvaeNavigationScript();
        loadNpcData();
    }
    public boolean run(AIOHunterConfig config) {        
        Rs2Antiban.resetAntibanSettings();
        //Rs2Antiban.antibanSetupTemplates.applyHunterSetup();
        applyAntiBanSettings();
        Rs2Antiban.setActivity(Activity.GENERAL_HUNTER);
        //int unprocessedItemPrice = Microbot.getItemManager().search(config.ITEM().getName()).get(0).getPrice();
        //int processedItemPrice = Microbot.getItemManager().search(config.ITEM().getFinished()).get(0).getPrice();
        //profitPerPlank = processedItemPrice - unprocessedItemPrice;
        //useSetDelay = config.useSetDelay();
        //setDelay = config.setDelay();
        //useRandomDelay = config.useRandomDelay();
        //maxRandomDelay = config.maxRandomDelay();     
        initialize(config);
        mainScheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(() -> {
          try {
                if (!Microbot.isLoggedIn()) return;
                if (Microbot.pauseAllScripts) return;
                if (!super.run()) return;
                if (Rs2AntibanSettings.actionCooldownActive) return;
                /*if (startCourse == null) {
                    Microbot.showMessage("Agility course: " + config.agilityCourse().name() + " is not supported.");
                    sleep(10000);
                    return;
                }*/
                long startTime = System.currentTimeMillis();
                final LocalPoint playerLocation = Microbot.getClient().getLocalPlayer().getLocalLocation();
                final WorldPoint playerWorldLocation = Microbot.getClient().getLocalPlayer().getWorldLocation();
                handleState();
                long endTime = System.currentTimeMillis();
                long totalTime = endTime - startTime;
                System.out.println("Total time for loop " + totalTime);
            } catch (Exception ex) {
                System.out.println(ex.getMessage());
            }
        }, 0, 600, TimeUnit.MILLISECONDS);
        return true;
    }
    public void onGameTick() {
    }
    public void onChatMessage(ChatMessage event) {
    }
    public void onProfileChanged(ProfileChanged event) {
    }
    private int getSkillLevel(Skill skill) {
        return Microbot.getClient().getRealSkillLevel(skill);
    }
    @Override
    public void shutdown() {
        Rs2Antiban.resetAntibanSettings();
        super.shutdown();
        Microbot.pauseAllScripts = true;
    }
    private void loadNpcData() {
        try {
            Rs2NpcManager.loadJson();
        } catch (Exception e) {
            throw new RuntimeException("Failed to load NPC data", e);
        }
    }
    /*private void loadFoodItems() {
        try {
            List<Rs2Item> foods = Microbot.getClientThread().runOnClientThread(Rs2Inventory::getInventoryFood);
        } catch (Exception e) {
            throw new RuntimeException("Failed to load item data", e);
        }
    }*/
    private void handleState() {
        if (!super.run() || !Microbot.isLoggedIn() || Rs2Antiban.isIdleTooLong(500)) {
            //oreVein = null;
            //miningSpot = MLMMiningSpot.IDLE;
            currentState = HunterState.INITIALIZE;
            return;
        }
        //if (pickAxeInInventory.isEmpty() && config.pickAxeInInventory()) {
            //Microbot.showMessage("Pickaxe was not found in your inventory");
        //    sleep(5000);
        //    return;
        //}
        if (Rs2AntibanSettings.actionCooldownActive) return;
        if (Rs2Player.isAnimating() || Microbot.getClient().getLocalPlayer().isInteracting()) return;
        switch (currentState) {
            case INITIALIZE:
                Rs2Antiban.setActivityIntensity(Rs2Antiban.getActivity().getActivityIntensity());
                initializeHunting();
                break;
            case SELECT_TASK:
                Rs2Antiban.setActivityIntensity(Rs2Antiban.getActivity().getActivityIntensity());
                selectNewHunterTask();
                break;
            case GET_TASK:
                Rs2Antiban.setActivityIntensity(Rs2Antiban.getActivity().getActivityIntensity());
                getNewHunterTask();
                break;
            case SETUP_INVENTORY:
                Rs2Antiban.setActivityIntensity(Rs2Antiban.getActivity().getActivityIntensity());
                loadInventorySetup();
                break;
            case CHECK_REQUIREMENTS:
                //
                if (checkHunterRequirements()) {
                    currentState = HunterState.NAVIGATE_TO_HUNT;
                } else {
                    currentState = HunterState.FINISHED;
                }
                break;
            case NAVIGATE_TO_HUNT:
                if (navigateToHuntingArea()) {
                    currentState = HunterState.PERFORM_HUNTING;
                }
                break;
            case PERFORM_HUNTING:
                if (currentHuntingCreature == null) {
                    currentState = HunterState.SELECT_TASK;
                    return;
                }
                //any chinchompa: black, red, grey
                if (currentHuntingCreatureTarget.getName().toLowerCase() == "Black chinchompa".toLowerCase()
                    || currentHuntingCreatureTarget.getName().toLowerCase() == "Grey chinchompa".toLowerCase()
                    || currentHuntingCreatureTarget.getName().toLowerCase() == "Red chinchompa".toLowerCase()) {
                    Rs2Antiban.setActivity(Activity.HUNTING_BLACK_CHINCHOMPAS);                                        
                }elif (currentHuntingCreatureTarget.getName().toLowerCase() == "Moonlight Antelope".toLowerCase()) {
                    Rs2Antiban.setActivity(Activity.HUNTING_BLACK_CHINCHOMPAS);                                        
                }elif (currentHuntingCreatureTarget.getName().toLowerCase() == "Sunligth Antelope".toLowerCase()) {
                    Rs2Antiban.setActivity(Activity.HUNTING_SUNLIGHT_ANTELOPES); 
                }elif (currentHuntingCreatureTarget.getName() == "Herbiboar") {
                    Rs2Antiban.setActivity(Activity.HUNTING_HERBIBOARS);    
                }elif (currentHuntingCreatureTarget.getName() == "Moonlight Moth") {
                    Rs2Antiban.setActivityIntensity(ActivityIntensity.EXTREME);    
                }else{
                    Rs2Antiban.setActivity(Activity.GENERAL_HUNTER);
                }
                performHunting(this.currentHuntingCreatureTarget);
                break;
            case CHECK_BREAK:
                break;
            case FINISHED:
                shutdown();
                break;
        }
    }
    private void loadInventorySetup(){
        String inventorySetupName = "";//placeholder, get name from currentHuntingCreature
        if (!inventoryAndBankManagementScript.loadInventoryAndEquipment(inventorySetupName)){
            currentState = HunterState.FINISHED;
            Microbot.showMessage("Failed to load inventory setup");
        }else{
            Microbot.log(version + "<loadInventorySetup> loaded inventory setup: " + inventorySetupName+ " for hunter task: " + currentHuntingCreatureTarget.getName()+ "completed at: " +System.currentTimeMillis());
            currentState = HunterState.CHECK_REQUIREMENTS;
        }
    }
    private void selectNewHunterTask(){
        if (config.huntingMode() == HuntingMode.CLASSIC_HUNTING ) {
            //rumoursTaskManager.initialize();
            currentHuntingCreatureTarget = config.preferredHuntingCreature();
        } else {
            currentHuntingCreatureTarget = null;
            //classicHuntingManager.initialize(config.classicHuntingCreature());
        }
        currentState = HunterState.GET_TASK;
    }
    private void getNewHunterTask() {
        //getnew hunter task when we do hunter rounmours
        if (currentHuntingCreatureTarget == null) {
            //get possible task master(highst for the current level)
            //navigate to task master
            //get task by interaction with the task master npc
            //chat box, check which tast we have gotten
            //set currentHuntingCreatureTarget to the task we have gotten
            //when successful, set currentState = HunterState.SETUP_INVENTORY;
            //otherwise wait for the until we have been there,, when some thing fails, set currentState = HunterState.FINISHED;
            // currentState = HunterState.SETUP_INVENTORY;
            return;
        }
        currentState = HunterState.SETUP_INVENTORY;
        // Walk to the task master, only one step at a time
        //Microbot.getWalker().walkTo(master.getLocation());
        // Interact with the task master to get a new task (performed over multiple ticks)
        //interactWithTaskMaster(master);
    }
    private void initializeHunting() {
    }
    private WallObject findClosestVein() {
        return Rs2GameObject.getWallObjects().stream()
                .filter(this::isVein).filter(this::isWithinMiningArea).min((a, b) -> Integer.compare(distanceToPlayer(a), distanceToPlayer(b))).orElse(null);
    }
    private boolean isVein(WallObject wallObject) {
        int id = wallObject.getId();
        return id == 26661 || id == 26662 || id == 26663 || id == 26664;
    }
    private boolean isWithinMiningArea(WallObject wallObject) {
        WorldArea WEST_UPPER_AREA = new WorldArea(3748, 5676, 7, 9, 0);
        WorldArea EAST_UPPER_AREA = new WorldArea(3755, 5668, 8, 8, 0);
        boolean mineUpstairs = true;
        if (!mineUpstairs)
            return true;
        WorldPoint walkableTile = wallObject.getWorldLocation();
        return WEST_UPPER_AREA.contains(walkableTile) || EAST_UPPER_AREA.contains(walkableTile);
    }
    private int distanceToPlayer(WallObject wallObject) {
        WorldPoint closestWalkableNeighbour = Rs2Tile.getNearestWalkableTile(wallObject.getWorldLocation());
        if (closestWalkableNeighbour == null) return 999;
        return Microbot.getClient().getLocalPlayer().getWorldLocation().distanceTo2D(closestWalkableNeighbour);
    }
    private void performHunting(HunterCreatureTarget creatureTarget) {
        //check which hunting acction must be peformed, based on the current creature target
        //only start with implentation of snare hunting         
        // when we have to setup traps, find optimal locations
        // based on the current number of creatures near by number of available traps, check if the location is not occupied by game obejects(like trees, rocks, etc)-> valid tile for placeing a trap
        // for deadfall hunting only only location ->  stay at the location, check if the trap is setup, if not set it up
        // pidfall, find all near by pitfalls, check if they are setup, other player near by, switch world, occupy the location
        /*LootingParameters itemLootParams = new LootingParameters(
                                config.distanceToStray(),
                                1,
                                1,
                                config.minFreeSlots(),
                                config.toggleDelayedLooting(),
                                config.toggleLootMyItemsOnly(),
                                config.listOfItemsToLoot().split(",")
                        );
        */
        /*if (Rs2GroundItem.lootItemsBasedOnNames(itemLootParams)) {
            Microbot.pauseAllScripts = false;
            Rs2Antiban.actionCooldown();
            Rs2Antiban.takeMicroBreakByChance();
        }*/
       /* LootingParameters valueParams = new LootingParameters(
            config.minPriceOfItem(),
            config.maxPriceOfItem(),
            config.distanceToStray(),
            1,
            config.minFreeSlots(),
            config.toggleDelayedLooting(),
            config.toggleLootMyItemsOnly()
        );
        if (Rs2GroundItem.lootItemBasedOnValue(valueParams)) {
            Microbot.pauseAllScripts = false;
            Rs2Antiban.actionCooldown();
            Rs2Antiban.takeMicroBreakByChance();
        }
            Rs2Antiban.takeMicroBreakByChance();
        } */
    private void performBox(HunterCreatureTarget creatureTarget) {
        // Add logic to set traps, catch animals, and complete the task
        // This would include using the trap type in the specified location
        Rs2Antiban.actionCooldown();
        Rs2Antiban.takeMicroBreakByChance();
    }
    private void performHerbiboarHunting(HunterCreatureTarget creatureTarget) {
        // Add logic to set traps, catch animals, and complete the task
        // This would include using the trap type in the specified location
        Rs2Antiban.actionCooldown();
        Rs2Antiban.takeMicroBreakByChance();
    }
    private void performBirdHunting(HunterCreatureTarget creatureTarget) {
        // Add logic to set traps, catch animals, and complete the task
        // This would include using the trap type in the specified location
        Rs2Antiban.actionCooldown();
        Rs2Antiban.takeMicroBreakByChance();
    }
    private void performButterflyHunting(HunterCreatureTarget creatureTarget) {
        // Add logic to set traps, catch animals, and complete the task
        // This would include using the trap type in the specified location
        Rs2Antiban.actionCooldown();
        Rs2Antiban.takeMicroBreakByChance();
    }
    private void performDeadfall(HunterCreatureTarget creatureTarget) {
        // Add logic to set traps, catch animals, and complete the task
        // This would include using the trap type in the specified location
        Rs2Antiban.actionCooldown();
        Rs2Antiban.takeMicroBreakByChance();
    }
    private void performNet(HunterCreatureTarget creatureTarget) {
        // Add logic to set traps, catch animals, and complete the task
        // This would include using the trap type in the specified location
        Rs2Antiban.actionCooldown();
        Rs2Antiban.takeMicroBreakByChance();
    }
    private void performPitfall(HunterCreatureTarget creatureTarget) {
        // Add logic to set traps, catch animals, and complete the task
        // This would include using the trap type in the specified location
        Rs2Antiban.actionCooldown();
        Rs2Antiban.takeMicroBreakByChance();
    }
    private void performSnare(HunterCreatureTarget creatureTarget) {
        // Add logic to set traps, catch animals, and complete the task
        // This would include using the trap type in the specified location
        Rs2Antiban.actionCooldown();
        Rs2Antiban.takeMicroBreakByChance();
    }
    private void performTracking(HunterCreatureTarget creatureTarget) {
        // Add logic to set traps, catch animals, and complete the task
        // This would include using the trap type in the specified location
        Rs2Antiban.actionCooldown();
        Rs2Antiban.takeMicroBreakByChance();
    }
    private void findAllInteractableTraps(){
        //find all traps that are setup and ready to catch an animal
        //huntingplugin must have these logic
    }
    private void checkTrap(String trapName){
        //check if trap is setup and if it has caught an animal
        //huntingplugin must have these logic
    }
    private void setupTrap(String trapName){
        //setup trap, place it in the correct location, move loc to the correct tile, place down the trap, wait animation to finish with sleepunitl
    }
    private boolean checkHunterRequirements() {
        int hunterLevel = getSkillLevel(Skill.HUNTER);
        return true;
    }
    private boolean navigateToHuntingArea() {
        WorldPoint destination = null;
        if (currentHuntingCreatureTarget != null) {
            List<CreatureLocation> locations = currentHuntingCreatureTarget.getLocations();
            if (locations != null && !locations.isEmpty()) {
                destination = locations.get(0).getWorldPoint();
            }
            if (!navigationScript.walkTo(destination, 1)){
                Microbot.showMessage("Failed to navigate to hunting area");
                currentState= HunterState.FINISHED;
            }
        }
        //Rs2Antiban.actionCooldown();
        Rs2Antiban.takeMicroBreakByChance();
        return false;
    }
    private void applyAntiBanSettings() {
        Rs2AntibanSettings.antibanEnabled = true;
        Rs2AntibanSettings.usePlayStyle = true;
        Rs2AntibanSettings.simulateFatigue = true;
        Rs2AntibanSettings.simulateAttentionSpan = true;
        Rs2AntibanSettings.behavioralVariability = true;
        Rs2AntibanSettings.nonLinearIntervals = true;
        Rs2AntibanSettings.naturalMouse = true;
        Rs2AntibanSettings.moveMouseOffScreen = true;
        Rs2AntibanSettings.contextualVariability = true;
        Rs2AntibanSettings.dynamicIntensity = true;
        Rs2AntibanSettings.devDebug = false;
        Rs2AntibanSettings.moveMouseRandomly = true;
        Rs2AntibanSettings.takeMicroBreaks = true;
        Rs2AntibanSettings.microBreakDurationLow = 3;
        Rs2AntibanSettings.microBreakDurationHigh = 15;
        Rs2AntibanSettings.actionCooldownChance = 0.4;
        Rs2AntibanSettings.microBreakChance = 0.15;
        Rs2AntibanSettings.moveMouseRandomlyChance = 0.1;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/navigation/VoxSylvaeNavigationOverlay.java
================
/*
 * Copyright (c) 2018, Seth <https://github.com/sethtroll>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package net.runelite.client.plugins.VoxSylvaePlugins.util.navigation;
import net.runelite.api.Client;
import net.runelite.api.coords.LocalPoint;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.ui.overlay.OverlayLayer;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import javax.inject.Inject;
import java.awt.*;
import static net.runelite.api.Constants.CHUNK_SIZE;
public class VoxSylvaeNavigationOverlay extends OverlayPanel {
    private final Client client;
    //private final VoxSylvaeNavigationPlugin plugin;
    private final VoxSylvaeNavigationScript navigationScript;
    @Inject
    //VoxSylvaeNavigationOverlay(Client client, VoxSylvaeNavigationPlugin plugin, VoxSylvaeNavigationScript script) {
    VoxSylvaeNavigationOverlay(Client client, VoxSylvaeNavigationScript script) {
        this.client = client;        
        this.navigationScript = script;
        setPosition(OverlayPosition.TOP_LEFT);
        setLayer(OverlayLayer.ABOVE_SCENE);        
        setNaughty();
        setPosition(OverlayPosition.TOP_LEFT);
    }
    @Override
    public Dimension render(Graphics2D graphics) {
        //if (!navigationScript.getCurrentDesiredLocation()) {
         //   return null;
        //}
        WorldPoint worldPoint = client.getLocalPlayer().getWorldLocation();
        LocalPoint localPoint = client.getLocalPlayer().getLocalLocation();
        if (client.isInInstancedRegion()) {
            worldPoint = WorldPoint.fromLocalInstance(client, localPoint);
            panelComponent.getChildren().add(LineComponent.builder()
                    .left("Instance")
                    .build());
        }
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Local")
                .right(localPoint.getX() + ", " + localPoint.getY())
                .build());
        panelComponent.getChildren().add(LineComponent.builder()
                .left("World")
                .right(worldPoint.getX() + ", " + worldPoint.getY() + ", " + client.getPlane())
                .build());
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Region")
                .right(worldPoint.getRegionX() + ", " + worldPoint.getRegionY() + ", " + worldPoint.getRegionID())
                .build());
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Scene")
                .right(localPoint.getSceneX() + ", " + localPoint.getSceneY())
                .build());
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Tile")
                .right(localPoint.getSceneX() / 128 + ", " + localPoint.getSceneY() / 128)
                .build());
        WorldPoint currentDesWorldPoint = navigationScript.getCurrentDesiredLocation();
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Desired Location")
                .right( currentDesWorldPoint.getX()+ ", " + currentDesWorldPoint.getY() + ", " + currentDesWorldPoint.getPlane())
                .build());
        int[][][] instanceTemplateChunks = client.getInstanceTemplateChunks();
        int z = client.getPlane();
        int chunkData = instanceTemplateChunks[z][localPoint.getSceneX() / CHUNK_SIZE][localPoint.getSceneY() / CHUNK_SIZE];
        int rotation = chunkData >> 1 & 0x3;
        int chunkY = (chunkData >> 3 & 0x7FF) * CHUNK_SIZE;
        int chunkX = (chunkData >> 14 & 0x3FF) * CHUNK_SIZE;
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Chunk " + localPoint.getSceneX() / CHUNK_SIZE + "," + localPoint.getSceneY() / CHUNK_SIZE)
                .right(rotation + " " + chunkX + " " + chunkY)
                .build());
        panelComponent.getChildren().add(LineComponent.builder()
                .left("Base")
                .right(client.getBaseX() + ", " + client.getBaseY())
                .build());
        for (int i = 0; i < client.getMapRegions().length; i++) {
            int region = client.getMapRegions()[i];
            int mx = region >> 8;
            int my = region & 0xff;
            panelComponent.getChildren().add(LineComponent.builder()
                    .left((i == 0) ? "Map regions" : " ")
                    .right(mx + ", " + my)
                    .rightColor((region == worldPoint.getRegionID()) ? Color.GREEN : Color.WHITE)
                    .build());
        }
        panelComponent.getChildren().add(LineComponent.builder()
                .left("State")
                .right(navigationScript.getNavigationState()+"")
                .rightColor( (navigationScript.getNavigationState() == VoxSylvaeNavigationScript.NavigationState.IDLE)? Color.GREEN:Color.RED )
                .build());
        return super.render(graphics);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/navigation/VoxSylvaeNavigationScript.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.util.navigation;
import net.runelite.client.plugins.VoxSylvaePlugins.util.*;
import net.runelite.client.plugins.VoxSylvaePlugins.util.teleport.TeleportationManager;
import net.runelite.client.plugins.microbot.util.antiban.Rs2Antiban;
import net.runelite.client.plugins.microbot.util.antiban.Rs2AntibanSettings;
import net.runelite.client.plugins.VoxSylvaePlugins.util.teleport.Teleport;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.coords.WorldArea;
import net.runelite.api.Skill;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.magic.Rs2Magic;
import net.runelite.client.plugins.microbot.util.walker.Rs2Walker;
import net.runelite.client.plugins.microbot.util.gameobject.Rs2GameObject;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.bank.Rs2Bank;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.skillcalculator.skills.MagicAction;
import net.runelite.api.Skill;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemID;
import net.runelite.client.plugins.microbot.Script;
import net.runelite.client.plugins.microbot.util.keyboard.Rs2Keyboard;
import javax.inject.Inject;
import java.awt.event.KeyEvent;
import java.util.concurrent.TimeUnit;
import java.util.Random;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import static net.runelite.client.plugins.microbot.util.Global.sleep;
public class VoxSylvaeNavigationScript extends Script {
    enum NavigationState {
        IDLE,
        WALKING,
        TELEPORTING,
        BANKING,
        INTERACTING
    }
    @Inject
    VoxSylvaeInventoryAndBankManagementScript inventoryAndBankManagementScript;
    @Inject
    TeleportationManager teleportationManager;
    private static Map<String, Teleport> availableTeleports = new HashMap<>();
    private static final WorldPoint BANK_LOCATION = new WorldPoint(3183, 3436, 0); // Example: Varrock West Bank
    private NavigationState navigationState = NavigationState.IDLE;
    private WorldPoint currentDesiredLocation;
    public NavigationState getNavigationState() {
        return navigationState;
    }
    public WorldPoint getCurrentDesiredLocation() {
        return currentDesiredLocation;
    }
    private static void initialize() {
        loadAllTeleports();
        checkPlayerTeleports();
    }
    private static void loadAllTeleports() {
        // get all completed quests and add them to the list of available teleports
        List<String> completedQuests = new ArrayList<>();
        Rs2Player.
        availableTeleports = TeleportationManager.getTeleports();
        // Add all possible teleports here
        availableTeleports.put("Varrock", new TeleportInfo(Rs2Magic.Spell.VARROCK_TELEPORT, new WorldPoint(3212, 3424, 0), 25, "Law rune", "Air rune", "Fire rune"));
        availableTeleports.put("Lumbridge", new TeleportInfo(Rs2Magic.Spell.LUMBRIDGE_TELEPORT, new WorldPoint(3225, 3219, 0), 31, "Law rune", "Air rune", "Earth rune"));
        availableTeleports.put("Falador", new TeleportInfo(Rs2Magic.Spell.FALADOR_TELEPORT, new WorldPoint(2964, 3379, 0), 37, "Law rune", "Air rune", "Water rune"));
        // Add more teleports as needed
    }
    private boolean hasAllItemsInInventory(List<String> items) {
        for (String item : items) {
            if (!Rs2Inventory.hasItem(item)) {
                return false;
            }
        }
        return true;
    }
    private static void checkPlayerTeleports() {
        int magicLevel = getSkillLevel(Skill.MAGIC);
        for (Map.Entry<String, TeleportInfo> entry : availableTeleports.entrySet()) {
            TeleportInfo info = entry.getValue();
            if (magicLevel >= info.requiredLevel && hasAllItemsInInventory(info.requiredItems)) {
                info.isAvailable = true;
            }
        }
    }
    /*public boolean teleportToLocation(String teleportName, WorldPoint finalDestination) {
        TeleportInfo teleport = availableTeleports.get(teleportName);
        if (teleport != null && teleport.isAvailable) {
            Rs2Magic.castSpell(teleport.spell);
            sleep(3000, 4000);
            if (!Microbot.getClient().getLocalPlayer().getWorldLocation().equals(finalDestination)) {
                return walkTo(finalDestination,2);
            }
            return true;
        } else {
            System.out.println("Teleport not available: " + teleportName);
            return walkTo(finalDestination,2);
        }
    }*/
    public boolean walkToWithRandomizedDistance(WorldPoint destination, int minDistance, int maxDistance) {
        Random random = new Random();
        int distance = random.nextInt(maxDistance - minDistance + 1) + minDistance;
        return walkTo(destination, distance);
    }
    public boolean walkToWithTeleport(WorldPoint destination, int distance) {
        // find the nearest teleport to the destination
        Teleport nearestTeleport = teleportationManager.findNearestTeleport(destination);
        if (Rs2Walker.getDistanceBetween(Rs2Player.getWorldLocation(), destination) > distance) {
            return walkTo(destination, distance);
        } else {
            return true;
        }
    }
    public boolean walkTo(WorldPoint destination, int distance) {
        this.navigationState = NavigationState.WALKING;
        this.currentDesiredLocation = destination;
        mainScheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(() -> {
            try {
                Microbot.log("Walk todestination.");
                //Rs2Walker.walkTo(NORTH_OF_WEB, 2);
                //return sleepUntil(() -> Rs2Walker.getDistanceBetween(playerLocation, NORTH_OF_WEB) < 5 && !Rs2Player.isMoving(), 300);
                sleepUntil(() -> Rs2Walker.walkTo(destination, distance) && !Rs2Player.isMoving(), 300);
            } catch (Exception ex) {
                System.out.println(ex.getMessage());
            }
        }, 0, 1000, TimeUnit.MILLISECONDS);
        //sleepUntil(() -> Rs2Walker.walkTo(destination, distance) && !Rs2Player.isMoving(), 300);
        this.navigationState = NavigationState.IDLE;
        return true;
    }
    public boolean openBank ( WorldPoint desiredBankLocation) {
        if (Rs2Player.getWorldLocation().equals(desiredBankLocation)) {
            return inventoryAndBankManagementScript.openBank();
        } else {
            walkTo(desiredBankLocation, 2);
            return inventoryAndBankManagementScript.openBank();
        }
    }
    public walkToWithAntiBan(){
        // get antiban settings
        Rs2AntibanSettings = new Rs2AntibanSettings();
        Microbot.pauseAllScripts = false;
        //Rs2Antiban.actionCooldown();
        //Rs2Antiban.takeMicroBreakByChance();
    }
    private void applyAntiBanSettings() {
        Rs2AntibanSettings.antibanEnabled = true;
        Rs2AntibanSettings.usePlayStyle = true;
        Rs2AntibanSettings.simulateFatigue = true;
        Rs2AntibanSettings.simulateAttentionSpan = true;
        Rs2AntibanSettings.behavioralVariability = true;
        Rs2AntibanSettings.nonLinearIntervals = true;
        Rs2AntibanSettings.naturalMouse = true;
        Rs2AntibanSettings.moveMouseOffScreen = true;
        Rs2AntibanSettings.contextualVariability = true;
        Rs2AntibanSettings.dynamicIntensity = true;
        Rs2AntibanSettings.devDebug = false;
        Rs2AntibanSettings.moveMouseRandomly = true;
        Rs2AntibanSettings.takeMicroBreaks = true;
        Rs2AntibanSettings.microBreakDurationLow = 3;
        Rs2AntibanSettings.microBreakDurationHigh = 15;
        Rs2AntibanSettings.actionCooldownChance = 0.4;
        Rs2AntibanSettings.microBreakChance = 0.15;
        Rs2AntibanSettings.moveMouseRandomlyChance = 0.1;
    }
    public boolean walkToAreabyName(String  AreaName, int radius) {
        //notimplented yet
        assert false;
        WorldPoint destinationArea = NULL;
        return walkTo(destinationArea, radius);        
    }
    public static boolean useTransportation(String transportType, int objectId) {
        if (transportType.equals("Fairy Ring")) {
            Rs2GameObject fairyRing = Rs2GameObject.findObjectById(objectId);
            if (fairyRing != null) {
                return Rs2GameObject.interact(fairyRing, "Configure");
            }
        } else {
        mainScheduledFuture = scheduledExecutorService.scheduleWithFixedDelay(() -> {
                Rs2GameObject transportObject = Rs2GameObject.findObjectById(objectId);
                if (transportObject != null) {
                    return Rs2GameObject.interact(transportObject, transportType);
                } catch (Exception ex) {
                    System.out.println(ex.getMessage());
                }
            }, 0, 1000, TimeUnit.MILLISECONDS);  
        }
        return false;
    }
    public static boolean useItemOnObject(String itemName, int objectId) {
        if (Rs2Inventory.hasItem(itemName)) {
            Rs2GameObject targetObject = Rs2GameObject.findObjectById(objectId);
            if (targetObject != null) {
                Rs2Inventory.get(itemName).useOn(targetObject);
                return true;
            }
        }
        return false;
    }
    public boolean performTeleport(String teleportName) {
        navigationState = NavigationState.TELEPORTING;
        TeleportInfo teleport = availableTeleports.get(teleportName);
        if (teleport == null) {
            System.out.println("Unknown teleport: " + teleportName);
            navigationState = NavigationState.IDLE;
            return false;
        }
        List<String> missingItems = new ArrayList<>();
        for (String item : teleport.requiredItems) {
            if (!Rs2Inventory.hasItem(item)) {
                missingItems.add(item);
            }
        }
        if (!missingItems.isEmpty()) {
            navigationState = NavigationState.BANKING;
            // get missing items from bank not implemented yet
            assert false;
            navigationState = NavigationState.IDLE;
            return False
        }
        navigationState = NavigationState.IDLE;
        return true;
    }
    public boolean navigateToArea(String areaName) {
        WorldPoint currentLocation = Rs2Player.getWorldLocation();
        // logic for getting area location coordiantes
        if (currentLocation != null) {
            WorldPoint destinationArea = NULL;
            // First, try to teleport close to the destination
            //TODO implement this
            //TeleportationType nearestTeleport = findNearestTeleport(destination);
            //WorldPoint nearestTeleportationLocation
            //
            if (nearestTeleportationLocation != null) {
                return false
                //HunterMovementUtils.teleportToLocation(nearestTeleport, destination);
            }
            // Then, walk to the exact location
            return walkTo(destinationArea,0);
        }
        return false;
    }
    private static int getSkillLevel(Skill skill) {
        return Microbot.getClient().getRealSkillLevel(skill);
    }
    private static String findNearestTeleport(WorldPoint destination) {
        // Implement logic to find the nearest teleport to the destination
        // Return the teleport method name or null if no suitable teleport is found
        return null;
    }
    private static class TeleportInfo {
        MagicAction spell;
        WorldPoint destination;
        int requiredLevel;
        List<String> requiredItems;
        boolean isAvailable;
        TeleportInfo(MagicAction spell, WorldPoint destination, int requiredLevel, String... requiredItems) {
            this.spell = spell;
            this.destination = destination;
            this.requiredLevel = requiredLevel;
            this.requiredItems = requiredItems;
            this.isAvailable = false;
        }
    }
    @Override
    public void shutdown() {
        super.shutdown();
        Microbot.pauseAllScripts = true;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/teleport/AbstractTeleport.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.util.teleport;
import net.runelite.api.coords.WorldPoint;
import java.util.List;
public abstract class AbstractTeleport implements Teleport {
    protected String name;
    protected TeleportType type;
    protected int requiredLevel;
    protected List<String> requiredItems;
    protected List<String> requiredQuests;
    public AbstractTeleport(String name, TeleportType type, int requiredLevel, List<String> requiredItems, List<String> requiredQuests) {
        this.name = name;
        this.type = type;
        this.requiredLevel = requiredLevel;
        this.requiredItems = requiredItems;
        this.requiredQuests = requiredQuests;
    }
    @Override
    public String getName() { return name; }
    @Override
    public TeleportType getType() { return type; }
    @Override
    public int getRequiredLevel() { return requiredLevel; }
    @Override
    public List<String> getRequiredItems() { return requiredItems; }
    @Override
    public List<String> getRequiredQuests() { return requiredQuests; }
    @Override
    public abstract double getDistanceTo(WorldPoint destination);
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/teleport/FairyRingTeleport.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.util.teleport;
import net.runelite.api.coords.WorldPoint;
import java.util.List;
public class FairyRingTeleport implements Teleport {
    private String code;
    private String location;
    private WorldPoint coordinates;
    private String notes;
    public FairyRingTeleport(String code, String location, WorldPoint coordinates, String notes) {
        this.code = code;
        this.location = location;
        this.coordinates = coordinates;
        this.notes = notes;
    }
    @Override
    public String getName() {
        return "Fairy Ring " + code;
    }
    @Override
    public TeleportType getType() {
        return TeleportType.FAIRY_RING;
    }
    @Override
    public int getRequiredLevel() {
        return 0; // Fairy rings don't have a level requirement
    }
    @Override
    public List<String> getRequiredItems() {
        return List.of("Dramen staff", "Lunar staff"); // Either staff is required
    }
    @Override
    public List<String> getRequiredQuests() {
        return List.of("Fairy Tale II - Cure a Queen (partial completion)");
    }
    @Override
    public double getDistanceTo(WorldPoint destination) {
        return coordinates.distanceTo2D(destination);
    }
    public String getCode() {
        return code;
    }
    public String getLocation() {
        return location;
    }
    public WorldPoint getCoordinates() {
        return coordinates;
    }
    public String getNotes() {
        return notes;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/teleport/ItemTeleport.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.util.teleport;
import net.runelite.api.coords.WorldPoint;
public class ItemTeleport extends Teleport {
    private int itemId;
    private boolean consumable;
    public ItemTeleport(String name, WorldPoint destination, int itemId, boolean consumable) {
        super(name, destination, TeleportType.ITEM, 0, null, null);
        this.itemId = itemId;
        this.consumable = consumable;
    }
    public int getItemId() { return itemId; }
    public boolean isConsumable() { return consumable; }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/teleport/JewelryTeleport.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.util.teleport;
import net.runelite.api.coords.WorldPoint;
import java.util.List;
public class JewelryTeleport implements Teleport {
    private String name;
    private int charges;
    private List<JewelryDestination> destinations;
    public JewelryTeleport(String name, int charges, List<JewelryDestination> destinations) {
        this.name = name;
        this.charges = charges;
        this.destinations = destinations;
    }
    @Override
    public String getName() {
        return name;
    }
    @Override
    public TeleportType getType() {
        return TeleportType.JEWELRY;
    }
    @Override
    public int getRequiredLevel() {
        return 0; // Jewelry doesn't typically have a level requirement
    }
    @Override
    public List<String> getRequiredItems() {
        return List.of(name); // The jewelry item itself is required
    }
    @Override
    public List<String> getRequiredQuests() {
        return null; // Typically, jewelry doesn't have quest requirements
    }
    @Override
    public double getDistanceTo(WorldPoint destination) {
        double minDistance = Double.MAX_VALUE;
        for (JewelryDestination jewelryDest : destinations) {
            double distance = jewelryDest.getCoordinates().distanceTo2D(destination);
            if (distance < minDistance) {
                minDistance = distance;
            }
        }
        return minDistance;
    }
    public int getCharges() {
        return charges;
    }
    public List<JewelryDestination> getDestinations() {
        return destinations;
    }
    public static class JewelryDestination {
        private String name;
        private WorldPoint coordinates;
        private boolean membersOnly;
        public JewelryDestination(String name, WorldPoint coordinates, boolean membersOnly) {
            this.name = name;
            this.coordinates = coordinates;
            this.membersOnly = membersOnly;
        }
        public String getName() {
            return name;
        }
        public WorldPoint getCoordinates() {
            return coordinates;
        }
        public boolean isMembersOnly() {
            return membersOnly;
        }
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/teleport/POHTeleport.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.util.teleport;
import net.runelite.api.coords.WorldPoint;
import java.util.List;
import java.util.Map;
public class POHTeleport extends AbstractTeleport {
    private String furniture;
    private Map<String, List<POHDestination>> teleports;
    public POHTeleport(String name, String furniture, Map<String, List<POHDestination>> teleports, int requiredLevel, List<String> requiredItems, List<String> requiredQuests) {
        super(name, TeleportType.POH, requiredLevel, requiredItems, requiredQuests);
        this.furniture = furniture;
        this.teleports = teleports;
    }
    public String getFurniture() { return furniture; }
    public Map<String, List<POHDestination>> getTeleports() { return teleports; }
    @Override
    public double getDistanceTo(WorldPoint destination) {
        double minDistance = Double.MAX_VALUE;
        for (List<POHDestination> destinations : teleports.values()) {
            for (POHDestination pohDest : destinations) {
                double distance = pohDest.getCoordinates().distanceTo2D(destination);
                if (distance < minDistance) {
                    minDistance = distance;
                }
            }
        }
        return minDistance;
    }
    public static class POHDestination {
        private String name;
        private WorldPoint coordinates;
        public POHDestination(String name, WorldPoint coordinates) {
            this.name = name;
            this.coordinates = coordinates;
        }
        public String getName() { return name; }
        public WorldPoint getCoordinates() { return coordinates; }
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/teleport/StandardTeleport.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.util.teleport;
import net.runelite.api.coords.WorldPoint;
import java.util.List;
public class StandardTeleport extends AbstractTeleport {
    private WorldPoint destination;
    public StandardTeleport(String name, WorldPoint destination, TeleportType type, int requiredLevel, List<String> requiredItems, List<String> requiredQuests) {
        super(name, type, requiredLevel, requiredItems, requiredQuests);
        this.destination = destination;
    }
    public WorldPoint getDestination() { return destination; }
    @Override
    public double getDistanceTo(WorldPoint destination) {
        return this.destination.distanceTo2D(destination);
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/teleport/Teleport.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.util.teleport;
import net.runelite.api.coords.WorldPoint;
import java.util.List;
public interface Teleport {
    String getName();
    TeleportType getType();
    int getRequiredLevel();
    List<String> getRequiredItems();
    List<String> getRequiredQuests();
    double getDistanceTo(WorldPoint destination);
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/teleport/TeleportType.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.util.teleport;
public enum TeleportType {
    STANDARD_SPELLBOOK,
    ANCIENT_MAGICKS,
    ARCEUUS_SPELLBOOK,
    LUNAR_SPELLBOOK,
    JEWELRY,
    FAIRY_RING,
    POH,
    ITEM
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/TeleportationManager.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.util;
import net.runelite.api.*;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.plugins.VoxSylvaePlugins.data.locationData.JewelryTeleport;
import net.runelite.client.plugins.VoxSylvaePlugins.util.teleport.*;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.magic.Rs2Magic;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.skillcalculator.skills.MagicAction;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.magic.Rs2Magic;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.VoxSylvaePlugins.util.teleport.*;
import java.io.FileReader;
import java.io.IOException;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.inject.Inject;
import java.util.*;
import java.awt.event.KeyEvent;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.function.BooleanSupplier;
import lombok.Getter;
import net.runelite.api.coords.WorldPoint;
import net.runelite.api.events.WidgetLoaded;
import net.runelite.api.widgets.Widget;
import net.runelite.client.plugins.microbot.globval.enums.InterfaceTab;
import net.runelite.client.plugins.microbot.shortestpath.ShortestPathPlugin;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.keyboard.Rs2Keyboard;
import net.runelite.client.plugins.microbot.util.math.Random;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.microbot.util.tabs.Rs2Tab;
import net.runelite.client.plugins.microbot.util.widget.Rs2Widget;
import java.awt.*;
import java.util.stream.Collectors;
public class TeleportationManager{
    @Inject
    private Client client;
    private Map<TeleportType, List<Teleport>> teleports;
    private Teleport currentTeleport;
    private boolean isTeleporting;
    private int teleportStartTick;
    private Map<String, MagicAction> teleportToMagicActionMap;
    public TeleportationManager(Client client) {
        if (client == null) {
          this.client = Microbot.getClient();
        }else{
          this.client = client;
        }        
        initialize();
        int unprocessedItemPrice = Microbot.getItemManager().search(config.ITEM().getName()).get(0).getPrice();
        int processedItemPrice = Microbot.getItemManager().search(config.ITEM().getFinished()).get(0).getPrice();
        profitPerPlank = processedItemPrice - unprocessedItemPrice;
        useSetDelay = config.useSetDelay();
        setDelay = config.setDelay();
        useRandomDelay = config.useRandomDelay();
        maxRandomDelay = config.maxRandomDelay();
    }
    private void loadTeleportData() {
        loadStandardSpellbookTeleports();
        loadAncientMagicksTeleports();
        loadArceuusTeleports();
        loadLunarMagicTeleports();
        loadJewelryTeleports();
        loadFairyRingTeleports();
        loadPOHTeleports();
    }
    public void initialize() {
        this.teleports = new HashMap<>();
        this.isTeleporting = false;
        loadTeleportData();
        initializeTeleportToMagicActionMap();
    }
    private List<Teleport> loadTeleportsFromFile(String filename) {
        try (FileReader reader = new FileReader("../data/locationData/" + filename)) {
            Gson gson = new Gson();
            Type teleportListType = new TypeToken<ArrayList<Teleport>>(){}.getType();
            return gson.fromJson(reader, teleportListType);
        } catch (IOException e) {
            e.printStackTrace();
            return new ArrayList<>();
        }
    }
    private void initializeTeleportToMagicActionMap() {
        teleportToMagicActionMap.put("Varrock Teleport", MagicAction.VARROCK_TELEPORT);
        teleportToMagicActionMap.put("Lumbridge Teleport", MagicAction.LUMBRIDGE_TELEPORT);
        teleportToMagicActionMap.put("Falador Teleport", MagicAction.FALADOR_TELEPORT);
        teleportToMagicActionMap.put("Camelot Teleport", MagicAction.CAMELOT_TELEPORT);
        teleportToMagicActionMap.put("Ardougne Teleport", MagicAction.ARDOUGNE_TELEPORT);
        teleportToMagicActionMap.put("Watchtower Teleport", MagicAction.WATCHTOWER_TELEPORT);
        teleportToMagicActionMap.put("Teleport To House", MagicAction.TELEPORT_TO_HOUSE);
        teleportToMagicActionMap.put("Trollheim Teleport", MagicAction.TROLLHEIM_TELEPORT);
        teleportToMagicActionMap.put("Ape Atoll Teleport", MagicAction.APE_ATOLL_TELEPORT);
        teleportToMagicActionMap.put("Kourend Castle Teleport", MagicAction.KOUREND_CASTLE_TELEPORT);
        teleportToMagicActionMap.put("Teleport To Ape Atoll", MagicAction.TELEPORT_APE_ATOLL);
        //MagicAction BATTLEFRONT_TELEPORT= new MagicAction("Battlefront Teleport", 1, 5.5f, SpriteID.SPELL_WIND_STRIKE, false);
        // Arceuus spellbook teleports
        teleportToMagicActionMap.put("Arceuus Library Teleport", MagicAction.ARCEUUS_LIBRARY_TELEPORT);
        teleportToMagicActionMap.put("Draynor Manor Teleport", MagicAction.DRAYNOR_MANOR_TELEPORT);
        //teleportToMagicActionMap.put("Battlefront Teleport", MagicAction.BATTLEFRONT_TELEPORT);
        teleportToMagicActionMap.put("Mind Altar Teleport", MagicAction.MIND_ALTAR_TELEPORT);
        teleportToMagicActionMap.put("Respawn Teleport", MagicAction.RESPAWN_TELEPORT);
        teleportToMagicActionMap.put("Salve Graveyard Teleport", MagicAction.SALVE_GRAVEYARD_TELEPORT);
        teleportToMagicActionMap.put("Fenkenstrains Castle Teleport", MagicAction.FENKENSTRAINS_CASTLE_TELEPORT);
        teleportToMagicActionMap.put("West Ardougne Teleport", MagicAction.WEST_ARDOUGNE_TELEPORT);
        teleportToMagicActionMap.put("Harmony Island Teleport", MagicAction.HARMONY_ISLAND_TELEPORT);
        teleportToMagicActionMap.put("Cemetery Teleport", MagicAction.CEMETERY_TELEPORT);
        teleportToMagicActionMap.put("Barrows Teleport", MagicAction.BARROWS_TELEPORT);
        teleportToMagicActionMap.put("Ape Atoll Teleport", MagicAction.APE_ATOLL_TELEPORT);
        // Ancient Magicks teleports
        teleportToMagicActionMap.put("Paddewwa Teleport", MagicAction.PADDEWWA_TELEPORT);
        teleportToMagicActionMap.put("Senntisten Teleport", MagicAction.SENNTISTEN_TELEPORT);
        teleportToMagicActionMap.put("Kharyrll Teleport", MagicAction.KHARYRLL_TELEPORT);
        teleportToMagicActionMap.put("Lassar Teleport", MagicAction.LASSAR_TELEPORT);
        teleportToMagicActionMap.put("Dareeyak Teleport", MagicAction.DAREEYAK_TELEPORT);
        teleportToMagicActionMap.put("Carrallangar Teleport", MagicAction.CARRALLANGER_TELEPORT);
        teleportToMagicActionMap.put("Annakarl Teleport", MagicAction.ANNAKARL_TELEPORT);
        teleportToMagicActionMap.put("Ghorrock Teleport", MagicAction.GHORROCK_TELEPORT);
        // Lunar spellbook teleports
        teleportToMagicActionMap.put("Moonclan Teleport", MagicAction.MOONCLAN_TELEPORT);
        teleportToMagicActionMap.put("Ourania Teleport", MagicAction.OURANIA_TELEPORT);
        teleportToMagicActionMap.put("Waterbirth Teleport", MagicAction.WATERBIRTH_TELEPORT);
        teleportToMagicActionMap.put("Barbarian Teleport", MagicAction.BARBARIAN_TELEPORT);
        teleportToMagicActionMap.put("Khazard Teleport", MagicAction.KHAZARD_TELEPORT);
        teleportToMagicActionMap.put("Fishing Guild Teleport", MagicAction.FISHING_GUILD_TELEPORT);
        teleportToMagicActionMap.put("Catherby Teleport", MagicAction.CATHERBY_TELEPORT);
        teleportToMagicActionMap.put("Ice Plateau Teleport", MagicAction.ICE_PLATEAU_TELEPORT);
    }
    private void loadStandardSpellbookTeleports() {
        List<Teleport> standardTeleports = loadTeleportsFromFile("teleportationSpells.json");
        teleports.put(TeleportType.STANDARD_SPELLBOOK, standardTeleports);
    }
    private void loadAncientMagicksTeleports() {
        List<Teleport> ancientTeleports = loadTeleportsFromFile("ancientMagicksTeleports.json");
        teleports.put(TeleportType.ANCIENT_MAGICKS, ancientTeleports);
    }
    private void loadArceuusTeleports() {
        List<Teleport> arceuusTeleports = loadTeleportsFromFile("arceuusTeleports.json");
        teleports.put(TeleportType.ARCEUUS_SPELLBOOK, arceuusTeleports);
    }
    private void loadLunarMagicTeleports() {
        List<Teleport> lunarTeleports = loadTeleportsFromFile("lunarMagicTeleports.json");
        teleports.put(TeleportType.LUNAR_SPELLBOOK, lunarTeleports);
    }
    private void loadJewelryTeleports() {
        try (FileReader reader = new FileReader("../data/locationData/jewelryTeleports.json")) {
            Gson gson = new Gson();
            Type jewelryTeleportListType = new TypeToken<ArrayList<JewelryTeleport>>(){}.getType();
            List<JewelryTeleport> jewelryTeleports = gson.fromJson(reader, jewelryTeleportListType);
            // Convert List<JewelryTeleport> to List<Teleport>
            List<Teleport> teleportList = new ArrayList<>(jewelryTeleports.stream()
                .map(jt -> (Teleport) jt)
                .collect(Collectors.toList()));
            teleports.put(TeleportType.JEWELRY, teleportList);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    private void loadFairyRingTeleports() {
        try (FileReader reader = new FileReader("../data/locationData/fairyRingTeleports.json")) {
            Gson gson = new Gson();
            Type fairyRingTeleportListType = new TypeToken<ArrayList<FairyRingTeleport>>(){}.getType();
            List<FairyRingTeleport> fairyRingTeleports = gson.fromJson(reader, fairyRingTeleportListType);
            // Convert List<FairyRingTeleport> to List<Teleport>
            List<Teleport> teleportList = new ArrayList<>(fairyRingTeleports.stream()
                .map(frt -> (Teleport) frt)
                .collect(Collectors.toList()));
            teleports.put(TeleportType.FAIRY_RING, teleportList);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    private void loadPOHTeleports() {
        try (FileReader reader = new FileReader("../data/locationData/POHTeleportOptions.json")) {
            Gson gson = new Gson();
            Type pohTeleportListType = new TypeToken<ArrayList<POHTeleport>>(){}.getType();
            List<POHTeleport> pohTeleports = gson.fromJson(reader, pohTeleportListType);
            teleports.put(TeleportType.POH, new ArrayList<>(pohTeleports));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    public Teleport findNearestTeleport(WorldPoint destination) {
        Teleport nearest = null;
        double minDistance = Double.MAX_VALUE;
        for (List<Teleport> teleportList : teleports.values()) {
            for (Teleport teleport : teleportList) {
                double distance = teleport.getDistanceTo(destination);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearest = teleport;
                }
            }
        }
        return nearest;
    }
    public Teleport findNearestTeleport(WorldPoint destination, TeleportType type) {
        List<Teleport> typeSpecificTeleports = teleports.get(type);
        if (typeSpecificTeleports == null) {
            return null;
        }
        return findNearestTeleportInList(destination, typeSpecificTeleports);
    }
    public Teleport findNearestTeleport(WorldPoint destination, List<String> completedQuests) {
        Teleport nearest = null;
        double minDistance = Double.MAX_VALUE;
        for (List<Teleport> teleportList : teleports.values()) {
            for (Teleport teleport : teleportList) {
                if (meetsQuestRequirements(teleport, completedQuests)) {
                    double distance = teleport.getDistanceTo(destination);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearest = teleport;
                    }
                }
            }
        }
        return nearest;
    }
    private Teleport findNearestTeleportInList(WorldPoint destination, List<Teleport> teleportList) {
        Teleport nearest = null;
        double minDistance = Double.MAX_VALUE;
        for (Teleport teleport : teleportList) {
            double distance = teleport.getDistanceTo(destination);
            if (distance < minDistance) {
                minDistance = distance;
                nearest = teleport;
            }
        }
        return nearest;
    }
    private boolean meetsQuestRequirements(Teleport teleport, List<String> completedQuests) {
        if (teleport.getRequiredQuests() == null || teleport.getRequiredQuests().isEmpty()) {
            return true;
        }
        return completedQuests.containsAll(teleport.getRequiredQuests());
    }
     public boolean performTeleport(Teleport teleport) {
        if (!canPerformTeleport(teleport)) {
            Microbot.showMessage("Cannot perform teleport: " + teleport.getName());
            return false;
        }
        if (teleport instanceof StandardTeleport) {
            return castTeleportSpell((StandardTeleport) teleport);
        } else if (teleport instanceof JewelryTeleport) {
            return useJewelryTeleport((JewelryTeleport) teleport);
        } else if (teleport instanceof POHTeleport) {
            return usePOHTeleport((POHTeleport) teleport);
        }
        Microbot.showMessage("Unsupported teleport type: " + teleport.getClass().getSimpleName());
        return false;
    }
    private boolean canPerformTeleport(Teleport teleport) {
        if (teleport.getRequiredLevel() > client.getRealSkillLevel(Skill.MAGIC)) {
            return false;
        }
        if (teleport.getRequiredItems() != null) {
            for (String item : teleport.getRequiredItems()) {
                if (!Rs2Inventory.hasItem(item)) {
                    Microbot.showMessage("Missing required item" + item+" for teleport: " + teleport.getName());
                    return false;
                }
            }
        }
        // Add more checks as needed (e.g., quest requirements)
        return true;
    }
    private boolean castTeleportSpell(StandardTeleport teleport) {
        MagicAction magicTeleportAction = teleportToMagicActionMap.get(teleport.getName());
        if (magicTeleportAction == null) {
            Microbot.showMessage("Unknown teleport spell: " + teleport.getName());
            return false;
        }
        Rs2Magic.cast(magicTeleportAction);
        sleepUntil(() -> {return Rs2Player.isIdle() && !Rs2Player.isAnimating(); }, 5000);
        //Microbot.log("teleport with"+teleport.getName() +  to location {}, current player location", , client.getLocalPlayer().getWorldLocation());
        WorldPoint playerLocation = client.getLocalPlayer().getWorldLocation();
        boolean success = playerLocation.distanceTo(teleport.getDestination()) < 5;
        if (success) {
            currentTeleport = teleport;
            isTeleporting = true;
            teleportStartTick = client.getTickCount();
        }
        return success;
    }
    private boolean useJewelryTeleport(JewelryTeleport teleport) {
        // Implement jewelry teleport logic
        // This might involve finding the jewelry in the inventory and using it
        return false; // Placeholder
    }
    private boolean usePOHTeleport(POHTeleport teleport) {
        // Implement POH teleport logic
        // This might involve interacting with POH objects
        return false; // Placeholder
    }
    public void onGameTick() {
        if (isTeleporting) {
            checkTeleportCompletion();
        }
    }
    private void checkTeleportCompletion() {
        Player player = client.getLocalPlayer();
        if (player == null) return;
        if (player.getAnimation() == -1 && client.getGameState() == GameState.LOGGED_IN) {
            int ticksSinceTeleport = client.getTickCount() - teleportStartTick;
            if (ticksSinceTeleport > 5) { // Adjust this value as needed
                WorldPoint playerLocation = player.getWorldLocation();
                if (currentTeleport.getDistanceTo(playerLocation) < 5) { // Teleport successful
                    isTeleporting = false;
                    currentTeleport = null;
                    Microbot.showMessage("Teleport completed successfully");
                } else {
                    isTeleporting = false;
                    currentTeleport = null;
                    Microbot.showMessage("Teleport failed");
                }
            }
        }
    }
    // Add more methods as needed, such as filtering by requirements, etc.
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/VoxSylvaeInventoryAndBankManagementScript.java
================
package net.runelite.client.plugins.VoxSylvaePlugins.util;
import net.runelite.api.InventoryID;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.api.ItemID;
import net.runelite.api.coords.WorldPoint;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.Rs2InventorySetup;
import net.runelite.client.plugins.microbot.util.bank.Rs2Bank;
import net.runelite.client.plugins.microbot.util.equipment.Rs2Equipment;
import net.runelite.client.plugins.microbot.util.inventory.DropOrder;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.microbot.util.walker.Rs2Walker;
import java.util.List;
import lombok.extern.slf4j.Slf4j;
import net.runelite.api.widgets.Widget;
import net.runelite.client.plugins.microbot.util.widget.Rs2Widget;
import net.runelite.client.plugins.microbot.Script;
import net.runelite.client.plugins.microbot.util.dialogues.Rs2Dialogue;
import net.runelite.client.plugins.microbot.util.math.Rs2Random;
import net.runelite.client.plugins.microbot.util.menu.NewMenuEntry;
import net.runelite.client.plugins.microbot.util.npc.Rs2NpcManager;
import net.runelite.api.Client;
import net.runelite.api.InventoryID;
import net.runelite.api.Item;
import net.runelite.api.ItemComposition;
import net.runelite.api.ItemContainer;
import net.runelite.client.game.ItemManager;
import net.runelite.client.plugins.questhelper.runeliteobjects.extendedruneliteobjects.FaceAnimationIDs;
import java.awt.*;
import java.util.Objects;
import java.util.concurrent.TimeUnit;
import javax.inject.Inject;
import org.apache.commons.lang3.ObjectUtils.Null;
@Slf4j
public class VoxSylvaeInventoryAndBankManagementScript extends Script {
    @Inject
    private Client client;
    @Inject
    private ItemManager itemManager;
    public static class BankItemInfo {
        public final int slot;
        public final int tab;
        public final int itemId;
        public final String itemName;
        public final int quantity;
        public BankItemInfo(int slot, int tab, int itemId, String itemName, int quantity) {
            this.slot = slot;
            this.tab = tab;
            this.itemId = itemId;
            this.itemName = itemName;
            this.quantity = quantity;
        }
    }
    enum InvnetoryAndBankingState{
        IDLE,
        BANKING,
        DEPOSITING,
        WITHDRAWING,
        EQUIPPING,
        DROPPING,
        COMBINING,
        CLOSING_BANK
    }
    enum BankingAction{
        DEPOSIT_INVENTORY,
        DEPOSIT_WORN_ITEMS,
        WITHDRAW,
        EQUIP,
        DROP,
        COMBINE,
        CLOSE_BANK
    }
    InvnetoryAndBankingState currentState = InvnetoryAndBankingState.IDLE;
    public void dropInventoryItems(DropOrder configuredDropOrder, String subStringItem ) {
        DropOrder dropOrder = configuredDropOrder == DropOrder.RANDOM ? DropOrder.random() : configuredDropOrder;
        Rs2Inventory.dropAll(x -> x.name.toLowerCase().contains(subStringItem), dropOrder);
    }
    private boolean retrieveItemsFromBank(int itemId) {
        if (Rs2Bank.hasItem(itemId)) {
            Rs2Bank.withdrawAll(itemId);
            sleepUntil(() -> Rs2Inventory.hasItem(itemId), 5000);
            return Rs2Inventory.hasItem(itemId);
        }
        return false;
    }
    private Widget openAndScrollToBankTab(int itemTabID, int ItemSlotId) {
        if (!Rs2Bank.isTabOpen(itemTabID)) {
            log.info("Switching to tab: {}", itemTabID);
            Rs2Bank.openTab(itemTabID);
            sleepUntil(() -> Rs2Bank.isTabOpen(itemTabID), 5000);
        }
        Rs2Bank.scrollBankToSlot(ItemSlotId);
        Rs2Random.wait(200, 500);
        return Rs2Bank.getItemWidget(ItemSlotId);
    }
    public BankItemInfo findItemInBank(int itemId) {
        ItemContainer bank = client.getItemContainer(InventoryID.BANK);
        // throw exeption if bank is not open
        if (bank == null) {
            return null; // Bank is not open
        }
        Item[] bankItems = bank.getItems();
        int currentTab = 0;
        int currentSlot = 0;
        for (Item item : bankItems) {
            if (item.getId() == itemId) {
                ItemComposition itemComposition = itemManager.getItemComposition(itemId);
                String itemName = itemComposition.getName();
                return new BankItemInfo(currentSlot, currentTab, itemId, itemName, item.getQuantity());
            }
            currentSlot++;
            if (item.getId() == 21) { // ID 21 is the item ID for bank tab separators
                currentTab++;
                currentSlot = 0;
            }
        }
        return null; // Item not found
    }
    public BankItemInfo findItemInBank(String itemName) {
        if(openBank()){
            Microbot.log("<findItemInBank> Bank did not open");
            return null;
        }
        ItemContainer bank = client.getItemContainer(InventoryID.BANK);
        if (bank == null) {
            return null; // Bank is not open
        }
        Item[] bankItems = bank.getItems();
        int currentTab = 0;
        int currentSlot = 0;
        for (Item item : bankItems) {
            ItemComposition itemComposition = itemManager.getItemComposition(item.getId());
            if (itemComposition.getName().equalsIgnoreCase(itemName)) {
                return new BankItemInfo(currentSlot, currentTab, item.getId(), itemName, item.getQuantity());
            }
            currentSlot++;
            if (item.getId() == 21) { // ID 21 is the item ID for bank tab separators
                currentTab++;
                currentSlot = 0;
            }
        }
        return null; // Item not found
    }
    private int getItemIdByName(String itemName) {
        for (int i = 0; i < client.getItemCount(); i++) {
            ItemComposition itemComposition = itemManager.getItemComposition(i);
            if (itemComposition.getName().equalsIgnoreCase(itemName)) {
                return i;
            }
        }
        return -1; // Item not found
    }
    private boolean retrieveItemsFromBank(List<Integer> itemIDs) {
        if(openBank()){
            Microbot.log("<retrieveItemsFromBank> Bank did not open");
            return false;
        }
        for (int itemID : itemIDs) {
            if (Rs2Bank.hasItem(itemID)) {
                Rs2Bank.withdrawItem(itemID);
                sleepUntil(() -> Rs2Inventory.hasItem(itemID), 50);
                if (!Rs2Inventory.hasItem(itemID)) {
                    Microbot.log("Failed to withdraw item: " + itemID);
                    Rs2Bank.closeBank();
                    return false;
                }
            } else {
                System.out.println("Missing item in bank: " + itemID);
                Rs2Bank.closeBank();
                return false;
            }
        }
        Rs2Bank.closeBank();
        return true;
    }
    private boolean retrieveItemsFromBank(List<String> items) {
        if(openBank()){
            Microbot.log("<retrieveItemsFromBank> Bank did not open to retrieve items: " + items);
            return false;
        }
        for (String item : items) {
            if (Rs2Bank.hasItem(item)) {
                Rs2Bank.withdrawItem(item);
                sleepUntil(() -> Rs2Inventory.hasItem(item), 50);
                if (!Rs2Inventory.hasItem(item)) {
                    Microbot.log("Failed to withdraw item: " + item);
                    Rs2Bank.closeBank();
                    return false;
                }
            } else {
                System.out.println("Missing item in bank: " + item);
                Rs2Bank.closeBank();
                return false;
            }
        }
        Rs2Bank.closeBank();
        return true;
    }
    public boolean loadInventoryAndEquipment(String inventorySetupName) {
        boolean hasEquipment = false;
        boolean hasInventory = false;
        if (!openBank()) {
            Microbot.log("Bank did not open");
            return false;
        }
        try {
            Rs2InventorySetup rs2InventorySetup = new Rs2InventorySetup(inventorySetupName, mainScheduledFuture);
            if (!rs2InventorySetup.hasSpellBook()) {
                Microbot.showMessage("Your spellbook is not matching "+inventorySetupName+" the inventory setup.");
                sleep(10000);
                return false;
            }
            hasEquipment = rs2InventorySetup.doesEquipmentMatch();
            hasInventory = rs2InventorySetup.doesInventoryMatch();
            if (!hasEquipment) {
                hasEquipment = rs2InventorySetup.loadEquipment();
            }
            if (!hasInventory && rs2InventorySetup.doesEquipmentMatch()) {
                hasInventory = rs2InventorySetup.loadInventory();
                sleep(1000);
            }
        } catch (Exception ignored) {            
            Microbot.pauseAllScripts = false;
            Microbot.log("Failed to "+inventorySetupName+"load inventory setup");
        }
        return hasInventory && hasEquipment;
    }
    public boolean openBank () {
        try {
            if (Rs2Bank.isOpen()) {
                return true;
            }
            if (!Rs2Bank.walkToBankAndUseBank()) {
                System.out.println("Failed to reach the bank");
                return false;
            }   
            sleepUntil(Rs2Bank::isOpen, 10000);
        } catch (Exception ignored) {            
            Microbot.pauseAllScripts = true;
            Microbot.log("Failed to open bank");
        }
        return Rs2Bank.isOpen();
    }
    private void checkBeforeWithdrawAndEquip(int itemId) {
        if (!Rs2Equipment.isWearing(itemId)) {
            Rs2Bank.withdrawAndEquip(itemId);
           //check if it is wearing
            sleepUntil(() -> Rs2Equipment.isWearing(itemId), 5000);
        }
    }
    private void checkBeforeWithdrawAndEquip(String itemName) {
        if (!Rs2Equipment.isWearing(itemName)) {
            Rs2Bank.withdrawAndEquip(itemName);
            //check if it is wearing
            sleepUntil(() -> Rs2Equipment.isWearing(itemName), 5000);
        }
    }
    public boolean withdrawAndEquipItemWithMultipleIds(List<Integer> itemIds) {
        if (!Rs2Bank.openBank()) {
            Microbot.log("<withdrawAndEquipItemWithMultipleIds> Bank did not open, cant get any item with ids: " + itemIds);
            return false;
        }
        for (int itemId : itemIds) {
            if (Rs2Bank.hasItem(itemId)) {
                checkBeforeWithdrawAndEquip(itemId);
                return true;
            } else {
              continue;
            }
        }
        Microbot.log("<withdrawAndEquipItemWithMultipleIds> Missing all items in bank: " + itemIds);        
        return true;
    }
    public boolean withdrawAndEquip(String itemName) {
        if (!Rs2Bank.openBank()) {
            Microbot.log("<withdrawAndEquip> Bank did not open, item: " + itemName);
            return false;
        }
        if (Rs2Bank.hasItem(itemName)) {
            checkBeforeWithdrawAndEquip(itemName);
            return true;
        }
        Microbot.log("<withdrawAndEquip> Missing item in bank: " + itemName);
        return false;
    }
    public boolean withdrawAndEquip(int itemId) {
        try{
        if (!Rs2Bank.openBank()) {
            Microbot.log("<withdrawAndEquip> Bank did not open, item: " + itemId);
            return false;
        }
        if (Rs2Bank.hasItem(itemId)) {
            checkBeforeWithdrawAndEquip(itemId);
            return true;
        }
        Microbot.log("<withdrawAndEquip> Missing item in bank: " + itemId);
        return false;
    }
    //utitlity methods
    public void equipGraceful() {
        withdrawAndEquip("GRACEFUL HOOD");
        withdrawAndEquip("GRACEFUL CAPE");
        withdrawAndEquip("GRACEFUL BOOTS");
        withdrawAndEquip("GRACEFUL GLOVES");
        withdrawAndEquip("GRACEFUL TOP");
        withdrawAndEquip("GRACEFUL LEGS");
    }
    public boolean withdrawDigsitePendant() {
        List<Integer> digsitePendants = List.of(ItemID.DIGSITE_PENDANT_1, ItemID.DIGSITE_PENDANT_2, ItemID.DIGSITE_PENDANT_3, ItemID.DIGSITE_PENDANT_4, ItemID.DIGSITE_PENDANT_5);
        return withdrawAndEquipItemWithMultipleIds(digsitePendants);     
    }
    @Override
    public void shutdown() {
        super.shutdown();
        Microbot.pauseAllScripts = true;
    }
}

================
File: runelite-client/src/main/java/net/runelite/client/plugins/VoxSylvaePlugins/util/VoxSylvaeUtil.java
================
import net.runelite.client.plugins.PluginDescriptor;
import net.runelite.client.plugins.hunter.HunterConfig;
import net.runelite.client.plugins.microbot.Microbot;
import net.runelite.client.plugins.microbot.util.antiban.AntibanOverlay;
import net.runelite.client.plugins.microbot.util.antiban.Rs2Antiban;
import net.runelite.client.plugins.microbot.util.antiban.Rs2AntibanSettings;
import net.runelite.client.plugins.microbot.util.inventory.Rs2Inventory;
import net.runelite.client.plugins.microbot.util.mouse.VirtualMouse;
import net.runelite.client.plugins.microbot.util.player.Rs2Player;
import net.runelite.client.plugins.xptracker.XpTrackerPlugin;
import net.runelite.client.ui.overlay.OverlayManager;
import net.runelite.client.ui.overlay.OverlayPanel;
import net.runelite.client.ui.overlay.OverlayPosition;
import net.runelite.client.ui.overlay.components.LineComponent;
import net.runelite.client.ui.overlay.components.TitleComponent;
import net.runelite.api.AnimationID;
import net.runelite.api.Client;
import net.runelite.api.GameState;
import net.runelite.api.Skill;
import net.runelite.api.events.ChatMessage;
import net.runelite.api.events.GameStateChanged;
import net.runelite.api.events.GameTick;
import net.runelite.api.events.StatChanged;
import net.runelite.client.Notifier;
import net.runelite.client.callback.ClientThread;
import net.runelite.client.config.ConfigManager;
import net.runelite.client.eventbus.Subscribe;
import net.runelite.client.events.ProfileChanged;
import net.runelite.client.input.KeyManager;
import net.runelite.client.plugins.Plugin;
import net.runelite.client.plugins.PluginDependency;
import net.runelite.client.plugins.microbot.breakhandler.BreakHandlerPlugin;
import net.runelite.client.plugins.microbot.util.antiban.AntibanPlugin;
//import net.runelite.client.plugins.microbot.fishing.barbarian.BarbarianFishingConfig;
//import net.runelite.client.plugins.microbot.fishing.barbarian.BarbarianFishingScript;
import net.runelite.client.plugins.microbot.util.antiban.enums.Activity;
import net.runelite.client.plugins.microbot.util.antiban.enums.ActivityIntensity;
import net.runelite.client.plugins.microbot.util.antiban.enums.CombatSkills;
import net.runelite.client.plugins.microbot.util.antiban.ui.MasterPanel;
import net.runelite.client.plugins.PluginInstantiationException;
import net.runelite.client.ui.ClientToolbar;
import net.runelite.client.ui.NavigationButton;
import net.runelite.client.util.HotkeyListener;
import net.runelite.client.util.ImageUtil;
import javax.inject.Inject;
import javax.swing.*;
import com.google.inject.Provides;
import lombok.extern.slf4j.Slf4j;
import java.awt.image.BufferedImage;
import java.time.Duration;
import java.time.Instant;
import java.util.EnumMap;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;
import java.awt.*;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
public void ensurePluginEnabled(Class pluginClass,  boolean devDebug){
    if (!Microbot.isPluginEnabled(pluginClass)) {
        String pluginName = pluginClass.getName();
        if (devDebug)
            Microbot.showMessage("AIO Hunter plugin depend on the plugin \""+pluginName +"\", enabling it now.");
        Microbot.log("\""+pluginName +"\""+"BreakHandlerPlugin not enabled, enabling it now.");
        Plugin PluginObject = Microbot.getPluginManager().getPlugins().stream()
                .filter(x -> x.getClass().getName().equals(pluginName))
                .findFirst()
                .orElse(null);
        Microbot.startPlugin(PluginObject);
    }
}
public static Plugin getPluginByNameByName(String pluginName) {
    for (Plugin plugin : Microbot.getPluginManager().getPlugins()) {
        PluginDescriptor descriptor = plugin.getClass().getAnnotation(PluginDescriptor.class);
        if (descriptor != null && descriptor.name().contains(pluginName)) {
            return plugin;
        }
    }
    return null;
}
public static String startPluginByName(String pluginName) {
        System.out.println("Starting startPlugin"); // Debug line
        try {
            Microbot.getPluginManager().setPluginEnabled(getPluginByName(pluginName), true);
            //sleep(100);
            Microbot.getPluginManager().startPlugins();
            //if (!(currentPluginName == null))
            //    lastPluginName = currentPluginName;
            //currentPluginName = pluginName;
            //activity = "running";
            //pluginStartTime = System.currentTimeMillis();
            System.out.println("started plugin: " + pluginName);
            return pluginName;
        } catch (Exception e) {
            System.out.println("Failed to start plugin: " + e.getMessage());
            return null;
        }
    }
public static void stopPluginByName(String pluginName) {
    try {
        Microbot.getPluginManager().setPluginEnabled(getPluginByName(pluginName), false);
        sleep(500);
        SwingUtilities.invokeLater(() -> {
            try {
                Microbot.getPluginManager().stopPlugin(getPluginByName(pluginName));
                System.out.println("stopped plugin: " + pluginName);
            } catch (PluginInstantiationException e) {
                System.out.println("error stopPlugin"); // Debug line
                throw new RuntimeException(e);
            }
        });
    } catch (Exception e) {
        System.out.println("Failed to stop plugin: " + e.getMessage());
    }
}
